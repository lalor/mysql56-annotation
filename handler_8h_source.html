<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: handler.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">handler.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef HANDLER_INCLUDED</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define HANDLER_INCLUDED</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/*</span>
<a name="l00005"></a>00005 <span class="comment">   Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">   This program is free software; you can redistribute it and/or</span>
<a name="l00008"></a>00008 <span class="comment">   modify it under the terms of the GNU General Public License</span>
<a name="l00009"></a>00009 <span class="comment">   as published by the Free Software Foundation; version 2 of</span>
<a name="l00010"></a>00010 <span class="comment">   the License.</span>
<a name="l00011"></a>00011 <span class="comment"></span>
<a name="l00012"></a>00012 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the</span>
<a name="l00015"></a>00015 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00016"></a>00016 <span class="comment"></span>
<a name="l00017"></a>00017 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00018"></a>00018 <span class="comment">   along with this program; if not, write to the Free Software</span>
<a name="l00019"></a>00019 <span class="comment">   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA</span>
<a name="l00020"></a>00020 <span class="comment">*/</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="comment">/* Definitions for parameters to do with handler-routines */</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;my_pthread.h&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;<a class="code" href="sql__const_8h.html">sql_const.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;mysqld.h&quot;</span>                             <span class="comment">/* server_id */</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;sql_plugin.h&quot;</span>        <span class="comment">/* plugin_ref, st_plugin_int, plugin */</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;thr_lock.h&quot;</span>          <span class="comment">/* thr_lock_type, THR_LOCK_DATA */</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;sql_cache.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;structs.h&quot;</span>                            <span class="comment">/* SHOW_COMP_OPTION */</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;my_global.h&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;my_compare.h&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;ft_global.h&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;keycache.h&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keyword">class </span><a class="code" href="classAlter__info.html">Alter_info</a>;
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="comment">// the following is for checking tables</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#define HA_ADMIN_ALREADY_DONE     1</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_OK               0</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_NOT_IMPLEMENTED -1</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_FAILED          -2</span>
<a name="l00046"></a>00046 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_CORRUPT         -3</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_INTERNAL_ERROR  -4</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_INVALID         -5</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_REJECT          -6</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_TRY_ALTER       -7</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_WRONG_CHECKSUM  -8</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_NOT_BASE_TABLE  -9</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_NEEDS_UPGRADE  -10</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_NEEDS_ALTER    -11</span>
<a name="l00055"></a>00055 <span class="preprocessor"></span><span class="preprocessor">#define HA_ADMIN_NEEDS_CHECK    -12</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>
<a name="l00063"></a>00063 <span class="keyword">enum</span> enum_alter_inplace_result {
<a name="l00064"></a>00064   HA_ALTER_ERROR,
<a name="l00065"></a>00065   HA_ALTER_INPLACE_NOT_SUPPORTED,
<a name="l00066"></a>00066   HA_ALTER_INPLACE_EXCLUSIVE_LOCK,
<a name="l00067"></a>00067   HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE,
<a name="l00068"></a>00068   HA_ALTER_INPLACE_SHARED_LOCK,
<a name="l00069"></a>00069   HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE,
<a name="l00070"></a>00070   HA_ALTER_INPLACE_NO_LOCK
<a name="l00071"></a>00071 };
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="comment">/* Bits in table_flags() to show what database can do */</span>
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="preprocessor">#define HA_NO_TRANSACTIONS     (1 &lt;&lt; 0) </span><span class="comment">/* Doesn&#39;t support transactions */</span>
<a name="l00076"></a>00076 <span class="preprocessor">#define HA_PARTIAL_COLUMN_READ (1 &lt;&lt; 1) </span><span class="comment">/* read may not return all columns */</span>
<a name="l00077"></a>00077 <span class="preprocessor">#define HA_TABLE_SCAN_ON_INDEX (1 &lt;&lt; 2) </span><span class="comment">/* No separate data/index file */</span>
<a name="l00078"></a>00078 <span class="comment">/*</span>
<a name="l00079"></a>00079 <span class="comment">  The following should be set if the following is not true when scanning</span>
<a name="l00080"></a>00080 <span class="comment">  a table with rnd_next()</span>
<a name="l00081"></a>00081 <span class="comment">  - We will see all rows (including deleted ones)</span>
<a name="l00082"></a>00082 <span class="comment">  - Row positions are &#39;table-&gt;s-&gt;db_record_offset&#39; apart</span>
<a name="l00083"></a>00083 <span class="comment">  If this flag is not set, filesort will do a position() call for each matched</span>
<a name="l00084"></a>00084 <span class="comment">  row to be able to find the row later.</span>
<a name="l00085"></a>00085 <span class="comment">*/</span>
<a name="l00086"></a>00086 <span class="preprocessor">#define HA_REC_NOT_IN_SEQ      (1 &lt;&lt; 3)</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span><span class="preprocessor">#define HA_CAN_GEOMETRY        (1 &lt;&lt; 4)</span>
<a name="l00088"></a>00088 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00089"></a>00089 <span class="comment">  Reading keys in random order is as fast as reading keys in sort order</span>
<a name="l00090"></a>00090 <span class="comment">  (Used in records.cc to decide if we should use a record cache and by</span>
<a name="l00091"></a>00091 <span class="comment">  filesort to decide if we should sort key + data or key + pointer-to-row</span>
<a name="l00092"></a>00092 <span class="comment">*/</span>
<a name="l00093"></a>00093 <span class="preprocessor">#define HA_FAST_KEY_READ       (1 &lt;&lt; 5)</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00095"></a>00095 <span class="comment">  Set the following flag if we on delete should force all key to be read</span>
<a name="l00096"></a>00096 <span class="comment">  and on update read all keys that changes</span>
<a name="l00097"></a>00097 <span class="comment">*/</span>
<a name="l00098"></a>00098 <span class="preprocessor">#define HA_REQUIRES_KEY_COLUMNS_FOR_DELETE (1 &lt;&lt; 6)</span>
<a name="l00099"></a>00099 <span class="preprocessor"></span><span class="preprocessor">#define HA_NULL_IN_KEY         (1 &lt;&lt; 7) </span><span class="comment">/* One can have keys with NULL */</span>
<a name="l00100"></a>00100 <span class="preprocessor">#define HA_DUPLICATE_POS       (1 &lt;&lt; 8)    </span><span class="comment">/* position() gives dup row */</span>
<a name="l00101"></a>00101 <span class="preprocessor">#define HA_NO_BLOBS            (1 &lt;&lt; 9) </span><span class="comment">/* Doesn&#39;t support blobs */</span>
<a name="l00102"></a>00102 <span class="preprocessor">#define HA_CAN_INDEX_BLOBS     (1 &lt;&lt; 10)</span>
<a name="l00103"></a>00103 <span class="preprocessor"></span><span class="preprocessor">#define HA_AUTO_PART_KEY       (1 &lt;&lt; 11) </span><span class="comment">/* auto-increment in multi-part key */</span>
<a name="l00104"></a>00104 <span class="preprocessor">#define HA_REQUIRE_PRIMARY_KEY (1 &lt;&lt; 12) </span><span class="comment">/* .. and can&#39;t create a hidden one */</span>
<a name="l00105"></a>00105 <span class="preprocessor">#define HA_STATS_RECORDS_IS_EXACT (1 &lt;&lt; 13) </span><span class="comment">/* stats.records is exact */</span>
<a name="l00106"></a>00106 <span class="comment">/*</span>
<a name="l00107"></a>00107 <span class="comment">  INSERT_DELAYED only works with handlers that uses MySQL internal table</span>
<a name="l00108"></a>00108 <span class="comment">  level locks</span>
<a name="l00109"></a>00109 <span class="comment">*/</span>
<a name="l00110"></a>00110 <span class="preprocessor">#define HA_CAN_INSERT_DELAYED  (1 &lt;&lt; 14)</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00112"></a>00112 <span class="comment">  If we get the primary key columns for free when we do an index read</span>
<a name="l00113"></a>00113 <span class="comment">  (usually, it also implies that HA_PRIMARY_KEY_REQUIRED_FOR_POSITION</span>
<a name="l00114"></a>00114 <span class="comment">  flag is set).</span>
<a name="l00115"></a>00115 <span class="comment">*/</span>
<a name="l00116"></a>00116 <span class="preprocessor">#define HA_PRIMARY_KEY_IN_READ_INDEX (1 &lt;&lt; 15)</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00118"></a>00118 <span class="comment">  If HA_PRIMARY_KEY_REQUIRED_FOR_POSITION is set, it means that to position()</span>
<a name="l00119"></a>00119 <span class="comment">  uses a primary key given by the record argument.</span>
<a name="l00120"></a>00120 <span class="comment">  Without primary key, we can&#39;t call position().</span>
<a name="l00121"></a>00121 <span class="comment">  If not set, the position is returned as the current rows position</span>
<a name="l00122"></a>00122 <span class="comment">  regardless of what argument is given.</span>
<a name="l00123"></a>00123 <span class="comment">*/</span> 
<a name="l00124"></a>00124 <span class="preprocessor">#define HA_PRIMARY_KEY_REQUIRED_FOR_POSITION (1 &lt;&lt; 16) </span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">#define HA_CAN_RTREEKEYS       (1 &lt;&lt; 17)</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="preprocessor">#define HA_NOT_DELETE_WITH_CACHE (1 &lt;&lt; 18)</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00128"></a>00128 <span class="comment">  The following is we need to a primary key to delete (and update) a row.</span>
<a name="l00129"></a>00129 <span class="comment">  If there is no primary key, all columns needs to be read on update and delete</span>
<a name="l00130"></a>00130 <span class="comment">*/</span>
<a name="l00131"></a>00131 <span class="preprocessor">#define HA_PRIMARY_KEY_REQUIRED_FOR_DELETE (1 &lt;&lt; 19)</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span><span class="preprocessor">#define HA_NO_PREFIX_CHAR_KEYS (1 &lt;&lt; 20)</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span><span class="preprocessor">#define HA_CAN_FULLTEXT        (1 &lt;&lt; 21)</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#define HA_CAN_SQL_HANDLER     (1 &lt;&lt; 22)</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="preprocessor">#define HA_NO_AUTO_INCREMENT   (1 &lt;&lt; 23)</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor">#define HA_HAS_CHECKSUM        (1 &lt;&lt; 24)</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="comment">/* Table data are stored in separate files (for lower_case_table_names) */</span>
<a name="l00138"></a>00138 <span class="preprocessor">#define HA_FILE_BASED          (1 &lt;&lt; 26)</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">#define HA_NO_VARCHAR          (1 &lt;&lt; 27)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#define HA_CAN_BIT_FIELD       (1 &lt;&lt; 28) </span><span class="comment">/* supports bit fields */</span>
<a name="l00141"></a>00141 <span class="preprocessor">#define HA_ANY_INDEX_MAY_BE_UNIQUE (1 &lt;&lt; 30)</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span><span class="preprocessor">#define HA_NO_COPY_ON_ALTER    (LL(1) &lt;&lt; 31)</span>
<a name="l00143"></a>00143 <span class="preprocessor"></span><span class="preprocessor">#define HA_HAS_RECORDS         (LL(1) &lt;&lt; 32) </span><span class="comment">/* records() gives exact count*/</span>
<a name="l00144"></a>00144 <span class="comment">/* Has it&#39;s own method of binlog logging */</span>
<a name="l00145"></a>00145 <span class="preprocessor">#define HA_HAS_OWN_BINLOGGING  (LL(1) &lt;&lt; 33)</span>
<a name="l00146"></a>00146 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00147"></a>00147 <span class="comment">  Engine is capable of row-format and statement-format logging,</span>
<a name="l00148"></a>00148 <span class="comment">  respectively</span>
<a name="l00149"></a>00149 <span class="comment">*/</span>
<a name="l00150"></a>00150 <span class="preprocessor">#define HA_BINLOG_ROW_CAPABLE  (LL(1) &lt;&lt; 34)</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span><span class="preprocessor">#define HA_BINLOG_STMT_CAPABLE (LL(1) &lt;&lt; 35)</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00153"></a>00153 <span class="comment">    When a multiple key conflict happens in a REPLACE command mysql</span>
<a name="l00154"></a>00154 <span class="comment">    expects the conflicts to be reported in the ascending order of</span>
<a name="l00155"></a>00155 <span class="comment">    key names.</span>
<a name="l00156"></a>00156 <span class="comment"></span>
<a name="l00157"></a>00157 <span class="comment">    For e.g.</span>
<a name="l00158"></a>00158 <span class="comment"></span>
<a name="l00159"></a>00159 <span class="comment">    CREATE TABLE t1 (a INT, UNIQUE (a), b INT NOT NULL, UNIQUE (b), c INT NOT</span>
<a name="l00160"></a>00160 <span class="comment">                     NULL, INDEX(c));</span>
<a name="l00161"></a>00161 <span class="comment"></span>
<a name="l00162"></a>00162 <span class="comment">    REPLACE INTO t1 VALUES (1,1,1),(2,2,2),(2,1,3);</span>
<a name="l00163"></a>00163 <span class="comment"></span>
<a name="l00164"></a>00164 <span class="comment">    MySQL expects the conflict with &#39;a&#39; to be reported before the conflict with</span>
<a name="l00165"></a>00165 <span class="comment">    &#39;b&#39;.</span>
<a name="l00166"></a>00166 <span class="comment"></span>
<a name="l00167"></a>00167 <span class="comment">    If the underlying storage engine does not report the conflicting keys in</span>
<a name="l00168"></a>00168 <span class="comment">    ascending order, it causes unexpected errors when the REPLACE command is</span>
<a name="l00169"></a>00169 <span class="comment">    executed.</span>
<a name="l00170"></a>00170 <span class="comment"></span>
<a name="l00171"></a>00171 <span class="comment">    This flag helps the underlying SE to inform the server that the keys are not</span>
<a name="l00172"></a>00172 <span class="comment">    ordered.</span>
<a name="l00173"></a>00173 <span class="comment">*/</span>
<a name="l00174"></a>00174 <span class="preprocessor">#define HA_DUPLICATE_KEY_NOT_IN_ORDER    (LL(1) &lt;&lt; 36)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00176"></a>00176 <span class="comment">  Engine supports REPAIR TABLE. Used by CHECK TABLE FOR UPGRADE if an</span>
<a name="l00177"></a>00177 <span class="comment">  incompatible table is detected. If this flag is set, CHECK TABLE FOR UPGRADE</span>
<a name="l00178"></a>00178 <span class="comment">  will report ER_TABLE_NEEDS_UPGRADE, otherwise ER_TABLE_NEED_REBUILD.</span>
<a name="l00179"></a>00179 <span class="comment">*/</span>
<a name="l00180"></a>00180 <span class="preprocessor">#define HA_CAN_REPAIR                    (LL(1) &lt;&lt; 37)</span>
<a name="l00181"></a>00181 <span class="preprocessor"></span>
<a name="l00182"></a>00182 <span class="comment">/*</span>
<a name="l00183"></a>00183 <span class="comment">  Set of all binlog flags. Currently only contain the capabilities</span>
<a name="l00184"></a>00184 <span class="comment">  flags.</span>
<a name="l00185"></a>00185 <span class="comment"> */</span>
<a name="l00186"></a>00186 <span class="preprocessor">#define HA_BINLOG_FLAGS (HA_BINLOG_ROW_CAPABLE | HA_BINLOG_STMT_CAPABLE)</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>
<a name="l00220"></a>00220 <span class="preprocessor">#define HA_READ_BEFORE_WRITE_REMOVAL  (LL(1) &lt;&lt; 38)</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>
<a name="l00222"></a>00222 <span class="comment">/*</span>
<a name="l00223"></a>00223 <span class="comment">  Engine supports extended fulltext API</span>
<a name="l00224"></a>00224 <span class="comment"> */</span>
<a name="l00225"></a>00225 <span class="preprocessor">#define HA_CAN_FULLTEXT_EXT              (LL(1) &lt;&lt; 39)</span>
<a name="l00226"></a>00226 <span class="preprocessor"></span>
<a name="l00227"></a>00227 <span class="comment">/*</span>
<a name="l00228"></a>00228 <span class="comment">  Storage engine doesn&#39;t synchronize result set with expected table contents.</span>
<a name="l00229"></a>00229 <span class="comment">  Used by replication slave to check if it is possible to retrieve rows from</span>
<a name="l00230"></a>00230 <span class="comment">  the table when deciding whether to do a full table scan, index scan or hash</span>
<a name="l00231"></a>00231 <span class="comment">  scan while applying a row event.</span>
<a name="l00232"></a>00232 <span class="comment"> */</span>
<a name="l00233"></a>00233 <span class="preprocessor">#define HA_READ_OUT_OF_SYNC              (LL(1) &lt;&lt; 40)</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span>
<a name="l00235"></a>00235 <span class="comment">/*</span>
<a name="l00236"></a>00236 <span class="comment">  Storage engine supports table export using the</span>
<a name="l00237"></a>00237 <span class="comment">  FLUSH TABLE &lt;table_list&gt; FOR EXPORT statement.</span>
<a name="l00238"></a>00238 <span class="comment"> */</span>
<a name="l00239"></a>00239 <span class="preprocessor">#define HA_CAN_EXPORT                 (LL(1) &lt;&lt; 41)</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span>
<a name="l00241"></a>00241 <span class="comment">/*</span>
<a name="l00242"></a>00242 <span class="comment">  The handler don&#39;t want accesses to this table to </span>
<a name="l00243"></a>00243 <span class="comment">  be const-table optimized</span>
<a name="l00244"></a>00244 <span class="comment">*/</span>
<a name="l00245"></a>00245 <span class="preprocessor">#define HA_BLOCK_CONST_TABLE          (LL(1) &lt;&lt; 42)</span>
<a name="l00246"></a>00246 <span class="preprocessor"></span>
<a name="l00247"></a>00247 <span class="comment">/* bits in index_flags(index_number) for what you can do with index */</span>
<a name="l00248"></a>00248 <span class="preprocessor">#define HA_READ_NEXT            1       </span><span class="comment">/* TODO really use this flag */</span>
<a name="l00249"></a>00249 <span class="preprocessor">#define HA_READ_PREV            2       </span><span class="comment">/* supports ::index_prev */</span>
<a name="l00250"></a>00250 <span class="preprocessor">#define HA_READ_ORDER           4       </span><span class="comment">/* index_next/prev follow sort order */</span>
<a name="l00251"></a>00251 <span class="preprocessor">#define HA_READ_RANGE           8       </span><span class="comment">/* can find all records in a range */</span>
<a name="l00252"></a>00252 <span class="preprocessor">#define HA_ONLY_WHOLE_INDEX     16      </span><span class="comment">/* Can&#39;t use part key searches */</span>
<a name="l00253"></a>00253 <span class="preprocessor">#define HA_KEYREAD_ONLY         64      </span><span class="comment">/* Support HA_EXTRA_KEYREAD */</span>
<a name="l00254"></a>00254 <span class="comment">/*</span>
<a name="l00255"></a>00255 <span class="comment">  Index scan will not return records in rowid order. Not guaranteed to be</span>
<a name="l00256"></a>00256 <span class="comment">  set for unordered (e.g. HASH) indexes.</span>
<a name="l00257"></a>00257 <span class="comment">*/</span>
<a name="l00258"></a>00258 <span class="preprocessor">#define HA_KEY_SCAN_NOT_ROR     128 </span>
<a name="l00259"></a>00259 <span class="preprocessor"></span><span class="preprocessor">#define HA_DO_INDEX_COND_PUSHDOWN  256 </span><span class="comment">/* Supports Index Condition Pushdown */</span>
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 
<a name="l00262"></a>00262 
<a name="l00290"></a>00290 <span class="preprocessor">#define HA_PARTITION_FUNCTION_SUPPORTED         (1L &lt;&lt; 0)</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span><span class="preprocessor">#define HA_FAST_CHANGE_PARTITION                (1L &lt;&lt; 1)</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span><span class="preprocessor">#define HA_PARTITION_ONE_PHASE                  (1L &lt;&lt; 2)</span>
<a name="l00293"></a>00293 <span class="preprocessor"></span>
<a name="l00294"></a>00294 <span class="comment">/* operations for disable/enable indexes */</span>
<a name="l00295"></a>00295 <span class="preprocessor">#define HA_KEY_SWITCH_NONUNIQ      0</span>
<a name="l00296"></a>00296 <span class="preprocessor"></span><span class="preprocessor">#define HA_KEY_SWITCH_ALL          1</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span><span class="preprocessor">#define HA_KEY_SWITCH_NONUNIQ_SAVE 2</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span><span class="preprocessor">#define HA_KEY_SWITCH_ALL_SAVE     3</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span>
<a name="l00300"></a>00300 <span class="comment">/*</span>
<a name="l00301"></a>00301 <span class="comment">  Note: the following includes binlog and closing 0.</span>
<a name="l00302"></a>00302 <span class="comment">  so: innodb + bdb + ndb + binlog + myisam + myisammrg + archive +</span>
<a name="l00303"></a>00303 <span class="comment">      example + csv + heap + blackhole + federated + 0</span>
<a name="l00304"></a>00304 <span class="comment">  (yes, the sum is deliberately inaccurate)</span>
<a name="l00305"></a>00305 <span class="comment">  TODO remove the limit, use dynarrays</span>
<a name="l00306"></a>00306 <span class="comment">*/</span>
<a name="l00307"></a>00307 <span class="preprocessor">#define MAX_HA 15</span>
<a name="l00308"></a>00308 <span class="preprocessor"></span>
<a name="l00309"></a>00309 <span class="comment">/*</span>
<a name="l00310"></a>00310 <span class="comment">  Use this instead of 0 as the initial value for the slot number of</span>
<a name="l00311"></a>00311 <span class="comment">  handlerton, so that we can distinguish uninitialized slot number</span>
<a name="l00312"></a>00312 <span class="comment">  from slot 0.</span>
<a name="l00313"></a>00313 <span class="comment">*/</span>
<a name="l00314"></a>00314 <span class="preprocessor">#define HA_SLOT_UNDEF ((uint)-1)</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span>
<a name="l00316"></a>00316 <span class="comment">/*</span>
<a name="l00317"></a>00317 <span class="comment">  Parameters for open() (in register form-&gt;filestat)</span>
<a name="l00318"></a>00318 <span class="comment">  HA_GET_INFO does an implicit HA_ABORT_IF_LOCKED</span>
<a name="l00319"></a>00319 <span class="comment">*/</span>
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="preprocessor">#define HA_OPEN_KEYFILE         1</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span><span class="preprocessor">#define HA_OPEN_RNDFILE         2</span>
<a name="l00323"></a>00323 <span class="preprocessor"></span><span class="preprocessor">#define HA_GET_INDEX            4</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span><span class="preprocessor">#define HA_GET_INFO             8       </span><span class="comment">/* do a ha_info() after open */</span>
<a name="l00325"></a>00325 <span class="preprocessor">#define HA_READ_ONLY            16      </span><span class="comment">/* File opened as readonly */</span>
<a name="l00326"></a>00326 <span class="comment">/* Try readonly if can&#39;t open with read and write */</span>
<a name="l00327"></a>00327 <span class="preprocessor">#define HA_TRY_READ_ONLY        32</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span><span class="preprocessor">#define HA_WAIT_IF_LOCKED       64      </span><span class="comment">/* Wait if locked on open */</span>
<a name="l00329"></a>00329 <span class="preprocessor">#define HA_ABORT_IF_LOCKED      128     </span><span class="comment">/* skip if locked on open.*/</span>
<a name="l00330"></a>00330 <span class="preprocessor">#define HA_BLOCK_LOCK           256     </span><span class="comment">/* unlock when reading some records */</span>
<a name="l00331"></a>00331 <span class="preprocessor">#define HA_OPEN_TEMPORARY       512</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span>
<a name="l00333"></a>00333         <span class="comment">/* Some key definitions */</span>
<a name="l00334"></a>00334 <span class="preprocessor">#define HA_KEY_NULL_LENGTH      1</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span><span class="preprocessor">#define HA_KEY_BLOB_LENGTH      2</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span>
<a name="l00337"></a>00337 <span class="preprocessor">#define HA_LEX_CREATE_TMP_TABLE 1</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span><span class="preprocessor">#define HA_LEX_CREATE_IF_NOT_EXISTS 2</span>
<a name="l00339"></a>00339 <span class="preprocessor"></span><span class="preprocessor">#define HA_LEX_CREATE_TABLE_LIKE 4</span>
<a name="l00340"></a>00340 <span class="preprocessor"></span><span class="preprocessor">#define HA_OPTION_NO_CHECKSUM   (1L &lt;&lt; 17)</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span><span class="preprocessor">#define HA_OPTION_NO_DELAY_KEY_WRITE (1L &lt;&lt; 18)</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span><span class="preprocessor">#define HA_MAX_REC_LENGTH       65535U</span>
<a name="l00343"></a>00343 <span class="preprocessor"></span>
<a name="l00344"></a>00344 <span class="comment">/* Table caching type */</span>
<a name="l00345"></a>00345 <span class="preprocessor">#define HA_CACHE_TBL_NONTRANSACT 0</span>
<a name="l00346"></a>00346 <span class="preprocessor"></span><span class="preprocessor">#define HA_CACHE_TBL_NOCACHE     1</span>
<a name="l00347"></a>00347 <span class="preprocessor"></span><span class="preprocessor">#define HA_CACHE_TBL_ASKTRANSACT 2</span>
<a name="l00348"></a>00348 <span class="preprocessor"></span><span class="preprocessor">#define HA_CACHE_TBL_TRANSACT    4</span>
<a name="l00349"></a>00349 <span class="preprocessor"></span>
<a name="l00362"></a>00362 <span class="comment">// WITH CONSISTENT SNAPSHOT option</span>
<a name="l00363"></a>00363 <span class="keyword">static</span> <span class="keyword">const</span> uint MYSQL_START_TRANS_OPT_WITH_CONS_SNAPSHOT = 1;
<a name="l00364"></a>00364 <span class="comment">// READ ONLY option</span>
<a name="l00365"></a>00365 <span class="keyword">static</span> <span class="keyword">const</span> uint MYSQL_START_TRANS_OPT_READ_ONLY          = 2;
<a name="l00366"></a>00366 <span class="comment">// READ WRITE option</span>
<a name="l00367"></a>00367 <span class="keyword">static</span> <span class="keyword">const</span> uint MYSQL_START_TRANS_OPT_READ_WRITE         = 4;
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 <span class="comment">/* Flags for method is_fatal_error */</span>
<a name="l00370"></a>00370 <span class="preprocessor">#define HA_CHECK_DUP_KEY 1</span>
<a name="l00371"></a>00371 <span class="preprocessor"></span><span class="preprocessor">#define HA_CHECK_DUP_UNIQUE 2</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span><span class="preprocessor">#define HA_CHECK_DUP (HA_CHECK_DUP_KEY + HA_CHECK_DUP_UNIQUE)</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>
<a name="l00374"></a>00374 <span class="keyword">enum</span> legacy_db_type
<a name="l00375"></a>00375 {
<a name="l00376"></a>00376   DB_TYPE_UNKNOWN=0,DB_TYPE_DIAB_ISAM=1,
<a name="l00377"></a>00377   DB_TYPE_HASH,DB_TYPE_MISAM,DB_TYPE_PISAM,
<a name="l00378"></a>00378   DB_TYPE_RMS_ISAM, DB_TYPE_HEAP, DB_TYPE_ISAM,
<a name="l00379"></a>00379   DB_TYPE_MRG_ISAM, DB_TYPE_MYISAM, DB_TYPE_MRG_MYISAM,
<a name="l00380"></a>00380   DB_TYPE_BERKELEY_DB, DB_TYPE_INNODB,
<a name="l00381"></a>00381   DB_TYPE_GEMINI, DB_TYPE_NDBCLUSTER,
<a name="l00382"></a>00382   DB_TYPE_EXAMPLE_DB, DB_TYPE_ARCHIVE_DB, DB_TYPE_CSV_DB,
<a name="l00383"></a>00383   DB_TYPE_FEDERATED_DB,
<a name="l00384"></a>00384   DB_TYPE_BLACKHOLE_DB,
<a name="l00385"></a>00385   DB_TYPE_PARTITION_DB,
<a name="l00386"></a>00386   DB_TYPE_BINLOG,
<a name="l00387"></a>00387   DB_TYPE_SOLID,
<a name="l00388"></a>00388   DB_TYPE_PBXT,
<a name="l00389"></a>00389   DB_TYPE_TABLE_FUNCTION,
<a name="l00390"></a>00390   DB_TYPE_MEMCACHE,
<a name="l00391"></a>00391   DB_TYPE_FALCON,
<a name="l00392"></a>00392   DB_TYPE_MARIA,
<a name="l00394"></a>00394   DB_TYPE_PERFORMANCE_SCHEMA,
<a name="l00395"></a>00395   DB_TYPE_FIRST_DYNAMIC=42,
<a name="l00396"></a>00396   DB_TYPE_DEFAULT=127 <span class="comment">// Must be last</span>
<a name="l00397"></a>00397 };
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 <span class="keyword">enum</span> row_type { ROW_TYPE_NOT_USED=-1, ROW_TYPE_DEFAULT, ROW_TYPE_FIXED,
<a name="l00400"></a>00400                 ROW_TYPE_DYNAMIC, ROW_TYPE_COMPRESSED,
<a name="l00401"></a>00401                 ROW_TYPE_REDUNDANT, ROW_TYPE_COMPACT,
<a name="l00403"></a>00403                 ROW_TYPE_PAGE };
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="comment">/* Specifies data storage format for individual columns */</span>
<a name="l00406"></a>00406 <span class="keyword">enum</span> column_format_type {
<a name="l00407"></a>00407   COLUMN_FORMAT_TYPE_DEFAULT=   0, <span class="comment">/* Not specified (use engine default) */</span>
<a name="l00408"></a>00408   COLUMN_FORMAT_TYPE_FIXED=     1, <span class="comment">/* FIXED format */</span>
<a name="l00409"></a>00409   COLUMN_FORMAT_TYPE_DYNAMIC=   2  <span class="comment">/* DYNAMIC format */</span>
<a name="l00410"></a>00410 };
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 <span class="keyword">enum</span> enum_binlog_func {
<a name="l00413"></a>00413   BFN_RESET_LOGS=        1,
<a name="l00414"></a>00414   BFN_RESET_SLAVE=       2,
<a name="l00415"></a>00415   BFN_BINLOG_WAIT=       3,
<a name="l00416"></a>00416   BFN_BINLOG_END=        4,
<a name="l00417"></a>00417   BFN_BINLOG_PURGE_FILE= 5
<a name="l00418"></a>00418 };
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="keyword">enum</span> enum_binlog_command {
<a name="l00421"></a>00421   LOGCOM_CREATE_TABLE,
<a name="l00422"></a>00422   LOGCOM_ALTER_TABLE,
<a name="l00423"></a>00423   LOGCOM_RENAME_TABLE,
<a name="l00424"></a>00424   LOGCOM_DROP_TABLE,
<a name="l00425"></a>00425   LOGCOM_CREATE_DB,
<a name="l00426"></a>00426   LOGCOM_ALTER_DB,
<a name="l00427"></a>00427   LOGCOM_DROP_DB
<a name="l00428"></a>00428 };
<a name="l00429"></a>00429 
<a name="l00430"></a>00430 <span class="comment">/* struct to hold information about the table that should be created */</span>
<a name="l00431"></a>00431 
<a name="l00432"></a>00432 <span class="comment">/* Bits in used_fields */</span>
<a name="l00433"></a>00433 <span class="preprocessor">#define HA_CREATE_USED_AUTO             (1L &lt;&lt; 0)</span>
<a name="l00434"></a>00434 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_RAID             (1L &lt;&lt; 1) //RAID is no longer availble</span>
<a name="l00435"></a>00435 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_UNION            (1L &lt;&lt; 2)</span>
<a name="l00436"></a>00436 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_INSERT_METHOD    (1L &lt;&lt; 3)</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_MIN_ROWS         (1L &lt;&lt; 4)</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_MAX_ROWS         (1L &lt;&lt; 5)</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_AVG_ROW_LENGTH   (1L &lt;&lt; 6)</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_PACK_KEYS        (1L &lt;&lt; 7)</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_CHARSET          (1L &lt;&lt; 8)</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_DEFAULT_CHARSET  (1L &lt;&lt; 9)</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_DATADIR          (1L &lt;&lt; 10)</span>
<a name="l00444"></a>00444 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_INDEXDIR         (1L &lt;&lt; 11)</span>
<a name="l00445"></a>00445 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_ENGINE           (1L &lt;&lt; 12)</span>
<a name="l00446"></a>00446 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_CHECKSUM         (1L &lt;&lt; 13)</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_DELAY_KEY_WRITE  (1L &lt;&lt; 14)</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_ROW_FORMAT       (1L &lt;&lt; 15)</span>
<a name="l00449"></a>00449 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_COMMENT          (1L &lt;&lt; 16)</span>
<a name="l00450"></a>00450 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_PASSWORD         (1L &lt;&lt; 17)</span>
<a name="l00451"></a>00451 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_CONNECTION       (1L &lt;&lt; 18)</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span><span class="preprocessor">#define HA_CREATE_USED_KEY_BLOCK_SIZE   (1L &lt;&lt; 19)</span>
<a name="l00453"></a>00453 <span class="preprocessor"></span>
<a name="l00454"></a>00454 <span class="preprocessor">#define HA_CREATE_USED_TRANSACTIONAL    (1L &lt;&lt; 20)</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span>
<a name="l00456"></a>00456 <span class="preprocessor">#define HA_CREATE_USED_PAGE_CHECKSUM    (1L &lt;&lt; 21)</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span>
<a name="l00462"></a>00462 <span class="preprocessor">#define HA_CREATE_USED_STATS_PERSISTENT (1L &lt;&lt; 22)</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>
<a name="l00469"></a>00469 <span class="preprocessor">#define HA_CREATE_USED_STATS_AUTO_RECALC (1L &lt;&lt; 23)</span>
<a name="l00470"></a>00470 <span class="preprocessor"></span>
<a name="l00476"></a>00476 <span class="preprocessor">#define HA_CREATE_USED_STATS_SAMPLE_PAGES (1L &lt;&lt; 24)</span>
<a name="l00477"></a>00477 <span class="preprocessor"></span>
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="comment">/*</span>
<a name="l00480"></a>00480 <span class="comment">  This is master database for most of system tables. However there</span>
<a name="l00481"></a>00481 <span class="comment">  can be other databases which can hold system tables. Respective</span>
<a name="l00482"></a>00482 <span class="comment">  storage engines define their own system database names.</span>
<a name="l00483"></a>00483 <span class="comment">*/</span>
<a name="l00484"></a>00484 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="handler_8cc.html#a2e9669474fbe960e4b34b87509dda498">mysqld_system_database</a>;
<a name="l00485"></a>00485 
<a name="l00486"></a>00486 <span class="comment">/*</span>
<a name="l00487"></a>00487 <span class="comment">  Structure to hold list of system_database.system_table.</span>
<a name="l00488"></a>00488 <span class="comment">  This is used at both mysqld and storage engine layer.</span>
<a name="l00489"></a>00489 <span class="comment">*/</span>
<a name="l00490"></a><a class="code" href="structst__system__tablename.html">00490</a> <span class="keyword">struct </span><a class="code" href="structst__system__tablename.html">st_system_tablename</a>
<a name="l00491"></a>00491 {
<a name="l00492"></a>00492   <span class="keyword">const</span> <span class="keywordtype">char</span> *db;
<a name="l00493"></a>00493   <span class="keyword">const</span> <span class="keywordtype">char</span> *tablename;
<a name="l00494"></a>00494 };
<a name="l00495"></a>00495 
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="keyword">typedef</span> ulonglong my_xid; <span class="comment">// this line is the same as in log_event.h</span>
<a name="l00498"></a>00498 <span class="preprocessor">#define MYSQL_XID_PREFIX &quot;MySQLXid&quot;</span>
<a name="l00499"></a>00499 <span class="preprocessor"></span><span class="preprocessor">#define MYSQL_XID_PREFIX_LEN 8 // must be a multiple of 8</span>
<a name="l00500"></a>00500 <span class="preprocessor"></span><span class="preprocessor">#define MYSQL_XID_OFFSET (MYSQL_XID_PREFIX_LEN+sizeof(server_id))</span>
<a name="l00501"></a>00501 <span class="preprocessor"></span><span class="preprocessor">#define MYSQL_XID_GTRID_LEN (MYSQL_XID_OFFSET+sizeof(my_xid))</span>
<a name="l00502"></a>00502 <span class="preprocessor"></span>
<a name="l00503"></a>00503 <span class="preprocessor">#define XIDDATASIZE MYSQL_XIDDATASIZE</span>
<a name="l00504"></a>00504 <span class="preprocessor"></span><span class="preprocessor">#define MAXGTRIDSIZE 64</span>
<a name="l00505"></a>00505 <span class="preprocessor"></span><span class="preprocessor">#define MAXBQUALSIZE 64</span>
<a name="l00506"></a>00506 <span class="preprocessor"></span>
<a name="l00507"></a>00507 <span class="preprocessor">#define COMPATIBLE_DATA_YES 0</span>
<a name="l00508"></a>00508 <span class="preprocessor"></span><span class="preprocessor">#define COMPATIBLE_DATA_NO  1</span>
<a name="l00509"></a>00509 <span class="preprocessor"></span>
<a name="l00510"></a>00510 <span class="keyword">namespace </span>AQP {
<a name="l00511"></a>00511   <span class="keyword">class </span>Join_plan;
<a name="l00512"></a>00512 };
<a name="l00513"></a>00513 
<a name="l00522"></a><a class="code" href="structxid__t.html">00522</a> <span class="keyword">struct </span><a class="code" href="structxid__t.html">xid_t</a> {
<a name="l00523"></a>00523   <span class="keywordtype">long</span> formatID;
<a name="l00524"></a>00524   <span class="keywordtype">long</span> gtrid_length;
<a name="l00525"></a>00525   <span class="keywordtype">long</span> bqual_length;
<a name="l00526"></a>00526   <span class="keywordtype">char</span> data[XIDDATASIZE];  <span class="comment">// not \0-terminated !</span>
<a name="l00527"></a>00527 
<a name="l00528"></a>00528   <a class="code" href="structxid__t.html">xid_t</a>() {}                                <span class="comment">/* Remove gcc warning */</span>  
<a name="l00529"></a>00529   <span class="keywordtype">bool</span> eq(<span class="keyword">struct</span> <a class="code" href="structxid__t.html">xid_t</a> *xid)
<a name="l00530"></a>00530   { <span class="keywordflow">return</span> eq(xid-&gt;gtrid_length, xid-&gt;bqual_length, xid-&gt;data); }
<a name="l00531"></a>00531   <span class="keywordtype">bool</span> eq(<span class="keywordtype">long</span> g, <span class="keywordtype">long</span> b, <span class="keyword">const</span> <span class="keywordtype">char</span> *d)
<a name="l00532"></a>00532   { <span class="keywordflow">return</span> g == gtrid_length &amp;&amp; b == bqual_length &amp;&amp; !memcmp(d, data, g+b); }
<a name="l00533"></a>00533   <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keyword">struct </span><a class="code" href="structxid__t.html">xid_t</a> *xid)
<a name="l00534"></a>00534   { memcpy(<span class="keyword">this</span>, xid, xid-&gt;length()); }
<a name="l00535"></a>00535   <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keywordtype">long</span> f, <span class="keyword">const</span> <span class="keywordtype">char</span> *g, <span class="keywordtype">long</span> gl, <span class="keyword">const</span> <span class="keywordtype">char</span> *b, <span class="keywordtype">long</span> bl)
<a name="l00536"></a>00536   {
<a name="l00537"></a>00537     formatID= f;
<a name="l00538"></a>00538     memcpy(data, g, gtrid_length= gl);
<a name="l00539"></a>00539     memcpy(data+gl, b, bqual_length= bl);
<a name="l00540"></a>00540   }
<a name="l00541"></a>00541   <span class="keywordtype">void</span> <span class="keyword">set</span>(ulonglong xid)
<a name="l00542"></a>00542   {
<a name="l00543"></a>00543     my_xid tmp;
<a name="l00544"></a>00544     formatID= 1;
<a name="l00545"></a>00545     <span class="keyword">set</span>(MYSQL_XID_PREFIX_LEN, 0, MYSQL_XID_PREFIX);
<a name="l00546"></a>00546     memcpy(data+MYSQL_XID_PREFIX_LEN, &amp;server_id, <span class="keyword">sizeof</span>(server_id));
<a name="l00547"></a>00547     tmp= xid;
<a name="l00548"></a>00548     memcpy(data+MYSQL_XID_OFFSET, &amp;tmp, <span class="keyword">sizeof</span>(tmp));
<a name="l00549"></a>00549     gtrid_length=MYSQL_XID_GTRID_LEN;
<a name="l00550"></a>00550   }
<a name="l00551"></a>00551   <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keywordtype">long</span> g, <span class="keywordtype">long</span> b, <span class="keyword">const</span> <span class="keywordtype">char</span> *d)
<a name="l00552"></a>00552   {
<a name="l00553"></a>00553     formatID= 1;
<a name="l00554"></a>00554     gtrid_length= g;
<a name="l00555"></a>00555     bqual_length= b;
<a name="l00556"></a>00556     memcpy(data, d, g+b);
<a name="l00557"></a>00557   }
<a name="l00558"></a>00558   <span class="keywordtype">bool</span> is_null() { <span class="keywordflow">return</span> formatID == -1; }
<a name="l00559"></a>00559   <span class="keywordtype">void</span> null() { formatID= -1; }
<a name="l00560"></a>00560   my_xid quick_get_my_xid()
<a name="l00561"></a>00561   {
<a name="l00562"></a>00562     my_xid tmp;
<a name="l00563"></a>00563     memcpy(&amp;tmp, data+MYSQL_XID_OFFSET, <span class="keyword">sizeof</span>(tmp));
<a name="l00564"></a>00564     <span class="keywordflow">return</span> tmp;
<a name="l00565"></a>00565   }
<a name="l00566"></a>00566   my_xid get_my_xid()
<a name="l00567"></a>00567   {
<a name="l00568"></a>00568     <span class="keywordflow">return</span> gtrid_length == MYSQL_XID_GTRID_LEN &amp;&amp; bqual_length == 0 &amp;&amp;
<a name="l00569"></a>00569            !memcmp(data, MYSQL_XID_PREFIX, MYSQL_XID_PREFIX_LEN) ?
<a name="l00570"></a>00570            quick_get_my_xid() : 0;
<a name="l00571"></a>00571   }
<a name="l00572"></a>00572   uint length()
<a name="l00573"></a>00573   {
<a name="l00574"></a>00574     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(formatID)+<span class="keyword">sizeof</span>(gtrid_length)+<span class="keyword">sizeof</span>(bqual_length)+
<a name="l00575"></a>00575            gtrid_length+bqual_length;
<a name="l00576"></a>00576   }
<a name="l00577"></a>00577   uchar *key()
<a name="l00578"></a>00578   {
<a name="l00579"></a>00579     <span class="keywordflow">return</span> (uchar *)&amp;gtrid_length;
<a name="l00580"></a>00580   }
<a name="l00581"></a>00581   uint key_length()
<a name="l00582"></a>00582   {
<a name="l00583"></a>00583     <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(gtrid_length)+<span class="keyword">sizeof</span>(bqual_length)+gtrid_length+bqual_length;
<a name="l00584"></a>00584   }
<a name="l00585"></a>00585 };
<a name="l00586"></a>00586 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structxid__t.html">xid_t</a> <a class="code" href="structxid__t.html">XID</a>;
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="comment">/* for recover() handlerton call */</span>
<a name="l00589"></a>00589 <span class="preprocessor">#define MIN_XID_LIST_SIZE  128</span>
<a name="l00590"></a>00590 <span class="preprocessor"></span><span class="preprocessor">#define MAX_XID_LIST_SIZE  (1024*128)</span>
<a name="l00591"></a>00591 <span class="preprocessor"></span>
<a name="l00592"></a>00592 <span class="comment">/*</span>
<a name="l00593"></a>00593 <span class="comment">  These structures are used to pass information from a set of SQL commands</span>
<a name="l00594"></a>00594 <span class="comment">  on add/drop/change tablespace definitions to the proper hton.</span>
<a name="l00595"></a>00595 <span class="comment">*/</span>
<a name="l00596"></a>00596 <span class="preprocessor">#define UNDEF_NODEGROUP 65535</span>
<a name="l00597"></a>00597 <span class="preprocessor"></span><span class="keyword">enum</span> ts_command_type
<a name="l00598"></a>00598 {
<a name="l00599"></a>00599   TS_CMD_NOT_DEFINED = -1,
<a name="l00600"></a>00600   CREATE_TABLESPACE = 0,
<a name="l00601"></a>00601   ALTER_TABLESPACE = 1,
<a name="l00602"></a>00602   CREATE_LOGFILE_GROUP = 2,
<a name="l00603"></a>00603   ALTER_LOGFILE_GROUP = 3,
<a name="l00604"></a>00604   DROP_TABLESPACE = 4,
<a name="l00605"></a>00605   DROP_LOGFILE_GROUP = 5,
<a name="l00606"></a>00606   CHANGE_FILE_TABLESPACE = 6,
<a name="l00607"></a>00607   ALTER_ACCESS_MODE_TABLESPACE = 7
<a name="l00608"></a>00608 };
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="keyword">enum</span> ts_alter_tablespace_type
<a name="l00611"></a>00611 {
<a name="l00612"></a>00612   TS_ALTER_TABLESPACE_TYPE_NOT_DEFINED = -1,
<a name="l00613"></a>00613   ALTER_TABLESPACE_ADD_FILE = 1,
<a name="l00614"></a>00614   ALTER_TABLESPACE_DROP_FILE = 2
<a name="l00615"></a>00615 };
<a name="l00616"></a>00616 
<a name="l00617"></a>00617 <span class="keyword">enum</span> tablespace_access_mode
<a name="l00618"></a>00618 {
<a name="l00619"></a>00619   TS_NOT_DEFINED= -1,
<a name="l00620"></a>00620   TS_READ_ONLY = 0,
<a name="l00621"></a>00621   TS_READ_WRITE = 1,
<a name="l00622"></a>00622   TS_NOT_ACCESSIBLE = 2
<a name="l00623"></a>00623 };
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="keyword">struct </span><a class="code" href="structhandlerton.html">handlerton</a>;
<a name="l00626"></a><a class="code" href="classst__alter__tablespace.html">00626</a> <span class="keyword">class </span><a class="code" href="classst__alter__tablespace.html">st_alter_tablespace</a> : <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l00627"></a>00627 {
<a name="l00628"></a>00628   <span class="keyword">public</span>:
<a name="l00629"></a>00629   <span class="keyword">const</span> <span class="keywordtype">char</span> *tablespace_name;
<a name="l00630"></a>00630   <span class="keyword">const</span> <span class="keywordtype">char</span> *logfile_group_name;
<a name="l00631"></a>00631   <span class="keyword">enum</span> ts_command_type ts_cmd_type;
<a name="l00632"></a>00632   <span class="keyword">enum</span> ts_alter_tablespace_type ts_alter_tablespace_type;
<a name="l00633"></a>00633   <span class="keyword">const</span> <span class="keywordtype">char</span> *data_file_name;
<a name="l00634"></a>00634   <span class="keyword">const</span> <span class="keywordtype">char</span> *undo_file_name;
<a name="l00635"></a>00635   <span class="keyword">const</span> <span class="keywordtype">char</span> *redo_file_name;
<a name="l00636"></a>00636   ulonglong extent_size;
<a name="l00637"></a>00637   ulonglong undo_buffer_size;
<a name="l00638"></a>00638   ulonglong redo_buffer_size;
<a name="l00639"></a>00639   ulonglong initial_size;
<a name="l00640"></a>00640   ulonglong autoextend_size;
<a name="l00641"></a>00641   ulonglong max_size;
<a name="l00642"></a>00642   uint nodegroup_id;
<a name="l00643"></a>00643   <a class="code" href="structhandlerton.html">handlerton</a> *storage_engine;
<a name="l00644"></a>00644   <span class="keywordtype">bool</span> wait_until_completed;
<a name="l00645"></a>00645   <span class="keyword">const</span> <span class="keywordtype">char</span> *ts_comment;
<a name="l00646"></a>00646   <span class="keyword">enum</span> tablespace_access_mode ts_access_mode;
<a name="l00647"></a>00647   <a class="code" href="classst__alter__tablespace.html">st_alter_tablespace</a>()
<a name="l00648"></a>00648   {
<a name="l00649"></a>00649     tablespace_name= NULL;
<a name="l00650"></a>00650     logfile_group_name= <span class="stringliteral">&quot;DEFAULT_LG&quot;</span>; <span class="comment">//Default log file group</span>
<a name="l00651"></a>00651     ts_cmd_type= TS_CMD_NOT_DEFINED;
<a name="l00652"></a>00652     data_file_name= NULL;
<a name="l00653"></a>00653     undo_file_name= NULL;
<a name="l00654"></a>00654     redo_file_name= NULL;
<a name="l00655"></a>00655     extent_size= 1024*1024;        <span class="comment">//Default 1 MByte</span>
<a name="l00656"></a>00656     undo_buffer_size= 8*1024*1024; <span class="comment">//Default 8 MByte</span>
<a name="l00657"></a>00657     redo_buffer_size= 8*1024*1024; <span class="comment">//Default 8 MByte</span>
<a name="l00658"></a>00658     initial_size= 128*1024*1024;   <span class="comment">//Default 128 MByte</span>
<a name="l00659"></a>00659     autoextend_size= 0;            <span class="comment">//No autoextension as default</span>
<a name="l00660"></a>00660     max_size= 0;                   <span class="comment">//Max size == initial size =&gt; no extension</span>
<a name="l00661"></a>00661     storage_engine= NULL;
<a name="l00662"></a>00662     nodegroup_id= UNDEF_NODEGROUP;
<a name="l00663"></a>00663     wait_until_completed= TRUE;
<a name="l00664"></a>00664     ts_comment= NULL;
<a name="l00665"></a>00665     ts_access_mode= TS_NOT_DEFINED;
<a name="l00666"></a>00666   }
<a name="l00667"></a>00667 };
<a name="l00668"></a>00668 
<a name="l00669"></a>00669 <span class="comment">/* The handler for a table type.  Will be included in the TABLE structure */</span>
<a name="l00670"></a>00670 
<a name="l00671"></a>00671 <span class="keyword">struct </span><a class="code" href="structTABLE.html">TABLE</a>;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 <span class="comment">/*</span>
<a name="l00674"></a>00674 <span class="comment">  Make sure that the order of schema_tables and enum_schema_tables are the same.</span>
<a name="l00675"></a>00675 <span class="comment">*/</span>
<a name="l00676"></a>00676 <span class="keyword">enum</span> enum_schema_tables
<a name="l00677"></a>00677 {
<a name="l00678"></a>00678   SCH_CHARSETS= 0,
<a name="l00679"></a>00679   SCH_COLLATIONS,
<a name="l00680"></a>00680   SCH_COLLATION_CHARACTER_SET_APPLICABILITY,
<a name="l00681"></a>00681   SCH_COLUMNS,
<a name="l00682"></a>00682   SCH_COLUMN_PRIVILEGES,
<a name="l00683"></a>00683   SCH_ENGINES,
<a name="l00684"></a>00684   SCH_EVENTS,
<a name="l00685"></a>00685   SCH_FILES,
<a name="l00686"></a>00686   SCH_GLOBAL_STATUS,
<a name="l00687"></a>00687   SCH_GLOBAL_VARIABLES,
<a name="l00688"></a>00688   SCH_KEY_COLUMN_USAGE,
<a name="l00689"></a>00689   SCH_OPEN_TABLES,
<a name="l00690"></a>00690   SCH_OPTIMIZER_TRACE,
<a name="l00691"></a>00691   SCH_PARAMETERS,
<a name="l00692"></a>00692   SCH_PARTITIONS,
<a name="l00693"></a>00693   SCH_PLUGINS,
<a name="l00694"></a>00694   SCH_PROCESSLIST,
<a name="l00695"></a>00695   SCH_PROFILES,
<a name="l00696"></a>00696   SCH_REFERENTIAL_CONSTRAINTS,
<a name="l00697"></a>00697   SCH_PROCEDURES,
<a name="l00698"></a>00698   SCH_SCHEMATA,
<a name="l00699"></a>00699   SCH_SCHEMA_PRIVILEGES,
<a name="l00700"></a>00700   SCH_SESSION_STATUS,
<a name="l00701"></a>00701   SCH_SESSION_VARIABLES,
<a name="l00702"></a>00702   SCH_STATISTICS,
<a name="l00703"></a>00703   SCH_STATUS,
<a name="l00704"></a>00704   SCH_TABLES,
<a name="l00705"></a>00705   SCH_TABLESPACES,
<a name="l00706"></a>00706   SCH_TABLE_CONSTRAINTS,
<a name="l00707"></a>00707   SCH_TABLE_NAMES,
<a name="l00708"></a>00708   SCH_TABLE_PRIVILEGES,
<a name="l00709"></a>00709   SCH_TRIGGERS,
<a name="l00710"></a>00710   SCH_USER_PRIVILEGES,
<a name="l00711"></a>00711   SCH_VARIABLES,
<a name="l00712"></a>00712   SCH_VIEWS
<a name="l00713"></a>00713 };
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 <span class="keyword">struct </span><a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a>;
<a name="l00716"></a>00716 <span class="keyword">struct </span><a class="code" href="structst__foreign__key__info.html">st_foreign_key_info</a>;
<a name="l00717"></a>00717 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__foreign__key__info.html">st_foreign_key_info</a> <a class="code" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a>;
<a name="l00718"></a>00718 <span class="keyword">typedef</span> bool (stat_print_fn)(THD *thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *type, uint type_len,
<a name="l00719"></a>00719                              <span class="keyword">const</span> <span class="keywordtype">char</span> *file, uint file_len,
<a name="l00720"></a>00720                              <span class="keyword">const</span> <span class="keywordtype">char</span> *status, uint status_len);
<a name="l00721"></a>00721 <span class="keyword">enum</span> ha_stat_type { HA_ENGINE_STATUS, HA_ENGINE_LOGS, HA_ENGINE_MUTEX };
<a name="l00722"></a>00722 <span class="keyword">extern</span> <a class="code" href="structst__plugin__int.html">st_plugin_int</a> *hton2plugin[MAX_HA];
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 <span class="comment">/* Transaction log maintains type definitions */</span>
<a name="l00725"></a>00725 <span class="keyword">enum</span> log_status
<a name="l00726"></a>00726 {
<a name="l00727"></a>00727   HA_LOG_STATUS_FREE= 0,      <span class="comment">/* log is free and can be deleted */</span>
<a name="l00728"></a>00728   HA_LOG_STATUS_INUSE= 1,     <span class="comment">/* log can&#39;t be deleted because it is in use */</span>
<a name="l00729"></a>00729   HA_LOG_STATUS_NOSUCHLOG= 2  <span class="comment">/* no such log (can&#39;t be returned by</span>
<a name="l00730"></a>00730 <span class="comment">                                the log iterator status) */</span>
<a name="l00731"></a>00731 };
<a name="l00732"></a>00732 <span class="comment">/*</span>
<a name="l00733"></a>00733 <span class="comment">  Function for signaling that the log file changed its state from</span>
<a name="l00734"></a>00734 <span class="comment">  LOG_STATUS_INUSE to LOG_STATUS_FREE</span>
<a name="l00735"></a>00735 <span class="comment"></span>
<a name="l00736"></a>00736 <span class="comment">  Now it do nothing, will be implemented as part of new transaction</span>
<a name="l00737"></a>00737 <span class="comment">  log management for engines.</span>
<a name="l00738"></a>00738 <span class="comment">  TODO: implement the function.</span>
<a name="l00739"></a>00739 <span class="comment">*/</span>
<a name="l00740"></a>00740 <span class="keywordtype">void</span> <a class="code" href="handler_8cc.html#a5c3fac9bba02dad1b33fa9eb648ca282" title="Dummy function which accept information about log files which is not need by handlers.">signal_log_not_needed</a>(<span class="keyword">struct</span> <a class="code" href="structhandlerton.html">handlerton</a>, <span class="keywordtype">char</span> *log_file);
<a name="l00741"></a>00741 <span class="comment">/*</span>
<a name="l00742"></a>00742 <span class="comment">  Data of transaction log iterator.</span>
<a name="l00743"></a>00743 <span class="comment">*/</span>
<a name="l00744"></a><a class="code" href="structhandler__log__file__data.html">00744</a> <span class="keyword">struct </span><a class="code" href="structhandler__log__file__data.html">handler_log_file_data</a> {
<a name="l00745"></a>00745   LEX_STRING filename;
<a name="l00746"></a>00746   <span class="keyword">enum</span> log_status status;
<a name="l00747"></a>00747 };
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 <span class="keyword">enum</span> handler_iterator_type
<a name="l00751"></a>00751 {
<a name="l00752"></a>00752   <span class="comment">/* request of transaction log iterator */</span>
<a name="l00753"></a>00753   HA_TRANSACTLOG_ITERATOR= 1
<a name="l00754"></a>00754 };
<a name="l00755"></a>00755 <span class="keyword">enum</span> handler_create_iterator_result
<a name="l00756"></a>00756 {
<a name="l00757"></a>00757   HA_ITERATOR_OK,          <span class="comment">/* iterator created */</span>
<a name="l00758"></a>00758   HA_ITERATOR_UNSUPPORTED, <span class="comment">/* such type of iterator is not supported */</span>
<a name="l00759"></a>00759   HA_ITERATOR_ERROR        <span class="comment">/* error during iterator creation */</span>
<a name="l00760"></a>00760 };
<a name="l00761"></a>00761 
<a name="l00762"></a>00762 <span class="comment">/*</span>
<a name="l00763"></a>00763 <span class="comment">  Iterator structure. Can be used by handler/handlerton for different purposes.</span>
<a name="l00764"></a>00764 <span class="comment"></span>
<a name="l00765"></a>00765 <span class="comment">  Iterator should be created in the way to point &quot;before&quot; the first object</span>
<a name="l00766"></a>00766 <span class="comment">  it iterate, so next() call move it to the first object or return !=0 if</span>
<a name="l00767"></a>00767 <span class="comment">  there is nothing to iterate through.</span>
<a name="l00768"></a>00768 <span class="comment">*/</span>
<a name="l00769"></a><a class="code" href="structhandler__iterator.html">00769</a> <span class="keyword">struct </span><a class="code" href="structhandler__iterator.html">handler_iterator</a> {
<a name="l00770"></a>00770   <span class="comment">/*</span>
<a name="l00771"></a>00771 <span class="comment">    Moves iterator to next record and return 0 or return !=0</span>
<a name="l00772"></a>00772 <span class="comment">    if there is no records.</span>
<a name="l00773"></a>00773 <span class="comment">    iterator_object will be filled by this function if next() returns 0.</span>
<a name="l00774"></a>00774 <span class="comment">    Content of the iterator_object depend on iterator type.</span>
<a name="l00775"></a>00775 <span class="comment">  */</span>
<a name="l00776"></a>00776   int (*next)(<span class="keyword">struct </span><a class="code" href="structhandler__iterator.html">handler_iterator</a> *, <span class="keywordtype">void</span> *iterator_object);
<a name="l00777"></a>00777   <span class="comment">/*</span>
<a name="l00778"></a>00778 <span class="comment">    Free resources allocated by iterator, after this call iterator</span>
<a name="l00779"></a>00779 <span class="comment">    is not usable.</span>
<a name="l00780"></a>00780 <span class="comment">  */</span>
<a name="l00781"></a>00781   void (*destroy)(<span class="keyword">struct </span><a class="code" href="structhandler__iterator.html">handler_iterator</a> *);
<a name="l00782"></a>00782   <span class="comment">/*</span>
<a name="l00783"></a>00783 <span class="comment">    Pointer to buffer for the iterator to use.</span>
<a name="l00784"></a>00784 <span class="comment">    Should be allocated by function which created the iterator and</span>
<a name="l00785"></a>00785 <span class="comment">    destroied by freed by above &quot;destroy&quot; call</span>
<a name="l00786"></a>00786 <span class="comment">  */</span>
<a name="l00787"></a>00787   <span class="keywordtype">void</span> *buffer;
<a name="l00788"></a>00788 };
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <span class="keyword">class </span><a class="code" href="classhandler.html">handler</a>;
<a name="l00791"></a>00791 <span class="comment">/*</span>
<a name="l00792"></a>00792 <span class="comment">  handlerton is a singleton structure - one instance per storage engine -</span>
<a name="l00793"></a>00793 <span class="comment">  to provide access to storage engine functionality that works on the</span>
<a name="l00794"></a>00794 <span class="comment">  &quot;global&quot; level (unlike handler class that works on a per-table basis)</span>
<a name="l00795"></a>00795 <span class="comment"></span>
<a name="l00796"></a>00796 <span class="comment">  usually handlerton instance is defined statically in ha_xxx.cc as</span>
<a name="l00797"></a>00797 <span class="comment"></span>
<a name="l00798"></a>00798 <span class="comment">  static handlerton { ... } xxx_hton;</span>
<a name="l00799"></a>00799 <span class="comment"></span>
<a name="l00800"></a>00800 <span class="comment">  savepoint_*, prepare, recover, and *_by_xid pointers can be 0.</span>
<a name="l00801"></a>00801 <span class="comment">*/</span>
<a name="l00802"></a><a class="code" href="structhandlerton.html">00802</a> <span class="keyword">struct </span><a class="code" href="structhandlerton.html">handlerton</a>
<a name="l00803"></a>00803 {
<a name="l00804"></a>00804   <span class="comment">/*</span>
<a name="l00805"></a>00805 <span class="comment">    Historical marker for if the engine is available of not</span>
<a name="l00806"></a>00806 <span class="comment">  */</span>
<a name="l00807"></a>00807   SHOW_COMP_OPTION state;
<a name="l00808"></a>00808 
<a name="l00809"></a>00809   <span class="comment">/*</span>
<a name="l00810"></a>00810 <span class="comment">    Historical number used for frm file to determine the correct storage engine.</span>
<a name="l00811"></a>00811 <span class="comment">    This is going away and new engines will just use &quot;name&quot; for this.</span>
<a name="l00812"></a>00812 <span class="comment">  */</span>
<a name="l00813"></a>00813   <span class="keyword">enum</span> legacy_db_type db_type;
<a name="l00814"></a>00814   <span class="comment">/*</span>
<a name="l00815"></a>00815 <span class="comment">    each storage engine has it&#39;s own memory area (actually a pointer)</span>
<a name="l00816"></a>00816 <span class="comment">    in the thd, for storing per-connection information.</span>
<a name="l00817"></a>00817 <span class="comment">    It is accessed as</span>
<a name="l00818"></a>00818 <span class="comment"></span>
<a name="l00819"></a>00819 <span class="comment">      thd-&gt;ha_data[xxx_hton.slot]</span>
<a name="l00820"></a>00820 <span class="comment"></span>
<a name="l00821"></a>00821 <span class="comment">   slot number is initialized by MySQL after xxx_init() is called.</span>
<a name="l00822"></a>00822 <span class="comment">   */</span>
<a name="l00823"></a>00823    uint slot;
<a name="l00824"></a>00824    <span class="comment">/*</span>
<a name="l00825"></a>00825 <span class="comment">     to store per-savepoint data storage engine is provided with an area</span>
<a name="l00826"></a>00826 <span class="comment">     of a requested size (0 is ok here).</span>
<a name="l00827"></a>00827 <span class="comment">     savepoint_offset must be initialized statically to the size of</span>
<a name="l00828"></a>00828 <span class="comment">     the needed memory to store per-savepoint information.</span>
<a name="l00829"></a>00829 <span class="comment">     After xxx_init it is changed to be an offset to savepoint storage</span>
<a name="l00830"></a>00830 <span class="comment">     area and need not be used by storage engine.</span>
<a name="l00831"></a>00831 <span class="comment">     see binlog_hton and binlog_savepoint_set/rollback for an example.</span>
<a name="l00832"></a>00832 <span class="comment">   */</span>
<a name="l00833"></a>00833    uint savepoint_offset;
<a name="l00834"></a>00834    <span class="comment">/*</span>
<a name="l00835"></a>00835 <span class="comment">     handlerton methods:</span>
<a name="l00836"></a>00836 <span class="comment"></span>
<a name="l00837"></a>00837 <span class="comment">     close_connection is only called if</span>
<a name="l00838"></a>00838 <span class="comment">     thd-&gt;ha_data[xxx_hton.slot] is non-zero, so even if you don&#39;t need</span>
<a name="l00839"></a>00839 <span class="comment">     this storage area - set it to something, so that MySQL would know</span>
<a name="l00840"></a>00840 <span class="comment">     this storage engine was accessed in this connection</span>
<a name="l00841"></a>00841 <span class="comment">   */</span>
<a name="l00842"></a>00842    int  (*close_connection)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd);
<a name="l00843"></a>00843    <span class="comment">/*</span>
<a name="l00844"></a>00844 <span class="comment">     sv points to an uninitialized storage area of requested size</span>
<a name="l00845"></a>00845 <span class="comment">     (see savepoint_offset description)</span>
<a name="l00846"></a>00846 <span class="comment">   */</span>
<a name="l00847"></a>00847    int  (*savepoint_set)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <span class="keywordtype">void</span> *sv);
<a name="l00848"></a>00848    <span class="comment">/*</span>
<a name="l00849"></a>00849 <span class="comment">     sv points to a storage area, that was earlier passed</span>
<a name="l00850"></a>00850 <span class="comment">     to the savepoint_set call</span>
<a name="l00851"></a>00851 <span class="comment">   */</span>
<a name="l00852"></a>00852    int  (*savepoint_rollback)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <span class="keywordtype">void</span> *sv);
<a name="l00859"></a><a class="code" href="structhandlerton.html#a6956aa9ca5819cb457d84318d1afdb81">00859</a>    bool (*<a class="code" href="structhandlerton.html#a6956aa9ca5819cb457d84318d1afdb81">savepoint_rollback_can_release_mdl</a>)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd);
<a name="l00860"></a>00860    int  (*savepoint_release)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <span class="keywordtype">void</span> *sv);
<a name="l00861"></a>00861    <span class="comment">/*</span>
<a name="l00862"></a>00862 <span class="comment">     &#39;all&#39; is true if it&#39;s a real commit, that makes persistent changes</span>
<a name="l00863"></a>00863 <span class="comment">     &#39;all&#39; is false if it&#39;s not in fact a commit but an end of the</span>
<a name="l00864"></a>00864 <span class="comment">     statement that is part of the transaction.</span>
<a name="l00865"></a>00865 <span class="comment">     NOTE &#39;all&#39; is also false in auto-commit mode where &#39;end of statement&#39;</span>
<a name="l00866"></a>00866 <span class="comment">     and &#39;real commit&#39; mean the same event.</span>
<a name="l00867"></a>00867 <span class="comment">   */</span>
<a name="l00868"></a>00868    int  (*commit)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <span class="keywordtype">bool</span> all);
<a name="l00869"></a>00869    int  (*rollback)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <span class="keywordtype">bool</span> all);
<a name="l00870"></a>00870    int  (*prepare)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <span class="keywordtype">bool</span> all);
<a name="l00871"></a>00871    int  (*recover)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <a class="code" href="structxid__t.html">XID</a> *xid_list, uint len);
<a name="l00872"></a>00872    int  (*commit_by_xid)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <a class="code" href="structxid__t.html">XID</a> *xid);
<a name="l00873"></a>00873    int  (*rollback_by_xid)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <a class="code" href="structxid__t.html">XID</a> *xid);
<a name="l00874"></a>00874    <span class="keywordtype">void</span> *(*create_cursor_read_view)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd);
<a name="l00875"></a>00875    void (*set_cursor_read_view)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <span class="keywordtype">void</span> *read_view);
<a name="l00876"></a>00876    void (*close_cursor_read_view)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <span class="keywordtype">void</span> *read_view);
<a name="l00877"></a>00877    <a class="code" href="classhandler.html">handler</a> *(*create)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *table, MEM_ROOT *mem_root);
<a name="l00878"></a>00878    void (*drop_database)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <span class="keywordtype">char</span>* path);
<a name="l00879"></a>00879    int (*panic)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <span class="keyword">enum</span> ha_panic_function flag);
<a name="l00880"></a>00880    int (*start_consistent_snapshot)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd);
<a name="l00881"></a>00881    bool (*flush_logs)(<a class="code" href="structhandlerton.html">handlerton</a> *hton);
<a name="l00882"></a>00882    bool (*show_status)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, stat_print_fn *print, <span class="keyword">enum</span> ha_stat_type stat);
<a name="l00883"></a>00883    uint (*partition_flags)();
<a name="l00884"></a>00884    uint (*alter_table_flags)(uint flags);
<a name="l00885"></a>00885    int (*alter_tablespace)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <a class="code" href="classst__alter__tablespace.html">st_alter_tablespace</a> *ts_info);
<a name="l00886"></a>00886    int (*fill_is_table)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, 
<a name="l00887"></a>00887                         <span class="keyword">class </span><a class="code" href="classItem.html">Item</a> *cond, 
<a name="l00888"></a>00888                         <span class="keyword">enum</span> enum_schema_tables);
<a name="l00889"></a>00889    uint32 flags;                                <span class="comment">/* global handler flags */</span>
<a name="l00890"></a>00890    <span class="comment">/*</span>
<a name="l00891"></a>00891 <span class="comment">      Those handlerton functions below are properly initialized at handler</span>
<a name="l00892"></a>00892 <span class="comment">      init.</span>
<a name="l00893"></a>00893 <span class="comment">   */</span>
<a name="l00894"></a>00894    int (*binlog_func)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, enum_binlog_func fn, <span class="keywordtype">void</span> *arg);
<a name="l00895"></a>00895    void (*binlog_log_query)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd, 
<a name="l00896"></a>00896                             enum_binlog_command binlog_command,
<a name="l00897"></a>00897                             <span class="keyword">const</span> <span class="keywordtype">char</span> *query, uint query_length,
<a name="l00898"></a>00898                             <span class="keyword">const</span> <span class="keywordtype">char</span> *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *table_name);
<a name="l00899"></a>00899    int (*release_temporary_latches)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd);
<a name="l00900"></a>00900 
<a name="l00901"></a>00901    <span class="comment">/*</span>
<a name="l00902"></a>00902 <span class="comment">     Get log status.</span>
<a name="l00903"></a>00903 <span class="comment">     If log_status is null then the handler do not support transaction</span>
<a name="l00904"></a>00904 <span class="comment">     log information (i.e. log iterator can&#39;t be created).</span>
<a name="l00905"></a>00905 <span class="comment">     (see example of implementation in handler.cc, TRANS_LOG_MGM_EXAMPLE_CODE)</span>
<a name="l00906"></a>00906 <span class="comment"></span>
<a name="l00907"></a>00907 <span class="comment">   */</span>
<a name="l00908"></a>00908    <span class="keyword">enum</span> log_status (*get_log_status)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <span class="keywordtype">char</span> *log);
<a name="l00909"></a>00909 
<a name="l00910"></a>00910    <span class="comment">/*</span>
<a name="l00911"></a>00911 <span class="comment">     Iterators creator.</span>
<a name="l00912"></a>00912 <span class="comment">     Presence of the pointer should be checked before using</span>
<a name="l00913"></a>00913 <span class="comment">   */</span>
<a name="l00914"></a>00914    <span class="keyword">enum</span> handler_create_iterator_result
<a name="l00915"></a>00915      (*create_iterator)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <span class="keyword">enum</span> handler_iterator_type type,
<a name="l00916"></a>00916                         <span class="keyword">struct </span><a class="code" href="structhandler__iterator.html">handler_iterator</a> *fill_this_in);
<a name="l00917"></a>00917    int (*discover)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD* thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *db, 
<a name="l00918"></a>00918                    <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00919"></a>00919                    uchar **frmblob, 
<a name="l00920"></a>00920                    <span class="keywordtype">size_t</span> *frmlen);
<a name="l00921"></a>00921    int (*find_files)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD *thd,
<a name="l00922"></a>00922                      <span class="keyword">const</span> <span class="keywordtype">char</span> *db,
<a name="l00923"></a>00923                      <span class="keyword">const</span> <span class="keywordtype">char</span> *path,
<a name="l00924"></a>00924                      <span class="keyword">const</span> <span class="keywordtype">char</span> *wild, <span class="keywordtype">bool</span> dir, <a class="code" href="classList.html">List&lt;LEX_STRING&gt;</a> *files);
<a name="l00925"></a>00925    int (*table_exists_in_engine)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD* thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *db,
<a name="l00926"></a>00926                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l00927"></a>00927    int (*make_pushed_join)(<a class="code" href="structhandlerton.html">handlerton</a> *hton, THD* thd, 
<a name="l00928"></a>00928                            <span class="keyword">const</span> <a class="code" href="classAQP_1_1Join__plan.html">AQP::Join_plan</a>* plan);
<a name="l00929"></a>00929 
<a name="l00941"></a><a class="code" href="structhandlerton.html#abf4414258eeb9135a9a21afb4695c4cb">00941</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* (*system_database)();
<a name="l00942"></a>00942 
<a name="l00958"></a><a class="code" href="structhandlerton.html#a978963d2e0fca8d726afe568c3f4c3c8">00958</a>   bool (*<a class="code" href="structhandlerton.html#a978963d2e0fca8d726afe568c3f4c3c8">is_supported_system_table</a>)(<span class="keyword">const</span> <span class="keywordtype">char</span> *db,
<a name="l00959"></a>00959                                     <span class="keyword">const</span> <span class="keywordtype">char</span> *table_name,
<a name="l00960"></a>00960                                     <span class="keywordtype">bool</span> is_sql_layer_system_table);
<a name="l00961"></a>00961 
<a name="l00962"></a>00962    uint32 license; <span class="comment">/* Flag for Engine License */</span>
<a name="l00963"></a>00963    <span class="keywordtype">void</span> *data; <span class="comment">/* Location for engines to keep personal structures */</span>
<a name="l00964"></a>00964 };
<a name="l00965"></a>00965 
<a name="l00966"></a>00966 
<a name="l00967"></a>00967 <span class="comment">/* Possible flags of a handlerton (there can be 32 of them) */</span>
<a name="l00968"></a>00968 <span class="preprocessor">#define HTON_NO_FLAGS                 0</span>
<a name="l00969"></a>00969 <span class="preprocessor"></span><span class="preprocessor">#define HTON_CLOSE_CURSORS_AT_COMMIT (1 &lt;&lt; 0)</span>
<a name="l00970"></a>00970 <span class="preprocessor"></span><span class="preprocessor">#define HTON_ALTER_NOT_SUPPORTED     (1 &lt;&lt; 1) //Engine does not support alter</span>
<a name="l00971"></a>00971 <span class="preprocessor"></span><span class="preprocessor">#define HTON_CAN_RECREATE            (1 &lt;&lt; 2) //Delete all is used fro truncate</span>
<a name="l00972"></a>00972 <span class="preprocessor"></span><span class="preprocessor">#define HTON_HIDDEN                  (1 &lt;&lt; 3) //Engine does not appear in lists</span>
<a name="l00973"></a>00973 <span class="preprocessor"></span><span class="preprocessor">#define HTON_FLUSH_AFTER_RENAME      (1 &lt;&lt; 4)</span>
<a name="l00974"></a>00974 <span class="preprocessor"></span><span class="preprocessor">#define HTON_NOT_USER_SELECTABLE     (1 &lt;&lt; 5)</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span><span class="preprocessor">#define HTON_TEMPORARY_NOT_SUPPORTED (1 &lt;&lt; 6) //Having temporary tables not supported</span>
<a name="l00976"></a>00976 <span class="preprocessor"></span><span class="preprocessor">#define HTON_SUPPORT_LOG_TABLES      (1 &lt;&lt; 7) //Engine supports log tables</span>
<a name="l00977"></a>00977 <span class="preprocessor"></span><span class="preprocessor">#define HTON_NO_PARTITION            (1 &lt;&lt; 8) //You can not partition these tables</span>
<a name="l00978"></a>00978 <span class="preprocessor"></span>
<a name="l00979"></a>00979 <span class="comment">/*</span>
<a name="l00980"></a>00980 <span class="comment">  This flag should be set when deciding that the engine does not allow row based</span>
<a name="l00981"></a>00981 <span class="comment">  binary logging (RBL) optimizations.</span>
<a name="l00982"></a>00982 <span class="comment"></span>
<a name="l00983"></a>00983 <span class="comment">  Currently, setting this flag, means that table&#39;s read/write_set will be left </span>
<a name="l00984"></a>00984 <span class="comment">  untouched when logging changes to tables in this engine. In practice this </span>
<a name="l00985"></a>00985 <span class="comment">  means that the server will not mess around with table-&gt;write_set and/or </span>
<a name="l00986"></a>00986 <span class="comment">  table-&gt;read_set when using RBL and deciding whether to log full or minimal rows.</span>
<a name="l00987"></a>00987 <span class="comment"></span>
<a name="l00988"></a>00988 <span class="comment">  It&#39;s valuable for instance for virtual tables, eg: Performance Schema which have</span>
<a name="l00989"></a>00989 <span class="comment">  no meaning for replication.</span>
<a name="l00990"></a>00990 <span class="comment">*/</span>
<a name="l00991"></a>00991 <span class="preprocessor">#define HTON_NO_BINLOG_ROW_OPT       (1 &lt;&lt; 9)</span>
<a name="l00992"></a>00992 <span class="preprocessor"></span>
<a name="l01001"></a>01001 <span class="preprocessor">#define HTON_SUPPORTS_EXTENDED_KEYS  (1 &lt;&lt; 10)</span>
<a name="l01002"></a>01002 <span class="preprocessor"></span><span class="comment">// Engine supports foreign key constraint.</span>
<a name="l01003"></a>01003 <span class="preprocessor">#define HTON_SUPPORTS_FOREIGN_KEYS   (1 &lt;&lt; 11)</span>
<a name="l01004"></a>01004 <span class="preprocessor"></span>
<a name="l01005"></a>01005 
<a name="l01006"></a>01006 <span class="keyword">enum</span> enum_tx_isolation { ISO_READ_UNCOMMITTED, ISO_READ_COMMITTED,
<a name="l01007"></a>01007                          ISO_REPEATABLE_READ, ISO_SERIALIZABLE};
<a name="l01008"></a>01008 
<a name="l01009"></a>01009 
<a name="l01010"></a><a class="code" href="structPARTITION__STATS.html">01010</a> <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l01011"></a>01011   ulonglong data_file_length;
<a name="l01012"></a>01012   ulonglong max_data_file_length;
<a name="l01013"></a>01013   ulonglong index_file_length;
<a name="l01014"></a>01014   ulonglong delete_length;
<a name="l01015"></a>01015   ha_rows records;
<a name="l01016"></a>01016   ulong mean_rec_length;
<a name="l01017"></a>01017   ulong create_time;
<a name="l01018"></a>01018   ulong check_time;
<a name="l01019"></a>01019   ulong update_time;
<a name="l01020"></a>01020   ulonglong check_sum;
<a name="l01021"></a>01021 } <a class="code" href="structPARTITION__STATS.html">PARTITION_STATS</a>;
<a name="l01022"></a>01022 
<a name="l01023"></a>01023 <span class="preprocessor">#define UNDEF_NODEGROUP 65535</span>
<a name="l01024"></a>01024 <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classItem.html">Item</a>;
<a name="l01025"></a>01025 <span class="keyword">struct </span>st_table_log_memory_entry;
<a name="l01026"></a>01026 
<a name="l01027"></a>01027 <span class="keyword">class </span><a class="code" href="classpartition__info.html">partition_info</a>;
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 <span class="keyword">struct </span><a class="code" href="structst__partition__iter.html">st_partition_iter</a>;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 <span class="keyword">enum</span> enum_ha_unused { HA_CHOICE_UNDEF, HA_CHOICE_NO, HA_CHOICE_YES };
<a name="l01032"></a>01032 
<a name="l01033"></a>01033 <span class="keyword">enum</span> enum_stats_auto_recalc { HA_STATS_AUTO_RECALC_DEFAULT= 0,
<a name="l01034"></a>01034                               HA_STATS_AUTO_RECALC_ON,
<a name="l01035"></a>01035                               HA_STATS_AUTO_RECALC_OFF };
<a name="l01036"></a>01036 
<a name="l01037"></a><a class="code" href="structst__ha__create__information.html">01037</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__ha__create__information.html">st_ha_create_information</a>
<a name="l01038"></a>01038 {
<a name="l01039"></a>01039   <span class="keyword">const</span> CHARSET_INFO *table_charset, *default_table_charset;
<a name="l01040"></a>01040   LEX_STRING connect_string;
<a name="l01041"></a>01041   <span class="keyword">const</span> <span class="keywordtype">char</span> *password, *tablespace;
<a name="l01042"></a>01042   LEX_STRING comment;
<a name="l01043"></a>01043   <span class="keyword">const</span> <span class="keywordtype">char</span> *data_file_name, *index_file_name;
<a name="l01044"></a>01044   <span class="keyword">const</span> <span class="keywordtype">char</span> *alias;
<a name="l01045"></a>01045   ulonglong max_rows,min_rows;
<a name="l01046"></a>01046   ulonglong auto_increment_value;
<a name="l01047"></a>01047   ulong table_options;
<a name="l01048"></a>01048   ulong avg_row_length;
<a name="l01049"></a>01049   ulong used_fields;
<a name="l01050"></a>01050   ulong key_block_size;
<a name="l01051"></a>01051   uint stats_sample_pages;              <span class="comment">/* number of pages to sample during</span>
<a name="l01052"></a>01052 <span class="comment">                                        stats estimation, if used, otherwise 0. */</span>
<a name="l01053"></a>01053   enum_stats_auto_recalc stats_auto_recalc;
<a name="l01054"></a>01054   <a class="code" href="classSQL__I__List.html">SQL_I_List&lt;TABLE_LIST&gt;</a> merge_list;
<a name="l01055"></a>01055   <a class="code" href="structhandlerton.html">handlerton</a> *db_type;
<a name="l01065"></a><a class="code" href="structst__ha__create__information.html#a2fd611ab0e3c6de92e58f50ca56efd76">01065</a>   <span class="keyword">enum</span> row_type <a class="code" href="structst__ha__create__information.html#a2fd611ab0e3c6de92e58f50ca56efd76">row_type</a>;
<a name="l01066"></a>01066   uint null_bits;                       <span class="comment">/* NULL bits at start of record */</span>
<a name="l01067"></a>01067   uint options;                         <span class="comment">/* OR of HA_CREATE_ options */</span>
<a name="l01068"></a>01068   uint merge_insert_method;
<a name="l01069"></a>01069   uint extra_size;                      <span class="comment">/* length of extra data segment */</span>
<a name="l01070"></a>01070   <span class="keywordtype">bool</span> varchar;                         <span class="comment">/* 1 if table has a VARCHAR */</span>
<a name="l01071"></a>01071   <span class="keyword">enum</span> ha_storage_media storage_media;  <span class="comment">/* DEFAULT, DISK or MEMORY */</span>
<a name="l01072"></a>01072 } <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a>;
<a name="l01073"></a>01073 
<a name="l01089"></a><a class="code" href="classinplace__alter__handler__ctx.html">01089</a> <span class="keyword">class </span><a class="code" href="classinplace__alter__handler__ctx.html">inplace_alter_handler_ctx</a> : <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l01090"></a>01090 {
<a name="l01091"></a>01091 <span class="keyword">public</span>:
<a name="l01092"></a>01092   <a class="code" href="classinplace__alter__handler__ctx.html">inplace_alter_handler_ctx</a>() {}
<a name="l01093"></a>01093 
<a name="l01094"></a>01094   <span class="keyword">virtual</span> ~<a class="code" href="classinplace__alter__handler__ctx.html">inplace_alter_handler_ctx</a>() {}
<a name="l01095"></a>01095 };
<a name="l01096"></a>01096 
<a name="l01097"></a>01097 
<a name="l01106"></a><a class="code" href="classAlter__inplace__info.html">01106</a> <span class="keyword">class </span><a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a>
<a name="l01107"></a>01107 {
<a name="l01108"></a>01108 <span class="keyword">public</span>:
<a name="l01123"></a><a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">01123</a>   <span class="keyword">typedef</span> ulong <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a>;
<a name="l01124"></a>01124 
<a name="l01125"></a>01125   <span class="comment">// Add non-unique, non-primary index</span>
<a name="l01126"></a>01126   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ADD_INDEX                  = 1L &lt;&lt; 0;
<a name="l01127"></a>01127 
<a name="l01128"></a>01128   <span class="comment">// Drop non-unique, non-primary index</span>
<a name="l01129"></a>01129   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> DROP_INDEX                 = 1L &lt;&lt; 1;
<a name="l01130"></a>01130 
<a name="l01131"></a>01131   <span class="comment">// Add unique, non-primary index</span>
<a name="l01132"></a>01132   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ADD_UNIQUE_INDEX           = 1L &lt;&lt; 2;
<a name="l01133"></a>01133 
<a name="l01134"></a>01134   <span class="comment">// Drop unique, non-primary index</span>
<a name="l01135"></a>01135   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> DROP_UNIQUE_INDEX          = 1L &lt;&lt; 3;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137   <span class="comment">// Add primary index</span>
<a name="l01138"></a>01138   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ADD_PK_INDEX               = 1L &lt;&lt; 4;
<a name="l01139"></a>01139 
<a name="l01140"></a>01140   <span class="comment">// Drop primary index</span>
<a name="l01141"></a>01141   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> DROP_PK_INDEX              = 1L &lt;&lt; 5;
<a name="l01142"></a>01142 
<a name="l01143"></a>01143   <span class="comment">// Add column</span>
<a name="l01144"></a>01144   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ADD_COLUMN                 = 1L &lt;&lt; 6;
<a name="l01145"></a>01145 
<a name="l01146"></a>01146   <span class="comment">// Drop column</span>
<a name="l01147"></a>01147   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> DROP_COLUMN                = 1L &lt;&lt; 7;
<a name="l01148"></a>01148 
<a name="l01149"></a>01149   <span class="comment">// Rename column</span>
<a name="l01150"></a>01150   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_COLUMN_NAME          = 1L &lt;&lt; 8;
<a name="l01151"></a>01151 
<a name="l01152"></a>01152   <span class="comment">// Change column datatype</span>
<a name="l01153"></a>01153   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_COLUMN_TYPE          = 1L &lt;&lt; 9;
<a name="l01154"></a>01154 
<a name="l01161"></a><a class="code" href="classAlter__inplace__info.html#a8169d3b1b033846bd832c449fdf3a733">01161</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> <a class="code" href="classAlter__inplace__info.html#a8169d3b1b033846bd832c449fdf3a733">ALTER_COLUMN_EQUAL_PACK_LENGTH</a> = 1L &lt;&lt; 10;
<a name="l01162"></a>01162 
<a name="l01163"></a>01163   <span class="comment">// Reorder column</span>
<a name="l01164"></a>01164   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_COLUMN_ORDER         = 1L &lt;&lt; 11;
<a name="l01165"></a>01165 
<a name="l01166"></a>01166   <span class="comment">// Change column from NOT NULL to NULL</span>
<a name="l01167"></a>01167   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_COLUMN_NULLABLE      = 1L &lt;&lt; 12;
<a name="l01168"></a>01168 
<a name="l01169"></a>01169   <span class="comment">// Change column from NULL to NOT NULL</span>
<a name="l01170"></a>01170   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_COLUMN_NOT_NULLABLE  = 1L &lt;&lt; 13;
<a name="l01171"></a>01171 
<a name="l01172"></a>01172   <span class="comment">// Set or remove default column value</span>
<a name="l01173"></a>01173   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_COLUMN_DEFAULT       = 1L &lt;&lt; 14;
<a name="l01174"></a>01174 
<a name="l01175"></a>01175   <span class="comment">// Add foreign key</span>
<a name="l01176"></a>01176   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ADD_FOREIGN_KEY            = 1L &lt;&lt; 15;
<a name="l01177"></a>01177 
<a name="l01178"></a>01178   <span class="comment">// Drop foreign key</span>
<a name="l01179"></a>01179   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> DROP_FOREIGN_KEY           = 1L &lt;&lt; 16;
<a name="l01180"></a>01180 
<a name="l01181"></a>01181   <span class="comment">// table_options changed, see HA_CREATE_INFO::used_fields for details.</span>
<a name="l01182"></a>01182   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> CHANGE_CREATE_OPTION       = 1L &lt;&lt; 17;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184   <span class="comment">// Table is renamed</span>
<a name="l01185"></a>01185   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_RENAME               = 1L &lt;&lt; 18;
<a name="l01186"></a>01186 
<a name="l01187"></a>01187   <span class="comment">// Change the storage type of column </span>
<a name="l01188"></a>01188   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_COLUMN_STORAGE_TYPE = 1L &lt;&lt; 19;
<a name="l01189"></a>01189 
<a name="l01190"></a>01190   <span class="comment">// Change the column format of column</span>
<a name="l01191"></a>01191   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_COLUMN_COLUMN_FORMAT = 1L &lt;&lt; 20;
<a name="l01192"></a>01192 
<a name="l01193"></a>01193   <span class="comment">// Add partition</span>
<a name="l01194"></a>01194   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ADD_PARTITION              = 1L &lt;&lt; 21;
<a name="l01195"></a>01195 
<a name="l01196"></a>01196   <span class="comment">// Drop partition</span>
<a name="l01197"></a>01197   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> DROP_PARTITION             = 1L &lt;&lt; 22;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199   <span class="comment">// Changing partition options</span>
<a name="l01200"></a>01200   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_PARTITION            = 1L &lt;&lt; 23;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202   <span class="comment">// Coalesce partition</span>
<a name="l01203"></a>01203   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> COALESCE_PARTITION         = 1L &lt;&lt; 24;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205   <span class="comment">// Reorganize partition ... into</span>
<a name="l01206"></a>01206   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> REORGANIZE_PARTITION       = 1L &lt;&lt; 25;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208   <span class="comment">// Reorganize partition</span>
<a name="l01209"></a>01209   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_TABLE_REORG          = 1L &lt;&lt; 26;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211   <span class="comment">// Remove partitioning</span>
<a name="l01212"></a>01212   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_REMOVE_PARTITIONING  = 1L &lt;&lt; 27;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214   <span class="comment">// Partition operation with ALL keyword</span>
<a name="l01215"></a>01215   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> ALTER_ALL_PARTITION        = 1L &lt;&lt; 28;
<a name="l01216"></a>01216 
<a name="l01221"></a><a class="code" href="classAlter__inplace__info.html#a30dd1964ce7046dee60a5b9284cdfe0b">01221</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> <a class="code" href="classAlter__inplace__info.html#a30dd1964ce7046dee60a5b9284cdfe0b">RECREATE_TABLE</a>             = 1L &lt;&lt; 29;
<a name="l01222"></a>01222 
<a name="l01232"></a><a class="code" href="classAlter__inplace__info.html#a98ccd138fdc5742b611b7328fc1c77a4">01232</a>   <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *<a class="code" href="classAlter__inplace__info.html#a98ccd138fdc5742b611b7328fc1c77a4">create_info</a>;
<a name="l01233"></a>01233 
<a name="l01245"></a><a class="code" href="classAlter__inplace__info.html#a025d7b7318cc152b91c63e89e9dbd2c8">01245</a>   <a class="code" href="classAlter__info.html">Alter_info</a> *<a class="code" href="classAlter__inplace__info.html#a025d7b7318cc152b91c63e89e9dbd2c8">alter_info</a>;
<a name="l01246"></a>01246 
<a name="l01262"></a><a class="code" href="classAlter__inplace__info.html#a1774915f106804ab1aeb6629d58bcae4">01262</a>   <a class="code" href="structst__key.html">KEY</a>  *<a class="code" href="classAlter__inplace__info.html#a1774915f106804ab1aeb6629d58bcae4">key_info_buffer</a>;
<a name="l01263"></a>01263 
<a name="l01265"></a><a class="code" href="classAlter__inplace__info.html#a06a73897d45e7a856647d308fae2bc95">01265</a>   uint <a class="code" href="classAlter__inplace__info.html#a06a73897d45e7a856647d308fae2bc95">key_count</a>;
<a name="l01266"></a>01266 
<a name="l01268"></a><a class="code" href="classAlter__inplace__info.html#a41e2dc4598fb84412237f845b501d086">01268</a>   uint <a class="code" href="classAlter__inplace__info.html#a41e2dc4598fb84412237f845b501d086">index_drop_count</a>;
<a name="l01269"></a>01269 
<a name="l01274"></a><a class="code" href="classAlter__inplace__info.html#ad4fe56b44525e8f3487d04d08ee9f7af">01274</a>   <a class="code" href="structst__key.html">KEY</a>  **<a class="code" href="classAlter__inplace__info.html#ad4fe56b44525e8f3487d04d08ee9f7af">index_drop_buffer</a>;
<a name="l01275"></a>01275 
<a name="l01277"></a><a class="code" href="classAlter__inplace__info.html#a824b2d597ed6cfd9b7e45a01694e6561">01277</a>   uint <a class="code" href="classAlter__inplace__info.html#a824b2d597ed6cfd9b7e45a01694e6561">index_add_count</a>;
<a name="l01278"></a>01278 
<a name="l01283"></a><a class="code" href="classAlter__inplace__info.html#adbd681149c93f943ff27833983ba1843">01283</a>   uint *<a class="code" href="classAlter__inplace__info.html#adbd681149c93f943ff27833983ba1843">index_add_buffer</a>;
<a name="l01284"></a>01284 
<a name="l01291"></a><a class="code" href="classAlter__inplace__info.html#a840f4313301458d892e80fd5bb7c6bcd">01291</a>   <a class="code" href="classinplace__alter__handler__ctx.html">inplace_alter_handler_ctx</a> *<a class="code" href="classAlter__inplace__info.html#a840f4313301458d892e80fd5bb7c6bcd">handler_ctx</a>;
<a name="l01292"></a>01292 
<a name="l01303"></a><a class="code" href="classAlter__inplace__info.html#aeacdbdf2da7047907f86f6b78b4cda9e">01303</a>   <a class="code" href="classinplace__alter__handler__ctx.html">inplace_alter_handler_ctx</a> **<a class="code" href="classAlter__inplace__info.html#aeacdbdf2da7047907f86f6b78b4cda9e">group_commit_ctx</a>;
<a name="l01304"></a>01304 
<a name="l01308"></a><a class="code" href="classAlter__inplace__info.html#aacb64dbd4ca006d7203f84e41890dbfd">01308</a>   <a class="code" href="classAlter__inplace__info.html#a29420335ffe92da5e311bcf5e3c8010a">HA_ALTER_FLAGS</a> <a class="code" href="classAlter__inplace__info.html#aacb64dbd4ca006d7203f84e41890dbfd">handler_flags</a>;
<a name="l01309"></a>01309 
<a name="l01316"></a><a class="code" href="classAlter__inplace__info.html#aa6d44a3120935d9ef9577beeb89f8c51">01316</a>   <a class="code" href="classpartition__info.html">partition_info</a> *<a class="code" href="classAlter__inplace__info.html#aa6d44a3120935d9ef9577beeb89f8c51">modified_part_info</a>;
<a name="l01317"></a>01317 
<a name="l01319"></a><a class="code" href="classAlter__inplace__info.html#ab5ef287d15493d9f375ef370d84e5ab5">01319</a>   <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="classAlter__inplace__info.html#ab5ef287d15493d9f375ef370d84e5ab5">ignore</a>;
<a name="l01320"></a>01320 
<a name="l01322"></a><a class="code" href="classAlter__inplace__info.html#acb2fbc0369799ac74f9cc74cb14d1bdf">01322</a>   <span class="keywordtype">bool</span> <a class="code" href="classAlter__inplace__info.html#acb2fbc0369799ac74f9cc74cb14d1bdf">online</a>;
<a name="l01323"></a>01323 
<a name="l01336"></a><a class="code" href="classAlter__inplace__info.html#a13eca57ab999f94ec5bf6b3c242cbb17">01336</a>   <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classAlter__inplace__info.html#a13eca57ab999f94ec5bf6b3c242cbb17">unsupported_reason</a>;
<a name="l01337"></a>01337 
<a name="l01338"></a>01338   <a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a>(<a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info_arg,
<a name="l01339"></a>01339                      <a class="code" href="classAlter__info.html">Alter_info</a> *alter_info_arg,
<a name="l01340"></a>01340                      <a class="code" href="structst__key.html">KEY</a> *key_info_arg, uint key_count_arg,
<a name="l01341"></a>01341                      <a class="code" href="classpartition__info.html">partition_info</a> *modified_part_info_arg,
<a name="l01342"></a>01342                      <span class="keywordtype">bool</span> ignore_arg)
<a name="l01343"></a>01343     : <a class="code" href="classAlter__inplace__info.html#a98ccd138fdc5742b611b7328fc1c77a4">create_info</a>(create_info_arg),
<a name="l01344"></a>01344     <a class="code" href="classAlter__inplace__info.html#a025d7b7318cc152b91c63e89e9dbd2c8">alter_info</a>(alter_info_arg),
<a name="l01345"></a>01345     <a class="code" href="classAlter__inplace__info.html#a1774915f106804ab1aeb6629d58bcae4">key_info_buffer</a>(key_info_arg),
<a name="l01346"></a>01346     <a class="code" href="classAlter__inplace__info.html#a06a73897d45e7a856647d308fae2bc95">key_count</a>(key_count_arg),
<a name="l01347"></a>01347     <a class="code" href="classAlter__inplace__info.html#a41e2dc4598fb84412237f845b501d086">index_drop_count</a>(0),
<a name="l01348"></a>01348     <a class="code" href="classAlter__inplace__info.html#ad4fe56b44525e8f3487d04d08ee9f7af">index_drop_buffer</a>(NULL),
<a name="l01349"></a>01349     <a class="code" href="classAlter__inplace__info.html#a824b2d597ed6cfd9b7e45a01694e6561">index_add_count</a>(0),
<a name="l01350"></a>01350     <a class="code" href="classAlter__inplace__info.html#adbd681149c93f943ff27833983ba1843">index_add_buffer</a>(NULL),
<a name="l01351"></a>01351     <a class="code" href="classAlter__inplace__info.html#a840f4313301458d892e80fd5bb7c6bcd">handler_ctx</a>(NULL),
<a name="l01352"></a>01352     <a class="code" href="classAlter__inplace__info.html#aeacdbdf2da7047907f86f6b78b4cda9e">group_commit_ctx</a>(NULL),
<a name="l01353"></a>01353     <a class="code" href="classAlter__inplace__info.html#aacb64dbd4ca006d7203f84e41890dbfd">handler_flags</a>(0),
<a name="l01354"></a>01354     <a class="code" href="classAlter__inplace__info.html#aa6d44a3120935d9ef9577beeb89f8c51">modified_part_info</a>(modified_part_info_arg),
<a name="l01355"></a>01355     <a class="code" href="classAlter__inplace__info.html#ab5ef287d15493d9f375ef370d84e5ab5">ignore</a>(ignore_arg),
<a name="l01356"></a>01356     <a class="code" href="classAlter__inplace__info.html#acb2fbc0369799ac74f9cc74cb14d1bdf">online</a>(false),
<a name="l01357"></a>01357     <a class="code" href="classAlter__inplace__info.html#a13eca57ab999f94ec5bf6b3c242cbb17">unsupported_reason</a>(NULL)
<a name="l01358"></a>01358   {}
<a name="l01359"></a>01359 
<a name="l01360"></a>01360   ~<a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a>()
<a name="l01361"></a>01361   {
<a name="l01362"></a>01362     <span class="keyword">delete</span> <a class="code" href="classAlter__inplace__info.html#a840f4313301458d892e80fd5bb7c6bcd">handler_ctx</a>;
<a name="l01363"></a>01363   }
<a name="l01364"></a>01364 
<a name="l01374"></a>01374   <span class="keywordtype">void</span> <a class="code" href="classAlter__inplace__info.html#a675fa8a5eedb1072620e3b831de6d946">report_unsupported_error</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *not_supported,
<a name="l01375"></a>01375                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *try_instead);
<a name="l01376"></a>01376 };
<a name="l01377"></a>01377 
<a name="l01378"></a>01378 
<a name="l01379"></a><a class="code" href="structst__key__create__information.html">01379</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__key__create__information.html">st_key_create_information</a>
<a name="l01380"></a>01380 {
<a name="l01381"></a>01381   <span class="keyword">enum</span> ha_key_alg algorithm;
<a name="l01382"></a>01382   ulong block_size;
<a name="l01383"></a>01383   LEX_STRING parser_name;
<a name="l01384"></a>01384   LEX_STRING comment;
<a name="l01391"></a><a class="code" href="structst__key__create__information.html#afb3cc6d51dba1814dff322bb7a771a99">01391</a>   <span class="keywordtype">bool</span> <a class="code" href="structst__key__create__information.html#afb3cc6d51dba1814dff322bb7a771a99">check_for_duplicate_indexes</a>;
<a name="l01392"></a>01392 } <a class="code" href="structst__key__create__information.html">KEY_CREATE_INFO</a>;
<a name="l01393"></a>01393 
<a name="l01394"></a>01394 
<a name="l01395"></a>01395 <span class="comment">/*</span>
<a name="l01396"></a>01396 <span class="comment">  Class for maintaining hooks used inside operations on tables such</span>
<a name="l01397"></a>01397 <span class="comment">  as: create table functions, delete table functions, and alter table</span>
<a name="l01398"></a>01398 <span class="comment">  functions.</span>
<a name="l01399"></a>01399 <span class="comment"></span>
<a name="l01400"></a>01400 <span class="comment">  Class is using the Template Method pattern to separate the public</span>
<a name="l01401"></a>01401 <span class="comment">  usage interface from the private inheritance interface.  This</span>
<a name="l01402"></a>01402 <span class="comment">  imposes no overhead, since the public non-virtual function is small</span>
<a name="l01403"></a>01403 <span class="comment">  enough to be inlined.</span>
<a name="l01404"></a>01404 <span class="comment"></span>
<a name="l01405"></a>01405 <span class="comment">  The hooks are usually used for functions that does several things,</span>
<a name="l01406"></a>01406 <span class="comment">  e.g., create_table_from_items(), which both create a table and lock</span>
<a name="l01407"></a>01407 <span class="comment">  it.</span>
<a name="l01408"></a>01408 <span class="comment"> */</span>
<a name="l01409"></a><a class="code" href="classTABLEOP__HOOKS.html">01409</a> <span class="keyword">class </span><a class="code" href="classTABLEOP__HOOKS.html">TABLEOP_HOOKS</a>
<a name="l01410"></a>01410 {
<a name="l01411"></a>01411 <span class="keyword">public</span>:
<a name="l01412"></a>01412   <a class="code" href="classTABLEOP__HOOKS.html">TABLEOP_HOOKS</a>() {}
<a name="l01413"></a>01413   <span class="keyword">virtual</span> ~<a class="code" href="classTABLEOP__HOOKS.html">TABLEOP_HOOKS</a>() {}
<a name="l01414"></a>01414 
<a name="l01415"></a>01415   <span class="keyword">inline</span> <span class="keywordtype">void</span> prelock(<a class="code" href="structTABLE.html">TABLE</a> **tables, uint count)
<a name="l01416"></a>01416   {
<a name="l01417"></a>01417     do_prelock(tables, count);
<a name="l01418"></a>01418   }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420   <span class="keyword">inline</span> <span class="keywordtype">int</span> postlock(<a class="code" href="structTABLE.html">TABLE</a> **tables, uint count)
<a name="l01421"></a>01421   {
<a name="l01422"></a>01422     <span class="keywordflow">return</span> do_postlock(tables, count);
<a name="l01423"></a>01423   }
<a name="l01424"></a>01424 <span class="keyword">private</span>:
<a name="l01425"></a>01425   <span class="comment">/* Function primitive that is called prior to locking tables */</span>
<a name="l01426"></a>01426   <span class="keyword">virtual</span> <span class="keywordtype">void</span> do_prelock(<a class="code" href="structTABLE.html">TABLE</a> **tables, uint count)
<a name="l01427"></a>01427   {
<a name="l01428"></a>01428     <span class="comment">/* Default is to do nothing */</span>
<a name="l01429"></a>01429   }
<a name="l01430"></a>01430 
<a name="l01439"></a>01439   <span class="keyword">virtual</span> <span class="keywordtype">int</span> do_postlock(<a class="code" href="structTABLE.html">TABLE</a> **tables, uint count)
<a name="l01440"></a>01440   {
<a name="l01441"></a>01441     <span class="keywordflow">return</span> 0;                           <span class="comment">/* Default is to do nothing */</span>
<a name="l01442"></a>01442   }
<a name="l01443"></a>01443 };
<a name="l01444"></a>01444 
<a name="l01445"></a>01445 <span class="keyword">typedef</span> <span class="keyword">struct </span>st_savepoint SAVEPOINT;
<a name="l01446"></a>01446 <span class="keyword">extern</span> ulong savepoint_alloc_size;
<a name="l01447"></a>01447 <span class="keyword">extern</span> <a class="code" href="structst__key__create__information.html">KEY_CREATE_INFO</a> default_key_create_info;
<a name="l01448"></a>01448 
<a name="l01449"></a><a class="code" href="structst__ha__check__opt.html">01449</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__ha__check__opt.html">st_ha_check_opt</a>
<a name="l01450"></a>01450 {
<a name="l01451"></a>01451   <a class="code" href="structst__ha__check__opt.html">st_ha_check_opt</a>() {}                        <span class="comment">/* Remove gcc warning */</span>
<a name="l01452"></a>01452   uint flags;       <span class="comment">/* isam layer flags (e.g. for myisamchk) */</span>
<a name="l01453"></a>01453   uint sql_flags;   <span class="comment">/* sql layer flags - for something myisamchk cannot do */</span>
<a name="l01454"></a>01454   KEY_CACHE *key_cache; <span class="comment">/* new key cache when changing key cache */</span>
<a name="l01455"></a>01455   <span class="keywordtype">void</span> init();
<a name="l01456"></a>01456 } <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>;
<a name="l01457"></a>01457 
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 
<a name="l01460"></a>01460 <span class="comment">/*</span>
<a name="l01461"></a>01461 <span class="comment">  This is a buffer area that the handler can use to store rows.</span>
<a name="l01462"></a>01462 <span class="comment">  &#39;end_of_used_area&#39; should be kept updated after calls to</span>
<a name="l01463"></a>01463 <span class="comment">  read-functions so that other parts of the code can use the</span>
<a name="l01464"></a>01464 <span class="comment">  remaining area (until next read calls is issued).</span>
<a name="l01465"></a>01465 <span class="comment">*/</span>
<a name="l01466"></a>01466 
<a name="l01467"></a><a class="code" href="structst__handler__buffer.html">01467</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__handler__buffer.html">st_handler_buffer</a>
<a name="l01468"></a>01468 {
<a name="l01469"></a>01469   uchar *buffer;         <span class="comment">/* Buffer one can start using */</span>
<a name="l01470"></a>01470   uchar *buffer_end;     <span class="comment">/* End of buffer */</span>
<a name="l01471"></a>01471   uchar *end_of_used_area;     <span class="comment">/* End of area that was used by handler */</span>
<a name="l01472"></a>01472 } <a class="code" href="structst__handler__buffer.html">HANDLER_BUFFER</a>;
<a name="l01473"></a>01473 
<a name="l01474"></a>01474 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structsystem__status__var.html">system_status_var</a> <a class="code" href="structsystem__status__var.html">SSV</a>;
<a name="l01475"></a>01475 
<a name="l01476"></a>01476 
<a name="l01477"></a>01477 <span class="keyword">typedef</span> <span class="keywordtype">void</span> *range_seq_t;
<a name="l01478"></a>01478 
<a name="l01479"></a><a class="code" href="structst__range__seq__if.html">01479</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__range__seq__if.html">st_range_seq_if</a>
<a name="l01480"></a>01480 {
<a name="l01481"></a>01481   <span class="comment">/*</span>
<a name="l01482"></a>01482 <span class="comment">    Initialize the traversal of range sequence</span>
<a name="l01483"></a>01483 <span class="comment">    </span>
<a name="l01484"></a>01484 <span class="comment">    SYNOPSIS</span>
<a name="l01485"></a>01485 <span class="comment">      init()</span>
<a name="l01486"></a>01486 <span class="comment">        init_params  The seq_init_param parameter </span>
<a name="l01487"></a>01487 <span class="comment">        n_ranges     The number of ranges obtained </span>
<a name="l01488"></a>01488 <span class="comment">        flags        A combination of HA_MRR_SINGLE_POINT, HA_MRR_FIXED_KEY</span>
<a name="l01489"></a>01489 <span class="comment"></span>
<a name="l01490"></a>01490 <span class="comment">    RETURN</span>
<a name="l01491"></a>01491 <span class="comment">      An opaque value to be used as RANGE_SEQ_IF::next() parameter</span>
<a name="l01492"></a>01492 <span class="comment">  */</span>
<a name="l01493"></a>01493   range_seq_t (*init)(<span class="keywordtype">void</span> *init_params, uint n_ranges, uint flags);
<a name="l01494"></a>01494 
<a name="l01495"></a>01495 
<a name="l01496"></a>01496   <span class="comment">/*</span>
<a name="l01497"></a>01497 <span class="comment">    Get the next range in the range sequence</span>
<a name="l01498"></a>01498 <span class="comment"></span>
<a name="l01499"></a>01499 <span class="comment">    SYNOPSIS</span>
<a name="l01500"></a>01500 <span class="comment">      next()</span>
<a name="l01501"></a>01501 <span class="comment">        seq    The value returned by RANGE_SEQ_IF::init()</span>
<a name="l01502"></a>01502 <span class="comment">        range  OUT Information about the next range</span>
<a name="l01503"></a>01503 <span class="comment">    </span>
<a name="l01504"></a>01504 <span class="comment">    RETURN</span>
<a name="l01505"></a>01505 <span class="comment">      0 - Ok, the range structure filled with info about the next range</span>
<a name="l01506"></a>01506 <span class="comment">      1 - No more ranges</span>
<a name="l01507"></a>01507 <span class="comment">  */</span>
<a name="l01508"></a>01508   uint (*next) (range_seq_t seq, KEY_MULTI_RANGE *range);
<a name="l01509"></a>01509 
<a name="l01510"></a>01510   <span class="comment">/*</span>
<a name="l01511"></a>01511 <span class="comment">    Check whether range_info orders to skip the next record</span>
<a name="l01512"></a>01512 <span class="comment"></span>
<a name="l01513"></a>01513 <span class="comment">    SYNOPSIS</span>
<a name="l01514"></a>01514 <span class="comment">      skip_record()</span>
<a name="l01515"></a>01515 <span class="comment">        seq         The value returned by RANGE_SEQ_IF::init()</span>
<a name="l01516"></a>01516 <span class="comment">        range_info  Information about the next range </span>
<a name="l01517"></a>01517 <span class="comment">                    (Ignored if MRR_NO_ASSOCIATION is set)</span>
<a name="l01518"></a>01518 <span class="comment">        rowid       Rowid of the record to be checked (ignored if set to 0)</span>
<a name="l01519"></a>01519 <span class="comment">    </span>
<a name="l01520"></a>01520 <span class="comment">    RETURN</span>
<a name="l01521"></a>01521 <span class="comment">      1 - Record with this range_info and/or this rowid shall be filtered</span>
<a name="l01522"></a>01522 <span class="comment">          out from the stream of records returned by multi_range_read_next()</span>
<a name="l01523"></a>01523 <span class="comment">      0 - The record shall be left in the stream</span>
<a name="l01524"></a>01524 <span class="comment">  */</span> 
<a name="l01525"></a>01525   bool (*skip_record) (range_seq_t seq, <span class="keywordtype">char</span> *range_info, uchar *rowid);
<a name="l01526"></a>01526 
<a name="l01527"></a>01527   <span class="comment">/*</span>
<a name="l01528"></a>01528 <span class="comment">    Check if the record combination matches the index condition</span>
<a name="l01529"></a>01529 <span class="comment">    SYNOPSIS</span>
<a name="l01530"></a>01530 <span class="comment">      skip_index_tuple()</span>
<a name="l01531"></a>01531 <span class="comment">        seq         The value returned by RANGE_SEQ_IF::init()</span>
<a name="l01532"></a>01532 <span class="comment">        range_info  Information about the next range </span>
<a name="l01533"></a>01533 <span class="comment">    </span>
<a name="l01534"></a>01534 <span class="comment">    RETURN</span>
<a name="l01535"></a>01535 <span class="comment">      0 - The record combination satisfies the index condition</span>
<a name="l01536"></a>01536 <span class="comment">      1 - Otherwise</span>
<a name="l01537"></a>01537 <span class="comment">  */</span> 
<a name="l01538"></a>01538   bool (*skip_index_tuple) (range_seq_t seq, <span class="keywordtype">char</span> *range_info);
<a name="l01539"></a>01539 } <a class="code" href="structst__range__seq__if.html">RANGE_SEQ_IF</a>;
<a name="l01540"></a>01540 
<a name="l01541"></a>01541 uint16 &amp;mrr_persistent_flag_storage(range_seq_t seq, uint idx);
<a name="l01542"></a>01542 <span class="keywordtype">char</span>* &amp;mrr_get_ptr_by_idx(range_seq_t seq, uint idx);
<a name="l01543"></a>01543 
<a name="l01550"></a><a class="code" href="classCost__estimate.html">01550</a> <span class="keyword">class </span><a class="code" href="classCost__estimate.html">Cost_estimate</a>
<a name="l01551"></a>01551 { 
<a name="l01552"></a>01552 <span class="keyword">private</span>:
<a name="l01553"></a>01553   <span class="keywordtype">double</span> io_cost;                               
<a name="l01554"></a>01554   <span class="keywordtype">double</span> cpu_cost;                              
<a name="l01555"></a>01555   <span class="keywordtype">double</span> import_cost;                           
<a name="l01556"></a>01556   <span class="keywordtype">double</span> mem_cost;                              
<a name="l01557"></a>01557   
<a name="l01558"></a>01558 <span class="keyword">public</span>:
<a name="l01559"></a>01559 
<a name="l01561"></a><a class="code" href="classCost__estimate.html#a9dfdbec3c629ac5d13425d601246841a">01561</a>   <span class="keyword">static</span> <span class="keywordtype">double</span> <a class="code" href="classCost__estimate.html#a9dfdbec3c629ac5d13425d601246841a" title="The cost of one I/O operation.">IO_BLOCK_READ_COST</a>() { <span class="keywordflow">return</span>  1.0; } 
<a name="l01562"></a>01562 
<a name="l01563"></a>01563   <a class="code" href="classCost__estimate.html">Cost_estimate</a>() :
<a name="l01564"></a>01564     io_cost(0),
<a name="l01565"></a>01565     cpu_cost(0),
<a name="l01566"></a>01566     import_cost(0),
<a name="l01567"></a>01567     mem_cost(0)
<a name="l01568"></a>01568   {}
<a name="l01569"></a>01569 
<a name="l01571"></a><a class="code" href="classCost__estimate.html#aa10022c6a4c679b9f7485b3ccda7576d">01571</a>   <span class="keywordtype">double</span> <a class="code" href="classCost__estimate.html#aa10022c6a4c679b9f7485b3ccda7576d" title="Returns sum of time-consuming costs, i.e., not counting memory cost.">total_cost</a>()<span class="keyword">      const </span>{ <span class="keywordflow">return</span> io_cost + cpu_cost + import_cost; }
<a name="l01572"></a>01572   <span class="keywordtype">double</span> get_io_cost()<span class="keyword">     const </span>{ <span class="keywordflow">return</span> io_cost; }
<a name="l01573"></a>01573   <span class="keywordtype">double</span> get_cpu_cost()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> cpu_cost; }
<a name="l01574"></a>01574   <span class="keywordtype">double</span> get_import_cost()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> import_cost; }
<a name="l01575"></a>01575   <span class="keywordtype">double</span> get_mem_cost()<span class="keyword">    const </span>{ <span class="keywordflow">return</span> mem_cost; }
<a name="l01576"></a>01576 
<a name="l01582"></a><a class="code" href="classCost__estimate.html#a8dd299e91d9dc1754c69fa2c22058ec1">01582</a>   <span class="keywordtype">bool</span> <a class="code" href="classCost__estimate.html#a8dd299e91d9dc1754c69fa2c22058ec1">is_zero</a>()<span class="keyword"> const</span>
<a name="l01583"></a>01583 <span class="keyword">  </span>{ 
<a name="l01584"></a>01584     <span class="keywordflow">return</span> !(io_cost || cpu_cost || import_cost || mem_cost);
<a name="l01585"></a>01585   }
<a name="l01586"></a>01586 
<a name="l01588"></a><a class="code" href="classCost__estimate.html#a39433a1e8b2745bf3df76b08f5ffff65">01588</a>   <span class="keywordtype">void</span> <a class="code" href="classCost__estimate.html#a39433a1e8b2745bf3df76b08f5ffff65" title="Reset all costs to zero.">reset</a>()
<a name="l01589"></a>01589   {
<a name="l01590"></a>01590     io_cost= cpu_cost= import_cost= mem_cost= 0;
<a name="l01591"></a>01591   }
<a name="l01592"></a>01592 
<a name="l01594"></a><a class="code" href="classCost__estimate.html#ace2183a6e8a050764f19208a5bd16181">01594</a>   <span class="keywordtype">void</span> <a class="code" href="classCost__estimate.html#ace2183a6e8a050764f19208a5bd16181" title="Multiply io, cpu and import costs by parameter.">multiply</a>(<span class="keywordtype">double</span> m)
<a name="l01595"></a>01595   {
<a name="l01596"></a>01596     io_cost *= m;
<a name="l01597"></a>01597     cpu_cost *= m;
<a name="l01598"></a>01598     import_cost *= m;
<a name="l01599"></a>01599     <span class="comment">/* Don&#39;t multiply mem_cost */</span>
<a name="l01600"></a>01600   }
<a name="l01601"></a>01601 
<a name="l01602"></a>01602   <a class="code" href="classCost__estimate.html">Cost_estimate</a>&amp; operator+= (<span class="keyword">const</span> <a class="code" href="classCost__estimate.html">Cost_estimate</a> &amp;other)
<a name="l01603"></a>01603   {
<a name="l01604"></a>01604     io_cost+= other.io_cost;
<a name="l01605"></a>01605     cpu_cost+= other.cpu_cost;
<a name="l01606"></a>01606     import_cost+= other.import_cost;
<a name="l01607"></a>01607     mem_cost+= other.mem_cost;
<a name="l01608"></a>01608 
<a name="l01609"></a>01609     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l01610"></a>01610   }
<a name="l01611"></a>01611 
<a name="l01612"></a>01612   <a class="code" href="classCost__estimate.html">Cost_estimate</a> operator+ (<span class="keyword">const</span> <a class="code" href="classCost__estimate.html">Cost_estimate</a> &amp;other)
<a name="l01613"></a>01613   {
<a name="l01614"></a>01614     <a class="code" href="classCost__estimate.html">Cost_estimate</a> result= *<span class="keyword">this</span>;
<a name="l01615"></a>01615     result+= other;
<a name="l01616"></a>01616     <span class="keywordflow">return</span> result;
<a name="l01617"></a>01617   }
<a name="l01618"></a>01618 
<a name="l01620"></a><a class="code" href="classCost__estimate.html#ab06e302ab71f760dd0a106131cfab848">01620</a>   <span class="keywordtype">void</span> <a class="code" href="classCost__estimate.html#ab06e302ab71f760dd0a106131cfab848" title="Add to IO cost.">add_io</a>(<span class="keywordtype">double</span> add_io_cost) { io_cost+= add_io_cost; }
<a name="l01621"></a>01621 
<a name="l01623"></a><a class="code" href="classCost__estimate.html#a75d7fd717bdad58c064ee49a0ea03e57">01623</a>   <span class="keywordtype">void</span> <a class="code" href="classCost__estimate.html#a75d7fd717bdad58c064ee49a0ea03e57" title="Add to CPU cost.">add_cpu</a>(<span class="keywordtype">double</span> add_cpu_cost) { cpu_cost+= add_cpu_cost; }
<a name="l01624"></a>01624 
<a name="l01626"></a><a class="code" href="classCost__estimate.html#a32474036e55eefc877555d22f15e01bd">01626</a>   <span class="keywordtype">void</span> <a class="code" href="classCost__estimate.html#a32474036e55eefc877555d22f15e01bd" title="Add to import cost.">add_import</a>(<span class="keywordtype">double</span> add_import_cost) { import_cost+= add_import_cost; }
<a name="l01627"></a>01627 
<a name="l01629"></a><a class="code" href="classCost__estimate.html#a87a6d90a85ae340685811f794e10dfe4">01629</a>   <span class="keywordtype">void</span> <a class="code" href="classCost__estimate.html#a87a6d90a85ae340685811f794e10dfe4" title="Add to memory cost.">add_mem</a>(<span class="keywordtype">double</span> add_mem_cost) { mem_cost+= add_mem_cost; }
<a name="l01630"></a>01630 };
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 <span class="keywordtype">void</span> <a class="code" href="handler_8cc.html#a7d121a7b14ef956c0df32895a7a9a08b">get_sweep_read_cost</a>(<a class="code" href="structTABLE.html">TABLE</a> *table, ha_rows nrows, <span class="keywordtype">bool</span> interrupted, 
<a name="l01633"></a>01633                          <a class="code" href="classCost__estimate.html">Cost_estimate</a> *cost);
<a name="l01634"></a>01634 
<a name="l01635"></a>01635 <span class="comment">/*</span>
<a name="l01636"></a>01636 <span class="comment">  The below two are not used (and not handled) in this milestone of this WL</span>
<a name="l01637"></a>01637 <span class="comment">  entry because there seems to be no use for them at this stage of</span>
<a name="l01638"></a>01638 <span class="comment">  implementation.</span>
<a name="l01639"></a>01639 <span class="comment">*/</span>
<a name="l01640"></a>01640 <span class="preprocessor">#define HA_MRR_SINGLE_POINT 1</span>
<a name="l01641"></a>01641 <span class="preprocessor"></span><span class="preprocessor">#define HA_MRR_FIXED_KEY  2</span>
<a name="l01642"></a>01642 <span class="preprocessor"></span>
<a name="l01643"></a>01643 <span class="comment">/* </span>
<a name="l01644"></a>01644 <span class="comment">  Indicates that RANGE_SEQ_IF::next(&amp;range) doesn&#39;t need to fill in the</span>
<a name="l01645"></a>01645 <span class="comment">  &#39;range&#39; parameter.</span>
<a name="l01646"></a>01646 <span class="comment">*/</span>
<a name="l01647"></a>01647 <span class="preprocessor">#define HA_MRR_NO_ASSOCIATION 4</span>
<a name="l01648"></a>01648 <span class="preprocessor"></span>
<a name="l01649"></a>01649 <span class="comment">/* </span>
<a name="l01650"></a>01650 <span class="comment">  The MRR user will provide ranges in key order, and MRR implementation</span>
<a name="l01651"></a>01651 <span class="comment">  must return rows in key order.</span>
<a name="l01652"></a>01652 <span class="comment">  Passing this flag to multi_read_range_init() may cause the</span>
<a name="l01653"></a>01653 <span class="comment">  default MRR handler to be used even if HA_MRR_USE_DEFAULT_IMPL</span>
<a name="l01654"></a>01654 <span class="comment">  was not specified.</span>
<a name="l01655"></a>01655 <span class="comment">  (If the native MRR impl. can not provide SORTED result)</span>
<a name="l01656"></a>01656 <span class="comment">*/</span>
<a name="l01657"></a>01657 <span class="preprocessor">#define HA_MRR_SORTED 8</span>
<a name="l01658"></a>01658 <span class="preprocessor"></span>
<a name="l01659"></a>01659 <span class="comment">/* MRR implementation doesn&#39;t have to retrieve full records */</span>
<a name="l01660"></a>01660 <span class="preprocessor">#define HA_MRR_INDEX_ONLY 16</span>
<a name="l01661"></a>01661 <span class="preprocessor"></span>
<a name="l01662"></a>01662 <span class="comment">/* </span>
<a name="l01663"></a>01663 <span class="comment">  The passed memory buffer is of maximum possible size, the caller can&#39;t</span>
<a name="l01664"></a>01664 <span class="comment">  assume larger buffer.</span>
<a name="l01665"></a>01665 <span class="comment">*/</span>
<a name="l01666"></a>01666 <span class="preprocessor">#define HA_MRR_LIMITS 32</span>
<a name="l01667"></a>01667 <span class="preprocessor"></span>
<a name="l01668"></a>01668 
<a name="l01669"></a>01669 <span class="comment">/*</span>
<a name="l01670"></a>01670 <span class="comment">  Flag set &lt;=&gt; default MRR implementation is used</span>
<a name="l01671"></a>01671 <span class="comment">  (The choice is made by **_info[_const]() function which may set this</span>
<a name="l01672"></a>01672 <span class="comment">   flag. SQL layer remembers the flag value and then passes it to</span>
<a name="l01673"></a>01673 <span class="comment">   multi_read_range_init().</span>
<a name="l01674"></a>01674 <span class="comment">*/</span>
<a name="l01675"></a>01675 <span class="preprocessor">#define HA_MRR_USE_DEFAULT_IMPL 64</span>
<a name="l01676"></a>01676 <span class="preprocessor"></span>
<a name="l01677"></a>01677 <span class="comment">/*</span>
<a name="l01678"></a>01678 <span class="comment">  Used only as parameter to multi_range_read_info():</span>
<a name="l01679"></a>01679 <span class="comment">  Flag set &lt;=&gt; the caller guarantees that the bounds of the scanned ranges</span>
<a name="l01680"></a>01680 <span class="comment">  will not have NULL values.</span>
<a name="l01681"></a>01681 <span class="comment">*/</span>
<a name="l01682"></a>01682 <span class="preprocessor">#define HA_MRR_NO_NULL_ENDPOINTS 128</span>
<a name="l01683"></a>01683 <span class="preprocessor"></span>
<a name="l01684"></a>01684 <span class="comment">/*</span>
<a name="l01685"></a>01685 <span class="comment">  Set by the MRR implementation to signal that it will natively</span>
<a name="l01686"></a>01686 <span class="comment">  produced sorted result if multi_range_read_init() is called with</span>
<a name="l01687"></a>01687 <span class="comment">  the HA_MRR_SORTED flag - Else multi_range_read_init(HA_MRR_SORTED)</span>
<a name="l01688"></a>01688 <span class="comment">  will revert to use the default MRR implementation. </span>
<a name="l01689"></a>01689 <span class="comment">*/</span>
<a name="l01690"></a>01690 <span class="preprocessor">#define HA_MRR_SUPPORT_SORTED 256</span>
<a name="l01691"></a>01691 <span class="preprocessor"></span>
<a name="l01692"></a>01692 
<a name="l01693"></a><a class="code" href="classha__statistics.html">01693</a> <span class="keyword">class </span><a class="code" href="classha__statistics.html">ha_statistics</a>
<a name="l01694"></a>01694 {
<a name="l01695"></a>01695 <span class="keyword">public</span>:
<a name="l01696"></a>01696   ulonglong data_file_length;           <span class="comment">/* Length off data file */</span>
<a name="l01697"></a>01697   ulonglong max_data_file_length;       <span class="comment">/* Length off data file */</span>
<a name="l01698"></a>01698   ulonglong index_file_length;
<a name="l01699"></a>01699   ulonglong max_index_file_length;
<a name="l01700"></a>01700   ulonglong delete_length;              <span class="comment">/* Free bytes */</span>
<a name="l01701"></a>01701   ulonglong auto_increment_value;
<a name="l01702"></a>01702   <span class="comment">/*</span>
<a name="l01703"></a>01703 <span class="comment">    The number of records in the table. </span>
<a name="l01704"></a>01704 <span class="comment">      0    - means the table has exactly 0 rows</span>
<a name="l01705"></a>01705 <span class="comment">    other  - if (table_flags() &amp; HA_STATS_RECORDS_IS_EXACT)</span>
<a name="l01706"></a>01706 <span class="comment">               the value is the exact number of records in the table</span>
<a name="l01707"></a>01707 <span class="comment">             else</span>
<a name="l01708"></a>01708 <span class="comment">               it is an estimate</span>
<a name="l01709"></a>01709 <span class="comment">  */</span>
<a name="l01710"></a>01710   ha_rows records;
<a name="l01711"></a>01711   ha_rows deleted;                      <span class="comment">/* Deleted records */</span>
<a name="l01712"></a>01712   ulong mean_rec_length;                <span class="comment">/* physical reclength */</span>
<a name="l01713"></a>01713   ulong create_time;                    <span class="comment">/* When table was created */</span>
<a name="l01714"></a>01714   ulong check_time;
<a name="l01715"></a>01715   ulong update_time;
<a name="l01716"></a>01716   uint block_size;                      <span class="comment">/* index block size */</span>
<a name="l01717"></a>01717   
<a name="l01718"></a>01718   <span class="comment">/*</span>
<a name="l01719"></a>01719 <span class="comment">    number of buffer bytes that native mrr implementation needs,</span>
<a name="l01720"></a>01720 <span class="comment">  */</span>
<a name="l01721"></a>01721   uint mrr_length_per_rec; 
<a name="l01722"></a>01722 
<a name="l01723"></a>01723   <a class="code" href="classha__statistics.html">ha_statistics</a>():
<a name="l01724"></a>01724     data_file_length(0), max_data_file_length(0),
<a name="l01725"></a>01725     index_file_length(0), delete_length(0), auto_increment_value(0),
<a name="l01726"></a>01726     records(0), deleted(0), mean_rec_length(0), create_time(0),
<a name="l01727"></a>01727     check_time(0), update_time(0), block_size(0)
<a name="l01728"></a>01728   {}
<a name="l01729"></a>01729 };
<a name="l01730"></a>01730 
<a name="l01731"></a>01731 uint calculate_key_len(<a class="code" href="structTABLE.html">TABLE</a> *, uint, <span class="keyword">const</span> uchar *, key_part_map);
<a name="l01732"></a>01732 <span class="comment">/*</span>
<a name="l01733"></a>01733 <span class="comment">  bitmap with first N+1 bits set</span>
<a name="l01734"></a>01734 <span class="comment">  (keypart_map for a key prefix of [0..N] keyparts)</span>
<a name="l01735"></a>01735 <span class="comment">*/</span>
<a name="l01736"></a>01736 <span class="preprocessor">#define make_keypart_map(N) (((key_part_map)2 &lt;&lt; (N)) - 1)</span>
<a name="l01737"></a>01737 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l01738"></a>01738 <span class="comment">  bitmap with first N bits set</span>
<a name="l01739"></a>01739 <span class="comment">  (keypart_map for a key prefix of [0..N-1] keyparts)</span>
<a name="l01740"></a>01740 <span class="comment">*/</span>
<a name="l01741"></a>01741 <span class="preprocessor">#define make_prev_keypart_map(N) (((key_part_map)1 &lt;&lt; (N)) - 1)</span>
<a name="l01742"></a>01742 <span class="preprocessor"></span>
<a name="l01743"></a>01743 
<a name="l01745"></a><a class="code" href="classHandler__share.html">01745</a> <span class="keyword">class </span><a class="code" href="classHandler__share.html">Handler_share</a>
<a name="l01746"></a>01746 {
<a name="l01747"></a>01747 <span class="keyword">public</span>:
<a name="l01748"></a>01748   <a class="code" href="classHandler__share.html">Handler_share</a>() {}
<a name="l01749"></a>01749   <span class="keyword">virtual</span> ~<a class="code" href="classHandler__share.html">Handler_share</a>() {}
<a name="l01750"></a>01750 };
<a name="l01751"></a>01751 
<a name="l01752"></a>01752 
<a name="l01801"></a><a class="code" href="classhandler.html">01801</a> <span class="keyword">class </span><a class="code" href="classhandler.html">handler</a> :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l01802"></a>01802 {
<a name="l01803"></a>01803 <span class="keyword">public</span>:
<a name="l01804"></a>01804   <span class="keyword">typedef</span> ulonglong Table_flags;
<a name="l01805"></a>01805 <span class="keyword">protected</span>:
<a name="l01806"></a>01806   <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *table_share;             <span class="comment">/* The table definition */</span>
<a name="l01807"></a>01807   <a class="code" href="structTABLE.html">TABLE</a> *table;                         <span class="comment">/* The current open table */</span>
<a name="l01808"></a>01808   Table_flags cached_table_flags;       <span class="comment">/* Set on init() and open() */</span>
<a name="l01809"></a>01809 
<a name="l01810"></a>01810   ha_rows estimation_rows_to_insert;
<a name="l01811"></a>01811 <span class="keyword">public</span>:
<a name="l01812"></a>01812   <a class="code" href="structhandlerton.html">handlerton</a> *ht;                 <span class="comment">/* storage engine of this handler */</span>
<a name="l01813"></a>01813   uchar *ref;                           <span class="comment">/* Pointer to current row */</span>
<a name="l01814"></a>01814   uchar *dup_ref;                       <span class="comment">/* Pointer to duplicate row */</span>
<a name="l01815"></a>01815 
<a name="l01816"></a>01816   <a class="code" href="classha__statistics.html">ha_statistics</a> stats;
<a name="l01817"></a>01817   
<a name="l01818"></a>01818   <span class="comment">/* MultiRangeRead-related members: */</span>
<a name="l01819"></a>01819   range_seq_t mrr_iter;    <span class="comment">/* Interator to traverse the range sequence */</span>
<a name="l01820"></a>01820   <a class="code" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> mrr_funcs;  <span class="comment">/* Range sequence traversal functions */</span>
<a name="l01821"></a>01821   <a class="code" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *multi_range_buffer; <span class="comment">/* MRR buffer info */</span>
<a name="l01822"></a>01822   uint ranges_in_seq; <span class="comment">/* Total number of ranges in the traversed sequence */</span>
<a name="l01823"></a>01823   <span class="comment">/* TRUE &lt;=&gt; source MRR ranges and the output are ordered */</span>
<a name="l01824"></a>01824   <span class="keywordtype">bool</span> mrr_is_output_sorted;
<a name="l01825"></a>01825   
<a name="l01826"></a>01826   <span class="comment">/* TRUE &lt;=&gt; we&#39;re currently traversing a range in mrr_cur_range. */</span>
<a name="l01827"></a>01827   <span class="keywordtype">bool</span> mrr_have_range;
<a name="l01828"></a>01828   <span class="comment">/* Current range (the one we&#39;re now returning rows from) */</span>
<a name="l01829"></a>01829   KEY_MULTI_RANGE mrr_cur_range;
<a name="l01830"></a>01830 
<a name="l01831"></a>01831   <span class="comment">/*</span>
<a name="l01832"></a>01832 <span class="comment">    The direction of the current range or index scan. This is used by</span>
<a name="l01833"></a>01833 <span class="comment">    the ICP implementation to determine if it has reached the end</span>
<a name="l01834"></a>01834 <span class="comment">    of the current range.</span>
<a name="l01835"></a>01835 <span class="comment">  */</span>
<a name="l01836"></a>01836   <span class="keyword">enum</span> enum_range_scan_direction {
<a name="l01837"></a>01837     RANGE_SCAN_ASC,
<a name="l01838"></a>01838     RANGE_SCAN_DESC
<a name="l01839"></a>01839   };
<a name="l01840"></a>01840 <span class="keyword">private</span>:
<a name="l01841"></a>01841   <span class="comment">/*</span>
<a name="l01842"></a>01842 <span class="comment">    Storage space for the end range value. Should only be accessed using</span>
<a name="l01843"></a>01843 <span class="comment">    the end_range pointer. The content is invalid when end_range is NULL.</span>
<a name="l01844"></a>01844 <span class="comment">  */</span>
<a name="l01845"></a>01845   key_range save_end_range;
<a name="l01846"></a>01846   enum_range_scan_direction range_scan_direction;
<a name="l01847"></a>01847   <span class="keywordtype">int</span> key_compare_result_on_equal;
<a name="l01848"></a>01848 
<a name="l01849"></a>01849 <span class="keyword">protected</span>:
<a name="l01850"></a>01850   <a class="code" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *range_key_part;
<a name="l01851"></a>01851   <span class="keywordtype">bool</span> eq_range;
<a name="l01852"></a>01852   <span class="comment">/* </span>
<a name="l01853"></a>01853 <span class="comment">    TRUE &lt;=&gt; the engine guarantees that returned records are within the range</span>
<a name="l01854"></a>01854 <span class="comment">    being scanned.</span>
<a name="l01855"></a>01855 <span class="comment">  */</span>
<a name="l01856"></a>01856   <span class="keywordtype">bool</span> in_range_check_pushed_down;
<a name="l01857"></a>01857 
<a name="l01858"></a>01858 <span class="keyword">public</span>:  
<a name="l01859"></a>01859   <span class="comment">/*</span>
<a name="l01860"></a>01860 <span class="comment">    End value for a range scan. If this is NULL the range scan has no</span>
<a name="l01861"></a>01861 <span class="comment">    end value. Should also be NULL when there is no ongoing range scan.</span>
<a name="l01862"></a>01862 <span class="comment">    Used by the read_range() functions and also evaluated by pushed</span>
<a name="l01863"></a>01863 <span class="comment">    index conditions.</span>
<a name="l01864"></a>01864 <span class="comment">  */</span>
<a name="l01865"></a>01865   key_range *end_range;
<a name="l01866"></a>01866   uint errkey;                          <span class="comment">/* Last dup key */</span>
<a name="l01867"></a>01867   uint key_used_on_scan;
<a name="l01868"></a>01868   uint active_index;
<a name="l01870"></a><a class="code" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">01870</a>   uint <a class="code" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a>;
<a name="l01871"></a>01871   FT_INFO *ft_handler;
<a name="l01872"></a>01872   <span class="keyword">enum</span> {NONE=0, INDEX, RND} inited;
<a name="l01873"></a>01873   <span class="keywordtype">bool</span> implicit_emptied;                <span class="comment">/* Can be !=0 only if HEAP */</span>
<a name="l01874"></a>01874   <span class="keyword">const</span> <a class="code" href="classItem.html">Item</a> *pushed_cond;
<a name="l01875"></a>01875 
<a name="l01876"></a>01876   <a class="code" href="classItem.html">Item</a> *pushed_idx_cond;
<a name="l01877"></a>01877   uint pushed_idx_cond_keyno;  <span class="comment">/* The index which the above condition is for */</span>
<a name="l01878"></a>01878 
<a name="l01888"></a><a class="code" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">01888</a>   ulonglong <a class="code" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a>;
<a name="l01895"></a><a class="code" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">01895</a>   ulonglong <a class="code" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a>;
<a name="l01900"></a><a class="code" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">01900</a>   <a class="code" href="classDiscrete__interval.html">Discrete_interval</a> <a class="code" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a>;
<a name="l01907"></a><a class="code" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">01907</a>   uint <a class="code" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a>;
<a name="l01908"></a>01908 
<a name="l01921"></a><a class="code" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">01921</a>   PSI_table *<a class="code" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a>;
<a name="l01922"></a>01922 
<a name="l01923"></a>01923   <span class="keyword">virtual</span> <span class="keywordtype">void</span> unbind_psi();
<a name="l01924"></a>01924   <span class="keyword">virtual</span> <span class="keywordtype">void</span> rebind_psi();
<a name="l01925"></a>01925 
<a name="l01926"></a>01926 <span class="keyword">private</span>:
<a name="l01927"></a>01927   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classDsMrr__impl.html">DsMrr_impl</a>;
<a name="l01934"></a>01934   <span class="keywordtype">int</span> m_lock_type;
<a name="l01939"></a>01939   <a class="code" href="classHandler__share.html">Handler_share</a> **ha_share;
<a name="l01940"></a>01940 
<a name="l01941"></a>01941 <span class="keyword">public</span>:
<a name="l01942"></a>01942   <a class="code" href="classhandler.html">handler</a>(<a class="code" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share_arg)
<a name="l01943"></a>01943     :table_share(share_arg), table(0),
<a name="l01944"></a>01944     estimation_rows_to_insert(0), ht(ht_arg),
<a name="l01945"></a>01945     ref(0), range_scan_direction(RANGE_SCAN_ASC),
<a name="l01946"></a>01946     in_range_check_pushed_down(false), end_range(NULL),
<a name="l01947"></a>01947     key_used_on_scan(MAX_KEY), active_index(MAX_KEY),
<a name="l01948"></a>01948     <a class="code" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a>(sizeof(my_off_t)),
<a name="l01949"></a>01949     ft_handler(0), inited(NONE),
<a name="l01950"></a>01950     implicit_emptied(0),
<a name="l01951"></a>01951     pushed_cond(0), pushed_idx_cond(NULL), pushed_idx_cond_keyno(MAX_KEY),
<a name="l01952"></a>01952     <a class="code" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a>(0), <a class="code" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a>(0),
<a name="l01953"></a>01953     <a class="code" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a>(0),
<a name="l01954"></a>01954     <a class="code" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a>(NULL), m_lock_type(F_UNLCK), ha_share(NULL)
<a name="l01955"></a>01955     {
<a name="l01956"></a>01956       DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>,
<a name="l01957"></a>01957                  (<span class="stringliteral">&quot;handler created F_UNLCK %d F_RDLCK %d F_WRLCK %d&quot;</span>,
<a name="l01958"></a>01958                   F_UNLCK, F_RDLCK, F_WRLCK));
<a name="l01959"></a>01959     }
<a name="l01960"></a>01960   <span class="keyword">virtual</span> ~<a class="code" href="classhandler.html">handler</a>(<span class="keywordtype">void</span>)
<a name="l01961"></a>01961   {
<a name="l01962"></a>01962     DBUG_ASSERT(m_lock_type == F_UNLCK);
<a name="l01963"></a>01963     DBUG_ASSERT(inited == NONE);
<a name="l01964"></a>01964   }
<a name="l01965"></a>01965   <span class="keyword">virtual</span> <a class="code" href="classhandler.html">handler</a> *clone(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, MEM_ROOT *mem_root);
<a name="l01967"></a><a class="code" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">01967</a>   <span class="keywordtype">void</span> <a class="code" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a>()
<a name="l01968"></a>01968   {
<a name="l01969"></a>01969     cached_table_flags= table_flags();
<a name="l01970"></a>01970   }
<a name="l01971"></a>01971   <span class="comment">/* ha_ methods: public wrappers for private virtual API */</span>
<a name="l01972"></a>01972 
<a name="l01973"></a>01973   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ab5e02829386929734724b143391e0a11" title="Open database-handler.">ha_open</a>(<a class="code" href="structTABLE.html">TABLE</a> *table, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> mode, <span class="keywordtype">int</span> test_if_locked);
<a name="l01974"></a>01974   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a>(<span class="keywordtype">void</span>);
<a name="l01975"></a>01975   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a>(uint idx, <span class="keywordtype">bool</span> sorted);
<a name="l01976"></a>01976   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a>();
<a name="l01977"></a>01977   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a>(<span class="keywordtype">bool</span> scan);
<a name="l01978"></a>01978   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a>();
<a name="l01979"></a>01979   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a>(uchar *buf);
<a name="l01980"></a>01980   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a>(uchar * buf, uchar *pos);
<a name="l01981"></a>01981   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a>(uchar *buf, <span class="keyword">const</span> uchar *key,
<a name="l01982"></a>01982                         key_part_map keypart_map,
<a name="l01983"></a>01983                         <span class="keyword">enum</span> ha_rkey_function find_flag);
<a name="l01984"></a>01984   <span class="keywordtype">int</span> ha_index_read_last_map(uchar * buf, <span class="keyword">const</span> uchar * key,
<a name="l01985"></a>01985                              key_part_map keypart_map);
<a name="l01986"></a>01986   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a>(uchar *buf, uint index, <span class="keyword">const</span> uchar *key,
<a name="l01987"></a>01987                            key_part_map keypart_map,
<a name="l01988"></a>01988                            <span class="keyword">enum</span> ha_rkey_function find_flag);
<a name="l01989"></a>01989   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a>(uchar * buf);
<a name="l01990"></a>01990   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a>(uchar * buf);
<a name="l01991"></a>01991   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a>(uchar * buf);
<a name="l01992"></a>01992   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a>(uchar * buf);
<a name="l01993"></a>01993   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a>(uchar *buf, <span class="keyword">const</span> uchar *key, uint keylen);
<a name="l01994"></a>01994   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a37f8c07d2ede3fb1f46fc0afb4052d2c">ha_index_read</a>(uchar *buf, <span class="keyword">const</span> uchar *key, uint key_len,
<a name="l01995"></a>01995                     <span class="keyword">enum</span> ha_rkey_function find_flag);
<a name="l01996"></a>01996   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a1790fe12f8d773f27d5b4b1cb30bd7ab">ha_index_read_last</a>(uchar *buf, <span class="keyword">const</span> uchar *key, uint key_len);
<a name="l01997"></a>01997   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42" title="Check handler usage and reset state of file to after &#39;open&#39;.">ha_reset</a>();
<a name="l01998"></a>01998   <span class="comment">/* this is necessary in many places, e.g. in HANDLER command */</span>
<a name="l01999"></a>01999   <span class="keywordtype">int</span> ha_index_or_rnd_end()
<a name="l02000"></a>02000   {
<a name="l02001"></a>02001     <span class="keywordflow">return</span> inited == INDEX ? <a class="code" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a>() : inited == RND ? <a class="code" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a>() : 0;
<a name="l02002"></a>02002   }
<a name="l02006"></a><a class="code" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">02006</a>   Table_flags <a class="code" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">ha_table_flags</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cached_table_flags; }
<a name="l02013"></a>02013   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a>(THD *thd, <span class="keywordtype">int</span> lock_type);
<a name="l02014"></a>02014   <span class="keywordtype">int</span> ha_write_row(uchar * buf);
<a name="l02015"></a>02015   <span class="keywordtype">int</span> ha_update_row(<span class="keyword">const</span> uchar * old_data, uchar * new_data);
<a name="l02016"></a>02016   <span class="keywordtype">int</span> ha_delete_row(<span class="keyword">const</span> uchar * buf);
<a name="l02017"></a>02017   <span class="keywordtype">void</span> ha_release_auto_increment();
<a name="l02018"></a>02018 
<a name="l02019"></a>02019   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">check_collation_compatibility</a>();
<a name="l02020"></a>02020   <span class="keywordtype">int</span> ha_check_for_upgrade(<a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt);
<a name="l02022"></a>02022   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a>(THD *thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt);
<a name="l02023"></a>02023   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a>(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt);
<a name="l02024"></a>02024   <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a>(ha_rows rows);
<a name="l02025"></a>02025   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a>();
<a name="l02026"></a>02026   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a>(<span class="keyword">const</span> uchar *old_data, uchar *new_data,
<a name="l02027"></a>02027                          uint *dup_key_found);
<a name="l02028"></a>02028   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a>();
<a name="l02029"></a>02029   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a25394328a49d42bb45b3b263009f02c7">ha_truncate</a>();
<a name="l02030"></a>02030   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#af68b71d64ca04789d1c6130320eaf22c">ha_reset_auto_increment</a>(ulonglong value);
<a name="l02031"></a>02031   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a>(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt);
<a name="l02032"></a>02032   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a>(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt);
<a name="l02033"></a>02033   <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a>(THD *thd);
<a name="l02034"></a>02034   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a>(uint mode);
<a name="l02035"></a>02035   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a>(uint mode);
<a name="l02036"></a>02036   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a1f75cf982985d21907140a17521cd6c5">ha_discard_or_import_tablespace</a>(my_bool discard);
<a name="l02037"></a>02037   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a6ee228a60527e81efd9a49ddfdd4850d">ha_rename_table</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, <span class="keyword">const</span> <span class="keywordtype">char</span> *to);
<a name="l02038"></a>02038   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a28700a3bf1af24f9a31ebae51bf877db">ha_delete_table</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l02039"></a>02039   <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l02040"></a>02040 
<a name="l02041"></a>02041   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a14af5825a427ba6baac74b13223637f8">ha_create</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="structTABLE.html">TABLE</a> *form, <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info);
<a name="l02042"></a>02042 
<a name="l02043"></a>02043   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a722462d7e71059a8ed1f43d0fb28366b">ha_create_handler_files</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *old_name,
<a name="l02044"></a>02044                               <span class="keywordtype">int</span> action_flag, <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info);
<a name="l02045"></a>02045 
<a name="l02046"></a>02046   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ab5fb90782fea926f7a4450889d2d4a93">ha_change_partitions</a>(<a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info,
<a name="l02047"></a>02047                            <span class="keyword">const</span> <span class="keywordtype">char</span> *path,
<a name="l02048"></a>02048                            ulonglong * <span class="keyword">const</span> copied,
<a name="l02049"></a>02049                            ulonglong * <span class="keyword">const</span> deleted,
<a name="l02050"></a>02050                            <span class="keyword">const</span> uchar *pack_frm_data,
<a name="l02051"></a>02051                            <span class="keywordtype">size_t</span> pack_frm_len);
<a name="l02052"></a>02052   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#af575e947965117a3a200aec827b1a7c3">ha_drop_partitions</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path);
<a name="l02053"></a>02053   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a624a8892433666df834a9b6ed6b8c2dd">ha_rename_partitions</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *path);
<a name="l02054"></a>02054 
<a name="l02055"></a>02055   <span class="keywordtype">void</span> adjust_next_insert_id_after_explicit_value(ulonglong nr);
<a name="l02056"></a>02056   <span class="keywordtype">int</span> update_auto_increment();
<a name="l02057"></a>02057   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">print_error</a>(<span class="keywordtype">int</span> error, myf errflag);
<a name="l02058"></a>02058   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">get_error_message</a>(<span class="keywordtype">int</span> error, <a class="code" href="classString.html">String</a> *buf);
<a name="l02059"></a>02059   uint <a class="code" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a>(<span class="keywordtype">int</span> error);
<a name="l02078"></a><a class="code" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">02078</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">get_foreign_dup_key</a>(<span class="keywordtype">char</span> *child_table_name,
<a name="l02079"></a>02079                                    uint child_table_name_len,
<a name="l02080"></a>02080                                    <span class="keywordtype">char</span> *child_key_name,
<a name="l02081"></a>02081                                    uint child_key_name_len)
<a name="l02082"></a>02082   { DBUG_ASSERT(<span class="keyword">false</span>); <span class="keywordflow">return</span>(<span class="keyword">false</span>); }
<a name="l02083"></a>02083   <span class="keyword">virtual</span> <span class="keywordtype">void</span> change_table_ptr(<a class="code" href="structTABLE.html">TABLE</a> *table_arg, <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)
<a name="l02084"></a>02084   {
<a name="l02085"></a>02085     table= table_arg;
<a name="l02086"></a>02086     table_share= share;
<a name="l02087"></a>02087   }
<a name="l02088"></a>02088   <span class="comment">/* Estimates calculation */</span>
<a name="l02089"></a>02089   <span class="keyword">virtual</span> <span class="keywordtype">double</span> scan_time()
<a name="l02090"></a>02090   { <span class="keywordflow">return</span> ulonglong2double(stats.data_file_length) / IO_SIZE + 2; }
<a name="l02091"></a>02091 
<a name="l02092"></a>02092 
<a name="l02104"></a><a class="code" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">02104</a>   <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">read_time</a>(uint index, uint ranges, ha_rows rows)
<a name="l02105"></a>02105   { <span class="keywordflow">return</span> rows2double(ranges+rows); }
<a name="l02106"></a>02106 
<a name="l02107"></a>02107   <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a>(uint keynr, <span class="keywordtype">double</span> <a class="code" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a>);
<a name="l02108"></a>02108   
<a name="l02114"></a><a class="code" href="classhandler.html#a48f5f0da08d94a8d050a48f44d0be575">02114</a>   <span class="keyword">virtual</span> longlong <a class="code" href="classhandler.html#a48f5f0da08d94a8d050a48f44d0be575">get_memory_buffer_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> -1; }
<a name="l02115"></a>02115 
<a name="l02116"></a>02116   <span class="keyword">virtual</span> ha_rows <a class="code" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">multi_range_read_info_const</a>(uint keyno, <a class="code" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq,
<a name="l02117"></a>02117                                               <span class="keywordtype">void</span> *seq_init_param, 
<a name="l02118"></a>02118                                               uint n_ranges, uint *bufsz,
<a name="l02119"></a>02119                                               uint *flags, 
<a name="l02120"></a>02120                                               <a class="code" href="classCost__estimate.html">Cost_estimate</a> *cost);
<a name="l02121"></a>02121   <span class="keyword">virtual</span> ha_rows <a class="code" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">multi_range_read_info</a>(uint keyno, uint n_ranges, uint keys,
<a name="l02122"></a>02122                                         uint *bufsz, uint *flags, 
<a name="l02123"></a>02123                                         <a class="code" href="classCost__estimate.html">Cost_estimate</a> *cost);
<a name="l02124"></a>02124   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init</a>(<a class="code" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, <span class="keywordtype">void</span> *seq_init_param,
<a name="l02125"></a>02125                                     uint n_ranges, uint mode,
<a name="l02126"></a>02126                                     <a class="code" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *buf);
<a name="l02127"></a>02127   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">multi_range_read_next</a>(<span class="keywordtype">char</span> **range_info);
<a name="l02128"></a>02128 
<a name="l02129"></a>02129 
<a name="l02130"></a>02130   <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> *keys_to_use_for_scanning() { <span class="keywordflow">return</span> &amp;key_map_empty; }
<a name="l02131"></a>02131   <span class="keywordtype">bool</span> has_transactions()
<a name="l02132"></a>02132   { <span class="keywordflow">return</span> (<a class="code" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">ha_table_flags</a>() &amp; HA_NO_TRANSACTIONS) == 0; }
<a name="l02133"></a>02133   <span class="keyword">virtual</span> uint extra_rec_buf_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02134"></a>02134 
<a name="l02145"></a><a class="code" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">02145</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">is_fatal_error</a>(<span class="keywordtype">int</span> error, uint flags)
<a name="l02146"></a>02146   {
<a name="l02147"></a>02147     <span class="keywordflow">if</span> (!error ||
<a name="l02148"></a>02148         ((flags &amp; HA_CHECK_DUP_KEY) &amp;&amp;
<a name="l02149"></a>02149          (error == HA_ERR_FOUND_DUPP_KEY ||
<a name="l02150"></a>02150           error == HA_ERR_FOUND_DUPP_UNIQUE)))
<a name="l02151"></a>02151       <span class="keywordflow">return</span> FALSE;
<a name="l02152"></a>02152     <span class="keywordflow">return</span> TRUE;
<a name="l02153"></a>02153   }
<a name="l02154"></a>02154 
<a name="l02159"></a><a class="code" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">02159</a>   <span class="keyword">virtual</span> ha_rows <a class="code" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a>() { <span class="keywordflow">return</span> stats.records; }
<a name="l02166"></a><a class="code" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">02166</a>   <span class="keyword">virtual</span> ha_rows <a class="code" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">estimate_rows_upper_bound</a>()
<a name="l02167"></a>02167   { <span class="keywordflow">return</span> stats.records+EXTRA_RECORDS; }
<a name="l02168"></a>02168 
<a name="l02173"></a><a class="code" href="classhandler.html#a0b8caf0f3c35db1b63d81fd121793d49">02173</a>   <span class="keyword">virtual</span> <span class="keyword">enum</span> row_type <a class="code" href="classhandler.html#a0b8caf0f3c35db1b63d81fd121793d49">get_row_type</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ROW_TYPE_NOT_USED; }
<a name="l02174"></a>02174 
<a name="l02175"></a>02175   <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *index_type(uint key_number) { DBUG_ASSERT(0); <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;}
<a name="l02176"></a>02176 
<a name="l02177"></a>02177 
<a name="l02185"></a>02185   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a4de97045e5381007565fd2b0da235c07" title="MySQL signal that it changed the column bitmap.">column_bitmaps_signal</a>();
<a name="l02186"></a>02186   uint get_index(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> active_index; }
<a name="l02187"></a>02187 
<a name="l02192"></a><a class="code" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">02192</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">start_bulk_update</a>() { <span class="keywordflow">return</span> 1; }
<a name="l02197"></a><a class="code" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">02197</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">start_bulk_delete</a>() { <span class="keywordflow">return</span> 1; }
<a name="l02209"></a><a class="code" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">02209</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">exec_bulk_update</a>(uint *dup_key_found)
<a name="l02210"></a>02210   {
<a name="l02211"></a>02211     DBUG_ASSERT(FALSE);
<a name="l02212"></a>02212     <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND;
<a name="l02213"></a>02213   }
<a name="l02218"></a><a class="code" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">02218</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">end_bulk_update</a>() { <span class="keywordflow">return</span>; }
<a name="l02225"></a><a class="code" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">02225</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">end_bulk_delete</a>()
<a name="l02226"></a>02226   {
<a name="l02227"></a>02227     DBUG_ASSERT(FALSE);
<a name="l02228"></a>02228     <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND;
<a name="l02229"></a>02229   }
<a name="l02230"></a>02230 <span class="keyword">protected</span>:
<a name="l02240"></a><a class="code" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">02240</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map</a>(uchar * buf, <span class="keyword">const</span> uchar * key,
<a name="l02241"></a>02241                              key_part_map keypart_map,
<a name="l02242"></a>02242                              <span class="keyword">enum</span> ha_rkey_function find_flag)
<a name="l02243"></a>02243   {
<a name="l02244"></a>02244     uint key_len= calculate_key_len(table, active_index, key, keypart_map);
<a name="l02245"></a>02245     <span class="keywordflow">return</span>  index_read(buf, key, key_len, find_flag);
<a name="l02246"></a>02246   }
<a name="l02254"></a>02254   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#acba0c549a00023dd44682cd9452cf830" title="Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index.">index_read_idx_map</a>(uchar * buf, uint index, <span class="keyword">const</span> uchar * key,
<a name="l02255"></a>02255                                  key_part_map keypart_map,
<a name="l02256"></a>02256                                  <span class="keyword">enum</span> ha_rkey_function find_flag);
<a name="l02258"></a><a class="code" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">02258</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">index_next</a>(uchar * buf)
<a name="l02259"></a>02259    { <span class="keywordflow">return</span>  HA_ERR_WRONG_COMMAND; }
<a name="l02261"></a><a class="code" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">02261</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">index_prev</a>(uchar * buf)
<a name="l02262"></a>02262    { <span class="keywordflow">return</span>  HA_ERR_WRONG_COMMAND; }
<a name="l02264"></a><a class="code" href="classhandler.html#af37bd518c53c966459632584c34855d0">02264</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#af37bd518c53c966459632584c34855d0">index_first</a>(uchar * buf)
<a name="l02265"></a>02265    { <span class="keywordflow">return</span>  HA_ERR_WRONG_COMMAND; }
<a name="l02267"></a><a class="code" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">02267</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">index_last</a>(uchar * buf)
<a name="l02268"></a>02268    { <span class="keywordflow">return</span>  HA_ERR_WRONG_COMMAND; }
<a name="l02270"></a>02270   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">index_next_same</a>(uchar *buf, <span class="keyword">const</span> uchar *key, uint keylen);
<a name="l02277"></a><a class="code" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">02277</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180" title="The following functions works like index_read, but it find the last row with the current key value or...">index_read_last_map</a>(uchar * buf, <span class="keyword">const</span> uchar * key,
<a name="l02278"></a>02278                                   key_part_map keypart_map)
<a name="l02279"></a>02279   {
<a name="l02280"></a>02280     uint key_len= calculate_key_len(table, active_index, key, keypart_map);
<a name="l02281"></a>02281     <span class="keywordflow">return</span> index_read_last(buf, key, key_len);
<a name="l02282"></a>02282   }
<a name="l02283"></a>02283 <span class="keyword">public</span>:
<a name="l02284"></a>02284   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b" title="Read first row between two ranges. Store ranges for future calls to read_range_next.">read_range_first</a>(<span class="keyword">const</span> key_range *start_key,
<a name="l02285"></a>02285                                <span class="keyword">const</span> key_range *end_key,
<a name="l02286"></a>02286                                <span class="keywordtype">bool</span> eq_range, <span class="keywordtype">bool</span> sorted);
<a name="l02287"></a>02287   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271" title="Read next row between two endpoints.">read_range_next</a>();
<a name="l02288"></a>02288 
<a name="l02297"></a>02297   <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a>(<span class="keyword">const</span> key_range* range,
<a name="l02298"></a>02298                      enum_range_scan_direction direction);
<a name="l02299"></a>02299   <span class="keywordtype">int</span> <a class="code" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a>(key_range *range);
<a name="l02300"></a>02300   <span class="keywordtype">int</span> compare_key_icp(<span class="keyword">const</span> key_range *range) <span class="keyword">const</span>;
<a name="l02301"></a>02301   <span class="keyword">virtual</span> <span class="keywordtype">int</span> ft_init() { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l02302"></a>02302   <span class="keywordtype">void</span> ft_end() { ft_handler=NULL; }
<a name="l02303"></a>02303   <span class="keyword">virtual</span> FT_INFO *ft_init_ext(uint flags, uint inx,<a class="code" href="classString.html">String</a> *key)
<a name="l02304"></a>02304     { <span class="keywordflow">return</span> NULL; }
<a name="l02305"></a>02305   <span class="keyword">virtual</span> <span class="keywordtype">int</span> ft_read(uchar *buf) { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l02306"></a>02306 <span class="keyword">protected</span>:
<a name="l02308"></a>02308   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">rnd_next</a>(uchar *buf)=0;
<a name="l02310"></a>02310   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">rnd_pos</a>(uchar * buf, uchar *pos)=0;
<a name="l02311"></a>02311 <span class="keyword">public</span>:
<a name="l02317"></a><a class="code" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">02317</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">rnd_pos_by_record</a>(uchar *record)
<a name="l02318"></a>02318     {
<a name="l02319"></a>02319       DBUG_ASSERT(table_flags() &amp; HA_PRIMARY_KEY_REQUIRED_FOR_POSITION);
<a name="l02320"></a>02320       position(record);
<a name="l02321"></a>02321       <span class="keywordflow">return</span> <a class="code" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a>(record, ref);
<a name="l02322"></a>02322     }
<a name="l02323"></a>02323   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">read_first_row</a>(uchar *buf, uint primary_key);
<a name="l02328"></a><a class="code" href="classhandler.html#a730672727f9ad989e80f3732eb838a10">02328</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a730672727f9ad989e80f3732eb838a10">restart_rnd_next</a>(uchar *buf, uchar *pos)
<a name="l02329"></a>02329     { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l02330"></a>02330   <span class="keyword">virtual</span> <span class="keywordtype">int</span> rnd_same(uchar *buf, uint inx)
<a name="l02331"></a>02331     { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l02332"></a>02332   <span class="keyword">virtual</span> ha_rows records_in_range(uint inx, key_range *min_key, key_range *max_key)
<a name="l02333"></a>02333     { <span class="keywordflow">return</span> (ha_rows) 10; }
<a name="l02334"></a>02334   <span class="comment">/*</span>
<a name="l02335"></a>02335 <span class="comment">    If HA_PRIMARY_KEY_REQUIRED_FOR_POSITION is set, then it sets ref</span>
<a name="l02336"></a>02336 <span class="comment">    (reference to the row, aka position, with the primary key given in</span>
<a name="l02337"></a>02337 <span class="comment">    the record).</span>
<a name="l02338"></a>02338 <span class="comment">    Otherwise it set ref to the current row.</span>
<a name="l02339"></a>02339 <span class="comment">  */</span>
<a name="l02340"></a>02340   <span class="keyword">virtual</span> <span class="keywordtype">void</span> position(<span class="keyword">const</span> uchar *record)=0;
<a name="l02341"></a>02341   <span class="keyword">virtual</span> <span class="keywordtype">int</span> info(uint)=0; <span class="comment">// see my_base.h for full description</span>
<a name="l02342"></a>02342   <span class="keyword">virtual</span> <span class="keywordtype">void</span> get_dynamic_partition_info(<a class="code" href="structPARTITION__STATS.html">PARTITION_STATS</a> *stat_info,
<a name="l02343"></a>02343                                           uint part_id);
<a name="l02344"></a>02344   <span class="keyword">virtual</span> uint32 calculate_key_hash_value(<a class="code" href="classField.html">Field</a> **field_array)
<a name="l02345"></a>02345   { DBUG_ASSERT(0); <span class="keywordflow">return</span> 0; }
<a name="l02346"></a>02346   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="structqep__row_1_1extra.html">extra</a>(<span class="keyword">enum</span> ha_extra_function operation)
<a name="l02347"></a>02347   { <span class="keywordflow">return</span> 0; }
<a name="l02348"></a>02348   <span class="keyword">virtual</span> <span class="keywordtype">int</span> extra_opt(<span class="keyword">enum</span> ha_extra_function operation, ulong cache_size)
<a name="l02349"></a>02349   { <span class="keywordflow">return</span> <a class="code" href="structqep__row_1_1extra.html">extra</a>(operation); }
<a name="l02350"></a>02350 
<a name="l02355"></a><a class="code" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">02355</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">start_read_removal</a>(<span class="keywordtype">void</span>)
<a name="l02356"></a>02356   { DBUG_ASSERT(0); <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l02357"></a>02357 
<a name="l02363"></a><a class="code" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">02363</a>   <span class="keyword">virtual</span> ha_rows <a class="code" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">end_read_removal</a>(<span class="keywordtype">void</span>)
<a name="l02364"></a>02364   { DBUG_ASSERT(0); <span class="keywordflow">return</span> (ha_rows) 0; }
<a name="l02365"></a>02365 
<a name="l02378"></a><a class="code" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">02378</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">was_semi_consistent_read</a>() { <span class="keywordflow">return</span> 0; }
<a name="l02385"></a><a class="code" href="classhandler.html#ab3e767094bff139a26743e9314df8476">02385</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#ab3e767094bff139a26743e9314df8476">try_semi_consistent_read</a>(<span class="keywordtype">bool</span>) {}
<a name="l02386"></a>02386   <span class="keyword">virtual</span> <span class="keywordtype">void</span> unlock_row() {}
<a name="l02387"></a>02387   <span class="keyword">virtual</span> <span class="keywordtype">int</span> start_stmt(THD *thd, thr_lock_type lock_type) {<span class="keywordflow">return</span> 0;}
<a name="l02388"></a>02388   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment</a>(ulonglong offset, ulonglong increment,
<a name="l02389"></a>02389                                   ulonglong nb_desired_values,
<a name="l02390"></a>02390                                   ulonglong *first_value,
<a name="l02391"></a>02391                                   ulonglong *nb_reserved_values);
<a name="l02392"></a>02392   <span class="keywordtype">void</span> set_next_insert_id(ulonglong <span class="keywordtype">id</span>)
<a name="l02393"></a>02393   {
<a name="l02394"></a>02394     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>,(<span class="stringliteral">&quot;auto_increment: next value %lu&quot;</span>, (ulong)<span class="keywordtype">id</span>));
<a name="l02395"></a>02395     <a class="code" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a>= id;
<a name="l02396"></a>02396   }
<a name="l02397"></a>02397   <span class="keywordtype">void</span> restore_auto_increment(ulonglong <a class="code" href="handler_8cc.html#ae9f796d8fbc7dc812557a17547b8e69e" title="Computes the largest number X:">prev_insert_id</a>)
<a name="l02398"></a>02398   {
<a name="l02399"></a>02399     <span class="comment">/*</span>
<a name="l02400"></a>02400 <span class="comment">      Insertion of a row failed, re-use the lastly generated auto_increment</span>
<a name="l02401"></a>02401 <span class="comment">      id, for the next row. This is achieved by resetting next_insert_id to</span>
<a name="l02402"></a>02402 <span class="comment">      what it was before the failed insertion (that old value is provided by</span>
<a name="l02403"></a>02403 <span class="comment">      the caller). If that value was 0, it was the first row of the INSERT;</span>
<a name="l02404"></a>02404 <span class="comment">      then if insert_id_for_cur_row contains 0 it means no id was generated</span>
<a name="l02405"></a>02405 <span class="comment">      for this first row, so no id was generated since the INSERT started, so</span>
<a name="l02406"></a>02406 <span class="comment">      we should set next_insert_id to 0; if insert_id_for_cur_row is not 0, it</span>
<a name="l02407"></a>02407 <span class="comment">      is the generated id of the first and failed row, so we use it.</span>
<a name="l02408"></a>02408 <span class="comment">    */</span>
<a name="l02409"></a>02409     <a class="code" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a>= (prev_insert_id &gt; 0) ? prev_insert_id :
<a name="l02410"></a>02410       <a class="code" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a>;
<a name="l02411"></a>02411   }
<a name="l02412"></a>02412 
<a name="l02413"></a>02413   <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_create_info(<a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info) {}
<a name="l02414"></a>02414   <span class="keywordtype">int</span> check_old_types();
<a name="l02415"></a>02415   <span class="keyword">virtual</span> <span class="keywordtype">int</span> assign_to_keycache(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt)
<a name="l02416"></a>02416   { <span class="keywordflow">return</span> HA_ADMIN_NOT_IMPLEMENTED; }
<a name="l02417"></a>02417   <span class="keyword">virtual</span> <span class="keywordtype">int</span> preload_keys(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt)
<a name="l02418"></a>02418   { <span class="keywordflow">return</span> HA_ADMIN_NOT_IMPLEMENTED; }
<a name="l02419"></a>02419   <span class="comment">/* end of the list of admin commands */</span>
<a name="l02420"></a>02420 
<a name="l02421"></a>02421   <span class="keyword">virtual</span> <span class="keywordtype">int</span> indexes_are_disabled(<span class="keywordtype">void</span>) {<span class="keywordflow">return</span> 0;}
<a name="l02422"></a>02422   <span class="keyword">virtual</span> <span class="keywordtype">char</span> *update_table_comment(<span class="keyword">const</span> <span class="keywordtype">char</span> * comment)
<a name="l02423"></a>02423   { <span class="keywordflow">return</span> (<span class="keywordtype">char</span>*) comment;}
<a name="l02424"></a>02424   <span class="keyword">virtual</span> <span class="keywordtype">void</span> append_create_info(<a class="code" href="classString.html">String</a> *packet) {}
<a name="l02435"></a><a class="code" href="classhandler.html#adda33331aacc500b1b974033cb64a869">02435</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#adda33331aacc500b1b974033cb64a869">is_fk_defined_on_table_or_index</a>(uint index)
<a name="l02436"></a>02436   { <span class="keywordflow">return</span> FALSE; }
<a name="l02437"></a>02437   <span class="keyword">virtual</span> <span class="keywordtype">char</span>* get_foreign_key_create_info()
<a name="l02438"></a>02438   { <span class="keywordflow">return</span>(NULL);}  <span class="comment">/* gets foreign key create string from InnoDB */</span>
<a name="l02447"></a><a class="code" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">02447</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">can_switch_engines</a>() { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l02459"></a>02459   <span class="keyword">virtual</span> <span class="keywordtype">int</span>
<a name="l02460"></a><a class="code" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">02460</a>   <a class="code" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">get_foreign_key_list</a>(THD *thd, <a class="code" href="classList.html">List&lt;FOREIGN_KEY_INFO&gt;</a> *f_key_list)
<a name="l02461"></a>02461   { <span class="keywordflow">return</span> 0; }
<a name="l02473"></a>02473   <span class="keyword">virtual</span> <span class="keywordtype">int</span>
<a name="l02474"></a><a class="code" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">02474</a>   <a class="code" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">get_parent_foreign_key_list</a>(THD *thd, <a class="code" href="classList.html">List&lt;FOREIGN_KEY_INFO&gt;</a> *f_key_list)
<a name="l02475"></a>02475   { <span class="keywordflow">return</span> 0; }
<a name="l02476"></a>02476   <span class="keyword">virtual</span> uint referenced_by_foreign_key() { <span class="keywordflow">return</span> 0;}
<a name="l02477"></a>02477   <span class="keyword">virtual</span> <span class="keywordtype">void</span> init_table_handle_for_HANDLER()
<a name="l02478"></a>02478   { <span class="keywordflow">return</span>; }       <span class="comment">/* prepare InnoDB for HANDLER */</span>
<a name="l02479"></a>02479   <span class="keyword">virtual</span> <span class="keywordtype">void</span> free_foreign_key_create_info(<span class="keywordtype">char</span>* str) {}
<a name="l02481"></a>02481   <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">table_type</a>() <span class="keyword">const</span> =0;
<a name="l02493"></a>02493   <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> **<a class="code" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext</a>() <span class="keyword">const</span> =0;
<a name="l02494"></a>02494 
<a name="l02495"></a>02495   <span class="keyword">virtual</span> <span class="keywordtype">int</span> get_default_no_partitions(<a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info) { <span class="keywordflow">return</span> 1;}
<a name="l02496"></a>02496   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_auto_partitions(<a class="code" href="classpartition__info.html">partition_info</a> *part_info) { <span class="keywordflow">return</span>; }
<a name="l02497"></a>02497 
<a name="l02508"></a><a class="code" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">02508</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">get_no_parts</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l02509"></a>02509                             uint *no_parts)
<a name="l02510"></a>02510   {
<a name="l02511"></a>02511     *no_parts= 0;
<a name="l02512"></a>02512     <span class="keywordflow">return</span> 0;
<a name="l02513"></a>02513   }
<a name="l02514"></a>02514   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_part_info(<a class="code" href="classpartition__info.html">partition_info</a> *part_info, <span class="keywordtype">bool</span> early) {<span class="keywordflow">return</span>;}
<a name="l02515"></a>02515 
<a name="l02516"></a>02516   <span class="keyword">virtual</span> ulong index_flags(uint idx, uint part, <span class="keywordtype">bool</span> all_parts) <span class="keyword">const</span> =0;
<a name="l02517"></a>02517 
<a name="l02518"></a>02518   uint max_record_length()<span class="keyword"> const</span>
<a name="l02519"></a>02519 <span class="keyword">  </span>{
<a name="l02520"></a>02520     <span class="keyword">using</span> std::min;
<a name="l02521"></a>02521     <span class="keywordflow">return</span> min(HA_MAX_REC_LENGTH, max_supported_record_length());
<a name="l02522"></a>02522   }
<a name="l02523"></a>02523   uint max_keys()<span class="keyword"> const</span>
<a name="l02524"></a>02524 <span class="keyword">  </span>{
<a name="l02525"></a>02525     <span class="keyword">using</span> std::min;
<a name="l02526"></a>02526     <span class="keywordflow">return</span> min(MAX_KEY, max_supported_keys());
<a name="l02527"></a>02527   }
<a name="l02528"></a>02528   uint max_key_parts()<span class="keyword"> const</span>
<a name="l02529"></a>02529 <span class="keyword">  </span>{
<a name="l02530"></a>02530     <span class="keyword">using</span> std::min;
<a name="l02531"></a>02531     <span class="keywordflow">return</span> min(MAX_REF_PARTS, max_supported_key_parts());
<a name="l02532"></a>02532   }
<a name="l02533"></a>02533   uint max_key_length()<span class="keyword"> const</span>
<a name="l02534"></a>02534 <span class="keyword">  </span>{
<a name="l02535"></a>02535     <span class="keyword">using</span> std::min;
<a name="l02536"></a>02536     <span class="keywordflow">return</span> min(MAX_KEY_LENGTH, max_supported_key_length());
<a name="l02537"></a>02537   }
<a name="l02538"></a>02538   uint max_key_part_length()<span class="keyword"> const</span>
<a name="l02539"></a>02539 <span class="keyword">  </span>{
<a name="l02540"></a>02540     <span class="keyword">using</span> std::min;
<a name="l02541"></a>02541     <span class="keywordflow">return</span> min(MAX_KEY_LENGTH, max_supported_key_part_length());
<a name="l02542"></a>02542   }
<a name="l02543"></a>02543 
<a name="l02544"></a>02544   <span class="keyword">virtual</span> uint max_supported_record_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_MAX_REC_LENGTH; }
<a name="l02545"></a>02545   <span class="keyword">virtual</span> uint max_supported_keys()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02546"></a>02546   <span class="keyword">virtual</span> uint max_supported_key_parts()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MAX_REF_PARTS; }
<a name="l02547"></a>02547   <span class="keyword">virtual</span> uint max_supported_key_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MAX_KEY_LENGTH; }
<a name="l02548"></a>02548   <span class="keyword">virtual</span> uint max_supported_key_part_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 255; }
<a name="l02549"></a>02549   <span class="keyword">virtual</span> uint min_record_length(uint options)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l02550"></a>02550 
<a name="l02551"></a>02551   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> low_byte_first()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l02552"></a>02552   <span class="keyword">virtual</span> uint checksum()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02553"></a>02553   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> is_crashed()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02554"></a>02554   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> auto_repair()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02555"></a>02555 
<a name="l02556"></a>02556 
<a name="l02557"></a>02557 <span class="preprocessor">#define CHF_CREATE_FLAG 0</span>
<a name="l02558"></a>02558 <span class="preprocessor"></span><span class="preprocessor">#define CHF_DELETE_FLAG 1</span>
<a name="l02559"></a>02559 <span class="preprocessor"></span><span class="preprocessor">#define CHF_RENAME_FLAG 2</span>
<a name="l02560"></a>02560 <span class="preprocessor"></span><span class="preprocessor">#define CHF_INDEX_FLAG  3</span>
<a name="l02561"></a>02561 <span class="preprocessor"></span>
<a name="l02562"></a>02562 
<a name="l02566"></a><a class="code" href="classhandler.html#a13f5a2b8ba9e4b9f9255243f0f1cd525">02566</a>   <span class="keyword">virtual</span> uint <a class="code" href="classhandler.html#a13f5a2b8ba9e4b9f9255243f0f1cd525">lock_count</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l02580"></a>02580   <span class="keyword">virtual</span> THR_LOCK_DATA **<a class="code" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock</a>(THD *thd,
<a name="l02581"></a>02581                                      THR_LOCK_DATA **to,
<a name="l02582"></a>02582                                      <span class="keyword">enum</span> thr_lock_type lock_type)=0;
<a name="l02583"></a>02583 
<a name="l02585"></a><a class="code" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">02585</a>   <span class="keyword">virtual</span> uint8 <a class="code" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">table_cache_type</a>() { <span class="keywordflow">return</span> HA_CACHE_TBL_NONTRANSACT; }
<a name="l02586"></a>02586 
<a name="l02587"></a>02587 
<a name="l02618"></a><a class="code" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f">02618</a>   <span class="keyword">virtual</span> my_bool <a class="code" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f" title="Register a named table with a call back function to the query cache.">register_query_cache_table</a>(THD *thd, <span class="keywordtype">char</span> *table_key,
<a name="l02619"></a>02619                                              uint key_length,
<a name="l02620"></a>02620                                              qc_engine_callback
<a name="l02621"></a>02621                                              *engine_callback,
<a name="l02622"></a>02622                                              ulonglong *engine_data)
<a name="l02623"></a>02623   {
<a name="l02624"></a>02624     *engine_callback= 0;
<a name="l02625"></a>02625     <span class="keywordflow">return</span> TRUE;
<a name="l02626"></a>02626   }
<a name="l02627"></a>02627 
<a name="l02628"></a>02628 
<a name="l02629"></a>02629  <span class="comment">/*</span>
<a name="l02630"></a>02630 <span class="comment">   @retval TRUE   Primary key (if there is one) is clustered</span>
<a name="l02631"></a>02631 <span class="comment">                  key covering all fields</span>
<a name="l02632"></a>02632 <span class="comment">   @retval FALSE  otherwise</span>
<a name="l02633"></a>02633 <span class="comment"> */</span>
<a name="l02634"></a>02634  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> primary_key_is_clustered() { <span class="keywordflow">return</span> FALSE; }
<a name="l02635"></a>02635  <span class="keyword">virtual</span> <span class="keywordtype">int</span> cmp_ref(<span class="keyword">const</span> uchar *ref1, <span class="keyword">const</span> uchar *ref2)
<a name="l02636"></a>02636  {
<a name="l02637"></a>02637    <span class="keywordflow">return</span> memcmp(ref1, ref2, <a class="code" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a>);
<a name="l02638"></a>02638  }
<a name="l02639"></a>02639 
<a name="l02640"></a>02640  <span class="comment">/*</span>
<a name="l02641"></a>02641 <span class="comment">   Condition pushdown to storage engines</span>
<a name="l02642"></a>02642 <span class="comment"> */</span>
<a name="l02643"></a>02643 
<a name="l02666"></a><a class="code" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">02666</a>  <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="classItem.html">Item</a> *<a class="code" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">cond_push</a>(<span class="keyword">const</span> <a class="code" href="classItem.html">Item</a> *cond) { <span class="keywordflow">return</span> cond; };
<a name="l02672"></a><a class="code" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">02672</a>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">cond_pop</a>() { <span class="keywordflow">return</span>; }
<a name="l02673"></a>02673 
<a name="l02699"></a><a class="code" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">02699</a>  <span class="keyword">virtual</span> <a class="code" href="classItem.html">Item</a> *<a class="code" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">idx_cond_push</a>(uint keyno, <a class="code" href="classItem.html">Item</a>* idx_cond) { <span class="keywordflow">return</span> idx_cond; }
<a name="l02700"></a>02700 
<a name="l02702"></a><a class="code" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">02702</a>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a>()
<a name="l02703"></a>02703  {
<a name="l02704"></a>02704    pushed_idx_cond= NULL;
<a name="l02705"></a>02705    pushed_idx_cond_keyno= MAX_KEY;
<a name="l02706"></a>02706    in_range_check_pushed_down= <span class="keyword">false</span>;
<a name="l02707"></a>02707  }
<a name="l02708"></a>02708 
<a name="l02713"></a><a class="code" href="classhandler.html#a243ce6f51c5538c6d1dae81db1bb1658">02713</a>   <span class="keyword">virtual</span> uint <a class="code" href="classhandler.html#a243ce6f51c5538c6d1dae81db1bb1658">number_of_pushed_joins</a>()<span class="keyword"> const</span>
<a name="l02714"></a>02714 <span class="keyword">  </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02715"></a>02715 
<a name="l02720"></a><a class="code" href="classhandler.html#ae1bf0cbd806508954db72a5707732ee6">02720</a>   <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="structTABLE.html">TABLE</a>* <a class="code" href="classhandler.html#ae1bf0cbd806508954db72a5707732ee6">root_of_pushed_join</a>()<span class="keyword"> const</span>
<a name="l02721"></a>02721 <span class="keyword">  </span>{ <span class="keywordflow">return</span> NULL; }
<a name="l02722"></a>02722 
<a name="l02727"></a><a class="code" href="classhandler.html#a915706fa5bb7e07752cc2d89ec467977">02727</a>   <span class="keyword">virtual</span> <span class="keyword">const</span> <a class="code" href="structTABLE.html">TABLE</a>* <a class="code" href="classhandler.html#a915706fa5bb7e07752cc2d89ec467977">parent_of_pushed_join</a>()<span class="keyword"> const</span>
<a name="l02728"></a>02728 <span class="keyword">  </span>{ <span class="keywordflow">return</span> NULL; }
<a name="l02729"></a>02729 
<a name="l02730"></a>02730   <span class="keyword">virtual</span> <span class="keywordtype">int</span> index_read_pushed(uchar * buf, <span class="keyword">const</span> uchar * key,
<a name="l02731"></a>02731                              key_part_map keypart_map)
<a name="l02732"></a>02732   { <span class="keywordflow">return</span>  HA_ERR_WRONG_COMMAND; }
<a name="l02733"></a>02733 
<a name="l02734"></a>02734   <span class="keyword">virtual</span> <span class="keywordtype">int</span> index_next_pushed(uchar * buf)
<a name="l02735"></a>02735   { <span class="keywordflow">return</span>  HA_ERR_WRONG_COMMAND; }
<a name="l02736"></a>02736 
<a name="l02740"></a><a class="code" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">02740</a>  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">check_if_incompatible_data</a>(<a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info,
<a name="l02741"></a>02741                                          uint table_changes)
<a name="l02742"></a>02742  { <span class="keywordflow">return</span> COMPATIBLE_DATA_NO; }
<a name="l02743"></a>02743 
<a name="l02744"></a>02744  <span class="comment">/* On-line/in-place ALTER TABLE interface. */</span>
<a name="l02745"></a>02745 
<a name="l02746"></a>02746  <span class="comment">/*</span>
<a name="l02747"></a>02747 <span class="comment">   Here is an outline of on-line/in-place ALTER TABLE execution through</span>
<a name="l02748"></a>02748 <span class="comment">   this interface.</span>
<a name="l02749"></a>02749 <span class="comment"></span>
<a name="l02750"></a>02750 <span class="comment">   Phase 1 : Initialization</span>
<a name="l02751"></a>02751 <span class="comment">   ========================</span>
<a name="l02752"></a>02752 <span class="comment">   During this phase we determine which algorithm should be used</span>
<a name="l02753"></a>02753 <span class="comment">   for execution of ALTER TABLE and what level concurrency it will</span>
<a name="l02754"></a>02754 <span class="comment">   require.</span>
<a name="l02755"></a>02755 <span class="comment"></span>
<a name="l02756"></a>02756 <span class="comment">   *) This phase starts by opening the table and preparing description</span>
<a name="l02757"></a>02757 <span class="comment">      of the new version of the table.</span>
<a name="l02758"></a>02758 <span class="comment">   *) Then we check if it is impossible even in theory to carry out</span>
<a name="l02759"></a>02759 <span class="comment">      this ALTER TABLE using the in-place algorithm. For example, because</span>
<a name="l02760"></a>02760 <span class="comment">      we need to change storage engine or the user has explicitly requested</span>
<a name="l02761"></a>02761 <span class="comment">      usage of the &quot;copy&quot; algorithm.</span>
<a name="l02762"></a>02762 <span class="comment">   *) If in-place ALTER TABLE is theoretically possible, we continue</span>
<a name="l02763"></a>02763 <span class="comment">      by compiling differences between old and new versions of the table</span>
<a name="l02764"></a>02764 <span class="comment">      in the form of HA_ALTER_FLAGS bitmap. We also build a few</span>
<a name="l02765"></a>02765 <span class="comment">      auxiliary structures describing requested changes and store</span>
<a name="l02766"></a>02766 <span class="comment">      all these data in the Alter_inplace_info object.</span>
<a name="l02767"></a>02767 <span class="comment">   *) Then the handler::check_if_supported_inplace_alter() method is called</span>
<a name="l02768"></a>02768 <span class="comment">      in order to find if the storage engine can carry out changes requested</span>
<a name="l02769"></a>02769 <span class="comment">      by this ALTER TABLE using the in-place algorithm. To determine this,</span>
<a name="l02770"></a>02770 <span class="comment">      the engine can rely on data in HA_ALTER_FLAGS/Alter_inplace_info</span>
<a name="l02771"></a>02771 <span class="comment">      passed to it as well as on its own checks. If the in-place algorithm</span>
<a name="l02772"></a>02772 <span class="comment">      can be used for this ALTER TABLE, the level of required concurrency for</span>
<a name="l02773"></a>02773 <span class="comment">      its execution is also returned.</span>
<a name="l02774"></a>02774 <span class="comment">      If any errors occur during the handler call, ALTER TABLE is aborted</span>
<a name="l02775"></a>02775 <span class="comment">      and no further handler functions are called.</span>
<a name="l02776"></a>02776 <span class="comment">   *) Locking requirements of the in-place algorithm are compared to any</span>
<a name="l02777"></a>02777 <span class="comment">      concurrency requirements specified by user. If there is a conflict</span>
<a name="l02778"></a>02778 <span class="comment">      between them, we either switch to the copy algorithm or emit an error.</span>
<a name="l02779"></a>02779 <span class="comment"></span>
<a name="l02780"></a>02780 <span class="comment">   Phase 2 : Execution</span>
<a name="l02781"></a>02781 <span class="comment">   ===================</span>
<a name="l02782"></a>02782 <span class="comment"></span>
<a name="l02783"></a>02783 <span class="comment">   In this phase the operations are executed.</span>
<a name="l02784"></a>02784 <span class="comment"></span>
<a name="l02785"></a>02785 <span class="comment">   *) As the first step, we acquire a lock corresponding to the concurrency</span>
<a name="l02786"></a>02786 <span class="comment">      level which was returned by handler::check_if_supported_inplace_alter()</span>
<a name="l02787"></a>02787 <span class="comment">      and requested by the user. This lock is held for most of the</span>
<a name="l02788"></a>02788 <span class="comment">      duration of in-place ALTER (if HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</span>
<a name="l02789"></a>02789 <span class="comment">      or HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE were returned we acquire an</span>
<a name="l02790"></a>02790 <span class="comment">      exclusive lock for duration of the next step only).</span>
<a name="l02791"></a>02791 <span class="comment">   *) After that we call handler::ha_prepare_inplace_alter_table() to give the</span>
<a name="l02792"></a>02792 <span class="comment">      storage engine a chance to update its internal structures with a higher</span>
<a name="l02793"></a>02793 <span class="comment">      lock level than the one that will be used for the main step of algorithm.</span>
<a name="l02794"></a>02794 <span class="comment">      After that we downgrade the lock if it is necessary.</span>
<a name="l02795"></a>02795 <span class="comment">   *) After that, the main step of this phase and algorithm is executed.</span>
<a name="l02796"></a>02796 <span class="comment">      We call the handler::ha_inplace_alter_table() method, which carries out the</span>
<a name="l02797"></a>02797 <span class="comment">      changes requested by ALTER TABLE but does not makes them visible to other</span>
<a name="l02798"></a>02798 <span class="comment">      connections yet.</span>
<a name="l02799"></a>02799 <span class="comment">   *) We ensure that no other connection uses the table by upgrading our</span>
<a name="l02800"></a>02800 <span class="comment">      lock on it to exclusive.</span>
<a name="l02801"></a>02801 <span class="comment">   *) a) If the previous step succeeds, handler::ha_commit_inplace_alter_table() is</span>
<a name="l02802"></a>02802 <span class="comment">         called to allow the storage engine to do any final updates to its structures,</span>
<a name="l02803"></a>02803 <span class="comment">         to make all earlier changes durable and visible to other connections.</span>
<a name="l02804"></a>02804 <span class="comment">      b) If we have failed to upgrade lock or any errors have occured during the</span>
<a name="l02805"></a>02805 <span class="comment">         handler functions calls (including commit), we call</span>
<a name="l02806"></a>02806 <span class="comment">         handler::ha_commit_inplace_alter_table()</span>
<a name="l02807"></a>02807 <span class="comment">         to rollback all changes which were done during previous steps.</span>
<a name="l02808"></a>02808 <span class="comment"></span>
<a name="l02809"></a>02809 <span class="comment">  Phase 3 : Final</span>
<a name="l02810"></a>02810 <span class="comment">  ===============</span>
<a name="l02811"></a>02811 <span class="comment"></span>
<a name="l02812"></a>02812 <span class="comment">  In this phase we:</span>
<a name="l02813"></a>02813 <span class="comment"></span>
<a name="l02814"></a>02814 <span class="comment">  *) Update SQL-layer data-dictionary by installing .FRM file for the new version</span>
<a name="l02815"></a>02815 <span class="comment">     of the table.</span>
<a name="l02816"></a>02816 <span class="comment">  *) Inform the storage engine about this change by calling the</span>
<a name="l02817"></a>02817 <span class="comment">     handler::ha_notify_table_changed() method.</span>
<a name="l02818"></a>02818 <span class="comment">  *) Destroy the Alter_inplace_info and handler_ctx objects.</span>
<a name="l02819"></a>02819 <span class="comment"></span>
<a name="l02820"></a>02820 <span class="comment"> */</span>
<a name="l02821"></a>02821 
<a name="l02850"></a>02850  <span class="keyword">virtual</span> enum_alter_inplace_result
<a name="l02851"></a>02851  <a class="code" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter</a>(<a class="code" href="structTABLE.html">TABLE</a> *altered_table,
<a name="l02852"></a>02852                                   <a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info);
<a name="l02853"></a>02853 
<a name="l02854"></a>02854 
<a name="l02859"></a>02859  <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#ad0ecf7f9bf265e6801b625768f0f2bbe">ha_prepare_inplace_alter_table</a>(<a class="code" href="structTABLE.html">TABLE</a> *altered_table,
<a name="l02860"></a>02860                                      <a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info);
<a name="l02861"></a>02861 
<a name="l02862"></a>02862 
<a name="l02867"></a><a class="code" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">02867</a>  <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">ha_inplace_alter_table</a>(<a class="code" href="structTABLE.html">TABLE</a> *altered_table,
<a name="l02868"></a>02868                              <a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)
<a name="l02869"></a>02869  {
<a name="l02870"></a>02870    <span class="keywordflow">return</span> <a class="code" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table</a>(altered_table, ha_alter_info);
<a name="l02871"></a>02871  }
<a name="l02872"></a>02872 
<a name="l02873"></a>02873 
<a name="l02879"></a>02879  <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a6ec170a4aa71186f9dc17358b55587c7">ha_commit_inplace_alter_table</a>(<a class="code" href="structTABLE.html">TABLE</a> *altered_table,
<a name="l02880"></a>02880                                     <a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info,
<a name="l02881"></a>02881                                     <span class="keywordtype">bool</span> commit);
<a name="l02882"></a>02882 
<a name="l02883"></a>02883 
<a name="l02888"></a><a class="code" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">02888</a>  <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">ha_notify_table_changed</a>()
<a name="l02889"></a>02889  {
<a name="l02890"></a>02890    <a class="code" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed</a>();
<a name="l02891"></a>02891  }
<a name="l02892"></a>02892 
<a name="l02893"></a>02893 
<a name="l02894"></a>02894 <span class="keyword">protected</span>:
<a name="l02923"></a><a class="code" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">02923</a>  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table</a>(<a class="code" href="structTABLE.html">TABLE</a> *altered_table,
<a name="l02924"></a>02924                                           <a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)
<a name="l02925"></a>02925  { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l02926"></a>02926 
<a name="l02927"></a>02927 
<a name="l02947"></a><a class="code" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">02947</a>  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table</a>(<a class="code" href="structTABLE.html">TABLE</a> *altered_table,
<a name="l02948"></a>02948                                   <a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)
<a name="l02949"></a>02949  { <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l02950"></a>02950 
<a name="l02951"></a>02951 
<a name="l02984"></a><a class="code" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">02984</a>  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table</a>(<a class="code" href="structTABLE.html">TABLE</a> *altered_table,
<a name="l02985"></a>02985                                          <a class="code" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info,
<a name="l02986"></a>02986                                          <span class="keywordtype">bool</span> commit)
<a name="l02987"></a>02987 {
<a name="l02988"></a>02988   <span class="comment">/* Nothing to commit/rollback, mark all handlers committed! */</span>
<a name="l02989"></a>02989   ha_alter_info-&gt;<a class="code" href="classAlter__inplace__info.html#aeacdbdf2da7047907f86f6b78b4cda9e">group_commit_ctx</a>= NULL;
<a name="l02990"></a>02990   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02991"></a>02991 }
<a name="l02992"></a>02992 
<a name="l02993"></a>02993 
<a name="l02999"></a>02999  <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed</a>();
<a name="l03000"></a>03000 
<a name="l03001"></a>03001 <span class="keyword">public</span>:
<a name="l03002"></a>03002  <span class="comment">/* End of On-line/in-place ALTER TABLE interface. */</span>
<a name="l03003"></a>03003 
<a name="l03004"></a>03004 
<a name="l03010"></a>03010   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a>();
<a name="l03011"></a>03011   <span class="keyword">virtual</span> uint alter_table_flags(uint flags)
<a name="l03012"></a>03012   {
<a name="l03013"></a>03013     <span class="keywordflow">if</span> (ht-&gt;alter_table_flags)
<a name="l03014"></a>03014       <span class="keywordflow">return</span> ht-&gt;alter_table_flags(flags);
<a name="l03015"></a>03015     <span class="keywordflow">return</span> 0;
<a name="l03016"></a>03016   }
<a name="l03017"></a>03017 
<a name="l03018"></a>03018 <span class="keyword">protected</span>:
<a name="l03019"></a>03019   <span class="comment">/* Service methods for use by storage engines. */</span>
<a name="l03020"></a>03020   <span class="keywordtype">void</span> ha_statistic_increment(ulonglong <a class="code" href="structsystem__status__var.html">SSV</a>::*offset) <span class="keyword">const</span>;
<a name="l03021"></a>03021   <span class="keywordtype">void</span> **ha_data(THD *) <span class="keyword">const</span>;
<a name="l03022"></a>03022   THD *ha_thd(<span class="keywordtype">void</span>) <span class="keyword">const</span>;
<a name="l03023"></a>03023 
<a name="l03029"></a>03029   PSI_table_share *<a class="code" href="classhandler.html#a6fb15a9a57acb926cdb2a9d5fca21f14">ha_table_share_psi</a>(<span class="keyword">const</span> <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share) <span class="keyword">const</span>;
<a name="l03030"></a>03030 
<a name="l03038"></a>03038   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">rename_table</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, <span class="keyword">const</span> <span class="keywordtype">char</span> *to);
<a name="l03043"></a>03043   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">delete_table</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l03044"></a>03044 <span class="keyword">private</span>:
<a name="l03045"></a>03045   <span class="comment">/* Private helpers */</span>
<a name="l03046"></a>03046   <span class="keyword">inline</span> <span class="keywordtype">void</span> mark_trx_read_write();
<a name="l03047"></a>03047   <span class="comment">/*</span>
<a name="l03048"></a>03048 <span class="comment">    Low-level primitives for storage engines.  These should be</span>
<a name="l03049"></a>03049 <span class="comment">    overridden by the storage engine class. To call these methods, use</span>
<a name="l03050"></a>03050 <span class="comment">    the corresponding &#39;ha_*&#39; method above.</span>
<a name="l03051"></a>03051 <span class="comment">  */</span>
<a name="l03052"></a>03052 
<a name="l03053"></a>03053   <span class="keyword">virtual</span> <span class="keywordtype">int</span> open(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> mode, uint test_if_locked)=0;
<a name="l03054"></a>03054   <span class="keyword">virtual</span> <span class="keywordtype">int</span> close(<span class="keywordtype">void</span>)=0;
<a name="l03055"></a>03055   <span class="keyword">virtual</span> <span class="keywordtype">int</span> index_init(uint idx, <span class="keywordtype">bool</span> sorted) { active_index= idx; <span class="keywordflow">return</span> 0; }
<a name="l03056"></a>03056   <span class="keyword">virtual</span> <span class="keywordtype">int</span> index_end() { active_index= MAX_KEY; <span class="keywordflow">return</span> 0; }
<a name="l03064"></a>03064   <span class="keyword">virtual</span> <span class="keywordtype">int</span> rnd_init(<span class="keywordtype">bool</span> scan)= 0;
<a name="l03065"></a>03065   <span class="keyword">virtual</span> <span class="keywordtype">int</span> rnd_end() { <span class="keywordflow">return</span> 0; }
<a name="l03066"></a>03066   <span class="keyword">virtual</span> <span class="keywordtype">int</span> write_row(uchar *buf __attribute__((unused)))
<a name="l03067"></a>03067   {
<a name="l03068"></a>03068     <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND;
<a name="l03069"></a>03069   }
<a name="l03070"></a>03070 
<a name="l03079"></a>03079   <span class="keyword">virtual</span> <span class="keywordtype">int</span> update_row(<span class="keyword">const</span> uchar *old_data __attribute__((unused)),
<a name="l03080"></a>03080                          uchar *new_data __attribute__((unused)))
<a name="l03081"></a>03081   {
<a name="l03082"></a>03082     <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND;
<a name="l03083"></a>03083   }
<a name="l03084"></a>03084 
<a name="l03085"></a>03085   <span class="keyword">virtual</span> <span class="keywordtype">int</span> delete_row(<span class="keyword">const</span> uchar *buf __attribute__((unused)))
<a name="l03086"></a>03086   {
<a name="l03087"></a>03087     <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND;
<a name="l03088"></a>03088   }
<a name="l03094"></a>03094   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classDsMrr__impl.html#a186174fdee0ea701012e58c55a1e5618">reset</a>() { <span class="keywordflow">return</span> 0; }
<a name="l03095"></a>03095   <span class="keyword">virtual</span> Table_flags table_flags(<span class="keywordtype">void</span>) <span class="keyword">const</span>= 0;
<a name="l03118"></a>03118   <span class="keyword">virtual</span> <span class="keywordtype">int</span> external_lock(THD *thd __attribute__((unused)),
<a name="l03119"></a>03119                             <span class="keywordtype">int</span> lock_type __attribute__((unused)))
<a name="l03120"></a>03120   {
<a name="l03121"></a>03121     <span class="keywordflow">return</span> 0;
<a name="l03122"></a>03122   }
<a name="l03123"></a>03123   <span class="keyword">virtual</span> <span class="keywordtype">void</span> release_auto_increment() { <span class="keywordflow">return</span>; };
<a name="l03125"></a>03125   <span class="keyword">virtual</span> <span class="keywordtype">int</span> check_for_upgrade(<a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)
<a name="l03126"></a>03126   { <span class="keywordflow">return</span> 0; }
<a name="l03127"></a>03127   <span class="keyword">virtual</span> <span class="keywordtype">int</span> check(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt)
<a name="l03128"></a>03128   { <span class="keywordflow">return</span> HA_ADMIN_NOT_IMPLEMENTED; }
<a name="l03129"></a>03129 
<a name="l03135"></a>03135   <span class="keyword">virtual</span> <span class="keywordtype">int</span> repair(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt)
<a name="l03136"></a>03136   {
<a name="l03137"></a>03137     DBUG_ASSERT(!(<a class="code" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">ha_table_flags</a>() &amp; HA_CAN_REPAIR));
<a name="l03138"></a>03138     <span class="keywordflow">return</span> HA_ADMIN_NOT_IMPLEMENTED;
<a name="l03139"></a>03139   }
<a name="l03140"></a>03140   <span class="keyword">virtual</span> <span class="keywordtype">void</span> start_bulk_insert(ha_rows rows) {}
<a name="l03141"></a>03141   <span class="keyword">virtual</span> <span class="keywordtype">int</span> end_bulk_insert() { <span class="keywordflow">return</span> 0; }
<a name="l03142"></a>03142 <span class="keyword">protected</span>:
<a name="l03143"></a>03143   <span class="keyword">virtual</span> <span class="keywordtype">int</span> index_read(uchar * buf, <span class="keyword">const</span> uchar * key, uint key_len,
<a name="l03144"></a>03144                          <span class="keyword">enum</span> ha_rkey_function find_flag)
<a name="l03145"></a>03145    { <span class="keywordflow">return</span>  HA_ERR_WRONG_COMMAND; }
<a name="l03146"></a>03146   <span class="keyword">virtual</span> <span class="keywordtype">int</span> index_read_last(uchar * buf, <span class="keyword">const</span> uchar * key, uint key_len)
<a name="l03147"></a>03147    { <span class="keywordflow">return</span> (my_errno= HA_ERR_WRONG_COMMAND); }
<a name="l03148"></a>03148 <span class="keyword">public</span>:
<a name="l03165"></a><a class="code" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">03165</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">bulk_update_row</a>(<span class="keyword">const</span> uchar *old_data, uchar *new_data,
<a name="l03166"></a>03166                               uint *dup_key_found)
<a name="l03167"></a>03167   {
<a name="l03168"></a>03168     DBUG_ASSERT(FALSE);
<a name="l03169"></a>03169     <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND;
<a name="l03170"></a>03170   }
<a name="l03177"></a><a class="code" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">03177</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">delete_all_rows</a>()
<a name="l03178"></a>03178   { <span class="keywordflow">return</span> (my_errno=HA_ERR_WRONG_COMMAND); }
<a name="l03197"></a><a class="code" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">03197</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">truncate</a>()
<a name="l03198"></a>03198   { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l03204"></a><a class="code" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">03204</a>   <span class="keyword">virtual</span> <span class="keywordtype">int</span> <a class="code" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">reset_auto_increment</a>(ulonglong value)
<a name="l03205"></a>03205   { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l03206"></a>03206   <span class="keyword">virtual</span> <span class="keywordtype">int</span> optimize(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt)
<a name="l03207"></a>03207   { <span class="keywordflow">return</span> HA_ADMIN_NOT_IMPLEMENTED; }
<a name="l03208"></a>03208   <span class="keyword">virtual</span> <span class="keywordtype">int</span> analyze(THD* thd, <a class="code" href="structst__ha__check__opt.html">HA_CHECK_OPT</a>* check_opt)
<a name="l03209"></a>03209   { <span class="keywordflow">return</span> HA_ADMIN_NOT_IMPLEMENTED; }
<a name="l03210"></a>03210   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> check_and_repair(THD *thd) { <span class="keywordflow">return</span> TRUE; }
<a name="l03211"></a>03211   <span class="keyword">virtual</span> <span class="keywordtype">int</span> disable_indexes(uint mode) { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l03212"></a>03212   <span class="keyword">virtual</span> <span class="keywordtype">int</span> enable_indexes(uint mode) { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l03213"></a>03213   <span class="keyword">virtual</span> <span class="keywordtype">int</span> discard_or_import_tablespace(my_bool discard)
<a name="l03214"></a>03214   { <span class="keywordflow">return</span> (my_errno=HA_ERR_WRONG_COMMAND); }
<a name="l03215"></a>03215   <span class="keyword">virtual</span> <span class="keywordtype">void</span> drop_table(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l03216"></a>03216   <span class="keyword">virtual</span> <span class="keywordtype">int</span> create(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <a class="code" href="structTABLE.html">TABLE</a> *form, <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)=0;
<a name="l03217"></a>03217 
<a name="l03218"></a>03218   <span class="keyword">virtual</span> <span class="keywordtype">int</span> create_handler_files(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *old_name,
<a name="l03219"></a>03219                                    <span class="keywordtype">int</span> action_flag, <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)
<a name="l03220"></a>03220   { <span class="keywordflow">return</span> FALSE; }
<a name="l03221"></a>03221 
<a name="l03222"></a>03222   <span class="keyword">virtual</span> <span class="keywordtype">int</span> change_partitions(<a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info,
<a name="l03223"></a>03223                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *path,
<a name="l03224"></a>03224                                 ulonglong * <span class="keyword">const</span> copied,
<a name="l03225"></a>03225                                 ulonglong * <span class="keyword">const</span> deleted,
<a name="l03226"></a>03226                                 <span class="keyword">const</span> uchar *pack_frm_data,
<a name="l03227"></a>03227                                 <span class="keywordtype">size_t</span> pack_frm_len)
<a name="l03228"></a>03228   { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l03229"></a>03229   <span class="keyword">virtual</span> <span class="keywordtype">int</span> drop_partitions(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)
<a name="l03230"></a>03230   { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l03231"></a>03231   <span class="keyword">virtual</span> <span class="keywordtype">int</span> rename_partitions(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)
<a name="l03232"></a>03232   { <span class="keywordflow">return</span> HA_ERR_WRONG_COMMAND; }
<a name="l03233"></a>03233   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> set_ha_share_ref(<a class="code" href="classHandler__share.html">Handler_share</a> **arg_ha_share)
<a name="l03234"></a>03234   {
<a name="l03235"></a>03235     DBUG_ASSERT(!ha_share);
<a name="l03236"></a>03236     DBUG_ASSERT(arg_ha_share);
<a name="l03237"></a>03237     <span class="keywordflow">if</span> (ha_share || !arg_ha_share)
<a name="l03238"></a>03238       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03239"></a>03239     ha_share= arg_ha_share;
<a name="l03240"></a>03240     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03241"></a>03241   }
<a name="l03242"></a>03242   <span class="keywordtype">int</span> get_lock_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_lock_type; }
<a name="l03243"></a>03243 <span class="keyword">protected</span>:
<a name="l03244"></a>03244   <a class="code" href="classHandler__share.html">Handler_share</a> *<a class="code" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a>();
<a name="l03245"></a>03245   <span class="keywordtype">void</span> <a class="code" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a>(<a class="code" href="classHandler__share.html">Handler_share</a> *arg_ha_share);
<a name="l03246"></a>03246   <span class="keywordtype">void</span> <a class="code" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a>();
<a name="l03247"></a>03247   <span class="keywordtype">void</span> <a class="code" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a>();
<a name="l03248"></a>03248 };
<a name="l03249"></a>03249 
<a name="l03250"></a>03250 
<a name="l03251"></a>03251 <span class="keywordtype">bool</span> <a class="code" href="handler_8cc.html#a136dfdf479102e63c8ddf02af552c445">key_uses_partial_cols</a>(<a class="code" href="structTABLE.html">TABLE</a> *table, uint keyno);
<a name="l03252"></a>03252 
<a name="l03253"></a>03253 <span class="comment">/*</span>
<a name="l03254"></a>03254 <span class="comment">  A Disk-Sweep MRR interface implementation</span>
<a name="l03255"></a>03255 <span class="comment"></span>
<a name="l03256"></a>03256 <span class="comment">  This implementation makes range (and, in the future, &#39;ref&#39;) scans to read</span>
<a name="l03257"></a>03257 <span class="comment">  table rows in disk sweeps. </span>
<a name="l03258"></a>03258 <span class="comment">  </span>
<a name="l03259"></a>03259 <span class="comment">  Currently it is used by MyISAM and InnoDB. Potentially it can be used with</span>
<a name="l03260"></a>03260 <span class="comment">  any table handler that has non-clustered indexes and on-disk rows.</span>
<a name="l03261"></a>03261 <span class="comment">*/</span>
<a name="l03262"></a>03262 
<a name="l03263"></a><a class="code" href="classDsMrr__impl.html">03263</a> <span class="keyword">class </span><a class="code" href="classDsMrr__impl.html">DsMrr_impl</a>
<a name="l03264"></a>03264 {
<a name="l03265"></a>03265 <span class="keyword">public</span>:
<a name="l03266"></a>03266   <span class="keyword">typedef</span> void (<a class="code" href="classhandler.html">handler</a>::*range_check_toggle_func_t)(<span class="keywordtype">bool</span> on);
<a name="l03267"></a>03267 
<a name="l03268"></a>03268   <a class="code" href="classDsMrr__impl.html">DsMrr_impl</a>()
<a name="l03269"></a>03269     : h2(NULL) {};
<a name="l03270"></a>03270   ~DsMrr_impl() { DBUG_ASSERT(h2 == NULL); }
<a name="l03271"></a>03271   
<a name="l03272"></a>03272   <span class="comment">/*</span>
<a name="l03273"></a>03273 <span class="comment">    The &quot;owner&quot; handler object (the one that calls dsmrr_XXX functions.</span>
<a name="l03274"></a>03274 <span class="comment">    It is used to retrieve full table rows by calling rnd_pos().</span>
<a name="l03275"></a>03275 <span class="comment">  */</span>
<a name="l03276"></a>03276   <a class="code" href="classhandler.html">handler</a> *h;
<a name="l03277"></a>03277   <a class="code" href="structTABLE.html">TABLE</a> *table; <span class="comment">/* Always equal to h-&gt;table */</span>
<a name="l03278"></a>03278 <span class="keyword">private</span>:
<a name="l03279"></a>03279   <span class="comment">/* Secondary handler object.  It is used for scanning the index */</span>
<a name="l03280"></a>03280   <a class="code" href="classhandler.html">handler</a> *h2;
<a name="l03281"></a>03281 
<a name="l03282"></a>03282   <span class="comment">/* Buffer to store rowids, or (rowid, range_id) pairs */</span>
<a name="l03283"></a>03283   uchar *rowids_buf;
<a name="l03284"></a>03284   uchar *rowids_buf_cur;   <span class="comment">/* Current position when reading/writing */</span>
<a name="l03285"></a>03285   uchar *rowids_buf_last;  <span class="comment">/* When reading: end of used buffer space */</span>
<a name="l03286"></a>03286   uchar *rowids_buf_end;   <span class="comment">/* End of the buffer */</span>
<a name="l03287"></a>03287 
<a name="l03288"></a>03288   <span class="keywordtype">bool</span> dsmrr_eof; <span class="comment">/* TRUE &lt;=&gt; We have reached EOF when reading index tuples */</span>
<a name="l03289"></a>03289 
<a name="l03290"></a>03290   <span class="comment">/* TRUE &lt;=&gt; need range association, buffer holds {rowid, range_id} pairs */</span>
<a name="l03291"></a>03291   <span class="keywordtype">bool</span> is_mrr_assoc;
<a name="l03292"></a>03292 
<a name="l03293"></a>03293   <span class="keywordtype">bool</span> use_default_impl; <span class="comment">/* TRUE &lt;=&gt; shortcut all calls to default MRR impl */</span>
<a name="l03294"></a>03294 <span class="keyword">public</span>:
<a name="l03295"></a>03295   <span class="keywordtype">void</span> init(<a class="code" href="classhandler.html">handler</a> *h_arg, <a class="code" href="structTABLE.html">TABLE</a> *table_arg)
<a name="l03296"></a>03296   {
<a name="l03297"></a>03297     h= h_arg; 
<a name="l03298"></a>03298     table= table_arg;
<a name="l03299"></a>03299   }
<a name="l03300"></a>03300   <span class="keywordtype">int</span> <a class="code" href="classDsMrr__impl.html#ade7283d68a19de82fd19ad836ac10506">dsmrr_init</a>(<a class="code" href="classhandler.html">handler</a> *h, <a class="code" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq_funcs, <span class="keywordtype">void</span> *seq_init_param, 
<a name="l03301"></a>03301                  uint n_ranges, uint mode, <a class="code" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *buf);
<a name="l03302"></a>03302   <span class="keywordtype">void</span> dsmrr_close();
<a name="l03303"></a>03303 
<a name="l03314"></a>03314   <span class="keywordtype">void</span> <a class="code" href="classDsMrr__impl.html#a186174fdee0ea701012e58c55a1e5618">reset</a>();
<a name="l03315"></a>03315   <span class="keywordtype">int</span> <a class="code" href="classDsMrr__impl.html#a444c0116a9c9b9eefb73195e8ad5c3e6">dsmrr_fill_buffer</a>();
<a name="l03316"></a>03316   <span class="keywordtype">int</span> dsmrr_next(<span class="keywordtype">char</span> **range_info);
<a name="l03317"></a>03317 
<a name="l03318"></a>03318   ha_rows dsmrr_info(uint keyno, uint n_ranges, uint keys, uint *bufsz,
<a name="l03319"></a>03319                      uint *flags, <a class="code" href="classCost__estimate.html">Cost_estimate</a> *cost);
<a name="l03320"></a>03320 
<a name="l03321"></a>03321   ha_rows dsmrr_info_const(uint keyno, <a class="code" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, 
<a name="l03322"></a>03322                             <span class="keywordtype">void</span> *seq_init_param, uint n_ranges, uint *bufsz,
<a name="l03323"></a>03323                             uint *flags, <a class="code" href="classCost__estimate.html">Cost_estimate</a> *cost);
<a name="l03324"></a>03324 <span class="keyword">private</span>:
<a name="l03325"></a>03325   <span class="keywordtype">bool</span> choose_mrr_impl(uint keyno, ha_rows rows, uint *flags, uint *bufsz, 
<a name="l03326"></a>03326                        <a class="code" href="classCost__estimate.html">Cost_estimate</a> *cost);
<a name="l03327"></a>03327   <span class="keywordtype">bool</span> get_disk_sweep_mrr_cost(uint keynr, ha_rows rows, uint flags, 
<a name="l03328"></a>03328                                uint *buffer_size, <a class="code" href="classCost__estimate.html">Cost_estimate</a> *cost);
<a name="l03329"></a>03329 };
<a name="l03330"></a>03330         <span class="comment">/* Some extern variables used with handlers */</span>
<a name="l03331"></a>03331 
<a name="l03332"></a>03332 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *ha_row_type[];
<a name="l03333"></a>03333 <span class="keyword">extern</span> MYSQL_PLUGIN_IMPORT <span class="keyword">const</span> <span class="keywordtype">char</span> *tx_isolation_names[];
<a name="l03334"></a>03334 <span class="keyword">extern</span> MYSQL_PLUGIN_IMPORT <span class="keyword">const</span> <span class="keywordtype">char</span> *binlog_format_names[];
<a name="l03335"></a>03335 <span class="keyword">extern</span> TYPELIB tx_isolation_typelib;
<a name="l03336"></a>03336 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *myisam_stats_method_names[];
<a name="l03337"></a>03337 <span class="keyword">extern</span> ulong total_ha, total_ha_2pc;
<a name="l03338"></a>03338 
<a name="l03339"></a>03339 <span class="comment">/* lookups */</span>
<a name="l03340"></a>03340 <a class="code" href="structhandlerton.html">handlerton</a> *<a class="code" href="handler_8cc.html#a81f4e93fa7d5ad8702a33afbf226e93b" title="Return the default storage engine handlerton used for non-temp tables for thread.">ha_default_handlerton</a>(THD *thd);
<a name="l03341"></a>03341 <a class="code" href="structhandlerton.html">handlerton</a> *<a class="code" href="handler_8cc.html#a0ac0c824f4d8dd002cb61b3bcd3947bc" title="Return the default storage engine handlerton used for explicitly created temp tables for a thread...">ha_default_temp_handlerton</a>(THD *thd);
<a name="l03342"></a>03342 <a class="code" href="structst__plugin__int.html">plugin_ref</a> <a class="code" href="handler_8cc.html#acd39f1826bca8434f79a47fda2af9f48" title="Return the storage engine handlerton for the supplied name.">ha_resolve_by_name</a>(THD *thd, <span class="keyword">const</span> LEX_STRING *name, 
<a name="l03343"></a>03343                               <span class="keywordtype">bool</span> is_temp_table);
<a name="l03344"></a>03344 <a class="code" href="structst__plugin__int.html">plugin_ref</a> ha_lock_engine(THD *thd, <span class="keyword">const</span> <a class="code" href="structhandlerton.html">handlerton</a> *hton);
<a name="l03345"></a>03345 <a class="code" href="structhandlerton.html">handlerton</a> *ha_resolve_by_legacy_type(THD *thd, <span class="keyword">enum</span> legacy_db_type db_type);
<a name="l03346"></a>03346 <a class="code" href="classhandler.html">handler</a> *get_new_handler(<a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, MEM_ROOT *alloc,
<a name="l03347"></a>03347                          <a class="code" href="structhandlerton.html">handlerton</a> *db_type);
<a name="l03348"></a>03348 <a class="code" href="structhandlerton.html">handlerton</a> *<a class="code" href="handler_8cc.html#a36740c5632ede113d26c6eb270e727ae">ha_checktype</a>(THD *thd, <span class="keyword">enum</span> legacy_db_type database_type,
<a name="l03349"></a>03349                           <span class="keywordtype">bool</span> no_substitute, <span class="keywordtype">bool</span> report_error);
<a name="l03350"></a>03350 
<a name="l03351"></a>03351 
<a name="l03352"></a>03352 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">enum</span> legacy_db_type ha_legacy_type(<span class="keyword">const</span> <a class="code" href="structhandlerton.html">handlerton</a> *db_type)
<a name="l03353"></a>03353 {
<a name="l03354"></a>03354   <span class="keywordflow">return</span> (db_type == NULL) ? DB_TYPE_UNKNOWN : db_type-&gt;db_type;
<a name="l03355"></a>03355 }
<a name="l03356"></a>03356 
<a name="l03357"></a>03357 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *ha_resolve_storage_engine_name(<span class="keyword">const</span> <a class="code" href="structhandlerton.html">handlerton</a> *db_type)
<a name="l03358"></a>03358 {
<a name="l03359"></a>03359   <span class="keywordflow">return</span> db_type == NULL ? <span class="stringliteral">&quot;UNKNOWN&quot;</span> : hton2plugin[db_type-&gt;slot]-&gt;name.str;
<a name="l03360"></a>03360 }
<a name="l03361"></a>03361 
<a name="l03362"></a>03362 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ha_check_storage_engine_flag(<span class="keyword">const</span> <a class="code" href="structhandlerton.html">handlerton</a> *db_type, uint32 flag)
<a name="l03363"></a>03363 {
<a name="l03364"></a>03364   <span class="keywordflow">return</span> db_type == NULL ? FALSE : MY_TEST(db_type-&gt;flags &amp; flag);
<a name="l03365"></a>03365 }
<a name="l03366"></a>03366 
<a name="l03367"></a>03367 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">bool</span> ha_storage_engine_is_enabled(<span class="keyword">const</span> <a class="code" href="structhandlerton.html">handlerton</a> *db_type)
<a name="l03368"></a>03368 {
<a name="l03369"></a>03369   <span class="keywordflow">return</span> (db_type &amp;&amp; db_type-&gt;create) ?
<a name="l03370"></a>03370          (db_type-&gt;state == SHOW_OPTION_YES) : FALSE;
<a name="l03371"></a>03371 }
<a name="l03372"></a>03372 
<a name="l03373"></a>03373 <span class="comment">/* basic stuff */</span>
<a name="l03374"></a>03374 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a7ceb3a3e413c9c3892b8104aecb60dbd">ha_init_errors</a>(<span class="keywordtype">void</span>);
<a name="l03375"></a>03375 <span class="keywordtype">int</span> ha_init(<span class="keywordtype">void</span>);
<a name="l03376"></a>03376 <span class="keywordtype">int</span> ha_end(<span class="keywordtype">void</span>);
<a name="l03377"></a>03377 <span class="keywordtype">int</span> ha_initialize_handlerton(<a class="code" href="structst__plugin__int.html">st_plugin_int</a> *plugin);
<a name="l03378"></a>03378 <span class="keywordtype">int</span> ha_finalize_handlerton(<a class="code" href="structst__plugin__int.html">st_plugin_int</a> *plugin);
<a name="l03379"></a>03379 
<a name="l03380"></a>03380 TYPELIB* ha_known_exts();
<a name="l03381"></a>03381 <span class="keywordtype">int</span> ha_panic(<span class="keyword">enum</span> ha_panic_function flag);
<a name="l03382"></a>03382 <span class="keywordtype">void</span> <a class="code" href="handler_8cc.html#ab753a55bd518a53d30dd053833304ebd">ha_close_connection</a>(THD* thd);
<a name="l03383"></a>03383 <span class="keywordtype">bool</span> ha_flush_logs(<a class="code" href="structhandlerton.html">handlerton</a> *db_type);
<a name="l03384"></a>03384 <span class="keywordtype">void</span> ha_drop_database(<span class="keywordtype">char</span>* path);
<a name="l03385"></a>03385 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#ac16449680328461d40dfae146f90e979">ha_create_table</a>(THD *thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *path,
<a name="l03386"></a>03386                     <span class="keyword">const</span> <span class="keywordtype">char</span> *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *table_name,
<a name="l03387"></a>03387                     <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info,
<a name="l03388"></a>03388                                 <span class="keywordtype">bool</span> update_create_info,
<a name="l03389"></a>03389                     <span class="keywordtype">bool</span> is_temp_table= <span class="keyword">false</span>);
<a name="l03390"></a>03390 
<a name="l03391"></a>03391 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#ae2294c29d2c517fd60f4d9889532c610" title="This should return ENOENT if the file doesn&#39;t exists. The .frm file will be deleted only if we return...">ha_delete_table</a>(THD *thd, <a class="code" href="structhandlerton.html">handlerton</a> *db_type, <span class="keyword">const</span> <span class="keywordtype">char</span> *path,
<a name="l03392"></a>03392                     <span class="keyword">const</span> <span class="keywordtype">char</span> *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *alias, <span class="keywordtype">bool</span> generate_warning);
<a name="l03393"></a>03393 
<a name="l03394"></a>03394 <span class="comment">/* statistics and info */</span>
<a name="l03395"></a>03395 <span class="keywordtype">bool</span> ha_show_status(THD *thd, <a class="code" href="structhandlerton.html">handlerton</a> *db_type, <span class="keyword">enum</span> ha_stat_type stat);
<a name="l03396"></a>03396 
<a name="l03397"></a>03397 <span class="comment">/* discovery */</span>
<a name="l03398"></a>03398 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#ad7fbd8c7ba3e1522597328bf6439e885">ha_create_table_from_engine</a>(THD* thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l03399"></a>03399 <span class="keywordtype">bool</span> <a class="code" href="handler_8cc.html#a78cb5fc09dd37f21dede2d9c0ac24ce6">ha_check_if_table_exists</a>(THD* thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l03400"></a>03400                              <span class="keywordtype">bool</span> *exists);
<a name="l03401"></a>03401 <span class="keywordtype">int</span> ha_discover(THD* thd, <span class="keyword">const</span> <span class="keywordtype">char</span>* dbname, <span class="keyword">const</span> <span class="keywordtype">char</span>* name,
<a name="l03402"></a>03402                 uchar** frmblob, <span class="keywordtype">size_t</span>* frmlen);
<a name="l03403"></a>03403 <span class="keywordtype">int</span> ha_find_files(THD *thd,<span class="keyword">const</span> <span class="keywordtype">char</span> *db,<span class="keyword">const</span> <span class="keywordtype">char</span> *path,
<a name="l03404"></a>03404                   <span class="keyword">const</span> <span class="keywordtype">char</span> *wild, <span class="keywordtype">bool</span> dir, <a class="code" href="classList.html">List&lt;LEX_STRING&gt;</a>* files);
<a name="l03405"></a>03405 <span class="keywordtype">int</span> ha_table_exists_in_engine(THD* thd, <span class="keyword">const</span> <span class="keywordtype">char</span>* db, <span class="keyword">const</span> <span class="keywordtype">char</span>* name);
<a name="l03406"></a>03406 <span class="keywordtype">bool</span> <a class="code" href="handler_8cc.html#a4b52399a74d9db4f3421851b46ff6dc9" title="Check if a given table is a system table.">ha_check_if_supported_system_table</a>(<a class="code" href="structhandlerton.html">handlerton</a> *hton, <span class="keyword">const</span> <span class="keywordtype">char</span>* db, 
<a name="l03407"></a>03407                                         <span class="keyword">const</span> <span class="keywordtype">char</span>* table_name);
<a name="l03408"></a>03408 
<a name="l03409"></a>03409 <span class="comment">/* key cache */</span>
<a name="l03410"></a>03410 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a148e166799444d311941a690a9e055ea">ha_init_key_cache</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, KEY_CACHE *key_cache);
<a name="l03411"></a>03411 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a1bf31fef3cb90da8800035f3687ba6c1">ha_resize_key_cache</a>(KEY_CACHE *key_cache);
<a name="l03412"></a>03412 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#ad57ca26b2d9aa5570f84cb2e491e8abc">ha_change_key_cache_param</a>(KEY_CACHE *key_cache);
<a name="l03413"></a>03413 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a2be2b29769464f494517c18082ed21b0">ha_change_key_cache</a>(KEY_CACHE *old_key_cache, KEY_CACHE *new_key_cache);
<a name="l03414"></a>03414 
<a name="l03415"></a>03415 <span class="comment">/* report to InnoDB that control passes to the client */</span>
<a name="l03416"></a>03416 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a48d3c7f3e6672bbac5021611a01564e9">ha_release_temporary_latches</a>(THD *thd);
<a name="l03417"></a>03417 
<a name="l03418"></a>03418 <span class="comment">/* transactions: interface to handlerton functions */</span>
<a name="l03419"></a>03419 <span class="keywordtype">int</span> ha_start_consistent_snapshot(THD *thd);
<a name="l03420"></a>03420 <span class="keywordtype">int</span> ha_commit_or_rollback_by_xid(THD *thd, <a class="code" href="structxid__t.html">XID</a> *xid, <span class="keywordtype">bool</span> commit);
<a name="l03421"></a>03421 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a9a81ce45b63a150449fb897a34572bb1">ha_commit_trans</a>(THD *thd, <span class="keywordtype">bool</span> all, <span class="keywordtype">bool</span> ignore_global_read_lock= <span class="keyword">false</span>);
<a name="l03422"></a>03422 <span class="keywordtype">int</span> ha_rollback_trans(THD *thd, <span class="keywordtype">bool</span> all);
<a name="l03423"></a>03423 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a04a7aaf17f4439699d7de62cbc2974f7">ha_prepare</a>(THD *thd);
<a name="l03424"></a>03424 <span class="keywordtype">int</span> ha_recover(HASH *commit_list);
<a name="l03425"></a>03425 
<a name="l03426"></a>03426 <span class="comment">/*</span>
<a name="l03427"></a>03427 <span class="comment"> transactions: interface to low-level handlerton functions. These are</span>
<a name="l03428"></a>03428 <span class="comment"> intended to be used by the transaction coordinators to</span>
<a name="l03429"></a>03429 <span class="comment"> commit/prepare/rollback transactions in the engines.</span>
<a name="l03430"></a>03430 <span class="comment">*/</span>
<a name="l03431"></a>03431 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a4a77fdd0e1d6bee79e29e7495c7d752a">ha_commit_low</a>(THD *thd, <span class="keywordtype">bool</span> all, <span class="keywordtype">bool</span> run_after_commit= <span class="keyword">true</span>);
<a name="l03432"></a>03432 <span class="keywordtype">int</span> ha_prepare_low(THD *thd, <span class="keywordtype">bool</span> all);
<a name="l03433"></a>03433 <span class="keywordtype">int</span> ha_rollback_low(THD *thd, <span class="keywordtype">bool</span> all);
<a name="l03434"></a>03434 
<a name="l03435"></a>03435 <span class="comment">/* transactions: these functions never call handlerton functions directly */</span>
<a name="l03436"></a>03436 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#a717442e00ab24e3265d6b997330ffea2">ha_enable_transaction</a>(THD *thd, <span class="keywordtype">bool</span> on);
<a name="l03437"></a>03437 
<a name="l03438"></a>03438 <span class="comment">/* savepoints */</span>
<a name="l03439"></a>03439 <span class="keywordtype">int</span> ha_rollback_to_savepoint(THD *thd, SAVEPOINT *sv);
<a name="l03440"></a>03440 <span class="keywordtype">bool</span> <a class="code" href="handler_8cc.html#ade7e42569784a1c80aa5ce3d233a4266">ha_rollback_to_savepoint_can_release_mdl</a>(THD *thd);
<a name="l03441"></a>03441 <span class="keywordtype">int</span> <a class="code" href="handler_8cc.html#ab62bed9d64dab80d4677b8900f5392c6">ha_savepoint</a>(THD *thd, SAVEPOINT *sv);
<a name="l03442"></a>03442 <span class="keywordtype">int</span> ha_release_savepoint(THD *thd, SAVEPOINT *sv);
<a name="l03443"></a>03443 
<a name="l03444"></a>03444 <span class="comment">/* Build pushed joins in handlers implementing this feature */</span>
<a name="l03445"></a>03445 <span class="keywordtype">int</span> ha_make_pushed_joins(THD *thd, <span class="keyword">const</span> <a class="code" href="classAQP_1_1Join__plan.html">AQP::Join_plan</a>* plan);
<a name="l03446"></a>03446 
<a name="l03447"></a>03447 <span class="comment">/* these are called by storage engines */</span>
<a name="l03448"></a>03448 <span class="keywordtype">void</span> <a class="code" href="handler_8cc.html#a257d69d232e363e6f15bf699f5785ca0">trans_register_ha</a>(THD *thd, <span class="keywordtype">bool</span> all, <a class="code" href="structhandlerton.html">handlerton</a> *ht);
<a name="l03449"></a>03449 
<a name="l03450"></a>03450 <span class="comment">/*</span>
<a name="l03451"></a>03451 <span class="comment">  Storage engine has to assume the transaction will end up with 2pc if</span>
<a name="l03452"></a>03452 <span class="comment">   - there is more than one 2pc-capable storage engine available</span>
<a name="l03453"></a>03453 <span class="comment">   - in the current transaction 2pc was not disabled yet</span>
<a name="l03454"></a>03454 <span class="comment">*/</span>
<a name="l03455"></a>03455 <span class="preprocessor">#define trans_need_2pc(thd, all)                   ((total_ha_2pc &gt; 1) &amp;&amp; \</span>
<a name="l03456"></a>03456 <span class="preprocessor">        !((all ? &amp;thd-&gt;transaction.all : &amp;thd-&gt;transaction.stmt)-&gt;no_2pc))</span>
<a name="l03457"></a>03457 <span class="preprocessor"></span>
<a name="l03458"></a>03458 <span class="preprocessor">#ifdef HAVE_NDB_BINLOG</span>
<a name="l03459"></a>03459 <span class="preprocessor"></span><span class="keywordtype">int</span> ha_reset_logs(THD *thd);
<a name="l03460"></a>03460 <span class="keywordtype">int</span> ha_binlog_index_purge_file(THD *thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *file);
<a name="l03461"></a>03461 <span class="keywordtype">void</span> ha_reset_slave(THD *thd);
<a name="l03462"></a>03462 <span class="keywordtype">void</span> ha_binlog_log_query(THD *thd, <a class="code" href="structhandlerton.html">handlerton</a> *db_type,
<a name="l03463"></a>03463                          enum_binlog_command binlog_command,
<a name="l03464"></a>03464                          <span class="keyword">const</span> <span class="keywordtype">char</span> *query, uint query_length,
<a name="l03465"></a>03465                          <span class="keyword">const</span> <span class="keywordtype">char</span> *db, <span class="keyword">const</span> <span class="keywordtype">char</span> *table_name);
<a name="l03466"></a>03466 <span class="keywordtype">void</span> ha_binlog_wait(THD *thd);
<a name="l03467"></a>03467 <span class="preprocessor">#else</span>
<a name="l03468"></a>03468 <span class="preprocessor"></span><span class="preprocessor">#define ha_reset_logs(a) do {} while (0)</span>
<a name="l03469"></a>03469 <span class="preprocessor"></span><span class="preprocessor">#define ha_binlog_index_purge_file(a,b) do {} while (0)</span>
<a name="l03470"></a>03470 <span class="preprocessor"></span><span class="preprocessor">#define ha_reset_slave(a) do {} while (0)</span>
<a name="l03471"></a>03471 <span class="preprocessor"></span><span class="preprocessor">#define ha_binlog_log_query(a,b,c,d,e,f,g) do {} while (0)</span>
<a name="l03472"></a>03472 <span class="preprocessor"></span><span class="preprocessor">#define ha_binlog_wait(a) do {} while (0)</span>
<a name="l03473"></a>03473 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l03474"></a>03474 <span class="preprocessor"></span>
<a name="l03475"></a>03475 <span class="comment">/* It is required by basic binlog features on both MySQL server and libmysqld */</span>
<a name="l03476"></a>03476 <span class="keywordtype">int</span> ha_binlog_end(THD *thd);
<a name="l03477"></a>03477 
<a name="l03478"></a>03478 <span class="keyword">const</span> <span class="keywordtype">char</span> *ha_legacy_type_name(legacy_db_type legacy_type);
<a name="l03479"></a>03479 <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="handler_8cc.html#ad012444cc24f2178ff92e9e7ecbfbc85" title="make canonical filename">get_canonical_filename</a>(<a class="code" href="classhandler.html">handler</a> *file, <span class="keyword">const</span> <span class="keywordtype">char</span> *path,
<a name="l03480"></a>03480                                    <span class="keywordtype">char</span> *tmp_path);
<a name="l03481"></a>03481 <span class="keywordtype">bool</span> <a class="code" href="handler_8cc.html#a305eff1aae0bb5dd0063024c6c15d656">mysql_xa_recover</a>(THD *thd);
<a name="l03482"></a>03482 
<a name="l03483"></a>03483 
<a name="l03484"></a>03484 <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *table_case_name(<a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info, <span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l03485"></a>03485 {
<a name="l03486"></a>03486   <span class="keywordflow">return</span> ((lower_case_table_names == 2 &amp;&amp; info-&gt;alias) ? info-&gt;alias : name);
<a name="l03487"></a>03487 }
<a name="l03488"></a>03488 
<a name="l03489"></a>03489 <span class="keywordtype">void</span> <a class="code" href="handler_8cc.html#a10ddf5a0a2c8e742a80be49cf751cea2">print_keydup_error</a>(<a class="code" href="structTABLE.html">TABLE</a> *table, <a class="code" href="structst__key.html">KEY</a> *key, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg, myf errflag);
<a name="l03490"></a>03490 <span class="keywordtype">void</span> <a class="code" href="handler_8cc.html#a10ddf5a0a2c8e742a80be49cf751cea2">print_keydup_error</a>(<a class="code" href="structTABLE.html">TABLE</a> *table, <a class="code" href="structst__key.html">KEY</a> *key, myf errflag);
<a name="l03491"></a>03491 
<a name="l03492"></a>03492 <span class="preprocessor">#endif </span><span class="comment">/* HANDLER_INCLUDED */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:45 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
