<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: field.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">field.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef FIELD_INCLUDED</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define FIELD_INCLUDED</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* Copyright (c) 2000, 2014, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment">   the Free Software Foundation; version 2 of the License.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment">   along with this program; if not, write to the Free Software</span>
<a name="l00017"></a>00017 <span class="comment">   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;mysqld.h&quot;</span>                             <span class="comment">/* system_charset_info */</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;table.h&quot;</span>                              <span class="comment">/* TABLE */</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;sql_string.h&quot;</span>                         <span class="comment">/* String */</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;<a class="code" href="my__decimal_8h.html">my_decimal.h</a>&quot;</span>                         <span class="comment">/* my_decimal */</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;sql_error.h&quot;</span>                          <span class="comment">/* Sql_condition */</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;mysql_version.h&quot;</span>                      <span class="comment">/* FRM_VER */</span>
<a name="l00025"></a>00025 
<a name="l00026"></a>00026 <span class="comment">/*</span>
<a name="l00027"></a>00027 <span class="comment"></span>
<a name="l00028"></a>00028 <span class="comment">Field class hierarchy</span>
<a name="l00029"></a>00029 <span class="comment"></span>
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">Field (abstract)</span>
<a name="l00032"></a>00032 <span class="comment">|</span>
<a name="l00033"></a>00033 <span class="comment">+--Field_bit</span>
<a name="l00034"></a>00034 <span class="comment">|  +--Field_bit_as_char</span>
<a name="l00035"></a>00035 <span class="comment">|  </span>
<a name="l00036"></a>00036 <span class="comment">+--Field_num (abstract)</span>
<a name="l00037"></a>00037 <span class="comment">|  |  +--Field_real (asbstract)</span>
<a name="l00038"></a>00038 <span class="comment">|  |     +--Field_decimal</span>
<a name="l00039"></a>00039 <span class="comment">|  |     +--Field_float</span>
<a name="l00040"></a>00040 <span class="comment">|  |     +--Field_double</span>
<a name="l00041"></a>00041 <span class="comment">|  |</span>
<a name="l00042"></a>00042 <span class="comment">|  +--Field_new_decimal</span>
<a name="l00043"></a>00043 <span class="comment">|  +--Field_short</span>
<a name="l00044"></a>00044 <span class="comment">|  +--Field_medium</span>
<a name="l00045"></a>00045 <span class="comment">|  +--Field_long</span>
<a name="l00046"></a>00046 <span class="comment">|  +--Field_longlong</span>
<a name="l00047"></a>00047 <span class="comment">|  +--Field_tiny</span>
<a name="l00048"></a>00048 <span class="comment">|     +--Field_year</span>
<a name="l00049"></a>00049 <span class="comment">|</span>
<a name="l00050"></a>00050 <span class="comment">+--Field_str (abstract)</span>
<a name="l00051"></a>00051 <span class="comment">|  +--Field_longstr</span>
<a name="l00052"></a>00052 <span class="comment">|  |  +--Field_string</span>
<a name="l00053"></a>00053 <span class="comment">|  |  +--Field_varstring</span>
<a name="l00054"></a>00054 <span class="comment">|  |  +--Field_blob</span>
<a name="l00055"></a>00055 <span class="comment">|  |     +--Field_geom</span>
<a name="l00056"></a>00056 <span class="comment">|  |</span>
<a name="l00057"></a>00057 <span class="comment">|  +--Field_null</span>
<a name="l00058"></a>00058 <span class="comment">|  +--Field_enum</span>
<a name="l00059"></a>00059 <span class="comment">|     +--Field_set</span>
<a name="l00060"></a>00060 <span class="comment">|</span>
<a name="l00061"></a>00061 <span class="comment">+--Field_temporal (abstract)</span>
<a name="l00062"></a>00062 <span class="comment">   +--Field_time_common (abstract)</span>
<a name="l00063"></a>00063 <span class="comment">   |  +--Field_time</span>
<a name="l00064"></a>00064 <span class="comment">   |  +--Field_timef</span>
<a name="l00065"></a>00065 <span class="comment">   |</span>
<a name="l00066"></a>00066 <span class="comment">   +--Field_temporal_with_date (abstract)</span>
<a name="l00067"></a>00067 <span class="comment">      +--Field_newdate</span>
<a name="l00068"></a>00068 <span class="comment">      +--Field_temporal_with_date_and_time (abstract)</span>
<a name="l00069"></a>00069 <span class="comment">         +--Field_timestamp</span>
<a name="l00070"></a>00070 <span class="comment">         +--Field_datetime</span>
<a name="l00071"></a>00071 <span class="comment">         +--Field_temporal_with_date_and_timef (abstract)</span>
<a name="l00072"></a>00072 <span class="comment">            +--Field_timestampf</span>
<a name="l00073"></a>00073 <span class="comment">            +--Field_datetimef</span>
<a name="l00074"></a>00074 <span class="comment">*/</span>
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="keyword">class </span><a class="code" href="classSend__field.html">Send_field</a>;
<a name="l00078"></a>00078 <span class="keyword">class </span><a class="code" href="classProtocol.html">Protocol</a>;
<a name="l00079"></a>00079 <span class="keyword">class </span><a class="code" href="classCreate__field.html">Create_field</a>;
<a name="l00080"></a>00080 <span class="keyword">class </span><a class="code" href="classRelay__log__info.html">Relay_log_info</a>;
<a name="l00081"></a>00081 <span class="keyword">class </span><a class="code" href="classField.html">Field</a>;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="keyword">enum</span> enum_check_fields
<a name="l00084"></a>00084 {
<a name="l00085"></a>00085   CHECK_FIELD_IGNORE,
<a name="l00086"></a>00086   CHECK_FIELD_WARN,
<a name="l00087"></a>00087   CHECK_FIELD_ERROR_FOR_NULL
<a name="l00088"></a>00088 };
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">enum</span> Derivation
<a name="l00092"></a>00092 {
<a name="l00093"></a>00093   DERIVATION_IGNORABLE= 6,
<a name="l00094"></a>00094   DERIVATION_NUMERIC= 5,
<a name="l00095"></a>00095   DERIVATION_COERCIBLE= 4,
<a name="l00096"></a>00096   DERIVATION_SYSCONST= 3,
<a name="l00097"></a>00097   DERIVATION_IMPLICIT= 2,
<a name="l00098"></a>00098   DERIVATION_NONE= 1,
<a name="l00099"></a>00099   DERIVATION_EXPLICIT= 0
<a name="l00100"></a>00100 };
<a name="l00101"></a>00101 
<a name="l00108"></a>00108 <span class="keyword">enum</span> type_conversion_status
<a name="l00109"></a>00109 {
<a name="l00111"></a>00111   TYPE_OK= 0,
<a name="l00116"></a>00116   TYPE_NOTE_TIME_TRUNCATED,
<a name="l00121"></a>00121   TYPE_WARN_OUT_OF_RANGE,
<a name="l00131"></a>00131   TYPE_NOTE_TRUNCATED,
<a name="l00140"></a>00140   TYPE_WARN_TRUNCATED,
<a name="l00142"></a>00142   TYPE_ERR_NULL_CONSTRAINT_VIOLATION,
<a name="l00147"></a>00147   TYPE_ERR_BAD_VALUE,
<a name="l00149"></a>00149   TYPE_ERR_OOM
<a name="l00150"></a>00150 };
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="preprocessor">#define STORAGE_TYPE_MASK 7</span>
<a name="l00154"></a>00154 <span class="preprocessor"></span><span class="preprocessor">#define COLUMN_FORMAT_MASK 7</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><span class="preprocessor">#define COLUMN_FORMAT_SHIFT 3</span>
<a name="l00156"></a>00156 <span class="preprocessor"></span>
<a name="l00157"></a>00157 <span class="preprocessor">#define my_charset_numeric      my_charset_latin1</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span><span class="preprocessor">#define MY_REPERTOIRE_NUMERIC   MY_REPERTOIRE_ASCII</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160 <span class="keyword">struct </span><a class="code" href="structst__cache__field.html">st_cache_field</a>;
<a name="l00161"></a>00161 type_conversion_status <a class="code" href="field__conv_8cc.html#ac6315ce5b8740662e0c10dd34c659fae">field_conv</a>(<a class="code" href="classField.html">Field</a> *to,<a class="code" href="classField.html">Field</a> *from);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="keyword">inline</span> uint get_enum_pack_length(<span class="keywordtype">int</span> elements)
<a name="l00164"></a>00164 {
<a name="l00165"></a>00165   <span class="keywordflow">return</span> elements &lt; 256 ? 1 : 2;
<a name="l00166"></a>00166 }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="keyword">inline</span> uint get_set_pack_length(<span class="keywordtype">int</span> elements)
<a name="l00169"></a>00169 {
<a name="l00170"></a>00170   uint len= (elements + 7) / 8;
<a name="l00171"></a>00171   <span class="keywordflow">return</span> len &gt; 4 ? 8 : len;
<a name="l00172"></a>00172 }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="keyword">inline</span> type_conversion_status
<a name="l00175"></a>00175 decimal_err_to_type_conv_status(<span class="keywordtype">int</span> dec_error)
<a name="l00176"></a>00176 {
<a name="l00177"></a>00177   <span class="keywordflow">if</span> (dec_error &amp; E_DEC_OOM)
<a name="l00178"></a>00178     <span class="keywordflow">return</span> TYPE_ERR_OOM;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   <span class="keywordflow">if</span> (dec_error &amp; (E_DEC_DIV_ZERO | E_DEC_BAD_NUM))
<a name="l00181"></a>00181     <span class="keywordflow">return</span> TYPE_ERR_BAD_VALUE;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <span class="keywordflow">if</span> (dec_error &amp; E_DEC_TRUNCATED)
<a name="l00184"></a>00184     <span class="keywordflow">return</span> TYPE_NOTE_TRUNCATED;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186   <span class="keywordflow">if</span> (dec_error &amp; E_DEC_OVERFLOW)
<a name="l00187"></a>00187     <span class="keywordflow">return</span> TYPE_WARN_OUT_OF_RANGE;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189   <span class="keywordflow">if</span> (dec_error == E_DEC_OK)
<a name="l00190"></a>00190     <span class="keywordflow">return</span> TYPE_OK;
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   <span class="comment">// impossible</span>
<a name="l00193"></a>00193   DBUG_ASSERT(<span class="keyword">false</span>);
<a name="l00194"></a>00194   <span class="keywordflow">return</span> TYPE_ERR_BAD_VALUE;
<a name="l00195"></a>00195 }
<a name="l00196"></a>00196 
<a name="l00201"></a>00201 <span class="keyword">inline</span> type_conversion_status
<a name="l00202"></a>00202 time_warning_to_type_conversion_status(<span class="keyword">const</span> <span class="keywordtype">int</span> warn)
<a name="l00203"></a>00203 {
<a name="l00204"></a>00204   <span class="keywordflow">if</span> (warn &amp; MYSQL_TIME_NOTE_TRUNCATED)
<a name="l00205"></a>00205     <span class="keywordflow">return</span> TYPE_NOTE_TIME_TRUNCATED;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207   <span class="keywordflow">if</span> (warn &amp; MYSQL_TIME_WARN_OUT_OF_RANGE)
<a name="l00208"></a>00208     <span class="keywordflow">return</span> TYPE_WARN_OUT_OF_RANGE;
<a name="l00209"></a>00209 
<a name="l00210"></a>00210   <span class="keywordflow">if</span> (warn &amp; MYSQL_TIME_WARN_TRUNCATED)
<a name="l00211"></a>00211     <span class="keywordflow">return</span> TYPE_NOTE_TRUNCATED;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <span class="keywordflow">if</span> (warn &amp; (MYSQL_TIME_WARN_ZERO_DATE | MYSQL_TIME_WARN_ZERO_IN_DATE))
<a name="l00214"></a>00214     <span class="keywordflow">return</span> TYPE_ERR_BAD_VALUE;
<a name="l00215"></a>00215 
<a name="l00216"></a>00216   <span class="keywordflow">if</span> (warn &amp; MYSQL_TIME_WARN_INVALID_TIMESTAMP)
<a name="l00217"></a>00217     <span class="comment">// date was fine but pointed to daylight saving time switch gap</span>
<a name="l00218"></a>00218     <span class="keywordflow">return</span> TYPE_OK;
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   DBUG_ASSERT(!warn);
<a name="l00221"></a>00221   <span class="keywordflow">return</span> TYPE_OK;
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 <span class="preprocessor">#define ASSERT_COLUMN_MARKED_FOR_READ \</span>
<a name="l00225"></a>00225 <span class="preprocessor">DBUG_ASSERT(!table || (!table-&gt;read_set || \</span>
<a name="l00226"></a>00226 <span class="preprocessor">                       bitmap_is_set(table-&gt;read_set, field_index)))</span>
<a name="l00227"></a>00227 <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_COLUMN_MARKED_FOR_WRITE \</span>
<a name="l00228"></a>00228 <span class="preprocessor">DBUG_ASSERT(!table || (!table-&gt;write_set || \</span>
<a name="l00229"></a>00229 <span class="preprocessor">                       bitmap_is_set(table-&gt;write_set, field_index)))</span>
<a name="l00230"></a>00230 <span class="preprocessor"></span>
<a name="l00231"></a>00231 
<a name="l00240"></a>00240 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_temporal_type(enum_field_types <a class="code" href="structst__cache__field.html#ae77e55995e7aa98b23bd4456b0c5abea">type</a>)
<a name="l00241"></a>00241 {
<a name="l00242"></a>00242   <span class="keywordflow">switch</span> (type)
<a name="l00243"></a>00243   {
<a name="l00244"></a>00244   <span class="keywordflow">case</span> MYSQL_TYPE_TIME:
<a name="l00245"></a>00245   <span class="keywordflow">case</span> MYSQL_TYPE_DATETIME:
<a name="l00246"></a>00246   <span class="keywordflow">case</span> MYSQL_TYPE_TIMESTAMP:
<a name="l00247"></a>00247   <span class="keywordflow">case</span> MYSQL_TYPE_DATE:
<a name="l00248"></a>00248   <span class="keywordflow">case</span> MYSQL_TYPE_NEWDATE:
<a name="l00249"></a>00249     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00250"></a>00250   <span class="keywordflow">default</span>:
<a name="l00251"></a>00251     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00252"></a>00252   }
<a name="l00253"></a>00253 }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255 
<a name="l00265"></a>00265 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_temporal_real_type(enum_field_types type)
<a name="l00266"></a>00266 {
<a name="l00267"></a>00267   <span class="keywordflow">switch</span> (type)
<a name="l00268"></a>00268   {
<a name="l00269"></a>00269   <span class="keywordflow">case</span> MYSQL_TYPE_TIME2:
<a name="l00270"></a>00270   <span class="keywordflow">case</span> MYSQL_TYPE_TIMESTAMP2:
<a name="l00271"></a>00271   <span class="keywordflow">case</span> MYSQL_TYPE_DATETIME2:
<a name="l00272"></a>00272     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00273"></a>00273   <span class="keywordflow">default</span>:
<a name="l00274"></a>00274     <span class="keywordflow">return</span> is_temporal_type(type);
<a name="l00275"></a>00275   }
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 
<a name="l00287"></a>00287 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_temporal_type_with_time(enum_field_types type)
<a name="l00288"></a>00288 {
<a name="l00289"></a>00289   <span class="keywordflow">switch</span> (type)
<a name="l00290"></a>00290   {
<a name="l00291"></a>00291   <span class="keywordflow">case</span> MYSQL_TYPE_TIME:
<a name="l00292"></a>00292   <span class="keywordflow">case</span> MYSQL_TYPE_DATETIME:
<a name="l00293"></a>00293   <span class="keywordflow">case</span> MYSQL_TYPE_TIMESTAMP:
<a name="l00294"></a>00294     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00295"></a>00295   <span class="keywordflow">default</span>:
<a name="l00296"></a>00296     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298 }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 
<a name="l00309"></a>00309 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_temporal_type_with_date(enum_field_types type)
<a name="l00310"></a>00310 {
<a name="l00311"></a>00311   <span class="keywordflow">switch</span> (type)
<a name="l00312"></a>00312   {
<a name="l00313"></a>00313   <span class="keywordflow">case</span> MYSQL_TYPE_DATE:
<a name="l00314"></a>00314   <span class="keywordflow">case</span> MYSQL_TYPE_DATETIME:
<a name="l00315"></a>00315   <span class="keywordflow">case</span> MYSQL_TYPE_TIMESTAMP:
<a name="l00316"></a>00316     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00317"></a>00317   <span class="keywordflow">default</span>:
<a name="l00318"></a>00318     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00319"></a>00319   }
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 
<a name="l00322"></a>00322 
<a name="l00331"></a>00331 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_temporal_type_with_date_and_time(enum_field_types type)
<a name="l00332"></a>00332 {
<a name="l00333"></a>00333   <span class="keywordflow">switch</span> (type)
<a name="l00334"></a>00334   {
<a name="l00335"></a>00335   <span class="keywordflow">case</span> MYSQL_TYPE_DATETIME:
<a name="l00336"></a>00336   <span class="keywordflow">case</span> MYSQL_TYPE_TIMESTAMP:
<a name="l00337"></a>00337     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00338"></a>00338   <span class="keywordflow">default</span>:
<a name="l00339"></a>00339     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00340"></a>00340   }
<a name="l00341"></a>00341 }
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 
<a name="l00352"></a>00352 <span class="keyword">inline</span> <span class="keywordtype">bool</span> real_type_with_now_as_default(enum_field_types type)
<a name="l00353"></a>00353 {
<a name="l00354"></a>00354   <span class="keywordflow">return</span> type == MYSQL_TYPE_TIMESTAMP || type == MYSQL_TYPE_TIMESTAMP2 ||
<a name="l00355"></a>00355     type == MYSQL_TYPE_DATETIME || type == MYSQL_TYPE_DATETIME2;
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358 
<a name="l00367"></a>00367 <span class="keyword">inline</span> <span class="keywordtype">bool</span> real_type_with_now_on_update(enum_field_types type)
<a name="l00368"></a>00368 {
<a name="l00369"></a>00369   <span class="keywordflow">return</span> type == MYSQL_TYPE_TIMESTAMP || type == MYSQL_TYPE_TIMESTAMP2 ||
<a name="l00370"></a>00370     type == MYSQL_TYPE_DATETIME || type == MYSQL_TYPE_DATETIME2;
<a name="l00371"></a>00371 }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373 
<a name="l00378"></a>00378 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_timestamp_type(enum_field_types type)
<a name="l00379"></a>00379 {
<a name="l00380"></a>00380   <span class="keywordflow">return</span> type == MYSQL_TYPE_TIMESTAMP || type == MYSQL_TYPE_TIMESTAMP2;
<a name="l00381"></a>00381 }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383 
<a name="l00391"></a>00391 <span class="keyword">inline</span> enum_field_types real_type_to_type(enum_field_types real_type)
<a name="l00392"></a>00392 {
<a name="l00393"></a>00393   <span class="keywordflow">switch</span> (real_type)
<a name="l00394"></a>00394   {
<a name="l00395"></a>00395   <span class="keywordflow">case</span> MYSQL_TYPE_TIME2:
<a name="l00396"></a>00396     <span class="keywordflow">return</span> MYSQL_TYPE_TIME;
<a name="l00397"></a>00397   <span class="keywordflow">case</span> MYSQL_TYPE_DATETIME2:
<a name="l00398"></a>00398     <span class="keywordflow">return</span> MYSQL_TYPE_DATETIME;
<a name="l00399"></a>00399   <span class="keywordflow">case</span> MYSQL_TYPE_TIMESTAMP2:
<a name="l00400"></a>00400     <span class="keywordflow">return</span> MYSQL_TYPE_TIMESTAMP;
<a name="l00401"></a>00401   <span class="keywordflow">case</span> MYSQL_TYPE_NEWDATE:
<a name="l00402"></a>00402     <span class="keywordflow">return</span> MYSQL_TYPE_DATE;
<a name="l00403"></a>00403   <span class="comment">/* Note: NEWDECIMAL is a type, not only a real_type */</span>
<a name="l00404"></a>00404   <span class="keywordflow">default</span>: <span class="keywordflow">return</span> real_type;
<a name="l00405"></a>00405   }
<a name="l00406"></a>00406 }
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 
<a name="l00427"></a>00427 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> Is_big_endian&gt;
<a name="l00428"></a>00428 <span class="keywordtype">void</span> copy_integer(uchar *to, <span class="keywordtype">int</span> to_length,
<a name="l00429"></a>00429                   <span class="keyword">const</span> uchar* from, <span class="keywordtype">int</span> from_length,
<a name="l00430"></a>00430                   <span class="keywordtype">bool</span> is_unsigned)
<a name="l00431"></a>00431 {
<a name="l00432"></a>00432   <span class="keywordflow">if</span> (Is_big_endian)
<a name="l00433"></a>00433   {
<a name="l00434"></a>00434     <span class="keywordflow">if</span> (is_unsigned)
<a name="l00435"></a>00435       to[0]= from[0];
<a name="l00436"></a>00436     <span class="keywordflow">else</span>
<a name="l00437"></a>00437       to[0]= (char)(from[0] ^ 128); <span class="comment">// Reverse the sign bit.</span>
<a name="l00438"></a>00438     memcpy(to + 1, from + 1, to_length - 1);
<a name="l00439"></a>00439   }
<a name="l00440"></a>00440   <span class="keywordflow">else</span>
<a name="l00441"></a>00441   {
<a name="l00442"></a>00442     <span class="keyword">const</span> <span class="keywordtype">int</span> sign_byte= from[from_length - 1];
<a name="l00443"></a>00443     <span class="keywordflow">if</span> (is_unsigned)
<a name="l00444"></a>00444       to[0]= sign_byte;
<a name="l00445"></a>00445     <span class="keywordflow">else</span>
<a name="l00446"></a>00446       to[0]= <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(sign_byte ^ 128); <span class="comment">// Reverse the sign bit.</span>
<a name="l00447"></a>00447     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= 1, j= from_length - 2; i &lt; to_length; ++i, --j)
<a name="l00448"></a>00448       to[i]= from[j];
<a name="l00449"></a>00449   }
<a name="l00450"></a>00450 }
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 
<a name="l00453"></a><a class="code" href="classField.html">00453</a> <span class="keyword">class </span><a class="code" href="classField.html">Field</a>
<a name="l00454"></a>00454 {
<a name="l00455"></a>00455   <a class="code" href="classField.html">Field</a>(<span class="keyword">const</span> <a class="code" href="classItem.html">Item</a> &amp;);                          <span class="comment">/* Prevent use of these */</span>
<a name="l00456"></a>00456   <span class="keywordtype">void</span> operator=(<a class="code" href="classField.html">Field</a> &amp;);
<a name="l00457"></a>00457 <span class="keyword">public</span>:
<a name="l00458"></a>00458 
<a name="l00459"></a>00459   <span class="keywordtype">bool</span> has_insert_default_function()<span class="keyword"> const</span>
<a name="l00460"></a>00460 <span class="keyword">  </span>{
<a name="l00461"></a>00461     <span class="keywordflow">return</span> unireg_check == TIMESTAMP_DN_FIELD ||
<a name="l00462"></a>00462       unireg_check == TIMESTAMP_DNUN_FIELD;
<a name="l00463"></a>00463   }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="keywordtype">bool</span> has_update_default_function()<span class="keyword"> const</span>
<a name="l00466"></a>00466 <span class="keyword">  </span>{
<a name="l00467"></a>00467     <span class="keywordflow">return</span> unireg_check == TIMESTAMP_UN_FIELD ||
<a name="l00468"></a>00468       unireg_check == TIMESTAMP_DNUN_FIELD;
<a name="l00469"></a>00469   }
<a name="l00470"></a>00470 
<a name="l00471"></a>00471   <span class="comment">/* To do: inherit Sql_alloc and get these for free */</span>
<a name="l00472"></a>00472   <span class="keyword">static</span> <span class="keywordtype">void</span> *operator new(<span class="keywordtype">size_t</span> size) <span class="keywordflow">throw</span> ()
<a name="l00473"></a>00473   { <span class="keywordflow">return</span> sql_alloc(size); }
<a name="l00474"></a>00474   <span class="keyword">static</span> <span class="keywordtype">void</span> *operator new(<span class="keywordtype">size_t</span> size, MEM_ROOT *mem_root) <span class="keywordflow">throw</span> () {
<a name="l00475"></a>00475     <span class="keywordflow">return</span> alloc_root(mem_root, size);
<a name="l00476"></a>00476   }
<a name="l00477"></a>00477   <span class="keyword">static</span> <span class="keywordtype">void</span> operator delete(<span class="keywordtype">void</span> *ptr, MEM_ROOT *mem_root)
<a name="l00478"></a>00478   { DBUG_ASSERT(<span class="keyword">false</span>); <span class="comment">/* never called */</span> }
<a name="l00479"></a>00479 
<a name="l00480"></a>00480   <span class="keyword">static</span> <span class="keywordtype">void</span> operator delete(<span class="keywordtype">void</span> *ptr_arg, <span class="keywordtype">size_t</span> size) <span class="keywordflow">throw</span>()
<a name="l00481"></a>00481   { TRASH(ptr_arg, size); }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   uchar         *ptr;                   <span class="comment">// Position to field in record</span>
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="keyword">protected</span>:
<a name="l00490"></a><a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">00490</a>   uchar         *<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="keyword">public</span>:
<a name="l00493"></a>00493   <span class="comment">/*</span>
<a name="l00494"></a>00494 <span class="comment">    Note that you can use table-&gt;in_use as replacement for current_thd member </span>
<a name="l00495"></a>00495 <span class="comment">    only inside of val_*() and store() members (e.g. you can&#39;t use it in cons)</span>
<a name="l00496"></a>00496 <span class="comment">  */</span>
<a name="l00497"></a>00497   <a class="code" href="structTABLE.html">TABLE</a> *table;                                 <span class="comment">// Pointer for table</span>
<a name="l00498"></a>00498   <a class="code" href="structTABLE.html">TABLE</a> *orig_table;                            <span class="comment">// Pointer to original table</span>
<a name="l00499"></a>00499   <span class="keyword">const</span> <span class="keywordtype">char</span>    **table_name, *field_name;
<a name="l00500"></a>00500   LEX_STRING    comment;
<a name="l00501"></a>00501   <span class="comment">/* Field is part of the following keys */</span>
<a name="l00502"></a>00502   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> key_start;                <span class="comment">/* Keys that starts with this field */</span>
<a name="l00503"></a>00503   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> part_of_key;              <span class="comment">/* All keys that includes this field */</span>
<a name="l00504"></a>00504   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> part_of_key_not_clustered;<span class="comment">/* ^ but only for non-clustered keys */</span>
<a name="l00505"></a>00505   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> part_of_sortkey;          <span class="comment">/* ^ but only keys usable for sorting */</span>
<a name="l00506"></a>00506   <span class="comment">/* </span>
<a name="l00507"></a>00507 <span class="comment">    We use three additional unireg types for TIMESTAMP to overcome limitation </span>
<a name="l00508"></a>00508 <span class="comment">    of current binary format of .frm file. We&#39;d like to be able to support </span>
<a name="l00509"></a>00509 <span class="comment">    NOW() as default and on update value for such fields but unable to hold </span>
<a name="l00510"></a>00510 <span class="comment">    this info anywhere except unireg_check field. This issue will be resolved</span>
<a name="l00511"></a>00511 <span class="comment">    in more clean way with transition to new text based .frm format.</span>
<a name="l00512"></a>00512 <span class="comment">    See also comment for Field_timestamp::Field_timestamp().</span>
<a name="l00513"></a>00513 <span class="comment">  */</span>
<a name="l00514"></a>00514   <span class="keyword">enum</span> utype  { NONE,DATE,SHIELD,NOEMPTY,CASEUP,PNR,BGNR,PGNR,YES,NO,REL,
<a name="l00515"></a>00515                 CHECK,EMPTY,UNKNOWN_FIELD,CASEDN,NEXT_NUMBER,INTERVAL_FIELD,
<a name="l00516"></a>00516                 BIT_FIELD, TIMESTAMP_OLD_FIELD, CAPITALIZE, BLOB_FIELD,
<a name="l00517"></a>00517                 TIMESTAMP_DN_FIELD, TIMESTAMP_UN_FIELD, TIMESTAMP_DNUN_FIELD};
<a name="l00518"></a>00518   <span class="keyword">enum</span> geometry_type
<a name="l00519"></a>00519   {
<a name="l00520"></a>00520     GEOM_GEOMETRY = 0, GEOM_POINT = 1, GEOM_LINESTRING = 2, GEOM_POLYGON = 3,
<a name="l00521"></a>00521     GEOM_MULTIPOINT = 4, GEOM_MULTILINESTRING = 5, GEOM_MULTIPOLYGON = 6,
<a name="l00522"></a>00522     GEOM_GEOMETRYCOLLECTION = 7
<a name="l00523"></a>00523   };
<a name="l00524"></a>00524   <span class="keyword">enum</span> imagetype { itRAW, itMBR};
<a name="l00525"></a>00525 
<a name="l00526"></a>00526   utype         unireg_check;
<a name="l00527"></a>00527   uint32        field_length;           <span class="comment">// Length of field</span>
<a name="l00528"></a>00528   uint32        flags;
<a name="l00529"></a>00529   uint16        field_index;            <span class="comment">// field number in fields array</span>
<a name="l00530"></a>00530   uchar         null_bit;               <span class="comment">// Bit used to test null bit</span>
<a name="l00540"></a><a class="code" href="classField.html#ad5afa4cc66ad7f3f58a1fdc4591b93a6">00540</a> <span class="comment"></span>  <span class="keywordtype">bool</span> <a class="code" href="classField.html#ad5afa4cc66ad7f3f58a1fdc4591b93a6">is_created_from_null_item</a>;
<a name="l00541"></a>00541 
<a name="l00542"></a>00542   <a class="code" href="classField.html">Field</a>(uchar *ptr_arg,uint32 length_arg,uchar *null_ptr_arg,
<a name="l00543"></a>00543         uchar null_bit_arg, utype unireg_check_arg,
<a name="l00544"></a>00544         <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg);
<a name="l00545"></a>00545   <span class="keyword">virtual</span> ~<a class="code" href="classField.html">Field</a>() {}
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <span class="comment">/* Store functions returns 1 on overflow and -1 on fatal error */</span>
<a name="l00548"></a>00548   <span class="keyword">virtual</span> type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l00549"></a>00549                                        <span class="keyword">const</span> CHARSET_INFO *cs)=0;
<a name="l00550"></a>00550   <span class="keyword">virtual</span> type_conversion_status store(<span class="keywordtype">double</span> nr)=0;
<a name="l00551"></a>00551   <span class="keyword">virtual</span> type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val)=0;
<a name="l00563"></a><a class="code" href="classField.html#a5c09752e8441d64ce2e4e611508bab7a">00563</a>   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField.html#a5c09752e8441d64ce2e4e611508bab7a">store_packed</a>(longlong nr)
<a name="l00564"></a>00564   {
<a name="l00565"></a>00565     <span class="keywordflow">return</span> store(nr, 0);
<a name="l00566"></a>00566   }
<a name="l00567"></a>00567   <span class="keyword">virtual</span> type_conversion_status store_decimal(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *d)=0;
<a name="l00583"></a>00583   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField.html#a7433aa07355def6c394687567256e6cf">store_time</a>(MYSQL_TIME *ltime, uint8 dec);
<a name="l00592"></a><a class="code" href="classField.html#a2c0631841b33f2912380400afe77daa8">00592</a>   type_conversion_status <a class="code" href="classField.html#a7433aa07355def6c394687567256e6cf">store_time</a>(MYSQL_TIME *ltime)
<a name="l00593"></a>00593   {
<a name="l00594"></a>00594     <span class="keywordflow">return</span> <a class="code" href="classField.html#a7433aa07355def6c394687567256e6cf">store_time</a>(ltime, 0);
<a name="l00595"></a>00595   }
<a name="l00596"></a>00596   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l00597"></a>00597                                <span class="keyword">const</span> CHARSET_INFO *cs,
<a name="l00598"></a>00598                                enum_check_fields check_level);
<a name="l00599"></a>00599   <span class="keyword">virtual</span> <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>)=0;
<a name="l00600"></a>00600   <span class="keyword">virtual</span> longlong val_int(<span class="keywordtype">void</span>)=0;
<a name="l00606"></a><a class="code" href="classField.html#a504ae8be08face4684852eaa79734158">00606</a>   <span class="keyword">virtual</span> longlong <a class="code" href="classField.html#a504ae8be08face4684852eaa79734158">val_time_temporal</a>()
<a name="l00607"></a>00607   {
<a name="l00608"></a>00608     DBUG_ASSERT(0);
<a name="l00609"></a>00609     <span class="keywordflow">return</span> 0;
<a name="l00610"></a>00610   }
<a name="l00616"></a><a class="code" href="classField.html#a85b7713df40509aaa467a75eb3945614">00616</a>   <span class="keyword">virtual</span> longlong <a class="code" href="classField.html#a85b7713df40509aaa467a75eb3945614">val_date_temporal</a>()
<a name="l00617"></a>00617   {
<a name="l00618"></a>00618     DBUG_ASSERT(0);
<a name="l00619"></a>00619     <span class="keywordflow">return</span> 0;
<a name="l00620"></a>00620   }
<a name="l00625"></a><a class="code" href="classField.html#a8317ba4d14c4ca783bfd657fc64070a3">00625</a>   longlong <a class="code" href="classField.html#a8317ba4d14c4ca783bfd657fc64070a3">val_temporal_by_field_type</a>()
<a name="l00626"></a>00626   {
<a name="l00627"></a>00627     <span class="comment">// Return longlong TIME or DATETIME representation, depending on field type</span>
<a name="l00628"></a>00628     <span class="keywordflow">if</span> (type() == MYSQL_TYPE_TIME)
<a name="l00629"></a>00629       <span class="keywordflow">return</span> <a class="code" href="classField.html#a504ae8be08face4684852eaa79734158">val_time_temporal</a>();
<a name="l00630"></a>00630     DBUG_ASSERT(is_temporal_with_date());
<a name="l00631"></a>00631     <span class="keywordflow">return</span> <a class="code" href="classField.html#a85b7713df40509aaa467a75eb3945614">val_date_temporal</a>();
<a name="l00632"></a>00632   }
<a name="l00633"></a>00633   <span class="keyword">virtual</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *)= 0;
<a name="l00634"></a>00634   <span class="keyword">inline</span> <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str) { <span class="keywordflow">return</span> val_str(str, str); }
<a name="l00635"></a>00635   <span class="comment">/*</span>
<a name="l00636"></a>00636 <span class="comment">     val_str(buf1, buf2) gets two buffers and should use them as follows:</span>
<a name="l00637"></a>00637 <span class="comment">     if it needs a temp buffer to convert result to string - use buf1</span>
<a name="l00638"></a>00638 <span class="comment">       example Field_tiny::val_str()</span>
<a name="l00639"></a>00639 <span class="comment">     if the value exists as a string already - use buf2</span>
<a name="l00640"></a>00640 <span class="comment">       example Field_string::val_str()</span>
<a name="l00641"></a>00641 <span class="comment">     consequently, buf2 may be created as &#39;String buf;&#39; - no memory</span>
<a name="l00642"></a>00642 <span class="comment">     will be allocated for it. buf1 will be allocated to hold a</span>
<a name="l00643"></a>00643 <span class="comment">     value if it&#39;s too small. Using allocated buffer for buf2 may result in</span>
<a name="l00644"></a>00644 <span class="comment">     an unnecessary free (and later, may be an alloc).</span>
<a name="l00645"></a>00645 <span class="comment">     This trickery is used to decrease a number of malloc calls.</span>
<a name="l00646"></a>00646 <span class="comment">  */</span>
<a name="l00647"></a>00647   <span class="keyword">virtual</span> <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *)=0;
<a name="l00648"></a>00648   <a class="code" href="classString.html">String</a> *<a class="code" href="classField.html#a180aa83c030df25313f083557b05c15b">val_int_as_str</a>(<a class="code" href="classString.html">String</a> *val_buffer, my_bool unsigned_flag);
<a name="l00649"></a>00649   <span class="comment">/*</span>
<a name="l00650"></a>00650 <span class="comment">   str_needs_quotes() returns TRUE if the value returned by val_str() needs</span>
<a name="l00651"></a>00651 <span class="comment">   to be quoted when used in constructing an SQL query.</span>
<a name="l00652"></a>00652 <span class="comment">  */</span>
<a name="l00653"></a>00653   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> str_needs_quotes() { <span class="keywordflow">return</span> FALSE; }
<a name="l00654"></a>00654   <span class="keyword">virtual</span> Item_result result_type () <span class="keyword">const</span>=0;
<a name="l00665"></a><a class="code" href="classField.html#a5cdc7da6647d844d5d881a8fdc512c39">00665</a>   <span class="keyword">virtual</span> Item_result <a class="code" href="classField.html#a5cdc7da6647d844d5d881a8fdc512c39">numeric_context_result_type</a>()<span class="keyword"> const</span>
<a name="l00666"></a>00666 <span class="keyword">  </span>{
<a name="l00667"></a>00667     <span class="keywordflow">return</span> result_type();
<a name="l00668"></a>00668   }
<a name="l00669"></a>00669   <span class="keyword">virtual</span> Item_result cmp_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> result_type(); }
<a name="l00670"></a>00670   <span class="keyword">virtual</span> Item_result cast_to_int_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> result_type(); }
<a name="l00671"></a>00671   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classField.html#a9119fec4aa570a98879146f00b48c90d">type_can_have_key_part</a>(enum_field_types);
<a name="l00672"></a>00672   <span class="keyword">static</span> enum_field_types <a class="code" href="classField.html#ab20100743e6462945e5c0a5130a9ab9d">field_type_merge</a>(enum_field_types, enum_field_types);
<a name="l00673"></a>00673   <span class="keyword">static</span> Item_result <a class="code" href="classField.html#a44fab88208586b91e5b201c2c6fff52e">result_merge_type</a>(enum_field_types);
<a name="l00674"></a>00674   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> eq(<a class="code" href="classField.html">Field</a> *field)
<a name="l00675"></a>00675   {
<a name="l00676"></a>00676     <span class="keywordflow">return</span> (ptr == field-&gt;ptr &amp;&amp; <a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a> == field-&gt;<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a> &amp;&amp;
<a name="l00677"></a>00677             null_bit == field-&gt;null_bit &amp;&amp; field-&gt;type() == type());
<a name="l00678"></a>00678   }
<a name="l00679"></a>00679   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classField.html#a7c9a51f0cc4e8c580838eed3a4f8e846">eq_def</a>(<a class="code" href="classField.html">Field</a> *field);
<a name="l00680"></a>00680   
<a name="l00681"></a>00681   <span class="comment">/*</span>
<a name="l00682"></a>00682 <span class="comment">    pack_length() returns size (in bytes) used to store field data in memory</span>
<a name="l00683"></a>00683 <span class="comment">    (i.e. it returns the maximum size of the field in a row of the table,</span>
<a name="l00684"></a>00684 <span class="comment">    which is located in RAM).</span>
<a name="l00685"></a>00685 <span class="comment">  */</span>
<a name="l00686"></a>00686   <span class="keyword">virtual</span> uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint32) field_length; }
<a name="l00687"></a>00687 
<a name="l00688"></a>00688   <span class="comment">/*</span>
<a name="l00689"></a>00689 <span class="comment">    pack_length_in_rec() returns size (in bytes) used to store field data on</span>
<a name="l00690"></a>00690 <span class="comment">    storage (i.e. it returns the maximal size of the field in a row of the</span>
<a name="l00691"></a>00691 <span class="comment">    table, which is located on disk).</span>
<a name="l00692"></a>00692 <span class="comment">  */</span>
<a name="l00693"></a>00693   <span class="keyword">virtual</span> uint32 pack_length_in_rec()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l00694"></a>00694   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classField.html#ab603b7f21a9116358e400dd7282cee50">compatible_field_size</a>(uint metadata, <a class="code" href="classRelay__log__info.html">Relay_log_info</a> *rli,
<a name="l00695"></a>00695                                      uint16 mflags, <span class="keywordtype">int</span> *order);
<a name="l00696"></a>00696   <span class="keyword">virtual</span> uint pack_length_from_metadata(uint field_metadata)
<a name="l00697"></a>00697   {
<a name="l00698"></a>00698     DBUG_ENTER(<span class="stringliteral">&quot;Field::pack_length_from_metadata&quot;</span>);
<a name="l00699"></a>00699     DBUG_RETURN(field_metadata);
<a name="l00700"></a>00700   }
<a name="l00701"></a>00701   <span class="keyword">virtual</span> uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00702"></a>00702   <span class="keyword">virtual</span> <span class="keywordtype">int</span> save_field_metadata(uchar *first_byte)
<a name="l00703"></a>00703   { <span class="keywordflow">return</span> do_save_field_metadata(first_byte); }
<a name="l00704"></a>00704 
<a name="l00705"></a>00705   <span class="comment">/*</span>
<a name="l00706"></a>00706 <span class="comment">    data_length() return the &quot;real size&quot; of the data in memory.</span>
<a name="l00707"></a>00707 <span class="comment">  */</span>
<a name="l00708"></a>00708   <span class="keyword">virtual</span> uint32 data_length() { <span class="keywordflow">return</span> pack_length(); }
<a name="l00709"></a>00709   <span class="keyword">virtual</span> uint32 sort_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l00710"></a>00710 
<a name="l00717"></a><a class="code" href="classField.html#a3d7c550819b5eb809ce8999671e58635">00717</a>   <span class="keyword">virtual</span> uint32 <a class="code" href="classField.html#a3d7c550819b5eb809ce8999671e58635">max_data_length</a>()<span class="keyword"> const </span>{
<a name="l00718"></a>00718     <span class="keywordflow">return</span> pack_length();
<a name="l00719"></a>00719   };
<a name="l00720"></a>00720 
<a name="l00721"></a>00721   <span class="keyword">virtual</span> type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l00722"></a>00722   {
<a name="l00723"></a>00723     memset(ptr, 0, pack_length());
<a name="l00724"></a>00724     <span class="keywordflow">return</span> TYPE_OK;
<a name="l00725"></a>00725   }
<a name="l00726"></a>00726   <span class="keyword">virtual</span> <span class="keywordtype">void</span> reset_fields() {}
<a name="l00732"></a>00732   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classField.html#ac6b92691afad064d5f80b762a39c0e7f">get_timestamp</a>(<span class="keyword">struct</span> timeval *tm, <span class="keywordtype">int</span> *warnings);
<a name="l00764"></a><a class="code" href="classField.html#aac6a006a51d128f9cf462b6ce1542def">00764</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classField.html#aac6a006a51d128f9cf462b6ce1542def">store_timestamp</a>(<span class="keyword">const</span> timeval *tm) { DBUG_ASSERT(<span class="keyword">false</span>); }
<a name="l00765"></a>00765 
<a name="l00772"></a><a class="code" href="classField.html#a34ceda8f27d73b5a547221598ba64db4">00772</a>   <span class="keywordtype">void</span> <a class="code" href="classField.html#aac6a006a51d128f9cf462b6ce1542def">store_timestamp</a>(my_time_t sec)
<a name="l00773"></a>00773   {
<a name="l00774"></a>00774     <span class="keyword">struct </span>timeval tm;
<a name="l00775"></a>00775     tm.tv_sec= sec;
<a name="l00776"></a>00776     tm.tv_usec= 0;
<a name="l00777"></a>00777     <a class="code" href="classField.html#aac6a006a51d128f9cf462b6ce1542def">store_timestamp</a>(&amp;tm);
<a name="l00778"></a>00778   }
<a name="l00779"></a>00779   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_default()
<a name="l00780"></a>00780   {
<a name="l00781"></a>00781     <span class="keywordflow">if</span> (has_insert_default_function())
<a name="l00782"></a>00782     {
<a name="l00783"></a>00783       <a class="code" href="classField.html#ad48db7aee495c54b9ea9976186bebf07">evaluate_insert_default_function</a>();
<a name="l00784"></a>00784       <span class="keywordflow">return</span>;
<a name="l00785"></a>00785     }
<a name="l00786"></a>00786 
<a name="l00787"></a>00787     my_ptrdiff_t l_offset= (my_ptrdiff_t) (table-&gt;s-&gt;default_values -
<a name="l00788"></a>00788                                           table-&gt;record[0]);
<a name="l00789"></a>00789     memcpy(ptr, ptr + l_offset, pack_length());
<a name="l00790"></a>00790     <span class="keywordflow">if</span> (<a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">real_maybe_null</a>())
<a name="l00791"></a>00791       *<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>= ((*<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a> &amp; (uchar) ~null_bit) |
<a name="l00792"></a>00792                   (<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>[l_offset] &amp; null_bit));
<a name="l00793"></a>00793   }
<a name="l00794"></a>00794 
<a name="l00795"></a>00795 
<a name="l00801"></a>00801   <span class="keywordtype">void</span> <a class="code" href="classField.html#ad48db7aee495c54b9ea9976186bebf07">evaluate_insert_default_function</a>();
<a name="l00802"></a>00802 
<a name="l00803"></a>00803 
<a name="l00810"></a>00810   <span class="keywordtype">void</span> <a class="code" href="classField.html#a7173d4f8198eab3214a638fd586c1ef8">evaluate_update_default_function</a>();
<a name="l00811"></a>00811   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> binary()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l00812"></a>00812   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l00813"></a>00813   <span class="keyword">virtual</span> <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_BINARY; }
<a name="l00814"></a>00814   <span class="keyword">virtual</span> uint32 key_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l00815"></a>00815   <span class="keyword">virtual</span> enum_field_types type() <span class="keyword">const</span> =0;
<a name="l00816"></a>00816   <span class="keyword">virtual</span> enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> type(); }
<a name="l00817"></a>00817   <span class="keyword">virtual</span> enum_field_types binlog_type()<span class="keyword"> const</span>
<a name="l00818"></a>00818 <span class="keyword">  </span>{
<a name="l00819"></a>00819     <span class="comment">/*</span>
<a name="l00820"></a>00820 <span class="comment">      Binlog stores field-&gt;type() as type code by default.</span>
<a name="l00821"></a>00821 <span class="comment">      This puts MYSQL_TYPE_STRING in case of CHAR, VARCHAR, SET and ENUM,</span>
<a name="l00822"></a>00822 <span class="comment">      with extra data type details put into metadata.</span>
<a name="l00823"></a>00823 <span class="comment"></span>
<a name="l00824"></a>00824 <span class="comment">      We cannot store field-&gt;type() in case of temporal types with</span>
<a name="l00825"></a>00825 <span class="comment">      fractional seconds: TIME(n), DATETIME(n) and TIMESTAMP(n),</span>
<a name="l00826"></a>00826 <span class="comment">      because binlog records with MYSQL_TYPE_TIME, MYSQL_TYPE_DATETIME</span>
<a name="l00827"></a>00827 <span class="comment">      type codes do not have metadata.</span>
<a name="l00828"></a>00828 <span class="comment">      So for temporal data types with fractional seconds we&#39;ll store</span>
<a name="l00829"></a>00829 <span class="comment">      real_type() type codes instead, i.e.</span>
<a name="l00830"></a>00830 <span class="comment">      MYSQL_TYPE_TIME2, MYSQL_TYPE_DATETIME2, MYSQL_TYPE_TIMESTAMP2,</span>
<a name="l00831"></a>00831 <span class="comment">      and put precision into metatada.</span>
<a name="l00832"></a>00832 <span class="comment"></span>
<a name="l00833"></a>00833 <span class="comment">      Note: perhaps binlog should eventually be modified to store</span>
<a name="l00834"></a>00834 <span class="comment">      real_type() instead of type() for all column types.</span>
<a name="l00835"></a>00835 <span class="comment">    */</span>
<a name="l00836"></a>00836     <span class="keywordflow">return</span> type();
<a name="l00837"></a>00837   }
<a name="l00838"></a>00838   <span class="keyword">inline</span>  <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *str) { <span class="keywordflow">return</span> cmp(ptr,str); }
<a name="l00839"></a>00839   <span class="keyword">virtual</span> <span class="keywordtype">int</span> cmp_max(<span class="keyword">const</span> uchar *a, <span class="keyword">const</span> uchar *b, uint max_len)
<a name="l00840"></a>00840     { <span class="keywordflow">return</span> cmp(a, b); }
<a name="l00841"></a>00841   <span class="keyword">virtual</span> <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *)=0;
<a name="l00842"></a>00842   <span class="keyword">virtual</span> <span class="keywordtype">int</span> cmp_binary(<span class="keyword">const</span> uchar *a,<span class="keyword">const</span> uchar *b, uint32 max_length=~0L)
<a name="l00843"></a>00843   { <span class="keywordflow">return</span> memcmp(a,b,pack_length()); }
<a name="l00844"></a>00844   <span class="keyword">virtual</span> <span class="keywordtype">int</span> cmp_offset(uint row_offset)
<a name="l00845"></a>00845   { <span class="keywordflow">return</span> cmp(ptr,ptr+row_offset); }
<a name="l00846"></a>00846   <span class="keyword">virtual</span> <span class="keywordtype">int</span> cmp_binary_offset(uint row_offset)
<a name="l00847"></a>00847   { <span class="keywordflow">return</span> cmp_binary(ptr, ptr+row_offset); };
<a name="l00848"></a>00848   <span class="keyword">virtual</span> <span class="keywordtype">int</span> key_cmp(<span class="keyword">const</span> uchar *a,<span class="keyword">const</span> uchar *b)
<a name="l00849"></a>00849   { <span class="keywordflow">return</span> cmp(a, b); }
<a name="l00850"></a>00850   <span class="keyword">virtual</span> <span class="keywordtype">int</span> key_cmp(<span class="keyword">const</span> uchar *str, uint length)
<a name="l00851"></a>00851   { <span class="keywordflow">return</span> cmp(ptr,str); }
<a name="l00852"></a>00852   <span class="keyword">virtual</span> uint decimals()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00853"></a>00853   <span class="comment">/*</span>
<a name="l00854"></a>00854 <span class="comment">    Caller beware: sql_type can change str.Ptr, so check</span>
<a name="l00855"></a>00855 <span class="comment">    ptr() to see if it changed if you are using your own buffer</span>
<a name="l00856"></a>00856 <span class="comment">    in str and restore it with set() if needed</span>
<a name="l00857"></a>00857 <span class="comment">  */</span>
<a name="l00858"></a>00858   <span class="keyword">virtual</span> <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span> =0;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860   <span class="keywordtype">bool</span> is_temporal()<span class="keyword"> const</span>
<a name="l00861"></a>00861 <span class="keyword">  </span>{ <span class="keywordflow">return</span> is_temporal_type(type()); }
<a name="l00862"></a>00862 
<a name="l00863"></a>00863   <span class="keywordtype">bool</span> is_temporal_with_date()<span class="keyword"> const</span>
<a name="l00864"></a>00864 <span class="keyword">  </span>{ <span class="keywordflow">return</span> is_temporal_type_with_date(type()); }
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   <span class="keywordtype">bool</span> is_temporal_with_time()<span class="keyword"> const</span>
<a name="l00867"></a>00867 <span class="keyword">  </span>{ <span class="keywordflow">return</span> is_temporal_type_with_time(type()); }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   <span class="keywordtype">bool</span> is_temporal_with_date_and_time()<span class="keyword"> const</span>
<a name="l00870"></a>00870 <span class="keyword">  </span>{ <span class="keywordflow">return</span> is_temporal_type_with_date_and_time(type()); }
<a name="l00871"></a>00871 
<a name="l00872"></a>00872   <span class="keywordtype">bool</span> is_null(my_ptrdiff_t row_offset= 0)<span class="keyword"> const</span>
<a name="l00873"></a>00873 <span class="keyword">  </span>{
<a name="l00874"></a>00874     <span class="comment">/*</span>
<a name="l00875"></a>00875 <span class="comment">      if the field is NULLable, it returns NULLity based</span>
<a name="l00876"></a>00876 <span class="comment">      on null_ptr[row_offset] value. Otherwise it returns</span>
<a name="l00877"></a>00877 <span class="comment">      NULL flag depending on TABLE::null_row value.</span>
<a name="l00878"></a>00878 <span class="comment"></span>
<a name="l00879"></a>00879 <span class="comment">      The table may have been marked as containing only NULL values</span>
<a name="l00880"></a>00880 <span class="comment">      for all fields if it is a NULL-complemented row of an OUTER JOIN</span>
<a name="l00881"></a>00881 <span class="comment">      or if the query is an implicitly grouped query (has aggregate</span>
<a name="l00882"></a>00882 <span class="comment">      functions but no GROUP BY clause) with no qualifying rows. If</span>
<a name="l00883"></a>00883 <span class="comment">      this is the case (in which TABLE::null_row is true) and the</span>
<a name="l00884"></a>00884 <span class="comment">      field is not nullable, the field is considered to be NULL.</span>
<a name="l00885"></a>00885 <span class="comment"></span>
<a name="l00886"></a>00886 <span class="comment">      Do not change the order of testing. Fields may be associated</span>
<a name="l00887"></a>00887 <span class="comment">      with a TABLE object without being part of the current row.</span>
<a name="l00888"></a>00888 <span class="comment">      For NULL value check to work for these fields, they must</span>
<a name="l00889"></a>00889 <span class="comment">      have a valid null_ptr, and this pointer must be checked before</span>
<a name="l00890"></a>00890 <span class="comment">      TABLE::null_row. </span>
<a name="l00891"></a>00891 <span class="comment"></span>
<a name="l00892"></a>00892 <span class="comment">    */</span>
<a name="l00893"></a>00893     <span class="keywordflow">return</span> <a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">real_maybe_null</a>() ?
<a name="l00894"></a>00894       MY_TEST(<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>[row_offset] &amp; null_bit) : table-&gt;null_row;
<a name="l00895"></a>00895   }
<a name="l00896"></a>00896 
<a name="l00897"></a>00897   <span class="keywordtype">bool</span> is_real_null(my_ptrdiff_t row_offset= 0)<span class="keyword"> const</span>
<a name="l00898"></a>00898 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">real_maybe_null</a>() ? MY_TEST(<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>[row_offset] &amp; null_bit) : false; }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900   <span class="keywordtype">bool</span> is_null_in_record(<span class="keyword">const</span> uchar *record)<span class="keyword"> const</span>
<a name="l00901"></a>00901 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">real_maybe_null</a>() ? MY_TEST(record[null_offset()] &amp; null_bit) : false; }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903   <span class="keywordtype">void</span> set_null(my_ptrdiff_t row_offset= 0)
<a name="l00904"></a>00904   {
<a name="l00905"></a>00905     <span class="keywordflow">if</span> (<a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">real_maybe_null</a>())
<a name="l00906"></a>00906       <a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>[row_offset]|= null_bit;
<a name="l00907"></a>00907   }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909   <span class="keywordtype">void</span> set_notnull(my_ptrdiff_t row_offset= 0)
<a name="l00910"></a>00910   {
<a name="l00911"></a>00911     <span class="keywordflow">if</span> (<a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">real_maybe_null</a>())
<a name="l00912"></a>00912       <a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>[row_offset]&amp;= (uchar) ~null_bit;
<a name="l00913"></a>00913   }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915   <span class="keywordtype">bool</span> maybe_null(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00916"></a>00916 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">real_maybe_null</a>() || table-&gt;maybe_null; }
<a name="l00917"></a>00917 
<a name="l00919"></a><a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">00919</a>   <span class="keywordtype">bool</span> <a class="code" href="classField.html#ad62aa5df4612558fa9b2705a154677f6">real_maybe_null</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l00920"></a>00920 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a> != 0; }
<a name="l00921"></a>00921 
<a name="l00922"></a>00922   uint null_offset(<span class="keyword">const</span> uchar *record)<span class="keyword"> const</span>
<a name="l00923"></a>00923 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (uint) (<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a> - record); }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   uint null_offset()<span class="keyword"> const</span>
<a name="l00926"></a>00926 <span class="keyword">  </span>{ <span class="keywordflow">return</span> null_offset(table-&gt;record[0]); }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928   <span class="keywordtype">void</span> set_null_ptr(uchar *p_null_ptr, uint p_null_bit)
<a name="l00929"></a>00929   {
<a name="l00930"></a>00930     <a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>= p_null_ptr;
<a name="l00931"></a>00931     null_bit= p_null_bit;
<a name="l00932"></a>00932   }
<a name="l00933"></a>00933 
<a name="l00934"></a>00934   <span class="keyword">enum</span> {
<a name="l00935"></a>00935     LAST_NULL_BYTE_UNDEF= 0
<a name="l00936"></a>00936   };
<a name="l00937"></a>00937 
<a name="l00938"></a>00938   <span class="comment">/*</span>
<a name="l00939"></a>00939 <span class="comment">    Find the position of the last null byte for the field.</span>
<a name="l00940"></a>00940 <span class="comment"></span>
<a name="l00941"></a>00941 <span class="comment">    SYNOPSIS</span>
<a name="l00942"></a>00942 <span class="comment">      last_null_byte()</span>
<a name="l00943"></a>00943 <span class="comment"></span>
<a name="l00944"></a>00944 <span class="comment">    DESCRIPTION</span>
<a name="l00945"></a>00945 <span class="comment">      Return a pointer to the last byte of the null bytes where the</span>
<a name="l00946"></a>00946 <span class="comment">      field conceptually is placed.</span>
<a name="l00947"></a>00947 <span class="comment"></span>
<a name="l00948"></a>00948 <span class="comment">    RETURN VALUE</span>
<a name="l00949"></a>00949 <span class="comment">      The position of the last null byte relative to the beginning of</span>
<a name="l00950"></a>00950 <span class="comment">      the record. If the field does not use any bits of the null</span>
<a name="l00951"></a>00951 <span class="comment">      bytes, the value 0 (LAST_NULL_BYTE_UNDEF) is returned.</span>
<a name="l00952"></a>00952 <span class="comment">   */</span>
<a name="l00953"></a>00953   <span class="keywordtype">size_t</span> last_null_byte()<span class="keyword"> const </span>{
<a name="l00954"></a>00954     <span class="keywordtype">size_t</span> bytes= do_last_null_byte();
<a name="l00955"></a>00955     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;last_null_byte() ==&gt; %ld&quot;</span>, (<span class="keywordtype">long</span>) bytes));
<a name="l00956"></a>00956     DBUG_ASSERT(bytes &lt;= table-&gt;s-&gt;null_bytes);
<a name="l00957"></a>00957     <span class="keywordflow">return</span> bytes;
<a name="l00958"></a>00958   }
<a name="l00959"></a>00959 
<a name="l00960"></a>00960   <span class="keyword">virtual</span> <span class="keywordtype">void</span> make_field(<a class="code" href="classSend__field.html">Send_field</a> *);
<a name="l00961"></a>00961 
<a name="l00972"></a>00972   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classField.html#a8ae56503783e7a91c0e4899527bc6cb5">make_sort_key</a>(uchar *buff, uint length) = 0;
<a name="l00973"></a>00973   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> optimize_range(uint idx, uint part);
<a name="l00974"></a>00974   <span class="comment">/*</span>
<a name="l00975"></a>00975 <span class="comment">    This should be true for fields which, when compared with constant</span>
<a name="l00976"></a>00976 <span class="comment">    items, can be casted to longlong. In this case we will at &#39;fix_fields&#39;</span>
<a name="l00977"></a>00977 <span class="comment">    stage cast the constant items to longlongs and at the execution stage</span>
<a name="l00978"></a>00978 <span class="comment">    use field-&gt;val_int() for comparison.  Used to optimize clauses like</span>
<a name="l00979"></a>00979 <span class="comment">    &#39;a_column BETWEEN date_const, date_const&#39;.</span>
<a name="l00980"></a>00980 <span class="comment">  */</span>
<a name="l00981"></a>00981   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> can_be_compared_as_longlong()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l00982"></a>00982   <span class="keyword">virtual</span> <span class="keywordtype">void</span> free() {}
<a name="l00983"></a>00983   <span class="keyword">virtual</span> <a class="code" href="classField.html">Field</a> *new_field(MEM_ROOT *root, <a class="code" href="structTABLE.html">TABLE</a> *new_table,
<a name="l00984"></a>00984                            <span class="keywordtype">bool</span> keep_type);
<a name="l00985"></a>00985   <span class="keyword">virtual</span> <a class="code" href="classField.html">Field</a> *new_key_field(MEM_ROOT *root, <a class="code" href="structTABLE.html">TABLE</a> *new_table,
<a name="l00986"></a>00986                                uchar *new_ptr, uchar *new_null_ptr,
<a name="l00987"></a>00987                                uint new_null_bit);
<a name="l00988"></a>00988 
<a name="l00989"></a>00989   <a class="code" href="classField.html">Field</a> *new_key_field(MEM_ROOT *root, <a class="code" href="structTABLE.html">TABLE</a> *new_table, uchar *new_ptr)
<a name="l00990"></a>00990   { <span class="keywordflow">return</span> new_key_field(root, new_table, new_ptr, <a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>, null_bit); }
<a name="l00991"></a>00991 
<a name="l01001"></a>01001   <span class="keyword">virtual</span> <a class="code" href="classField.html">Field</a> *<a class="code" href="classField.html#a01a9a9aa3a618941e839b1b8793c969d">clone</a>() <span class="keyword">const</span> =0;
<a name="l01002"></a>01002 
<a name="l01013"></a>01013   <span class="keyword">virtual</span> <a class="code" href="classField.html">Field</a> *<a class="code" href="classField.html#a01a9a9aa3a618941e839b1b8793c969d">clone</a>(MEM_ROOT *mem_root) <span class="keyword">const</span> =0;
<a name="l01014"></a>01014   <span class="keyword">inline</span> <span class="keywordtype">void</span> move_field(uchar *ptr_arg,uchar *null_ptr_arg,uchar null_bit_arg)
<a name="l01015"></a>01015   {
<a name="l01016"></a>01016     ptr=ptr_arg; <a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>=null_ptr_arg; null_bit=null_bit_arg;
<a name="l01017"></a>01017   }
<a name="l01018"></a>01018   <span class="keyword">inline</span> <span class="keywordtype">void</span> move_field(uchar *ptr_arg) { ptr=ptr_arg; }
<a name="l01019"></a>01019   <span class="keyword">virtual</span> <span class="keywordtype">void</span> move_field_offset(my_ptrdiff_t ptr_diff)
<a name="l01020"></a>01020   {
<a name="l01021"></a>01021     ptr=ADD_TO_PTR(ptr,ptr_diff, uchar*);
<a name="l01022"></a>01022     <span class="keywordflow">if</span> (<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>)
<a name="l01023"></a>01023       <a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>=ADD_TO_PTR(<a class="code" href="classField.html#ac9dda136278a1b71ae184e92aa6e3141">null_ptr</a>,ptr_diff,uchar*);
<a name="l01024"></a>01024   }
<a name="l01025"></a>01025   <span class="keyword">virtual</span> <span class="keywordtype">void</span> get_image(uchar *buff, uint length, <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l01026"></a>01026     { memcpy(buff,ptr,length); }
<a name="l01027"></a>01027   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_image(<span class="keyword">const</span> uchar *buff,uint length,
<a name="l01028"></a>01028                          <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l01029"></a>01029     { memcpy(ptr,buff,length); }
<a name="l01030"></a>01030 
<a name="l01031"></a>01031 
<a name="l01032"></a>01032   <span class="comment">/*</span>
<a name="l01033"></a>01033 <span class="comment">    Copy a field part into an output buffer.</span>
<a name="l01034"></a>01034 <span class="comment"></span>
<a name="l01035"></a>01035 <span class="comment">    SYNOPSIS</span>
<a name="l01036"></a>01036 <span class="comment">      Field::get_key_image()</span>
<a name="l01037"></a>01037 <span class="comment">      buff   [out] output buffer</span>
<a name="l01038"></a>01038 <span class="comment">      length       output buffer size</span>
<a name="l01039"></a>01039 <span class="comment">      type         itMBR for geometry blobs, otherwise itRAW</span>
<a name="l01040"></a>01040 <span class="comment"></span>
<a name="l01041"></a>01041 <span class="comment">    DESCRIPTION</span>
<a name="l01042"></a>01042 <span class="comment">      This function makes a copy of field part of size equal to or</span>
<a name="l01043"></a>01043 <span class="comment">      less than &quot;length&quot; parameter value.</span>
<a name="l01044"></a>01044 <span class="comment">      For fields of string types (CHAR, VARCHAR, TEXT) the rest of buffer</span>
<a name="l01045"></a>01045 <span class="comment">      is padded by zero byte.</span>
<a name="l01046"></a>01046 <span class="comment"></span>
<a name="l01047"></a>01047 <span class="comment">    NOTES</span>
<a name="l01048"></a>01048 <span class="comment">      For variable length character fields (i.e. UTF-8) the &quot;length&quot;</span>
<a name="l01049"></a>01049 <span class="comment">      parameter means a number of output buffer bytes as if all field</span>
<a name="l01050"></a>01050 <span class="comment">      characters have maximal possible size (mbmaxlen). In the other words,</span>
<a name="l01051"></a>01051 <span class="comment">      &quot;length&quot; parameter is a number of characters multiplied by</span>
<a name="l01052"></a>01052 <span class="comment">      field_charset-&gt;mbmaxlen.</span>
<a name="l01053"></a>01053 <span class="comment"></span>
<a name="l01054"></a>01054 <span class="comment">    RETURN</span>
<a name="l01055"></a>01055 <span class="comment">      Number of copied bytes (excluding padded zero bytes -- see above).</span>
<a name="l01056"></a>01056 <span class="comment">  */</span>
<a name="l01057"></a>01057 
<a name="l01058"></a>01058   <span class="keyword">virtual</span> uint get_key_image(uchar *buff, uint length, imagetype type)
<a name="l01059"></a>01059   {
<a name="l01060"></a>01060     get_image(buff, length, &amp;my_charset_bin);
<a name="l01061"></a>01061     <span class="keywordflow">return</span> length;
<a name="l01062"></a>01062   }
<a name="l01063"></a>01063   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_key_image(<span class="keyword">const</span> uchar *buff,uint length)
<a name="l01064"></a>01064     { set_image(buff,length, &amp;my_charset_bin); }
<a name="l01065"></a>01065   <span class="keyword">inline</span> longlong val_int_offset(uint row_offset)
<a name="l01066"></a>01066     {
<a name="l01067"></a>01067       ptr+=row_offset;
<a name="l01068"></a>01068       longlong tmp=val_int();
<a name="l01069"></a>01069       ptr-=row_offset;
<a name="l01070"></a>01070       <span class="keywordflow">return</span> tmp;
<a name="l01071"></a>01071     }
<a name="l01072"></a>01072   <span class="keyword">inline</span> longlong val_int(<span class="keyword">const</span> uchar *new_ptr)
<a name="l01073"></a>01073   {
<a name="l01074"></a>01074     uchar *old_ptr= ptr;
<a name="l01075"></a>01075     longlong return_value;
<a name="l01076"></a>01076     ptr= (uchar*) new_ptr;
<a name="l01077"></a>01077     return_value= val_int();
<a name="l01078"></a>01078     ptr= old_ptr;
<a name="l01079"></a>01079     <span class="keywordflow">return</span> return_value;
<a name="l01080"></a>01080   }
<a name="l01081"></a>01081   <span class="keyword">inline</span> <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str, <span class="keyword">const</span> uchar *new_ptr)
<a name="l01082"></a>01082   {
<a name="l01083"></a>01083     uchar *old_ptr= ptr;
<a name="l01084"></a>01084     ptr= (uchar*) new_ptr;
<a name="l01085"></a>01085     val_str(str);
<a name="l01086"></a>01086     ptr= old_ptr;
<a name="l01087"></a>01087     <span class="keywordflow">return</span> str;
<a name="l01088"></a>01088   }
<a name="l01089"></a>01089   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l01090"></a>01090 
<a name="l01091"></a>01091   <span class="keyword">virtual</span> uchar *<a class="code" href="classField.html#a9eaff8d3425ef0e1da69b32cbd8f2879">pack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l01092"></a>01092                       uint max_length, <span class="keywordtype">bool</span> low_byte_first);
<a name="l01096"></a>01096   uchar *<a class="code" href="classField.html#a9eaff8d3425ef0e1da69b32cbd8f2879">pack</a>(uchar *to, <span class="keyword">const</span> uchar *from)
<a name="l01097"></a>01097   {
<a name="l01098"></a>01098     DBUG_ENTER(<span class="stringliteral">&quot;Field::pack&quot;</span>);
<a name="l01099"></a>01099     uchar *result= this-&gt;<a class="code" href="classField.html#a9eaff8d3425ef0e1da69b32cbd8f2879">pack</a>(to, from, UINT_MAX, table-&gt;s-&gt;db_low_byte_first);
<a name="l01100"></a>01100     DBUG_RETURN(result);
<a name="l01101"></a>01101   }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField.html#a42f448ff2c939d91949f7635d939b16b">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01104"></a>01104                               uint param_data, <span class="keywordtype">bool</span> low_byte_first);
<a name="l01108"></a>01108   <span class="keyword">const</span> uchar *<a class="code" href="classField.html#a42f448ff2c939d91949f7635d939b16b">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from)
<a name="l01109"></a>01109   {
<a name="l01110"></a>01110     DBUG_ENTER(<span class="stringliteral">&quot;Field::unpack&quot;</span>);
<a name="l01111"></a>01111     <span class="keyword">const</span> uchar *result= <a class="code" href="classField.html#a42f448ff2c939d91949f7635d939b16b">unpack</a>(to, from, 0U, table-&gt;s-&gt;db_low_byte_first);
<a name="l01112"></a>01112     DBUG_RETURN(result);
<a name="l01113"></a>01113   }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115   <span class="keyword">virtual</span> uint packed_col_length(<span class="keyword">const</span> uchar *to, uint length)
<a name="l01116"></a>01116   { <span class="keywordflow">return</span> length;}
<a name="l01117"></a>01117   <span class="keyword">virtual</span> uint max_packed_col_length(uint max_length)
<a name="l01118"></a>01118   { <span class="keywordflow">return</span> max_length;}
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   uint offset(uchar *record)
<a name="l01121"></a>01121   {
<a name="l01122"></a>01122     <span class="keywordflow">return</span> (uint) (ptr - record);
<a name="l01123"></a>01123   }
<a name="l01124"></a>01124   <span class="keywordtype">void</span> copy_from_tmp(<span class="keywordtype">int</span> offset);
<a name="l01125"></a>01125   uint fill_cache_field(<span class="keyword">struct</span> <a class="code" href="structst__cache__field.html">st_cache_field</a> *copy);
<a name="l01126"></a>01126   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime,uint fuzzydate);
<a name="l01127"></a>01127   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime);
<a name="l01128"></a>01128   <span class="keyword">virtual</span> <span class="keyword">const</span> CHARSET_INFO *charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;my_charset_bin; }
<a name="l01129"></a>01129   <span class="keyword">virtual</span> <span class="keyword">const</span> CHARSET_INFO *charset_for_protocol(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l01130"></a>01130 <span class="keyword">  </span>{ <span class="keywordflow">return</span> binary() ? &amp;my_charset_bin : charset(); }
<a name="l01131"></a>01131   <span class="keyword">virtual</span> <span class="keyword">const</span> CHARSET_INFO *sort_charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> charset(); }
<a name="l01132"></a>01132   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> has_charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> FALSE; }
<a name="l01133"></a>01133   <span class="comment">/*</span>
<a name="l01134"></a>01134 <span class="comment">    match_collation_to_optimize_range() is to distinguish in</span>
<a name="l01135"></a>01135 <span class="comment">    range optimizer (see opt_range.cc) between real string types:</span>
<a name="l01136"></a>01136 <span class="comment">      CHAR, VARCHAR, TEXT</span>
<a name="l01137"></a>01137 <span class="comment">    and the other string-alike types with result_type() == STRING_RESULT:</span>
<a name="l01138"></a>01138 <span class="comment">      DATE, TIME, DATETIME, TIMESTAMP</span>
<a name="l01139"></a>01139 <span class="comment">    We need it to decide whether to test if collation of the operation</span>
<a name="l01140"></a>01140 <span class="comment">    matches collation of the field (needed only for real string types).</span>
<a name="l01141"></a>01141 <span class="comment">    QQ: shouldn&#39;t DATE/TIME types have their own XXX_RESULT types eventually?</span>
<a name="l01142"></a>01142 <span class="comment">  */</span>
<a name="l01143"></a>01143   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> match_collation_to_optimize_range()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; };
<a name="l01144"></a>01144   <span class="keyword">virtual</span> <span class="keyword">enum</span> Derivation derivation(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l01145"></a>01145 <span class="keyword">  </span>{ <span class="keywordflow">return</span> DERIVATION_IMPLICIT; }
<a name="l01146"></a>01146   <span class="keyword">virtual</span> uint repertoire(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MY_REPERTOIRE_UNICODE30; }
<a name="l01147"></a>01147   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_derivation(<span class="keyword">enum</span> Derivation derivation_arg) { }
<a name="l01148"></a>01148   <span class="keywordtype">bool</span> <a class="code" href="classField.html#acbb8c96f88b49c12a6648a8c06eab5f5">set_warning</a>(Sql_condition::enum_warning_level, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> code,
<a name="l01149"></a>01149                    <span class="keywordtype">int</span> cuted_increment) <span class="keyword">const</span>;
<a name="l01150"></a>01150   <span class="keyword">inline</span> <span class="keywordtype">bool</span> check_overflow(<span class="keywordtype">int</span> op_result)
<a name="l01151"></a>01151   {
<a name="l01152"></a>01152     <span class="keywordflow">return</span> (op_result == E_DEC_OVERFLOW);
<a name="l01153"></a>01153   }
<a name="l01154"></a>01154   <span class="keyword">inline</span> <span class="keywordtype">bool</span> check_truncated(<span class="keywordtype">int</span> op_result)
<a name="l01155"></a>01155   {
<a name="l01156"></a>01156     <span class="keywordflow">return</span> (op_result == E_DEC_TRUNCATED);
<a name="l01157"></a>01157   }
<a name="l01158"></a>01158   <span class="keywordtype">bool</span> <a class="code" href="classField.html#a910faac3cd041daebe318e9dbf1d2297">warn_if_overflow</a>(<span class="keywordtype">int</span> op_result);
<a name="l01159"></a>01159   <span class="keywordtype">void</span> init(<a class="code" href="structTABLE.html">TABLE</a> *table_arg)
<a name="l01160"></a>01160   {
<a name="l01161"></a>01161     orig_table= table= table_arg;
<a name="l01162"></a>01162     table_name= &amp;table_arg-&gt;alias;
<a name="l01163"></a>01163   }
<a name="l01164"></a>01164 
<a name="l01165"></a>01165   <span class="comment">/* maximum possible display length */</span>
<a name="l01166"></a>01166   <span class="keyword">virtual</span> uint32 max_display_length()= 0;
<a name="l01167"></a>01167 
<a name="l01175"></a>01175   <span class="keyword">virtual</span> uint <a class="code" href="classField.html#a8c99e9c66c1d578a339ae87d128843b7">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l01176"></a>01176   <span class="comment">/* convert decimal to longlong with overflow check */</span>
<a name="l01177"></a>01177   longlong <a class="code" href="classField.html#ae7b5281a68791e7d7ba3d5293a68c0cd">convert_decimal2longlong</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *val, <span class="keywordtype">bool</span> unsigned_flag,
<a name="l01178"></a>01178                                     <span class="keywordtype">bool</span> *has_overflow);
<a name="l01179"></a>01179   <span class="comment">/* The max. number of characters */</span>
<a name="l01180"></a>01180   <span class="keyword">virtual</span> uint32 char_length()
<a name="l01181"></a>01181   {
<a name="l01182"></a>01182     <span class="keywordflow">return</span> field_length / charset()-&gt;mbmaxlen;
<a name="l01183"></a>01183   }
<a name="l01184"></a>01184 
<a name="l01185"></a>01185   <span class="keyword">virtual</span> geometry_type get_geometry_type()
<a name="l01186"></a>01186   {
<a name="l01187"></a>01187     <span class="comment">/* shouldn&#39;t get here. */</span>
<a name="l01188"></a>01188     DBUG_ASSERT(0);
<a name="l01189"></a>01189     <span class="keywordflow">return</span> GEOM_GEOMETRY;
<a name="l01190"></a>01190   }
<a name="l01191"></a>01191 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l01192"></a>01192 <span class="preprocessor"></span>  <span class="comment">/* Print field value into debug trace, in NULL-aware way. */</span>
<a name="l01193"></a>01193   <span class="keywordtype">void</span> dbug_print()
<a name="l01194"></a>01194   {
<a name="l01195"></a>01195     <span class="keywordflow">if</span> (is_real_null())
<a name="l01196"></a>01196       fprintf(DBUG_FILE, <span class="stringliteral">&quot;NULL&quot;</span>);
<a name="l01197"></a>01197     <span class="keywordflow">else</span>
<a name="l01198"></a>01198     {
<a name="l01199"></a>01199       <span class="keywordtype">char</span> buf[256];
<a name="l01200"></a>01200       <a class="code" href="classString.html">String</a> str(buf, <span class="keyword">sizeof</span>(buf), &amp;my_charset_bin);
<a name="l01201"></a>01201       str.length(0);
<a name="l01202"></a>01202       <a class="code" href="classString.html">String</a> *pstr;
<a name="l01203"></a>01203       pstr= val_str(&amp;str);
<a name="l01204"></a>01204       fprintf(DBUG_FILE, <span class="stringliteral">&quot;&#39;%s&#39;&quot;</span>, pstr-&gt;c_ptr_safe());
<a name="l01205"></a>01205     }
<a name="l01206"></a>01206   }
<a name="l01207"></a>01207 <span class="preprocessor">#endif</span>
<a name="l01208"></a>01208 <span class="preprocessor"></span>
<a name="l01209"></a>01209   ha_storage_media field_storage_type()<span class="keyword"> const</span>
<a name="l01210"></a>01210 <span class="keyword">  </span>{
<a name="l01211"></a>01211     <span class="keywordflow">return</span> (ha_storage_media)
<a name="l01212"></a>01212       ((flags &gt;&gt; FIELD_FLAGS_STORAGE_MEDIA) &amp; 3);
<a name="l01213"></a>01213   }
<a name="l01214"></a>01214 
<a name="l01215"></a>01215   <span class="keywordtype">void</span> set_storage_type(ha_storage_media storage_type_arg)
<a name="l01216"></a>01216   {
<a name="l01217"></a>01217     DBUG_ASSERT(field_storage_type() == HA_SM_DEFAULT);
<a name="l01218"></a>01218     flags |= (storage_type_arg &lt;&lt; FIELD_FLAGS_STORAGE_MEDIA);
<a name="l01219"></a>01219   }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221   column_format_type column_format()<span class="keyword"> const</span>
<a name="l01222"></a>01222 <span class="keyword">  </span>{
<a name="l01223"></a>01223     <span class="keywordflow">return</span> (column_format_type)
<a name="l01224"></a>01224       ((flags &gt;&gt; FIELD_FLAGS_COLUMN_FORMAT) &amp; 3);
<a name="l01225"></a>01225   }
<a name="l01226"></a>01226 
<a name="l01227"></a>01227   <span class="keywordtype">void</span> set_column_format(column_format_type column_format_arg)
<a name="l01228"></a>01228   {
<a name="l01229"></a>01229     DBUG_ASSERT(column_format() == COLUMN_FORMAT_TYPE_DEFAULT);
<a name="l01230"></a>01230     flags |= (column_format_arg &lt;&lt; FIELD_FLAGS_COLUMN_FORMAT);
<a name="l01231"></a>01231   }
<a name="l01232"></a>01232 
<a name="l01233"></a>01233   <span class="comment">/* Validate the value stored in a field */</span>
<a name="l01234"></a>01234   <span class="keyword">virtual</span> type_conversion_status validate_stored_val(THD *thd)
<a name="l01235"></a>01235   { <span class="keywordflow">return</span> TYPE_OK; }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237   <span class="comment">/* Hash value */</span>
<a name="l01238"></a>01238   <span class="keyword">virtual</span> <span class="keywordtype">void</span> hash(ulong *nr, ulong *nr2);
<a name="l01239"></a>01239   <span class="keyword">friend</span> <span class="keywordtype">int</span> cre_myisam(<span class="keywordtype">char</span> * name, <span class="keyword">register</span> <a class="code" href="structTABLE.html">TABLE</a> *form, uint options,
<a name="l01240"></a>01240                         ulonglong auto_increment_value);
<a name="l01241"></a>01241   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classCopy__field.html">Copy_field</a>;
<a name="l01242"></a>01242   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__avg__field.html">Item_avg_field</a>;
<a name="l01243"></a>01243   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__std__field.html">Item_std_field</a>;
<a name="l01244"></a>01244   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__sum__num.html">Item_sum_num</a>;
<a name="l01245"></a>01245   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__sum__sum.html">Item_sum_sum</a>;
<a name="l01246"></a>01246   <span class="keyword">friend</span> <span class="keyword">class </span>Item_sum_str;
<a name="l01247"></a>01247   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__sum__count.html">Item_sum_count</a>;
<a name="l01248"></a>01248   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__sum__avg.html">Item_sum_avg</a>;
<a name="l01249"></a>01249   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__sum__std.html">Item_sum_std</a>;
<a name="l01250"></a>01250   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__sum__min.html">Item_sum_min</a>;
<a name="l01251"></a>01251   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__sum__max.html">Item_sum_max</a>;
<a name="l01252"></a>01252   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classItem__func__group__concat.html">Item_func_group_concat</a>;
<a name="l01253"></a>01253 
<a name="l01254"></a>01254 <span class="keyword">private</span>:
<a name="l01255"></a>01255   <span class="comment">/*</span>
<a name="l01256"></a>01256 <span class="comment">    Primitive for implementing last_null_byte().</span>
<a name="l01257"></a>01257 <span class="comment"></span>
<a name="l01258"></a>01258 <span class="comment">    SYNOPSIS</span>
<a name="l01259"></a>01259 <span class="comment">      do_last_null_byte()</span>
<a name="l01260"></a>01260 <span class="comment"></span>
<a name="l01261"></a>01261 <span class="comment">    DESCRIPTION</span>
<a name="l01262"></a>01262 <span class="comment">      Primitive for the implementation of the last_null_byte()</span>
<a name="l01263"></a>01263 <span class="comment">      function. This represents the inheritance interface and can be</span>
<a name="l01264"></a>01264 <span class="comment">      overridden by subclasses.</span>
<a name="l01265"></a>01265 <span class="comment">   */</span>
<a name="l01266"></a>01266   <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> do_last_null_byte() <span class="keyword">const</span>;
<a name="l01267"></a>01267 
<a name="l01278"></a>01278   <span class="keyword">virtual</span> <span class="keywordtype">int</span> do_save_field_metadata(uchar *metadata_ptr)
<a name="l01279"></a>01279   { <span class="keywordflow">return</span> 0; }
<a name="l01280"></a>01280 
<a name="l01281"></a>01281 <span class="keyword">protected</span>:
<a name="l01282"></a>01282   <span class="keyword">static</span> <span class="keywordtype">void</span> handle_int16(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l01283"></a>01283                            <span class="keywordtype">bool</span> low_byte_first_from, <span class="keywordtype">bool</span> low_byte_first_to)
<a name="l01284"></a>01284   {
<a name="l01285"></a>01285     int16 val;
<a name="l01286"></a>01286 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
<a name="l01287"></a>01287 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (low_byte_first_from)
<a name="l01288"></a>01288       val = sint2korr(from);
<a name="l01289"></a>01289     <span class="keywordflow">else</span>
<a name="l01290"></a>01290 <span class="preprocessor">#endif</span>
<a name="l01291"></a>01291 <span class="preprocessor"></span>      shortget(val, from);
<a name="l01292"></a>01292 
<a name="l01293"></a>01293 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
<a name="l01294"></a>01294 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (low_byte_first_to)
<a name="l01295"></a>01295       int2store(to, val);
<a name="l01296"></a>01296     <span class="keywordflow">else</span>
<a name="l01297"></a>01297 <span class="preprocessor">#endif</span>
<a name="l01298"></a>01298 <span class="preprocessor"></span>      shortstore(to, val);
<a name="l01299"></a>01299   }
<a name="l01300"></a>01300 
<a name="l01301"></a>01301   <span class="keyword">static</span> <span class="keywordtype">void</span> handle_int24(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l01302"></a>01302                            <span class="keywordtype">bool</span> low_byte_first_from, <span class="keywordtype">bool</span> low_byte_first_to)
<a name="l01303"></a>01303   {
<a name="l01304"></a>01304     int32 val;
<a name="l01305"></a>01305 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
<a name="l01306"></a>01306 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (low_byte_first_from)
<a name="l01307"></a>01307       val = sint3korr(from);
<a name="l01308"></a>01308     <span class="keywordflow">else</span>
<a name="l01309"></a>01309 <span class="preprocessor">#endif</span>
<a name="l01310"></a>01310 <span class="preprocessor"></span>      val= (from[0] &lt;&lt; 16) + (from[1] &lt;&lt; 8) + from[2];
<a name="l01311"></a>01311 
<a name="l01312"></a>01312 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
<a name="l01313"></a>01313 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (low_byte_first_to)
<a name="l01314"></a>01314       int2store(to, val);
<a name="l01315"></a>01315     <span class="keywordflow">else</span>
<a name="l01316"></a>01316 <span class="preprocessor">#endif</span>
<a name="l01317"></a>01317 <span class="preprocessor"></span>    {
<a name="l01318"></a>01318       to[0]= 0xFF &amp; (val &gt;&gt; 16);
<a name="l01319"></a>01319       to[1]= 0xFF &amp; (val &gt;&gt; 8);
<a name="l01320"></a>01320       to[2]= 0xFF &amp; val;
<a name="l01321"></a>01321     }
<a name="l01322"></a>01322   }
<a name="l01323"></a>01323 
<a name="l01324"></a>01324   <span class="comment">/*</span>
<a name="l01325"></a>01325 <span class="comment">    Helper function to pack()/unpack() int32 values</span>
<a name="l01326"></a>01326 <span class="comment">  */</span>
<a name="l01327"></a>01327   <span class="keyword">static</span> <span class="keywordtype">void</span> handle_int32(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l01328"></a>01328                            <span class="keywordtype">bool</span> low_byte_first_from, <span class="keywordtype">bool</span> low_byte_first_to)
<a name="l01329"></a>01329   {
<a name="l01330"></a>01330     int32 val;
<a name="l01331"></a>01331 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
<a name="l01332"></a>01332 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (low_byte_first_from)
<a name="l01333"></a>01333       val = sint4korr(from);
<a name="l01334"></a>01334     <span class="keywordflow">else</span>
<a name="l01335"></a>01335 <span class="preprocessor">#endif</span>
<a name="l01336"></a>01336 <span class="preprocessor"></span>      longget(val, from);
<a name="l01337"></a>01337 
<a name="l01338"></a>01338 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
<a name="l01339"></a>01339 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (low_byte_first_to)
<a name="l01340"></a>01340       int4store(to, val);
<a name="l01341"></a>01341     <span class="keywordflow">else</span>
<a name="l01342"></a>01342 <span class="preprocessor">#endif</span>
<a name="l01343"></a>01343 <span class="preprocessor"></span>      longstore(to, val);
<a name="l01344"></a>01344   }
<a name="l01345"></a>01345 
<a name="l01346"></a>01346   <span class="comment">/*</span>
<a name="l01347"></a>01347 <span class="comment">    Helper function to pack()/unpack() int64 values</span>
<a name="l01348"></a>01348 <span class="comment">  */</span>
<a name="l01349"></a>01349   <span class="keyword">static</span> <span class="keywordtype">void</span> handle_int64(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01350"></a>01350                            <span class="keywordtype">bool</span> low_byte_first_from, <span class="keywordtype">bool</span> low_byte_first_to)
<a name="l01351"></a>01351   {
<a name="l01352"></a>01352     int64 val;
<a name="l01353"></a>01353 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
<a name="l01354"></a>01354 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (low_byte_first_from)
<a name="l01355"></a>01355       val = sint8korr(from);
<a name="l01356"></a>01356     <span class="keywordflow">else</span>
<a name="l01357"></a>01357 <span class="preprocessor">#endif</span>
<a name="l01358"></a>01358 <span class="preprocessor"></span>      longlongget(val, from);
<a name="l01359"></a>01359 
<a name="l01360"></a>01360 <span class="preprocessor">#ifdef WORDS_BIGENDIAN</span>
<a name="l01361"></a>01361 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (low_byte_first_to)
<a name="l01362"></a>01362       int8store(to, val);
<a name="l01363"></a>01363     <span class="keywordflow">else</span>
<a name="l01364"></a>01364 <span class="preprocessor">#endif</span>
<a name="l01365"></a>01365 <span class="preprocessor"></span>      longlongstore(to, val);
<a name="l01366"></a>01366   }
<a name="l01367"></a>01367 
<a name="l01368"></a>01368   uchar *pack_int16(uchar *to, <span class="keyword">const</span> uchar *from, <span class="keywordtype">bool</span> low_byte_first_to)
<a name="l01369"></a>01369   {
<a name="l01370"></a>01370     handle_int16(to, from, table-&gt;s-&gt;db_low_byte_first, low_byte_first_to);
<a name="l01371"></a>01371     <span class="keywordflow">return</span> to  + <span class="keyword">sizeof</span>(int16);
<a name="l01372"></a>01372   }
<a name="l01373"></a>01373 
<a name="l01374"></a>01374   <span class="keyword">const</span> uchar *unpack_int16(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01375"></a>01375                             <span class="keywordtype">bool</span> low_byte_first_from)
<a name="l01376"></a>01376   {
<a name="l01377"></a>01377     handle_int16(to, from, low_byte_first_from, table-&gt;s-&gt;db_low_byte_first);
<a name="l01378"></a>01378     <span class="keywordflow">return</span> from + <span class="keyword">sizeof</span>(int16);
<a name="l01379"></a>01379   }
<a name="l01380"></a>01380 
<a name="l01381"></a>01381   uchar *pack_int24(uchar *to, <span class="keyword">const</span> uchar *from, <span class="keywordtype">bool</span> low_byte_first_to)
<a name="l01382"></a>01382   {
<a name="l01383"></a>01383     handle_int24(to, from, table-&gt;s-&gt;db_low_byte_first, low_byte_first_to);
<a name="l01384"></a>01384     <span class="keywordflow">return</span> to + 3;
<a name="l01385"></a>01385   }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387   <span class="keyword">const</span> uchar *unpack_int24(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01388"></a>01388                             <span class="keywordtype">bool</span> low_byte_first_from)
<a name="l01389"></a>01389   {
<a name="l01390"></a>01390     handle_int24(to, from, low_byte_first_from, table-&gt;s-&gt;db_low_byte_first);
<a name="l01391"></a>01391     <span class="keywordflow">return</span> from + 3;
<a name="l01392"></a>01392   }
<a name="l01393"></a>01393 
<a name="l01394"></a>01394   uchar *pack_int32(uchar *to, <span class="keyword">const</span> uchar *from, <span class="keywordtype">bool</span> low_byte_first_to)
<a name="l01395"></a>01395   {
<a name="l01396"></a>01396     handle_int32(to, from, table-&gt;s-&gt;db_low_byte_first, low_byte_first_to);
<a name="l01397"></a>01397     <span class="keywordflow">return</span> to  + <span class="keyword">sizeof</span>(int32);
<a name="l01398"></a>01398   }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400   <span class="keyword">const</span> uchar *unpack_int32(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01401"></a>01401                             <span class="keywordtype">bool</span> low_byte_first_from)
<a name="l01402"></a>01402   {
<a name="l01403"></a>01403     handle_int32(to, from, low_byte_first_from, table-&gt;s-&gt;db_low_byte_first);
<a name="l01404"></a>01404     <span class="keywordflow">return</span> from + <span class="keyword">sizeof</span>(int32);
<a name="l01405"></a>01405   }
<a name="l01406"></a>01406 
<a name="l01407"></a>01407   uchar *pack_int64(uchar* to, <span class="keyword">const</span> uchar *from, <span class="keywordtype">bool</span> low_byte_first_to)
<a name="l01408"></a>01408   {
<a name="l01409"></a>01409     handle_int64(to, from, table-&gt;s-&gt;db_low_byte_first, low_byte_first_to);
<a name="l01410"></a>01410     <span class="keywordflow">return</span> to + <span class="keyword">sizeof</span>(int64);
<a name="l01411"></a>01411   }
<a name="l01412"></a>01412 
<a name="l01413"></a>01413   <span class="keyword">const</span> uchar *unpack_int64(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01414"></a>01414                             <span class="keywordtype">bool</span> low_byte_first_from)
<a name="l01415"></a>01415   {
<a name="l01416"></a>01416     handle_int64(to, from, low_byte_first_from, table-&gt;s-&gt;db_low_byte_first);
<a name="l01417"></a>01417     <span class="keywordflow">return</span> from + <span class="keyword">sizeof</span>(int64);
<a name="l01418"></a>01418   }
<a name="l01419"></a>01419 
<a name="l01420"></a>01420 };
<a name="l01421"></a>01421 
<a name="l01422"></a>01422 
<a name="l01423"></a><a class="code" href="classField__num.html">01423</a> <span class="keyword">class </span><a class="code" href="classField__num.html">Field_num</a> :<span class="keyword">public</span> <a class="code" href="classField.html">Field</a> {
<a name="l01424"></a>01424 <span class="keyword">public</span>:
<a name="l01425"></a>01425   <span class="keyword">const</span> uint8 dec;
<a name="l01426"></a>01426   <span class="keywordtype">bool</span> zerofill,unsigned_flag;  <span class="comment">// Purify cannot handle bit fields</span>
<a name="l01427"></a>01427   <a class="code" href="classField__num.html#a7f74cee006e7ebcde71d71105bd66ec8">Field_num</a>(uchar *ptr_arg,uint32 len_arg, uchar *null_ptr_arg,
<a name="l01428"></a>01428             uchar null_bit_arg, utype unireg_check_arg,
<a name="l01429"></a>01429             <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01430"></a>01430             uint8 dec_arg, <span class="keywordtype">bool</span> zero_arg, <span class="keywordtype">bool</span> unsigned_arg);
<a name="l01431"></a>01431   Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> REAL_RESULT; }
<a name="l01432"></a>01432   <span class="keyword">enum</span> Derivation derivation(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DERIVATION_NUMERIC; }
<a name="l01433"></a>01433   uint repertoire(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MY_REPERTOIRE_NUMERIC; }
<a name="l01434"></a>01434   <span class="keyword">const</span> CHARSET_INFO *charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;my_charset_numeric; }
<a name="l01435"></a>01435   <span class="keywordtype">void</span> prepend_zeros(<a class="code" href="classString.html">String</a> *value);
<a name="l01436"></a>01436   <span class="keywordtype">void</span> add_zerofill_and_unsigned(<a class="code" href="classString.html">String</a> &amp;res) <span class="keyword">const</span>;
<a name="l01437"></a>01437   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classCreate__field.html">Create_field</a>;
<a name="l01438"></a>01438   uint decimals()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint) dec; }
<a name="l01439"></a>01439   <span class="keywordtype">bool</span> <a class="code" href="classField__num.html#a085c650230d92d4a6a2edc8891b79347">eq_def</a>(<a class="code" href="classField.html">Field</a> *field);
<a name="l01440"></a>01440   type_conversion_status <a class="code" href="classField__num.html#a66573c9ffc227799320c49a73a0f8de5">store_decimal</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01441"></a>01441   type_conversion_status <a class="code" href="classField__num.html#ab573b6e30982c3d517794503f14560de">store_time</a>(MYSQL_TIME *ltime, uint8 dec);
<a name="l01442"></a>01442   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classField__num.html#a6fec8b8c9fc5c0b9b0429f6fbc860de3">val_decimal</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01443"></a>01443   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l01444"></a>01444   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime);
<a name="l01445"></a>01445   uint <a class="code" href="classField__num.html#af9c9a23de2d14eceaeb96f1f98212ed4">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l01446"></a>01446   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l01447"></a>01447   uint32 pack_length_from_metadata(uint field_metadata) {
<a name="l01448"></a>01448     uint32 length= pack_length();
<a name="l01449"></a>01449     DBUG_PRINT(<span class="stringliteral">&quot;result&quot;</span>, (<span class="stringliteral">&quot;pack_length_from_metadata(%d): %u&quot;</span>,
<a name="l01450"></a>01450                           field_metadata, length));
<a name="l01451"></a>01451     <span class="keywordflow">return</span> length;
<a name="l01452"></a>01452   }
<a name="l01453"></a>01453   type_conversion_status <a class="code" href="classField__num.html#a4aba1e99e15d07a40cb6ae9fbff720b7">check_int</a>(<span class="keyword">const</span> CHARSET_INFO *cs,
<a name="l01454"></a>01454                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> length,
<a name="l01455"></a>01455                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *int_end, <span class="keywordtype">int</span> error);
<a name="l01456"></a>01456   type_conversion_status get_int(<span class="keyword">const</span> CHARSET_INFO *cs,
<a name="l01457"></a>01457                                  <span class="keyword">const</span> <span class="keywordtype">char</span> *from, uint len,
<a name="l01458"></a>01458                                  longlong *rnd, ulonglong unsigned_max,
<a name="l01459"></a>01459                                  longlong signed_min, longlong signed_max);
<a name="l01460"></a>01460 };
<a name="l01461"></a>01461 
<a name="l01462"></a>01462 
<a name="l01463"></a><a class="code" href="classField__str.html">01463</a> <span class="keyword">class </span><a class="code" href="classField__str.html">Field_str</a> :<span class="keyword">public</span> <a class="code" href="classField.html">Field</a> {
<a name="l01464"></a>01464 <span class="keyword">protected</span>:
<a name="l01465"></a>01465   <span class="keyword">const</span> CHARSET_INFO *field_charset;
<a name="l01466"></a>01466   <span class="keyword">enum</span> Derivation field_derivation;
<a name="l01467"></a>01467 <span class="keyword">public</span>:
<a name="l01468"></a>01468   <a class="code" href="classField__str.html">Field_str</a>(uchar *ptr_arg,uint32 len_arg, uchar *null_ptr_arg,
<a name="l01469"></a>01469             uchar null_bit_arg, utype unireg_check_arg,
<a name="l01470"></a>01470             <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg, <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01471"></a>01471   Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> STRING_RESULT; }
<a name="l01472"></a><a class="code" href="classField__str.html#a95583e4cf40652c959b4857d8cd90c62">01472</a>   Item_result <a class="code" href="classField__str.html#a95583e4cf40652c959b4857d8cd90c62">numeric_context_result_type</a>()<span class="keyword"> const</span>
<a name="l01473"></a>01473 <span class="keyword">  </span>{ 
<a name="l01474"></a>01474     <span class="keywordflow">return</span> REAL_RESULT; 
<a name="l01475"></a>01475   }
<a name="l01476"></a>01476   uint decimals()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> NOT_FIXED_DEC; }
<a name="l01477"></a>01477   <span class="keywordtype">void</span> make_field(<a class="code" href="classSend__field.html">Send_field</a> *field);
<a name="l01478"></a>01478   type_conversion_status <a class="code" href="classField__str.html#ad4b48698ff57cae15a2df92f1145b102">store</a>(<span class="keywordtype">double</span> nr);
<a name="l01479"></a>01479   type_conversion_status <a class="code" href="classField__str.html#ad4b48698ff57cae15a2df92f1145b102">store</a>(longlong nr, <span class="keywordtype">bool</span> unsigned_val)=0;
<a name="l01480"></a>01480   type_conversion_status <a class="code" href="classField__str.html#ae0a260a3e657aa6778dcf651ff3e9b95">store_decimal</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01481"></a>01481   type_conversion_status <a class="code" href="classField__str.html#ad4b48698ff57cae15a2df92f1145b102">store</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01482"></a>01482                                <span class="keyword">const</span> CHARSET_INFO *cs)=0;
<a name="l01483"></a>01483   uint repertoire(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l01484"></a>01484 <span class="keyword">  </span>{
<a name="l01485"></a>01485     <span class="keywordflow">return</span> my_charset_repertoire(field_charset);
<a name="l01486"></a>01486   }
<a name="l01487"></a>01487   <span class="keyword">const</span> CHARSET_INFO *charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> field_charset; }
<a name="l01488"></a>01488   <span class="keywordtype">void</span> set_charset(<span class="keyword">const</span> CHARSET_INFO *charset_arg)
<a name="l01489"></a>01489   { field_charset= charset_arg; }
<a name="l01490"></a>01490   <span class="keyword">enum</span> Derivation derivation(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> field_derivation; }
<a name="l01491"></a>01491   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_derivation(<span class="keyword">enum</span> Derivation derivation_arg)
<a name="l01492"></a>01492   { field_derivation= derivation_arg; }
<a name="l01493"></a>01493   <span class="keywordtype">bool</span> binary()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> field_charset == &amp;my_charset_bin; }
<a name="l01494"></a>01494   uint32 max_display_length() { <span class="keywordflow">return</span> field_length; }
<a name="l01495"></a>01495   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classCreate__field.html">Create_field</a>;
<a name="l01496"></a>01496   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> str_needs_quotes() { <span class="keywordflow">return</span> TRUE; }
<a name="l01497"></a>01497   uint <a class="code" href="classField__str.html#a281f4c166dbbfd070c6038c8b6f1595a">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l01498"></a>01498 };
<a name="l01499"></a>01499 
<a name="l01500"></a>01500 
<a name="l01501"></a>01501 <span class="comment">/* base class for Field_string, Field_varstring and Field_blob */</span>
<a name="l01502"></a>01502 
<a name="l01503"></a><a class="code" href="classField__longstr.html">01503</a> <span class="keyword">class </span><a class="code" href="classField__longstr.html">Field_longstr</a> :<span class="keyword">public</span> <a class="code" href="classField__str.html">Field_str</a>
<a name="l01504"></a>01504 {
<a name="l01505"></a>01505 <span class="keyword">protected</span>:
<a name="l01506"></a>01506   type_conversion_status report_if_important_data(<span class="keyword">const</span> <span class="keywordtype">char</span> *ptr,
<a name="l01507"></a>01507                                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *end,
<a name="l01508"></a>01508                                                   <span class="keywordtype">bool</span> count_spaces) <span class="keyword">const</span>;
<a name="l01509"></a>01509   type_conversion_status
<a name="l01510"></a>01510     <a class="code" href="classField__longstr.html#a5de0f7f3c8da78eb82a263429eb43cc8">check_string_copy_error</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *well_formed_error_pos,
<a name="l01511"></a>01511                             <span class="keyword">const</span> <span class="keywordtype">char</span> *cannot_convert_error_pos,
<a name="l01512"></a>01512                             <span class="keyword">const</span> <span class="keywordtype">char</span> *from_end_pos,
<a name="l01513"></a>01513                             <span class="keyword">const</span> <span class="keywordtype">char</span> *end,
<a name="l01514"></a>01514                             <span class="keywordtype">bool</span> count_spaces,
<a name="l01515"></a>01515                             <span class="keyword">const</span> CHARSET_INFO *cs) <span class="keyword">const</span>;
<a name="l01516"></a>01516 <span class="keyword">public</span>:
<a name="l01517"></a>01517   <a class="code" href="classField__longstr.html">Field_longstr</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01518"></a>01518                 uchar null_bit_arg, utype unireg_check_arg,
<a name="l01519"></a>01519                 <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg, <span class="keyword">const</span> CHARSET_INFO *charset_arg)
<a name="l01520"></a>01520     :<a class="code" href="classField__str.html">Field_str</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg, unireg_check_arg,
<a name="l01521"></a>01521                field_name_arg, charset_arg)
<a name="l01522"></a>01522     {}
<a name="l01523"></a>01523 
<a name="l01524"></a>01524   type_conversion_status <a class="code" href="classField__longstr.html#accc080bab51e57cdcefc594a17cb13f5">store_decimal</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *d);
<a name="l01525"></a>01525   uint32 <a class="code" href="classField__longstr.html#afd6c1ab085647b095b6e445b4358f09e">max_data_length</a>() <span class="keyword">const</span>;
<a name="l01526"></a>01526 };
<a name="l01527"></a>01527 
<a name="l01528"></a>01528 <span class="comment">/* base class for float and double and decimal (old one) */</span>
<a name="l01529"></a><a class="code" href="classField__real.html">01529</a> <span class="keyword">class </span><a class="code" href="classField__real.html">Field_real</a> :<span class="keyword">public</span> <a class="code" href="classField__num.html">Field_num</a> {
<a name="l01530"></a>01530 <span class="keyword">public</span>:
<a name="l01531"></a>01531   my_bool not_fixed;
<a name="l01532"></a>01532 
<a name="l01533"></a>01533   <a class="code" href="classField__real.html">Field_real</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01534"></a>01534              uchar null_bit_arg, utype unireg_check_arg,
<a name="l01535"></a>01535              <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01536"></a>01536              uint8 dec_arg, <span class="keywordtype">bool</span> zero_arg, <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01537"></a>01537     :<a class="code" href="classField__num.html#a7f74cee006e7ebcde71d71105bd66ec8">Field_num</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg, unireg_check_arg,
<a name="l01538"></a>01538                field_name_arg, dec_arg, zero_arg, unsigned_arg),
<a name="l01539"></a>01539     not_fixed(dec_arg &gt;= NOT_FIXED_DEC)
<a name="l01540"></a>01540     {}
<a name="l01541"></a>01541   type_conversion_status <a class="code" href="classField__real.html#ae06ebf885e6b10b0a7c4966873d6b80f">store_decimal</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01542"></a>01542   type_conversion_status <a class="code" href="classField__real.html#a2020c5eabc8cdc2c451ca0591e284150">store_time</a>(MYSQL_TIME *ltime, uint8 dec);
<a name="l01543"></a>01543   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classField__real.html#aea0b139caebcb6dc909b1bc397f5aba6">val_decimal</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01544"></a>01544   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l01545"></a>01545   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime);
<a name="l01546"></a>01546   <span class="keywordtype">bool</span> truncate(<span class="keywordtype">double</span> *nr, <span class="keywordtype">double</span> max_length);
<a name="l01547"></a>01547   uint32 max_display_length() { <span class="keywordflow">return</span> field_length; }
<a name="l01548"></a>01548   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__real.html#aab922b4da48c1fd508344b1f627e0e0e">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01549"></a>01549                               uint param_data, <span class="keywordtype">bool</span> low_byte_first);
<a name="l01550"></a>01550   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__real.html#a350715a27630782dd1247287d2446480">pack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01551"></a>01551                       uint max_length, <span class="keywordtype">bool</span> low_byte_first);
<a name="l01552"></a>01552 };
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 
<a name="l01555"></a><a class="code" href="classField__decimal.html">01555</a> <span class="keyword">class </span><a class="code" href="classField__decimal.html">Field_decimal</a> :<span class="keyword">public</span> <a class="code" href="classField__real.html">Field_real</a> {
<a name="l01556"></a>01556 <span class="keyword">public</span>:
<a name="l01557"></a>01557   <a class="code" href="classField__decimal.html">Field_decimal</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01558"></a>01558                 uchar null_bit_arg,
<a name="l01559"></a>01559                 <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01560"></a>01560                 uint8 dec_arg,<span class="keywordtype">bool</span> zero_arg,<span class="keywordtype">bool</span> unsigned_arg)
<a name="l01561"></a>01561     :<a class="code" href="classField__real.html">Field_real</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l01562"></a>01562                 unireg_check_arg, field_name_arg,
<a name="l01563"></a>01563                 dec_arg, zero_arg, unsigned_arg)
<a name="l01564"></a>01564     {}
<a name="l01565"></a>01565   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_DECIMAL;}
<a name="l01566"></a>01566   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const</span>
<a name="l01567"></a>01567 <span class="keyword">  </span>{ <span class="keywordflow">return</span> zerofill ? HA_KEYTYPE_BINARY : HA_KEYTYPE_NUM; }
<a name="l01568"></a>01568   type_conversion_status reset(<span class="keywordtype">void</span>);
<a name="l01569"></a>01569   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01570"></a>01570                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01571"></a>01571   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l01572"></a>01572   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l01573"></a>01573   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l01574"></a>01574   longlong val_int(<span class="keywordtype">void</span>);
<a name="l01575"></a>01575   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l01576"></a>01576   <span class="keywordtype">int</span> <a class="code" href="classField__decimal.html#ab82c27bf2bef656e8ba820be255262d1">cmp</a>(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l01577"></a>01577   <span class="keywordtype">void</span> <a class="code" href="classField__decimal.html#afd2d0715069090c2e5e911fe0ce45dce">make_sort_key</a>(uchar *buff, uint length);
<a name="l01578"></a>01578   <span class="keywordtype">void</span> overflow(<span class="keywordtype">bool</span> negative);
<a name="l01579"></a>01579   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l01580"></a>01580   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l01581"></a><a class="code" href="classField__decimal.html#af8c143081013a2e21ee1c938da76e546">01581</a>   <a class="code" href="classField__decimal.html">Field_decimal</a> *<a class="code" href="classField__decimal.html#af8c143081013a2e21ee1c938da76e546">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l01582"></a>01582     DBUG_ASSERT(type() == MYSQL_TYPE_DECIMAL);
<a name="l01583"></a>01583     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__decimal.html">Field_decimal</a>(*<span class="keyword">this</span>);
<a name="l01584"></a>01584   }
<a name="l01585"></a><a class="code" href="classField__decimal.html#a989f4a705f3e10f6d723e4e38781170e">01585</a>   <a class="code" href="classField__decimal.html">Field_decimal</a> *<a class="code" href="classField__decimal.html#a989f4a705f3e10f6d723e4e38781170e">clone</a>()<span class="keyword"> const </span>{
<a name="l01586"></a>01586     DBUG_ASSERT(type() == MYSQL_TYPE_DECIMAL);
<a name="l01587"></a>01587     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__decimal.html">Field_decimal</a>(*<span class="keyword">this</span>);
<a name="l01588"></a>01588   }
<a name="l01589"></a><a class="code" href="classField__decimal.html#a175db70d41ae30df50a1ec04d8680363">01589</a>   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__decimal.html#a175db70d41ae30df50a1ec04d8680363">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01590"></a>01590                               uint param_data, <span class="keywordtype">bool</span> low_byte_first)
<a name="l01591"></a>01591   {
<a name="l01592"></a>01592     <span class="keywordflow">return</span> <a class="code" href="classField__decimal.html#a175db70d41ae30df50a1ec04d8680363">Field::unpack</a>(to, from, param_data, low_byte_first);
<a name="l01593"></a>01593   }
<a name="l01594"></a><a class="code" href="classField__decimal.html#a85c1f4498b4f8f773056efcf6c3a901a">01594</a>   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__decimal.html#a85c1f4498b4f8f773056efcf6c3a901a">pack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01595"></a>01595                       uint max_length, <span class="keywordtype">bool</span> low_byte_first)
<a name="l01596"></a>01596   {
<a name="l01597"></a>01597     <span class="keywordflow">return</span> <a class="code" href="classField__decimal.html#a85c1f4498b4f8f773056efcf6c3a901a">Field::pack</a>(to, from, max_length, low_byte_first);
<a name="l01598"></a>01598   }
<a name="l01599"></a>01599 };
<a name="l01600"></a>01600 
<a name="l01601"></a>01601 
<a name="l01602"></a>01602 <span class="comment">/* New decimal/numeric field which use fixed point arithmetic */</span>
<a name="l01603"></a><a class="code" href="classField__new__decimal.html">01603</a> <span class="keyword">class </span><a class="code" href="classField__new__decimal.html">Field_new_decimal</a> :<span class="keyword">public</span> <a class="code" href="classField__num.html">Field_num</a> {
<a name="l01604"></a>01604 <span class="keyword">private</span>:
<a name="l01605"></a>01605   <span class="keywordtype">int</span> do_save_field_metadata(uchar *first_byte);
<a name="l01606"></a>01606 <span class="keyword">public</span>:
<a name="l01607"></a>01607 
<a name="l01608"></a>01608   <span class="comment">/* The maximum number of decimal digits can be stored */</span>
<a name="l01609"></a>01609   uint precision;
<a name="l01610"></a>01610   uint bin_size;
<a name="l01611"></a>01611   <span class="comment">/*</span>
<a name="l01612"></a>01612 <span class="comment">    Constructors take max_length of the field as a parameter - not the</span>
<a name="l01613"></a>01613 <span class="comment">    precision as the number of decimal digits allowed.</span>
<a name="l01614"></a>01614 <span class="comment">    So for example we need to count length from precision handling</span>
<a name="l01615"></a>01615 <span class="comment">    CREATE TABLE ( DECIMAL(x,y)) </span>
<a name="l01616"></a>01616 <span class="comment">  */</span>
<a name="l01617"></a>01617   <a class="code" href="classField__new__decimal.html">Field_new_decimal</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01618"></a>01618                     uchar null_bit_arg,
<a name="l01619"></a>01619                     <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01620"></a>01620                     uint8 dec_arg, <span class="keywordtype">bool</span> zero_arg, <span class="keywordtype">bool</span> unsigned_arg);
<a name="l01621"></a>01621   <a class="code" href="classField__new__decimal.html">Field_new_decimal</a>(uint32 len_arg, <span class="keywordtype">bool</span> maybe_null_arg,
<a name="l01622"></a>01622                     <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg, uint8 dec_arg,
<a name="l01623"></a>01623                     <span class="keywordtype">bool</span> unsigned_arg);
<a name="l01624"></a>01624   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_NEWDECIMAL;}
<a name="l01625"></a>01625   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_BINARY; }
<a name="l01626"></a>01626   Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DECIMAL_RESULT; }
<a name="l01627"></a>01627   type_conversion_status reset(<span class="keywordtype">void</span>);
<a name="l01628"></a>01628   type_conversion_status <a class="code" href="classField__new__decimal.html#a3d2dd290b995df3f7c8517fe37b6d4ef">store_value</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *decimal_value);
<a name="l01629"></a>01629   <span class="keywordtype">void</span> <a class="code" href="classField__new__decimal.html#a731366be6adfc65ab3b325235ff7eede">set_value_on_overflow</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *decimal_value, <span class="keywordtype">bool</span> sign);
<a name="l01630"></a>01630   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01631"></a>01631                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01632"></a>01632   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l01633"></a>01633   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l01634"></a>01634   type_conversion_status <a class="code" href="classField__new__decimal.html#ab6f4b13ae308695dffd15cb0c39038d0">store_time</a>(MYSQL_TIME *ltime, uint8 dec);
<a name="l01635"></a>01635   type_conversion_status <a class="code" href="classField__new__decimal.html#a15580620890eb78ffde70b2f54ad684f">store_decimal</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01636"></a>01636   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l01637"></a>01637   longlong val_int(<span class="keywordtype">void</span>);
<a name="l01638"></a>01638   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classField__new__decimal.html#a17f916c175e3c2520609d911574d9bde">val_decimal</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01639"></a>01639   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l01640"></a>01640   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime);
<a name="l01641"></a>01641   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*, <a class="code" href="classString.html">String</a> *);
<a name="l01642"></a>01642   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *, <span class="keyword">const</span> uchar *);
<a name="l01643"></a>01643   <span class="keywordtype">void</span> <a class="code" href="classField__new__decimal.html#af9f4657881c0f805c6ca63b6885e1c2b">make_sort_key</a>(uchar *buff, uint length);
<a name="l01644"></a>01644   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l01645"></a>01645   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l01646"></a>01646   uint32 max_display_length() { <span class="keywordflow">return</span> field_length; }
<a name="l01647"></a>01647   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint32) bin_size; }
<a name="l01648"></a>01648   uint <a class="code" href="classField__new__decimal.html#a295d3ea96855ddbf89b6e890b5ac1e2d">pack_length_from_metadata</a>(uint field_metadata);
<a name="l01649"></a>01649   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l01650"></a>01650   <span class="keywordtype">bool</span> <a class="code" href="classField__new__decimal.html#a55356fb799e02d0d09605cf5c1bbbc11">compatible_field_size</a>(uint field_metadata, <a class="code" href="classRelay__log__info.html">Relay_log_info</a> *rli,
<a name="l01651"></a>01651                              uint16 mflags, <span class="keywordtype">int</span> *order_var);
<a name="l01652"></a>01652   uint <a class="code" href="classField__new__decimal.html#a322bc9ecdcf1ffab0787b933fac016d9">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l01653"></a><a class="code" href="classField__new__decimal.html#ade2ccf00efc91638f6de3ee51d51c51e">01653</a>   <a class="code" href="classField__new__decimal.html">Field_new_decimal</a> *<a class="code" href="classField__new__decimal.html#ade2ccf00efc91638f6de3ee51d51c51e">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l01654"></a>01654     DBUG_ASSERT(type() == MYSQL_TYPE_NEWDECIMAL);
<a name="l01655"></a>01655     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__new__decimal.html">Field_new_decimal</a>(*<span class="keyword">this</span>);
<a name="l01656"></a>01656   }
<a name="l01657"></a><a class="code" href="classField__new__decimal.html#a3b343bd0fdcdcd4d7aa2d704267138ca">01657</a>   <a class="code" href="classField__new__decimal.html">Field_new_decimal</a> *<a class="code" href="classField__new__decimal.html#a3b343bd0fdcdcd4d7aa2d704267138ca">clone</a>()<span class="keyword"> const </span>{
<a name="l01658"></a>01658     DBUG_ASSERT(type() == MYSQL_TYPE_NEWDECIMAL);
<a name="l01659"></a>01659     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__new__decimal.html">Field_new_decimal</a>(*<span class="keyword">this</span>);
<a name="l01660"></a>01660   }
<a name="l01661"></a>01661   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__new__decimal.html#a62e2be62b919a9917874a4877fc924d9">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01662"></a>01662                               uint param_data, <span class="keywordtype">bool</span> low_byte_first);
<a name="l01663"></a>01663   <span class="keyword">static</span> <a class="code" href="classField.html">Field</a> *create_from_item (<a class="code" href="classItem.html">Item</a> *);
<a name="l01664"></a>01664 };
<a name="l01665"></a>01665 
<a name="l01666"></a>01666 
<a name="l01667"></a><a class="code" href="classField__tiny.html">01667</a> <span class="keyword">class </span><a class="code" href="classField__tiny.html">Field_tiny</a> :<span class="keyword">public</span> <a class="code" href="classField__num.html">Field_num</a> {
<a name="l01668"></a>01668 <span class="keyword">public</span>:
<a name="l01669"></a>01669   <a class="code" href="classField__tiny.html">Field_tiny</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01670"></a>01670              uchar null_bit_arg,
<a name="l01671"></a>01671              <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01672"></a>01672              <span class="keywordtype">bool</span> zero_arg, <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01673"></a>01673     :<a class="code" href="classField__num.html#a7f74cee006e7ebcde71d71105bd66ec8">Field_num</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l01674"></a>01674                unireg_check_arg, field_name_arg,
<a name="l01675"></a>01675                0, zero_arg,unsigned_arg)
<a name="l01676"></a>01676     {}
<a name="l01677"></a>01677   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l01678"></a>01678   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TINY;}
<a name="l01679"></a>01679   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const</span>
<a name="l01680"></a>01680 <span class="keyword">    </span>{ <span class="keywordflow">return</span> unsigned_flag ? HA_KEYTYPE_BINARY : HA_KEYTYPE_INT8; }
<a name="l01681"></a>01681   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01682"></a>01682                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01683"></a>01683   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l01684"></a>01684   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l01685"></a>01685   type_conversion_status reset(<span class="keywordtype">void</span>) { ptr[0]=0; <span class="keywordflow">return</span> TYPE_OK; }
<a name="l01686"></a>01686   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l01687"></a>01687   longlong val_int(<span class="keywordtype">void</span>);
<a name="l01688"></a>01688   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l01689"></a>01689   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l01690"></a>01690   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l01691"></a>01691   <span class="keywordtype">void</span> <a class="code" href="classField__tiny.html#a0ff3125a0a535c15bc6a4ecd3950485c">make_sort_key</a>(uchar *buff, uint length);
<a name="l01692"></a>01692   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l01693"></a>01693   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l01694"></a>01694   uint32 max_display_length() { <span class="keywordflow">return</span> 4; }
<a name="l01695"></a><a class="code" href="classField__tiny.html#a8844e68b6afcfceed8420fb0ecb69f2f">01695</a>   <a class="code" href="classField__tiny.html">Field_tiny</a> *<a class="code" href="classField__tiny.html#a8844e68b6afcfceed8420fb0ecb69f2f">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l01696"></a>01696     DBUG_ASSERT(type() == MYSQL_TYPE_TINY);
<a name="l01697"></a>01697     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__tiny.html">Field_tiny</a>(*<span class="keyword">this</span>);
<a name="l01698"></a>01698   }
<a name="l01699"></a><a class="code" href="classField__tiny.html#a15819f0068dd61b9b18449121e5e720c">01699</a>   <a class="code" href="classField__tiny.html">Field_tiny</a> *<a class="code" href="classField__tiny.html#a15819f0068dd61b9b18449121e5e720c">clone</a>()<span class="keyword"> const </span>{
<a name="l01700"></a>01700     DBUG_ASSERT(type() == MYSQL_TYPE_TINY);
<a name="l01701"></a>01701     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__tiny.html">Field_tiny</a>(*<span class="keyword">this</span>);
<a name="l01702"></a>01702   }
<a name="l01703"></a><a class="code" href="classField__tiny.html#ac3326a980428d393cd52d821578f87d7">01703</a>   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__tiny.html#ac3326a980428d393cd52d821578f87d7">pack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01704"></a>01704                       uint max_length, <span class="keywordtype">bool</span> low_byte_first)
<a name="l01705"></a>01705   {
<a name="l01706"></a>01706     *to= *from;
<a name="l01707"></a>01707     <span class="keywordflow">return</span> to + 1;
<a name="l01708"></a>01708   }
<a name="l01709"></a>01709 
<a name="l01710"></a><a class="code" href="classField__tiny.html#a1be4d9de39cf9efe57b276614f8f1bf9">01710</a>   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__tiny.html#a1be4d9de39cf9efe57b276614f8f1bf9">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01711"></a>01711                               uint param_data, <span class="keywordtype">bool</span> low_byte_first)
<a name="l01712"></a>01712   {
<a name="l01713"></a>01713     *to= *from;
<a name="l01714"></a>01714     <span class="keywordflow">return</span> from + 1;
<a name="l01715"></a>01715   }
<a name="l01716"></a>01716 };
<a name="l01717"></a>01717 
<a name="l01718"></a>01718 
<a name="l01719"></a><a class="code" href="classField__short.html">01719</a> <span class="keyword">class </span><a class="code" href="classField__short.html">Field_short</a> :<span class="keyword">public</span> <a class="code" href="classField__num.html">Field_num</a> {
<a name="l01720"></a>01720 <span class="keyword">public</span>:
<a name="l01721"></a>01721   <a class="code" href="classField__short.html">Field_short</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01722"></a>01722               uchar null_bit_arg,
<a name="l01723"></a>01723               <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01724"></a>01724               <span class="keywordtype">bool</span> zero_arg, <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01725"></a>01725     :<a class="code" href="classField__num.html#a7f74cee006e7ebcde71d71105bd66ec8">Field_num</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l01726"></a>01726                unireg_check_arg, field_name_arg,
<a name="l01727"></a>01727                0, zero_arg,unsigned_arg)
<a name="l01728"></a>01728     {}
<a name="l01729"></a>01729   <a class="code" href="classField__short.html">Field_short</a>(uint32 len_arg,<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01730"></a>01730               <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01731"></a>01731     :<a class="code" href="classField__num.html#a7f74cee006e7ebcde71d71105bd66ec8">Field_num</a>((uchar*) 0, len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0,0,
<a name="l01732"></a>01732                NONE, field_name_arg, 0, 0, unsigned_arg)
<a name="l01733"></a>01733     {}
<a name="l01734"></a>01734   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l01735"></a>01735   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_SHORT;}
<a name="l01736"></a>01736   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const</span>
<a name="l01737"></a>01737 <span class="keyword">    </span>{ <span class="keywordflow">return</span> unsigned_flag ? HA_KEYTYPE_USHORT_INT : HA_KEYTYPE_SHORT_INT;}
<a name="l01738"></a>01738   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01739"></a>01739                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01740"></a>01740   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l01741"></a>01741   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l01742"></a>01742   type_conversion_status reset(<span class="keywordtype">void</span>) { ptr[0]=ptr[1]=0; <span class="keywordflow">return</span> TYPE_OK; }
<a name="l01743"></a>01743   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l01744"></a>01744   longlong val_int(<span class="keywordtype">void</span>);
<a name="l01745"></a>01745   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l01746"></a>01746   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l01747"></a>01747   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l01748"></a>01748   <span class="keywordtype">void</span> <a class="code" href="classField__short.html#a66ed0cdd53f028080040648f03581dc2">make_sort_key</a>(uchar *buff, uint length);
<a name="l01749"></a>01749   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 2; }
<a name="l01750"></a>01750   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l01751"></a>01751   uint32 max_display_length() { <span class="keywordflow">return</span> 6; }
<a name="l01752"></a><a class="code" href="classField__short.html#a484ccc05a7e55494fc11ef9962c89fbb">01752</a>   <a class="code" href="classField__short.html">Field_short</a> *<a class="code" href="classField__short.html#a484ccc05a7e55494fc11ef9962c89fbb">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l01753"></a>01753     DBUG_ASSERT(type() == MYSQL_TYPE_SHORT);
<a name="l01754"></a>01754     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__short.html">Field_short</a>(*<span class="keyword">this</span>);
<a name="l01755"></a>01755   }
<a name="l01756"></a><a class="code" href="classField__short.html#a5244b3e769ff7187c42f0679cc5ca861">01756</a>   <a class="code" href="classField__short.html">Field_short</a> *<a class="code" href="classField__short.html#a5244b3e769ff7187c42f0679cc5ca861">clone</a>()<span class="keyword"> const </span>{
<a name="l01757"></a>01757     DBUG_ASSERT(type() == MYSQL_TYPE_SHORT);
<a name="l01758"></a>01758     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__short.html">Field_short</a>(*<span class="keyword">this</span>);
<a name="l01759"></a>01759   }
<a name="l01760"></a><a class="code" href="classField__short.html#a53af61e2ddf7e5e25d67e1bd1ea78099">01760</a>   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__short.html#a53af61e2ddf7e5e25d67e1bd1ea78099">pack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01761"></a>01761                       uint max_length, <span class="keywordtype">bool</span> low_byte_first)
<a name="l01762"></a>01762   {
<a name="l01763"></a>01763     <span class="keywordflow">return</span> pack_int16(to, from, low_byte_first);
<a name="l01764"></a>01764   }
<a name="l01765"></a>01765 
<a name="l01766"></a><a class="code" href="classField__short.html#ab017d92c943d172dd8f6691e6657cf7d">01766</a>   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__short.html#ab017d92c943d172dd8f6691e6657cf7d">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01767"></a>01767                               uint param_data, <span class="keywordtype">bool</span> low_byte_first)
<a name="l01768"></a>01768   {
<a name="l01769"></a>01769     <span class="keywordflow">return</span> unpack_int16(to, from, low_byte_first);
<a name="l01770"></a>01770   }
<a name="l01771"></a>01771 };
<a name="l01772"></a>01772 
<a name="l01773"></a><a class="code" href="classField__medium.html">01773</a> <span class="keyword">class </span><a class="code" href="classField__medium.html">Field_medium</a> :<span class="keyword">public</span> <a class="code" href="classField__num.html">Field_num</a> {
<a name="l01774"></a>01774 <span class="keyword">public</span>:
<a name="l01775"></a>01775   <a class="code" href="classField__medium.html">Field_medium</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01776"></a>01776               uchar null_bit_arg,
<a name="l01777"></a>01777               <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01778"></a>01778               <span class="keywordtype">bool</span> zero_arg, <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01779"></a>01779     :<a class="code" href="classField__num.html#a7f74cee006e7ebcde71d71105bd66ec8">Field_num</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l01780"></a>01780                unireg_check_arg, field_name_arg,
<a name="l01781"></a>01781                0, zero_arg,unsigned_arg)
<a name="l01782"></a>01782     {}
<a name="l01783"></a>01783   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l01784"></a>01784   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_INT24;}
<a name="l01785"></a>01785   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const</span>
<a name="l01786"></a>01786 <span class="keyword">    </span>{ <span class="keywordflow">return</span> unsigned_flag ? HA_KEYTYPE_UINT24 : HA_KEYTYPE_INT24; }
<a name="l01787"></a>01787   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01788"></a>01788                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01789"></a>01789   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l01790"></a>01790   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l01791"></a>01791   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l01792"></a>01792   {
<a name="l01793"></a>01793     ptr[0]=ptr[1]=ptr[2]=0;
<a name="l01794"></a>01794     <span class="keywordflow">return</span> TYPE_OK;
<a name="l01795"></a>01795   }
<a name="l01796"></a>01796   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l01797"></a>01797   longlong val_int(<span class="keywordtype">void</span>);
<a name="l01798"></a>01798   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l01799"></a>01799   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l01800"></a>01800   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l01801"></a>01801   <span class="keywordtype">void</span> <a class="code" href="classField__medium.html#ac96fce0de05fdc4f2b5321702f812709">make_sort_key</a>(uchar *buff, uint length);
<a name="l01802"></a>01802   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 3; }
<a name="l01803"></a>01803   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l01804"></a>01804   uint32 max_display_length() { <span class="keywordflow">return</span> 8; }
<a name="l01805"></a><a class="code" href="classField__medium.html#a8d10739fe81068dc02c066d3bf37d68a">01805</a>   <a class="code" href="classField__medium.html">Field_medium</a> *<a class="code" href="classField__medium.html#a8d10739fe81068dc02c066d3bf37d68a">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l01806"></a>01806     DBUG_ASSERT(type() == MYSQL_TYPE_INT24);
<a name="l01807"></a>01807     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__medium.html">Field_medium</a>(*<span class="keyword">this</span>);
<a name="l01808"></a>01808   }
<a name="l01809"></a><a class="code" href="classField__medium.html#a82c933cd2c8d12154d284efa1b7112be">01809</a>   <a class="code" href="classField__medium.html">Field_medium</a> *<a class="code" href="classField__medium.html#a82c933cd2c8d12154d284efa1b7112be">clone</a>()<span class="keyword"> const </span>{
<a name="l01810"></a>01810     DBUG_ASSERT(type() == MYSQL_TYPE_INT24);
<a name="l01811"></a>01811     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__medium.html">Field_medium</a>(*<span class="keyword">this</span>);
<a name="l01812"></a>01812   }
<a name="l01813"></a><a class="code" href="classField__medium.html#a1c93838ae85a69a18a5d3e88da916369">01813</a>   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__medium.html#a1c93838ae85a69a18a5d3e88da916369">pack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01814"></a>01814                       uint max_length, <span class="keywordtype">bool</span> low_byte_first)
<a name="l01815"></a>01815   {
<a name="l01816"></a>01816     <span class="keywordflow">return</span> <a class="code" href="classField__medium.html#a1c93838ae85a69a18a5d3e88da916369">Field::pack</a>(to, from, max_length, low_byte_first);
<a name="l01817"></a>01817   }
<a name="l01818"></a>01818 
<a name="l01819"></a><a class="code" href="classField__medium.html#aa04c697b728c9f1f6c92164d85894030">01819</a>   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__medium.html#aa04c697b728c9f1f6c92164d85894030">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01820"></a>01820                               uint param_data, <span class="keywordtype">bool</span> low_byte_first)
<a name="l01821"></a>01821   {
<a name="l01822"></a>01822     <span class="keywordflow">return</span> <a class="code" href="classField__medium.html#aa04c697b728c9f1f6c92164d85894030">Field::unpack</a>(to, from, param_data, low_byte_first);
<a name="l01823"></a>01823   }
<a name="l01824"></a>01824 };
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 
<a name="l01827"></a><a class="code" href="classField__long.html">01827</a> <span class="keyword">class </span><a class="code" href="classField__long.html">Field_long</a> :<span class="keyword">public</span> <a class="code" href="classField__num.html">Field_num</a> {
<a name="l01828"></a>01828 <span class="keyword">public</span>:
<a name="l01829"></a>01829 
<a name="l01830"></a>01830   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> PACK_LENGTH= 4;
<a name="l01831"></a>01831 
<a name="l01832"></a>01832   <a class="code" href="classField__long.html">Field_long</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01833"></a>01833              uchar null_bit_arg,
<a name="l01834"></a>01834              <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01835"></a>01835              <span class="keywordtype">bool</span> zero_arg, <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01836"></a>01836     :<a class="code" href="classField__num.html#a7f74cee006e7ebcde71d71105bd66ec8">Field_num</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l01837"></a>01837                unireg_check_arg, field_name_arg,
<a name="l01838"></a>01838                0, zero_arg,unsigned_arg)
<a name="l01839"></a>01839     {}
<a name="l01840"></a>01840   <a class="code" href="classField__long.html">Field_long</a>(uint32 len_arg,<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01841"></a>01841              <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01842"></a>01842     :<a class="code" href="classField__num.html#a7f74cee006e7ebcde71d71105bd66ec8">Field_num</a>((uchar*) 0, len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0,0,
<a name="l01843"></a>01843                NONE, field_name_arg,0,0,unsigned_arg)
<a name="l01844"></a>01844     {}
<a name="l01845"></a>01845   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l01846"></a>01846   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_LONG;}
<a name="l01847"></a>01847   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const</span>
<a name="l01848"></a>01848 <span class="keyword">    </span>{ <span class="keywordflow">return</span> unsigned_flag ? HA_KEYTYPE_ULONG_INT : HA_KEYTYPE_LONG_INT; }
<a name="l01849"></a>01849   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01850"></a>01850                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01851"></a>01851   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l01852"></a>01852   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l01853"></a>01853   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l01854"></a>01854   {
<a name="l01855"></a>01855     ptr[0]=ptr[1]=ptr[2]=ptr[3]=0;
<a name="l01856"></a>01856     <span class="keywordflow">return</span> TYPE_OK;
<a name="l01857"></a>01857   }
<a name="l01858"></a>01858   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l01859"></a>01859   longlong val_int(<span class="keywordtype">void</span>);
<a name="l01860"></a>01860   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l01861"></a>01861   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l01862"></a>01862   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l01863"></a>01863   <span class="keywordtype">void</span> <a class="code" href="classField__long.html#a4894375fc53597c03c3bc0c71fac7109">make_sort_key</a>(uchar *buff, uint length);
<a name="l01864"></a>01864   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> PACK_LENGTH; }
<a name="l01865"></a>01865   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l01866"></a>01866   uint32 max_display_length() { <span class="keywordflow">return</span> MY_INT32_NUM_DECIMAL_DIGITS; }
<a name="l01867"></a><a class="code" href="classField__long.html#aa8eb4c96da40f08d8f28b4f8ccac57ce">01867</a>   <a class="code" href="classField__long.html">Field_long</a> *<a class="code" href="classField__long.html#aa8eb4c96da40f08d8f28b4f8ccac57ce">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l01868"></a>01868     DBUG_ASSERT(type() == MYSQL_TYPE_LONG);
<a name="l01869"></a>01869     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__long.html">Field_long</a>(*<span class="keyword">this</span>);
<a name="l01870"></a>01870   }
<a name="l01871"></a><a class="code" href="classField__long.html#a5f8b5bd2eff8d3c2177e1da666126e15">01871</a>   <a class="code" href="classField__long.html">Field_long</a> *<a class="code" href="classField__long.html#a5f8b5bd2eff8d3c2177e1da666126e15">clone</a>()<span class="keyword"> const </span>{
<a name="l01872"></a>01872     DBUG_ASSERT(type() == MYSQL_TYPE_LONG);
<a name="l01873"></a>01873     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__long.html">Field_long</a>(*<span class="keyword">this</span>);
<a name="l01874"></a>01874   }
<a name="l01875"></a>01875   <span class="keyword">virtual</span> uchar *pack(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01876"></a>01876                       uint max_length __attribute__((unused)),
<a name="l01877"></a>01877                       <span class="keywordtype">bool</span> low_byte_first)
<a name="l01878"></a>01878   {
<a name="l01879"></a>01879     <span class="keywordflow">return</span> pack_int32(to, from, low_byte_first);
<a name="l01880"></a>01880   }
<a name="l01881"></a>01881   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *unpack(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01882"></a>01882                               uint param_data __attribute__((unused)),
<a name="l01883"></a>01883                               <span class="keywordtype">bool</span> low_byte_first)
<a name="l01884"></a>01884   {
<a name="l01885"></a>01885     <span class="keywordflow">return</span> unpack_int32(to, from, low_byte_first);
<a name="l01886"></a>01886   }
<a name="l01887"></a>01887 };
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 
<a name="l01890"></a>01890 <span class="preprocessor">#ifdef HAVE_LONG_LONG</span>
<a name="l01891"></a>01891 <span class="preprocessor"></span><span class="keyword">class </span>Field_longlong :<span class="keyword">public</span> <a class="code" href="classField__num.html">Field_num</a> {
<a name="l01892"></a>01892 <span class="keyword">public</span>:
<a name="l01893"></a>01893   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> PACK_LENGTH= 8;
<a name="l01894"></a>01894 
<a name="l01895"></a>01895   Field_longlong(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01896"></a>01896               uchar null_bit_arg,
<a name="l01897"></a>01897               <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01898"></a>01898               <span class="keywordtype">bool</span> zero_arg, <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01899"></a>01899     :<a class="code" href="classField__num.html">Field_num</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l01900"></a>01900                unireg_check_arg, field_name_arg,
<a name="l01901"></a>01901                0, zero_arg,unsigned_arg)
<a name="l01902"></a>01902     {}
<a name="l01903"></a>01903   Field_longlong(uint32 len_arg,<span class="keywordtype">bool</span> maybe_null_arg,
<a name="l01904"></a>01904                  <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01905"></a>01905                   <span class="keywordtype">bool</span> unsigned_arg)
<a name="l01906"></a>01906     :<a class="code" href="classField__num.html">Field_num</a>((uchar*) 0, len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0,0,
<a name="l01907"></a>01907                NONE, field_name_arg,0,0,unsigned_arg)
<a name="l01908"></a>01908     {}
<a name="l01909"></a>01909   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l01910"></a>01910   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_LONGLONG;}
<a name="l01911"></a>01911   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const</span>
<a name="l01912"></a>01912 <span class="keyword">    </span>{ <span class="keywordflow">return</span> unsigned_flag ? HA_KEYTYPE_ULONGLONG : HA_KEYTYPE_LONGLONG; }
<a name="l01913"></a>01913   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01914"></a>01914                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01915"></a>01915   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l01916"></a>01916   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l01917"></a>01917   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l01918"></a>01918   {
<a name="l01919"></a>01919     ptr[0]=ptr[1]=ptr[2]=ptr[3]=ptr[4]=ptr[5]=ptr[6]=ptr[7]=0;
<a name="l01920"></a>01920     <span class="keywordflow">return</span> TYPE_OK;
<a name="l01921"></a>01921   }
<a name="l01922"></a>01922   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l01923"></a>01923   longlong val_int(<span class="keywordtype">void</span>);
<a name="l01924"></a>01924   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l01925"></a>01925   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l01926"></a>01926   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l01927"></a>01927   <span class="keywordtype">void</span> <a class="code" href="classField.html#a8ae56503783e7a91c0e4899527bc6cb5">make_sort_key</a>(uchar *buff, uint length);
<a name="l01928"></a>01928   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> PACK_LENGTH; }
<a name="l01929"></a>01929   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l01930"></a>01930   <span class="keywordtype">bool</span> can_be_compared_as_longlong()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l01931"></a>01931   uint32 max_display_length() { <span class="keywordflow">return</span> 20; }
<a name="l01932"></a>01932   Field_longlong *<a class="code" href="classField.html#a01a9a9aa3a618941e839b1b8793c969d">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l01933"></a>01933     DBUG_ASSERT(type() == MYSQL_TYPE_LONGLONG);
<a name="l01934"></a>01934     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) Field_longlong(*<span class="keyword">this</span>);
<a name="l01935"></a>01935   }
<a name="l01936"></a>01936   Field_longlong *<a class="code" href="classField.html#a01a9a9aa3a618941e839b1b8793c969d">clone</a>()<span class="keyword"> const </span>{
<a name="l01937"></a>01937     DBUG_ASSERT(type() == MYSQL_TYPE_LONGLONG);
<a name="l01938"></a>01938     <span class="keywordflow">return</span> <span class="keyword">new</span> Field_longlong(*<span class="keyword">this</span>);
<a name="l01939"></a>01939   }
<a name="l01940"></a>01940   <span class="keyword">virtual</span> uchar *<a class="code" href="classField.html#a9eaff8d3425ef0e1da69b32cbd8f2879">pack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01941"></a>01941                       uint max_length  __attribute__((unused)),
<a name="l01942"></a>01942                       <span class="keywordtype">bool</span> low_byte_first)
<a name="l01943"></a>01943   {
<a name="l01944"></a>01944     <span class="keywordflow">return</span> pack_int64(to, from, low_byte_first);
<a name="l01945"></a>01945   }
<a name="l01946"></a>01946   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField.html#a42f448ff2c939d91949f7635d939b16b">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l01947"></a>01947                               uint param_data __attribute__((unused)),
<a name="l01948"></a>01948                               <span class="keywordtype">bool</span> low_byte_first)
<a name="l01949"></a>01949   {
<a name="l01950"></a>01950     <span class="keywordflow">return</span> unpack_int64(to, from, low_byte_first);
<a name="l01951"></a>01951   }
<a name="l01952"></a>01952 };
<a name="l01953"></a>01953 <span class="preprocessor">#endif</span>
<a name="l01954"></a>01954 <span class="preprocessor"></span>
<a name="l01955"></a>01955 
<a name="l01956"></a><a class="code" href="classField__float.html">01956</a> <span class="keyword">class </span><a class="code" href="classField__float.html">Field_float</a> :<span class="keyword">public</span> <a class="code" href="classField__real.html">Field_real</a> {
<a name="l01957"></a>01957 <span class="keyword">public</span>:
<a name="l01958"></a>01958   <a class="code" href="classField__float.html">Field_float</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l01959"></a>01959               uchar null_bit_arg,
<a name="l01960"></a>01960               <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01961"></a>01961               uint8 dec_arg,<span class="keywordtype">bool</span> zero_arg,<span class="keywordtype">bool</span> unsigned_arg)
<a name="l01962"></a>01962     :<a class="code" href="classField__real.html">Field_real</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l01963"></a>01963                 unireg_check_arg, field_name_arg,
<a name="l01964"></a>01964                 dec_arg, zero_arg, unsigned_arg)
<a name="l01965"></a>01965     {}
<a name="l01966"></a>01966   <a class="code" href="classField__float.html">Field_float</a>(uint32 len_arg, <span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l01967"></a>01967               uint8 dec_arg)
<a name="l01968"></a>01968     :<a class="code" href="classField__real.html">Field_real</a>((uchar*) 0, len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0, (uint) 0,
<a name="l01969"></a>01969                 NONE, field_name_arg, dec_arg, 0, 0)
<a name="l01970"></a>01970     {}
<a name="l01971"></a>01971   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_FLOAT;}
<a name="l01972"></a>01972   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_FLOAT; }
<a name="l01973"></a>01973   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l01974"></a>01974                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l01975"></a>01975   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l01976"></a>01976   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l01977"></a>01977   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l01978"></a>01978   {
<a name="l01979"></a>01979     memset(ptr, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l01980"></a>01980     <span class="keywordflow">return</span> TYPE_OK;
<a name="l01981"></a>01981   }
<a name="l01982"></a>01982   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l01983"></a>01983   longlong val_int(<span class="keywordtype">void</span>);
<a name="l01984"></a>01984   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l01985"></a>01985   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l01986"></a>01986   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l01987"></a>01987   <span class="keywordtype">void</span> <a class="code" href="classField__float.html#adaf2358f205faa2f0324724304b3f66d">make_sort_key</a>(uchar *buff, uint length);
<a name="l01988"></a>01988   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(float); }
<a name="l01989"></a>01989   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l01990"></a>01990   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l01991"></a><a class="code" href="classField__float.html#a0a8cf0060bfe5b6a830722aa326a580b">01991</a>   <a class="code" href="classField__float.html">Field_float</a> *<a class="code" href="classField__float.html#a0a8cf0060bfe5b6a830722aa326a580b">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l01992"></a>01992     DBUG_ASSERT(type() == MYSQL_TYPE_FLOAT);
<a name="l01993"></a>01993     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__float.html">Field_float</a>(*<span class="keyword">this</span>);
<a name="l01994"></a>01994   }
<a name="l01995"></a><a class="code" href="classField__float.html#a10c10572f1144c3dcfa9b9fa758db6ab">01995</a>   <a class="code" href="classField__float.html">Field_float</a> *<a class="code" href="classField__float.html#a10c10572f1144c3dcfa9b9fa758db6ab">clone</a>()<span class="keyword"> const </span>{
<a name="l01996"></a>01996     DBUG_ASSERT(type() == MYSQL_TYPE_FLOAT);
<a name="l01997"></a>01997     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__float.html">Field_float</a>(*<span class="keyword">this</span>);
<a name="l01998"></a>01998   }
<a name="l01999"></a>01999 <span class="keyword">private</span>:
<a name="l02000"></a>02000   <span class="keywordtype">int</span> do_save_field_metadata(uchar *first_byte);
<a name="l02001"></a>02001 };
<a name="l02002"></a>02002 
<a name="l02003"></a>02003 
<a name="l02004"></a><a class="code" href="classField__double.html">02004</a> <span class="keyword">class </span><a class="code" href="classField__double.html">Field_double</a> :<span class="keyword">public</span> <a class="code" href="classField__real.html">Field_real</a> {
<a name="l02005"></a>02005 <span class="keyword">public</span>:
<a name="l02006"></a>02006   <a class="code" href="classField__double.html">Field_double</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l02007"></a>02007                uchar null_bit_arg,
<a name="l02008"></a>02008                <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02009"></a>02009                uint8 dec_arg,<span class="keywordtype">bool</span> zero_arg,<span class="keywordtype">bool</span> unsigned_arg)
<a name="l02010"></a>02010     :<a class="code" href="classField__real.html">Field_real</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l02011"></a>02011                 unireg_check_arg, field_name_arg,
<a name="l02012"></a>02012                 dec_arg, zero_arg, unsigned_arg)
<a name="l02013"></a>02013     {}
<a name="l02014"></a>02014   <a class="code" href="classField__double.html">Field_double</a>(uint32 len_arg, <span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02015"></a>02015                uint8 dec_arg)
<a name="l02016"></a>02016     :<a class="code" href="classField__real.html">Field_real</a>((uchar*) 0, len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span> : 0, (uint) 0,
<a name="l02017"></a>02017                 NONE, field_name_arg, dec_arg, 0, 0)
<a name="l02018"></a>02018     {}
<a name="l02019"></a>02019   <a class="code" href="classField__double.html">Field_double</a>(uint32 len_arg, <span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02020"></a>02020                uint8 dec_arg, my_bool not_fixed_arg)
<a name="l02021"></a>02021     :<a class="code" href="classField__real.html">Field_real</a>((uchar*) 0, len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span> : 0, (uint) 0,
<a name="l02022"></a>02022                 NONE, field_name_arg, dec_arg, 0, 0)
<a name="l02023"></a>02023     {not_fixed= not_fixed_arg; }
<a name="l02024"></a>02024   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_DOUBLE;}
<a name="l02025"></a>02025   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_DOUBLE; }
<a name="l02026"></a>02026   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l02027"></a>02027                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l02028"></a>02028   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l02029"></a>02029   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l02030"></a>02030   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l02031"></a>02031   {
<a name="l02032"></a>02032     memset(ptr, 0, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l02033"></a>02033     <span class="keywordflow">return</span> TYPE_OK;
<a name="l02034"></a>02034   }
<a name="l02035"></a>02035   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l02036"></a>02036   longlong val_int(<span class="keywordtype">void</span>);
<a name="l02037"></a>02037   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l02038"></a>02038   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l02039"></a>02039   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l02040"></a>02040   <span class="keywordtype">void</span> <a class="code" href="classField__double.html#a05fcc4268b935a9a4937d05b3c6f9c17">make_sort_key</a>(uchar *buff, uint length);
<a name="l02041"></a>02041   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">sizeof</span>(double); }
<a name="l02042"></a>02042   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l02043"></a>02043   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02044"></a><a class="code" href="classField__double.html#a9cf823650aa108bddff68a5310ab733d">02044</a>   <a class="code" href="classField__double.html">Field_double</a> *<a class="code" href="classField__double.html#a9cf823650aa108bddff68a5310ab733d">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l02045"></a>02045     DBUG_ASSERT(type() == MYSQL_TYPE_DOUBLE);
<a name="l02046"></a>02046     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__double.html">Field_double</a>(*<span class="keyword">this</span>);
<a name="l02047"></a>02047   }
<a name="l02048"></a><a class="code" href="classField__double.html#ad1366318921f4e8ef0b594bd10b7fe15">02048</a>   <a class="code" href="classField__double.html">Field_double</a> *<a class="code" href="classField__double.html#ad1366318921f4e8ef0b594bd10b7fe15">clone</a>()<span class="keyword"> const </span>{
<a name="l02049"></a>02049     DBUG_ASSERT(type() == MYSQL_TYPE_DOUBLE);
<a name="l02050"></a>02050     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__double.html">Field_double</a>(*<span class="keyword">this</span>);
<a name="l02051"></a>02051   }
<a name="l02052"></a>02052 <span class="keyword">private</span>:
<a name="l02053"></a>02053   <span class="keywordtype">int</span> do_save_field_metadata(uchar *first_byte);
<a name="l02054"></a>02054 };
<a name="l02055"></a>02055 
<a name="l02056"></a>02056 
<a name="l02057"></a>02057 <span class="comment">/* Everything saved in this will disappear. It will always return NULL */</span>
<a name="l02058"></a>02058 
<a name="l02059"></a><a class="code" href="classField__null.html">02059</a> <span class="keyword">class </span><a class="code" href="classField__null.html">Field_null</a> :<span class="keyword">public</span> <a class="code" href="classField__str.html">Field_str</a> {
<a name="l02060"></a>02060   <span class="keyword">static</span> uchar null[1];
<a name="l02061"></a>02061 <span class="keyword">public</span>:
<a name="l02062"></a>02062   <a class="code" href="classField__null.html">Field_null</a>(uchar *ptr_arg, uint32 len_arg,
<a name="l02063"></a>02063              <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02064"></a>02064              <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l02065"></a>02065     :<a class="code" href="classField__str.html">Field_str</a>(ptr_arg, len_arg, null, 1,
<a name="l02066"></a>02066                unireg_check_arg, field_name_arg, cs)
<a name="l02067"></a>02067     {}
<a name="l02068"></a>02068   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_NULL;}
<a name="l02069"></a>02069   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l02070"></a>02070                                <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l02071"></a>02071   {
<a name="l02072"></a>02072     null[0]= 1;
<a name="l02073"></a>02073     <span class="keywordflow">return</span> TYPE_OK;
<a name="l02074"></a>02074   }
<a name="l02075"></a><a class="code" href="classField__null.html#a396499b751f2dd051b816a3953943d2b">02075</a>   type_conversion_status <a class="code" href="classField__null.html#a396499b751f2dd051b816a3953943d2b">store</a>(<span class="keywordtype">double</span> nr)   { null[0]=1; <span class="keywordflow">return</span> TYPE_OK; }
<a name="l02076"></a>02076   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val)
<a name="l02077"></a>02077   {
<a name="l02078"></a>02078     null[0]=1;
<a name="l02079"></a>02079     <span class="keywordflow">return</span> TYPE_OK;
<a name="l02080"></a>02080   }
<a name="l02081"></a><a class="code" href="classField__null.html#a67a8c81f634b920257aff8736ad6e00e">02081</a>   type_conversion_status <a class="code" href="classField__null.html#a67a8c81f634b920257aff8736ad6e00e">store_decimal</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *d)
<a name="l02082"></a>02082   {
<a name="l02083"></a>02083     null[0]=1;
<a name="l02084"></a>02084     <span class="keywordflow">return</span> TYPE_OK;
<a name="l02085"></a>02085   }
<a name="l02086"></a>02086   type_conversion_status reset(<span class="keywordtype">void</span>)       { <span class="keywordflow">return</span> TYPE_OK; }
<a name="l02087"></a>02087   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>)         { <span class="keywordflow">return</span> 0.0;}
<a name="l02088"></a>02088   longlong val_int(<span class="keywordtype">void</span>)        { <span class="keywordflow">return</span> 0;}
<a name="l02089"></a>02089   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *) { <span class="keywordflow">return</span> 0; }
<a name="l02090"></a>02090   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *value,<a class="code" href="classString.html">String</a> *value2)
<a name="l02091"></a>02091   { value2-&gt;length(0); <span class="keywordflow">return</span> value2;}
<a name="l02092"></a>02092   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *a, <span class="keyword">const</span> uchar *b) { <span class="keywordflow">return</span> 0;}
<a name="l02093"></a><a class="code" href="classField__null.html#a78c1d2710609755bb7825e2364acdd8c">02093</a>   <span class="keywordtype">void</span> <a class="code" href="classField__null.html#a78c1d2710609755bb7825e2364acdd8c">make_sort_key</a>(uchar *buff, uint length)  {}
<a name="l02094"></a>02094   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02095"></a>02095   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02096"></a>02096   uint32 max_display_length() { <span class="keywordflow">return</span> 4; }
<a name="l02097"></a><a class="code" href="classField__null.html#ac690a8b6c05568f3866f3fe8ae484e09">02097</a>   <a class="code" href="classField__null.html">Field_null</a> *<a class="code" href="classField__null.html#ac690a8b6c05568f3866f3fe8ae484e09">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l02098"></a>02098     DBUG_ASSERT(type() == MYSQL_TYPE_NULL);
<a name="l02099"></a>02099     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__null.html">Field_null</a>(*<span class="keyword">this</span>);
<a name="l02100"></a>02100   }
<a name="l02101"></a><a class="code" href="classField__null.html#a067938380dc07e8eae84245846d02421">02101</a>   <a class="code" href="classField__null.html">Field_null</a> *<a class="code" href="classField__null.html#a067938380dc07e8eae84245846d02421">clone</a>()<span class="keyword"> const </span>{
<a name="l02102"></a>02102     DBUG_ASSERT(type() == MYSQL_TYPE_NULL);
<a name="l02103"></a>02103     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__null.html">Field_null</a>(*<span class="keyword">this</span>);
<a name="l02104"></a>02104   }
<a name="l02105"></a>02105 };
<a name="l02106"></a>02106 
<a name="l02107"></a>02107 
<a name="l02108"></a>02108 <span class="comment">/*</span>
<a name="l02109"></a>02109 <span class="comment">  Abstract class for TIME, DATE, DATETIME, TIMESTAMP</span>
<a name="l02110"></a>02110 <span class="comment">  with and without fractional part.</span>
<a name="l02111"></a>02111 <span class="comment">*/</span>
<a name="l02112"></a><a class="code" href="classField__temporal.html">02112</a> <span class="keyword">class </span><a class="code" href="classField__temporal.html">Field_temporal</a> :<span class="keyword">public</span> <a class="code" href="classField.html">Field</a> {
<a name="l02113"></a>02113 <span class="keyword">protected</span>:
<a name="l02114"></a>02114   uint8 dec; <span class="comment">// Number of fractional digits</span>
<a name="l02115"></a>02115 
<a name="l02119"></a><a class="code" href="classField__temporal.html#a59092c5657c6b4dee5043fe3b6009705">02119</a>   uint8 <a class="code" href="classField__temporal.html#a59092c5657c6b4dee5043fe3b6009705">normalize_dec</a>(uint8 dec_arg)
<a name="l02120"></a>02120   { <span class="keywordflow">return</span> dec_arg == NOT_FIXED_DEC ? DATETIME_MAX_DECIMALS : dec_arg; }
<a name="l02121"></a>02121 
<a name="l02132"></a>02132   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField__temporal.html#a21c90848108fc5d00bad242efce2b490">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime,
<a name="l02133"></a>02133                                                 <span class="keywordtype">int</span> *error)= 0;
<a name="l02134"></a>02134 
<a name="l02144"></a>02144   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField__temporal.html#ae2be4bf490d06f2f1707bee19dcbebf4">store_internal_with_round</a>(MYSQL_TIME *ltime,
<a name="l02145"></a>02145                                                            <span class="keywordtype">int</span> *warnings)= 0;
<a name="l02146"></a>02146 
<a name="l02156"></a>02156   type_conversion_status <a class="code" href="classField__temporal.html#afa855ca4829068ed563d0f8c187ed0f6">store_lldiv_t</a>(<span class="keyword">const</span> lldiv_t *lld, <span class="keywordtype">int</span> *warning);
<a name="l02157"></a>02157 
<a name="l02169"></a>02169   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classField__temporal.html#aaf2c9fc3983dc78916893fd2133ce1f2">convert_str_to_TIME</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint len,
<a name="l02170"></a>02170                                    <span class="keyword">const</span> CHARSET_INFO *cs,
<a name="l02171"></a>02171                                    MYSQL_TIME *ltime, 
<a name="l02172"></a>02172                                    MYSQL_TIME_STATUS *status)= 0;
<a name="l02186"></a>02186   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField__temporal.html#a08043a131a33951273dc348cbacd2858">convert_number_to_TIME</a>(longlong nr,
<a name="l02187"></a>02187                                                         <span class="keywordtype">bool</span> unsigned_val,
<a name="l02188"></a>02188                                                         <span class="keywordtype">int</span> nanoseconds,
<a name="l02189"></a>02189                                                         MYSQL_TIME *ltime,
<a name="l02190"></a>02190                                                         <span class="keywordtype">int</span> *warning)= 0;
<a name="l02191"></a>02191 
<a name="l02201"></a>02201   longlong <a class="code" href="classField__temporal.html#a9f8fcf6b926588029301c793c7a84372">convert_number_to_datetime</a>(longlong nr, <span class="keywordtype">bool</span> unsigned_val,
<a name="l02202"></a>02202                                       MYSQL_TIME *ltime, <span class="keywordtype">int</span> *warning);
<a name="l02203"></a>02203 
<a name="l02213"></a>02213   <span class="keywordtype">void</span> <a class="code" href="classField__temporal.html#acd0614abebce85c137fcc3d8e208c309">set_warnings</a>(<a class="code" href="classErrConvString.html">ErrConvString</a> str, <span class="keywordtype">int</span> warnings);
<a name="l02214"></a>02214 
<a name="l02228"></a><a class="code" href="classField__temporal.html#a40a8b9639b6dc23ee9a7bfd42b0d1715">02228</a>   <span class="keyword">virtual</span> ulonglong <a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">date_flags</a>(<span class="keyword">const</span> THD *thd)
<a name="l02229"></a>02229   {
<a name="l02230"></a>02230     <span class="keywordflow">return</span> 0;
<a name="l02231"></a>02231   }
<a name="l02237"></a><a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">02237</a>   <span class="keyword">inline</span> ulonglong <a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">date_flags</a>()
<a name="l02238"></a>02238   {
<a name="l02239"></a>02239     <span class="keywordflow">return</span> <a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">date_flags</a>(table ? table-&gt;in_use : current_thd);
<a name="l02240"></a>02240   }
<a name="l02241"></a>02241 
<a name="l02251"></a>02251   <span class="keywordtype">void</span> <a class="code" href="classField__temporal.html#aa55a858a65f9fe7bad0156acac921f16">set_datetime_warning</a>(Sql_condition::enum_warning_level level, uint code,
<a name="l02252"></a>02252                             <a class="code" href="classErrConvString.html">ErrConvString</a> str,
<a name="l02253"></a>02253                             timestamp_type ts_type, <span class="keywordtype">int</span> cuted_increment);
<a name="l02254"></a>02254 <span class="keyword">public</span>:
<a name="l02265"></a><a class="code" href="classField__temporal.html#a2c22c4b8db86b16bffd9bb5a941b9455">02265</a>   <a class="code" href="classField__temporal.html#a2c22c4b8db86b16bffd9bb5a941b9455">Field_temporal</a>(uchar *ptr_arg,
<a name="l02266"></a>02266                  uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l02267"></a>02267                  <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02268"></a>02268                  uint32 len_arg, uint8 dec_arg)
<a name="l02269"></a>02269     :<a class="code" href="classField.html">Field</a>(ptr_arg,
<a name="l02270"></a>02270            len_arg + ((dec= <a class="code" href="classField__temporal.html#a59092c5657c6b4dee5043fe3b6009705">normalize_dec</a>(dec_arg)) ? dec + 1 : 0),
<a name="l02271"></a>02271            null_ptr_arg, null_bit_arg,
<a name="l02272"></a>02272            unireg_check_arg, field_name_arg)
<a name="l02273"></a>02273     { flags|= BINARY_FLAG; }
<a name="l02281"></a><a class="code" href="classField__temporal.html#a80fd9c8c387d9786056b44381a071772">02281</a>   <a class="code" href="classField__temporal.html#a2c22c4b8db86b16bffd9bb5a941b9455">Field_temporal</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02282"></a>02282                  uint32 len_arg, uint8 dec_arg)
<a name="l02283"></a>02283     :<a class="code" href="classField.html">Field</a>((uchar *) 0, 
<a name="l02284"></a>02284            len_arg + ((dec= <a class="code" href="classField__temporal.html#a59092c5657c6b4dee5043fe3b6009705">normalize_dec</a>(dec_arg)) ? dec + 1 : 0),
<a name="l02285"></a>02285            maybe_null_arg ? (uchar *) <span class="stringliteral">&quot;&quot;</span> : 0, 0,
<a name="l02286"></a>02286            NONE, field_name_arg)
<a name="l02287"></a>02287     { flags|= BINARY_FLAG; }
<a name="l02288"></a>02288   <span class="keyword">virtual</span> Item_result result_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> STRING_RESULT; }
<a name="l02289"></a>02289   <span class="keyword">virtual</span> uint32 max_display_length() { <span class="keywordflow">return</span> field_length; }
<a name="l02290"></a>02290   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> str_needs_quotes() { <span class="keywordflow">return</span> TRUE; }
<a name="l02291"></a>02291   <span class="keyword">virtual</span> uint <a class="code" href="classField__temporal.html#ad9e7766bb91a905a5d81cc1b30d73cfb">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l02292"></a><a class="code" href="classField__temporal.html#a23c064c77b376b596cddf60c92fc1c02">02292</a>   Item_result <a class="code" href="classField__temporal.html#a23c064c77b376b596cddf60c92fc1c02">numeric_context_result_type</a>()<span class="keyword"> const</span>
<a name="l02293"></a>02293 <span class="keyword">  </span>{
<a name="l02294"></a>02294     <span class="keywordflow">return</span> dec ? DECIMAL_RESULT : INT_RESULT;
<a name="l02295"></a>02295   }
<a name="l02296"></a>02296   <span class="keyword">enum</span> Item_result cmp_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l02297"></a>02297   <span class="keyword">enum</span> Derivation derivation()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DERIVATION_NUMERIC; }
<a name="l02298"></a>02298   uint repertoire()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MY_REPERTOIRE_NUMERIC; }
<a name="l02299"></a>02299   <span class="keyword">const</span> CHARSET_INFO *charset()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;my_charset_numeric; }
<a name="l02300"></a>02300   <span class="keywordtype">bool</span> can_be_compared_as_longlong()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l02301"></a>02301   <span class="keywordtype">bool</span> binary()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l02302"></a>02302   type_conversion_status <a class="code" href="classField__temporal.html#a15726346f5faf049c097f626d9492407">store</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint len,
<a name="l02303"></a>02303                                <span class="keyword">const</span> CHARSET_INFO *cs);
<a name="l02304"></a>02304   type_conversion_status store_decimal(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *decimal);
<a name="l02305"></a>02305   type_conversion_status <a class="code" href="classField__temporal.html#a15726346f5faf049c097f626d9492407">store</a>(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l02306"></a>02306   type_conversion_status <a class="code" href="classField__temporal.html#a15726346f5faf049c097f626d9492407">store</a>(<span class="keywordtype">double</span> nr);
<a name="l02307"></a>02307   <span class="keywordtype">double</span> val_real() <span class="comment">// FSP-enable types redefine it.</span>
<a name="l02308"></a>02308   {
<a name="l02309"></a>02309     <span class="keywordflow">return</span> (<span class="keywordtype">double</span>) val_int();
<a name="l02310"></a>02310   }
<a name="l02311"></a>02311   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *decimal_value); <span class="comment">// FSP types redefine it</span>
<a name="l02312"></a>02312 };
<a name="l02313"></a>02313 
<a name="l02314"></a>02314 
<a name="l02320"></a><a class="code" href="classField__temporal__with__date.html">02320</a> <span class="keyword">class </span><a class="code" href="classField__temporal__with__date.html">Field_temporal_with_date</a> :<span class="keyword">public</span> <a class="code" href="classField__temporal.html">Field_temporal</a> {
<a name="l02321"></a>02321 <span class="keyword">protected</span>:
<a name="l02326"></a>02326   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classField__temporal__with__date.html#aef905f77b5430dd2b3ef461ce916b4ef">get_date_internal</a>(MYSQL_TIME *ltime)= 0;
<a name="l02327"></a>02327 
<a name="l02333"></a>02333   <span class="keywordtype">bool</span> <a class="code" href="classField__temporal__with__date.html#a23cf3705a4d1f37ce93bc6d1701be400">get_internal_check_zero</a>(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l02334"></a>02334   
<a name="l02335"></a>02335   type_conversion_status <a class="code" href="classField__temporal__with__date.html#a161cad8d28fa79b793aca5a59b5c9044">convert_number_to_TIME</a>(longlong nr, <span class="keywordtype">bool</span> unsigned_val,
<a name="l02336"></a>02336                                                 <span class="keywordtype">int</span> nanoseconds,
<a name="l02337"></a>02337                                                 MYSQL_TIME *ltime,
<a name="l02338"></a>02338                                                 <span class="keywordtype">int</span> *warning);
<a name="l02339"></a>02339   <span class="keywordtype">bool</span> <a class="code" href="classField__temporal__with__date.html#a83dee44291217d8d4e67f83922d40969">convert_str_to_TIME</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint len, <span class="keyword">const</span> CHARSET_INFO *cs,
<a name="l02340"></a>02340                            MYSQL_TIME *ltime, MYSQL_TIME_STATUS *status);
<a name="l02341"></a>02341   type_conversion_status <a class="code" href="classField__temporal__with__date.html#a737fca0e5e576c4ae32386f6dc306a3c">store_internal_with_round</a>(MYSQL_TIME *ltime,
<a name="l02342"></a>02342                                                    <span class="keywordtype">int</span> *warnings);
<a name="l02343"></a>02343 <span class="keyword">public</span>:
<a name="l02354"></a><a class="code" href="classField__temporal__with__date.html#add449ec4ea8b3be7ee002d3def0a9c02">02354</a>   <a class="code" href="classField__temporal__with__date.html#add449ec4ea8b3be7ee002d3def0a9c02">Field_temporal_with_date</a>(uchar *ptr_arg, uchar *null_ptr_arg,
<a name="l02355"></a>02355                            uchar null_bit_arg,
<a name="l02356"></a>02356                            <span class="keyword">enum</span> utype unireg_check_arg,
<a name="l02357"></a>02357                            <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02358"></a>02358                            uint8 int_length_arg, uint8 dec_arg)
<a name="l02359"></a>02359     :<a class="code" href="classField__temporal.html">Field_temporal</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l02360"></a>02360                     unireg_check_arg, field_name_arg,
<a name="l02361"></a>02361                     int_length_arg, dec_arg)
<a name="l02362"></a>02362     { }
<a name="l02370"></a><a class="code" href="classField__temporal__with__date.html#a6898bd8188ce0c64a09ef367efdad6f3">02370</a>   <a class="code" href="classField__temporal__with__date.html#add449ec4ea8b3be7ee002d3def0a9c02">Field_temporal_with_date</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02371"></a>02371                            uint int_length_arg, uint8 dec_arg)
<a name="l02372"></a>02372     :<a class="code" href="classField__temporal.html">Field_temporal</a>((uchar*) 0, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0, 0,
<a name="l02373"></a>02373                     NONE, field_name_arg, int_length_arg, dec_arg)
<a name="l02374"></a>02374     { }
<a name="l02375"></a>02375   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l02376"></a>02376   type_conversion_status <a class="code" href="classField__temporal__with__date.html#aa93167bb62fc7b8e0428ef1e3baaaf7c">store_time</a>(MYSQL_TIME *ltime, uint8 dec);
<a name="l02377"></a>02377   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *, <a class="code" href="classString.html">String</a> *);
<a name="l02378"></a>02378   longlong <a class="code" href="classField__temporal__with__date.html#acf8330ac7e19ae7bdf978fc811e49c00">val_time_temporal</a>();
<a name="l02379"></a>02379   longlong <a class="code" href="classField__temporal__with__date.html#a3d1a5e9fb109d1da223753c6072436ab">val_date_temporal</a>();
<a name="l02380"></a>02380   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l02381"></a>02381   {
<a name="l02382"></a>02382     <span class="keywordflow">return</span> get_date(ltime, TIME_FUZZY_DATE);
<a name="l02383"></a>02383   }
<a name="l02384"></a>02384   <span class="comment">/* Validate the value stored in a field */</span>
<a name="l02385"></a>02385   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField__temporal__with__date.html#af9ebe4d96a6a81232e4a41e4b1d7b599">validate_stored_val</a>(THD *thd);
<a name="l02386"></a>02386 };
<a name="l02387"></a>02387 
<a name="l02388"></a>02388 
<a name="l02394"></a><a class="code" href="classField__temporal__with__date__and__time.html">02394</a> <span class="keyword">class </span><a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a> :<span class="keyword">public</span> <a class="code" href="classField__temporal__with__date.html">Field_temporal_with_date</a> {
<a name="l02395"></a>02395 <span class="keyword">private</span>:
<a name="l02396"></a>02396   <span class="keywordtype">int</span> do_save_field_metadata(uchar *metadata_ptr)
<a name="l02397"></a>02397   {
<a name="l02398"></a>02398     <span class="keywordflow">if</span> (decimals())
<a name="l02399"></a>02399     {
<a name="l02400"></a>02400       *metadata_ptr= decimals();
<a name="l02401"></a>02401       <span class="keywordflow">return</span> 1;
<a name="l02402"></a>02402     }
<a name="l02403"></a>02403     <span class="keywordflow">return</span> 0;
<a name="l02404"></a>02404   }
<a name="l02405"></a>02405 <span class="keyword">protected</span>:
<a name="l02412"></a>02412   <span class="keywordtype">void</span> <a class="code" href="classField__temporal__with__date__and__time.html#ac497834ddc1ef395a387790d97cfb63d">init_timestamp_flags</a>();
<a name="l02418"></a>02418   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classField__temporal__with__date__and__time.html#a3cfd6dc59b102362d592341dbf40a19e">store_timestamp_internal</a>(<span class="keyword">const</span> <span class="keyword">struct</span> timeval *tm)= 0;
<a name="l02419"></a>02419   <span class="keywordtype">bool</span> convert_TIME_to_timestamp(THD *thd, <span class="keyword">const</span> MYSQL_TIME *ltime,
<a name="l02420"></a>02420                                  <span class="keyword">struct</span> timeval *tm, <span class="keywordtype">int</span> *error);
<a name="l02421"></a>02421 
<a name="l02422"></a>02422 <span class="keyword">public</span>:
<a name="l02432"></a><a class="code" href="classField__temporal__with__date__and__time.html#a60d02d91b14a2b46453e749156f42486">02432</a>   <a class="code" href="classField__temporal__with__date__and__time.html#a60d02d91b14a2b46453e749156f42486">Field_temporal_with_date_and_time</a>(uchar *ptr_arg, uchar *null_ptr_arg,
<a name="l02433"></a>02433                                     uchar null_bit_arg,
<a name="l02434"></a>02434                                     <span class="keyword">enum</span> utype unireg_check_arg,
<a name="l02435"></a>02435                                     <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02436"></a>02436                                     uint8 dec_arg)
<a name="l02437"></a>02437     :<a class="code" href="classField__temporal__with__date.html">Field_temporal_with_date</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l02438"></a>02438                               unireg_check_arg, field_name_arg,
<a name="l02439"></a>02439                               MAX_DATETIME_WIDTH, dec_arg)
<a name="l02440"></a>02440     { }
<a name="l02441"></a>02441   <span class="keywordtype">void</span> store_timestamp(<span class="keyword">const</span> <span class="keyword">struct</span> timeval *tm);
<a name="l02442"></a>02442 };
<a name="l02443"></a>02443 
<a name="l02444"></a>02444 
<a name="l02449"></a><a class="code" href="classField__temporal__with__date__and__timef.html">02449</a> <span class="keyword">class </span><a class="code" href="classField__temporal__with__date__and__timef.html">Field_temporal_with_date_and_timef</a> :
<a name="l02450"></a>02450   <span class="keyword">public</span> <a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a> {
<a name="l02451"></a>02451 <span class="keyword">private</span>:
<a name="l02452"></a>02452   <span class="keywordtype">int</span> do_save_field_metadata(uchar *metadata_ptr)
<a name="l02453"></a>02453   {
<a name="l02454"></a>02454     *metadata_ptr= decimals();
<a name="l02455"></a>02455     <span class="keywordflow">return</span> 1;
<a name="l02456"></a>02456   }
<a name="l02457"></a>02457 <span class="keyword">public</span>:
<a name="l02467"></a><a class="code" href="classField__temporal__with__date__and__timef.html#abd543fce5b4062ed73faf037ec246838">02467</a>   <a class="code" href="classField__temporal__with__date__and__timef.html#abd543fce5b4062ed73faf037ec246838">Field_temporal_with_date_and_timef</a>(uchar *ptr_arg, uchar *null_ptr_arg,
<a name="l02468"></a>02468                                      uchar null_bit_arg,
<a name="l02469"></a>02469                                      <span class="keyword">enum</span> utype unireg_check_arg,
<a name="l02470"></a>02470                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02471"></a>02471                                      uint8 dec_arg)
<a name="l02472"></a>02472     :<a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l02473"></a>02473                                        unireg_check_arg, field_name_arg,
<a name="l02474"></a>02474                                        dec_arg)
<a name="l02475"></a>02475     { }
<a name="l02482"></a><a class="code" href="classField__temporal__with__date__and__timef.html#ae0d5affe5618da2f78f45a9ca2304a0b">02482</a>   <a class="code" href="classField__temporal__with__date__and__timef.html#abd543fce5b4062ed73faf037ec246838">Field_temporal_with_date_and_timef</a>(<span class="keywordtype">bool</span> maybe_null_arg,
<a name="l02483"></a>02483                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02484"></a>02484                                      uint8 dec_arg)
<a name="l02485"></a>02485     :<a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a>((uchar *) 0,
<a name="l02486"></a>02486                                        maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span> : 0, 0,
<a name="l02487"></a>02487                                        NONE, field_name_arg, dec_arg)
<a name="l02488"></a>02488     { }
<a name="l02489"></a>02489 
<a name="l02490"></a>02490   uint decimals()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dec; }
<a name="l02491"></a>02491   <span class="keyword">const</span> CHARSET_INFO *sort_charset()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;my_charset_bin; }
<a name="l02492"></a><a class="code" href="classField__temporal__with__date__and__timef.html#a6ff94e53b1ab4b159d7c224e6b1c7c3e">02492</a>   <span class="keywordtype">void</span> <a class="code" href="classField__temporal__with__date__and__timef.html#a6ff94e53b1ab4b159d7c224e6b1c7c3e">make_sort_key</a>(uchar *to, uint length) { memcpy(to, ptr, length); }
<a name="l02493"></a>02493   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *a_ptr, <span class="keyword">const</span> uchar *b_ptr)
<a name="l02494"></a>02494   {
<a name="l02495"></a>02495     <span class="keywordflow">return</span> memcmp(a_ptr, b_ptr, pack_length());
<a name="l02496"></a>02496   }
<a name="l02497"></a>02497   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l02498"></a>02498   <span class="keywordtype">double</span> val_real();
<a name="l02499"></a>02499   longlong val_int();
<a name="l02500"></a>02500   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *decimal_value);
<a name="l02501"></a>02501 };
<a name="l02502"></a>02502 
<a name="l02503"></a>02503 
<a name="l02504"></a>02504 <span class="comment">/*</span>
<a name="l02505"></a>02505 <span class="comment">  Field implementing TIMESTAMP data type without fractional seconds.</span>
<a name="l02506"></a>02506 <span class="comment">  We will be removed eventually.</span>
<a name="l02507"></a>02507 <span class="comment">*/</span>
<a name="l02508"></a><a class="code" href="classField__timestamp.html">02508</a> <span class="keyword">class </span><a class="code" href="classField__timestamp.html">Field_timestamp</a> :<span class="keyword">public</span> <a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a> {
<a name="l02509"></a>02509 <span class="keyword">protected</span>:
<a name="l02510"></a>02510   ulonglong <a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">date_flags</a>(<span class="keyword">const</span> THD *thd);
<a name="l02511"></a>02511   type_conversion_status <a class="code" href="classField__timestamp.html#a6bc92004c2d2df2242f0c6223b078432">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime, <span class="keywordtype">int</span> *error);
<a name="l02512"></a>02512   <span class="keywordtype">bool</span> <a class="code" href="classField__timestamp.html#aff69ed0b8fb6329aa9dd6dceb14ddd27">get_date_internal</a>(MYSQL_TIME *ltime);
<a name="l02513"></a>02513   <span class="keywordtype">void</span> <a class="code" href="classField__timestamp.html#a3dfb1ebf99c1e7da4296ddb6751deb91">store_timestamp_internal</a>(<span class="keyword">const</span> <span class="keyword">struct</span> timeval *tm);
<a name="l02514"></a>02514 <span class="keyword">public</span>:
<a name="l02515"></a>02515   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> PACK_LENGTH= 4;
<a name="l02516"></a>02516   <a class="code" href="classField__timestamp.html#ad53b84d4e965c99d46bc897a099d17f6">Field_timestamp</a>(uchar *ptr_arg, uint32 len_arg,
<a name="l02517"></a>02517                   uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l02518"></a>02518                   <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg);
<a name="l02519"></a>02519   <a class="code" href="classField__timestamp.html#ad53b84d4e965c99d46bc897a099d17f6">Field_timestamp</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg);
<a name="l02520"></a>02520   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TIMESTAMP;}
<a name="l02521"></a>02521   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_ULONG_INT; }
<a name="l02522"></a>02522   type_conversion_status <a class="code" href="classField__timestamp.html#aed9a6035937206a33864b8a6124791ee">store_packed</a>(longlong nr);
<a name="l02523"></a>02523   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l02524"></a>02524   {
<a name="l02525"></a>02525     ptr[0]=ptr[1]=ptr[2]=ptr[3]=0;
<a name="l02526"></a>02526     <span class="keywordflow">return</span> TYPE_OK;
<a name="l02527"></a>02527   }
<a name="l02528"></a>02528   longlong val_int(<span class="keywordtype">void</span>);
<a name="l02529"></a>02529   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l02530"></a>02530   <span class="keywordtype">void</span> <a class="code" href="classField__timestamp.html#ac3377b83381cf691693c6c200ad71195">make_sort_key</a>(uchar *buff, uint length);
<a name="l02531"></a>02531   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> PACK_LENGTH; }
<a name="l02532"></a>02532   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02533"></a>02533   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02534"></a>02534   <span class="comment">/* Get TIMESTAMP field value as seconds since begging of Unix Epoch */</span>
<a name="l02535"></a>02535   <span class="keywordtype">bool</span> <a class="code" href="classField__timestamp.html#a462bff06ee84cafedf33b0a23d56a0f2">get_timestamp</a>(<span class="keyword">struct</span> timeval *tm, <span class="keywordtype">int</span> *warnings);
<a name="l02536"></a>02536   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime,uint fuzzydate);
<a name="l02537"></a><a class="code" href="classField__timestamp.html#a0b3be133c2f8156a9b5ef5fa3544cfb1">02537</a>   <a class="code" href="classField__timestamp.html">Field_timestamp</a> *<a class="code" href="classField__timestamp.html#a0b3be133c2f8156a9b5ef5fa3544cfb1">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l02538"></a>02538     DBUG_ASSERT(type() == MYSQL_TYPE_TIMESTAMP);
<a name="l02539"></a>02539     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__timestamp.html#ad53b84d4e965c99d46bc897a099d17f6">Field_timestamp</a>(*<span class="keyword">this</span>);
<a name="l02540"></a>02540   }
<a name="l02541"></a><a class="code" href="classField__timestamp.html#a0b89c1ee22254ce7e62e089ec70a904c">02541</a>   <a class="code" href="classField__timestamp.html">Field_timestamp</a> *<a class="code" href="classField__timestamp.html#a0b89c1ee22254ce7e62e089ec70a904c">clone</a>()<span class="keyword"> const</span>
<a name="l02542"></a>02542 <span class="keyword">  </span>{
<a name="l02543"></a>02543     DBUG_ASSERT(type() == MYSQL_TYPE_TIMESTAMP);
<a name="l02544"></a>02544     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__timestamp.html#ad53b84d4e965c99d46bc897a099d17f6">Field_timestamp</a>(*<span class="keyword">this</span>);
<a name="l02545"></a>02545   }
<a name="l02546"></a>02546   uchar *pack(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l02547"></a>02547               uint max_length __attribute__((unused)), <span class="keywordtype">bool</span> low_byte_first)
<a name="l02548"></a>02548   {
<a name="l02549"></a>02549     <span class="keywordflow">return</span> pack_int32(to, from, low_byte_first);
<a name="l02550"></a>02550   }
<a name="l02551"></a>02551   <span class="keyword">const</span> uchar *unpack(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l02552"></a>02552                       uint param_data __attribute__((unused)),
<a name="l02553"></a>02553                       <span class="keywordtype">bool</span> low_byte_first)
<a name="l02554"></a>02554   {
<a name="l02555"></a>02555     <span class="keywordflow">return</span> unpack_int32(to, from, low_byte_first);
<a name="l02556"></a>02556   }
<a name="l02557"></a>02557   <span class="comment">/* Validate the value stored in a field */</span>
<a name="l02558"></a>02558   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField__timestamp.html#ac6253aa19d757ba5607be97fbbefe02a">validate_stored_val</a>(THD *thd);
<a name="l02559"></a>02559 };
<a name="l02560"></a>02560 
<a name="l02561"></a>02561 
<a name="l02562"></a>02562 <span class="comment">/*</span>
<a name="l02563"></a>02563 <span class="comment">  Field implementing TIMESTAMP(N) data type, where N=0..6.</span>
<a name="l02564"></a>02564 <span class="comment">*/</span>
<a name="l02565"></a><a class="code" href="classField__timestampf.html">02565</a> <span class="keyword">class </span><a class="code" href="classField__timestampf.html">Field_timestampf</a> :<span class="keyword">public</span> <a class="code" href="classField__temporal__with__date__and__timef.html">Field_temporal_with_date_and_timef</a> {
<a name="l02566"></a>02566 <span class="keyword">protected</span>:
<a name="l02567"></a>02567   <span class="keywordtype">bool</span> <a class="code" href="classField__timestampf.html#a2f546414955a5ad516e77dc821ff5f47">get_date_internal</a>(MYSQL_TIME *ltime);
<a name="l02568"></a>02568   type_conversion_status <a class="code" href="classField__timestampf.html#a383fd42f33dd3a95ecccb841a7209fdb">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime, <span class="keywordtype">int</span> *error);
<a name="l02569"></a>02569   ulonglong <a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">date_flags</a>(<span class="keyword">const</span> THD *thd);
<a name="l02570"></a>02570   <span class="keywordtype">void</span> <a class="code" href="classField__timestampf.html#a93e60b040799d30057489d11e3c65676">store_timestamp_internal</a>(<span class="keyword">const</span> <span class="keyword">struct</span> timeval *tm);
<a name="l02571"></a>02571 <span class="keyword">public</span>:
<a name="l02572"></a>02572   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> PACK_LENGTH= 8;
<a name="l02583"></a>02583   <a class="code" href="classField__timestampf.html#a2f06a04cbc5f999c3c16413a3a489b5c">Field_timestampf</a>(uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l02584"></a>02584                    <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02585"></a>02585                    uint8 dec_arg);
<a name="l02592"></a>02592   <a class="code" href="classField__timestampf.html#a2f06a04cbc5f999c3c16413a3a489b5c">Field_timestampf</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02593"></a>02593                    uint8 dec_arg);
<a name="l02594"></a><a class="code" href="classField__timestampf.html#a5086b9d8ba4ea51ca53062c12797285e">02594</a>   <a class="code" href="classField__timestampf.html">Field_timestampf</a> *<a class="code" href="classField__timestampf.html#ae0a1c73dafdbfbb3da067bcb569dea42">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l02595"></a>02595 <span class="keyword">  </span>{
<a name="l02596"></a>02596     DBUG_ASSERT(type() == MYSQL_TYPE_TIMESTAMP);
<a name="l02597"></a>02597     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__timestampf.html#a2f06a04cbc5f999c3c16413a3a489b5c">Field_timestampf</a>(*<span class="keyword">this</span>);
<a name="l02598"></a>02598   }
<a name="l02599"></a><a class="code" href="classField__timestampf.html#ae0a1c73dafdbfbb3da067bcb569dea42">02599</a>   <a class="code" href="classField__timestampf.html">Field_timestampf</a> *<a class="code" href="classField__timestampf.html#ae0a1c73dafdbfbb3da067bcb569dea42">clone</a>()<span class="keyword"> const</span>
<a name="l02600"></a>02600 <span class="keyword">  </span>{
<a name="l02601"></a>02601     DBUG_ASSERT(type() == MYSQL_TYPE_TIMESTAMP);
<a name="l02602"></a>02602     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__timestampf.html#a2f06a04cbc5f999c3c16413a3a489b5c">Field_timestampf</a>(*<span class="keyword">this</span>);
<a name="l02603"></a>02603   }
<a name="l02604"></a>02604 
<a name="l02605"></a>02605   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TIMESTAMP; }
<a name="l02606"></a>02606   enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TIMESTAMP2; }
<a name="l02607"></a>02607   enum_field_types binlog_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TIMESTAMP2; }
<a name="l02608"></a>02608   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l02609"></a>02609 
<a name="l02610"></a>02610   uint32 pack_length()<span class="keyword"> const</span>
<a name="l02611"></a>02611 <span class="keyword">  </span>{
<a name="l02612"></a>02612     <span class="keywordflow">return</span> my_timestamp_binary_length(dec);
<a name="l02613"></a>02613   }
<a name="l02614"></a>02614   <span class="keyword">virtual</span> uint pack_length_from_metadata(uint field_metadata)
<a name="l02615"></a>02615   {
<a name="l02616"></a>02616     DBUG_ENTER(<span class="stringliteral">&quot;Field_timestampf::pack_length_from_metadata&quot;</span>);
<a name="l02617"></a>02617     uint tmp= my_timestamp_binary_length(field_metadata);
<a name="l02618"></a>02618     DBUG_RETURN(tmp);
<a name="l02619"></a>02619   }
<a name="l02620"></a>02620 
<a name="l02621"></a>02621   type_conversion_status reset();
<a name="l02622"></a>02622   type_conversion_status <a class="code" href="classField__timestampf.html#ae2dfad15c21906d8651e3f52bdc6c263">store_packed</a>(longlong nr);
<a name="l02623"></a>02623   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l02624"></a>02624   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02625"></a>02625 
<a name="l02626"></a>02626   <span class="keywordtype">bool</span> <a class="code" href="classField__timestampf.html#a72149682778248e2084a68f08738c3a6">get_timestamp</a>(<span class="keyword">struct</span> timeval *tm, <span class="keywordtype">int</span> *warnings);
<a name="l02627"></a>02627   <span class="comment">/* Validate the value stored in a field */</span>
<a name="l02628"></a>02628   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField__timestampf.html#a3a96ed01920259945daf2744367a94f1">validate_stored_val</a>(THD *thd);
<a name="l02629"></a>02629 };
<a name="l02630"></a>02630 
<a name="l02631"></a>02631 
<a name="l02632"></a><a class="code" href="classField__year.html">02632</a> <span class="keyword">class </span><a class="code" href="classField__year.html">Field_year</a> :<span class="keyword">public</span> <a class="code" href="classField__tiny.html">Field_tiny</a> {
<a name="l02633"></a>02633 <span class="keyword">public</span>:
<a name="l02634"></a>02634   <a class="code" href="classField__year.html">Field_year</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l02635"></a>02635              uchar null_bit_arg,
<a name="l02636"></a>02636              <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg)
<a name="l02637"></a>02637     :<a class="code" href="classField__tiny.html">Field_tiny</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l02638"></a>02638                 unireg_check_arg, field_name_arg, 1, 1)
<a name="l02639"></a>02639     {}
<a name="l02640"></a>02640   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_YEAR;}
<a name="l02641"></a>02641   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to,uint length,
<a name="l02642"></a>02642                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l02643"></a>02643   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l02644"></a>02644   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l02645"></a>02645   type_conversion_status <a class="code" href="classField__year.html#a20cfacc8efbe8c12137deea34c287be0">store_time</a>(MYSQL_TIME *ltime, uint8 dec);
<a name="l02646"></a>02646   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l02647"></a>02647   longlong val_int(<span class="keywordtype">void</span>);
<a name="l02648"></a>02648   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l02649"></a>02649   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l02650"></a>02650   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02651"></a>02651   <span class="keywordtype">bool</span> can_be_compared_as_longlong()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l02652"></a><a class="code" href="classField__year.html#add7d91326382e2ed08f8ebf080e8ea58">02652</a>   <a class="code" href="classField__year.html">Field_year</a> *<a class="code" href="classField__year.html#add7d91326382e2ed08f8ebf080e8ea58">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l02653"></a>02653     DBUG_ASSERT(type() == MYSQL_TYPE_YEAR);
<a name="l02654"></a>02654     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__year.html">Field_year</a>(*<span class="keyword">this</span>);
<a name="l02655"></a>02655   }
<a name="l02656"></a><a class="code" href="classField__year.html#a4458bc7f6192a939dbe83aaf85b853f5">02656</a>   <a class="code" href="classField__year.html">Field_year</a> *<a class="code" href="classField__year.html#a4458bc7f6192a939dbe83aaf85b853f5">clone</a>()<span class="keyword"> const </span>{
<a name="l02657"></a>02657     DBUG_ASSERT(type() == MYSQL_TYPE_YEAR);
<a name="l02658"></a>02658     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__year.html">Field_year</a>(*<span class="keyword">this</span>);
<a name="l02659"></a>02659   }
<a name="l02660"></a>02660 };
<a name="l02661"></a>02661 
<a name="l02662"></a>02662 
<a name="l02663"></a><a class="code" href="classField__newdate.html">02663</a> <span class="keyword">class </span><a class="code" href="classField__newdate.html">Field_newdate</a> :<span class="keyword">public</span> <a class="code" href="classField__temporal__with__date.html">Field_temporal_with_date</a> {
<a name="l02664"></a>02664 <span class="keyword">protected</span>:
<a name="l02665"></a>02665   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> PACK_LENGTH= 3;
<a name="l02666"></a>02666   ulonglong <a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">date_flags</a>(<span class="keyword">const</span> THD *thd);
<a name="l02667"></a>02667   <span class="keywordtype">bool</span> <a class="code" href="classField__newdate.html#a108e583a4ec9f51e7f1a28d179b3b725">get_date_internal</a>(MYSQL_TIME *ltime);
<a name="l02668"></a>02668   type_conversion_status <a class="code" href="classField__newdate.html#a9b619622de655b7f82a85052854a2395">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime, <span class="keywordtype">int</span> *error);
<a name="l02669"></a>02669 
<a name="l02670"></a>02670 <span class="keyword">public</span>:
<a name="l02671"></a>02671   <a class="code" href="classField__newdate.html">Field_newdate</a>(uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l02672"></a>02672                 <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg)
<a name="l02673"></a>02673     :<a class="code" href="classField__temporal__with__date.html#add449ec4ea8b3be7ee002d3def0a9c02">Field_temporal_with_date</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l02674"></a>02674                               unireg_check_arg, field_name_arg,
<a name="l02675"></a>02675                               MAX_DATE_WIDTH, 0)
<a name="l02676"></a>02676     { }
<a name="l02677"></a>02677   <a class="code" href="classField__newdate.html">Field_newdate</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg)
<a name="l02678"></a>02678     :<a class="code" href="classField__temporal__with__date.html#add449ec4ea8b3be7ee002d3def0a9c02">Field_temporal_with_date</a>((uchar *) 0, maybe_null_arg ? (uchar *) <span class="stringliteral">&quot;&quot;</span> : 0,
<a name="l02679"></a>02679                               0, NONE, field_name_arg, MAX_DATE_WIDTH, 0)
<a name="l02680"></a>02680     { }
<a name="l02681"></a>02681   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_DATE;}
<a name="l02682"></a>02682   enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_NEWDATE; }
<a name="l02683"></a>02683   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_UINT24; }
<a name="l02684"></a>02684   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l02685"></a>02685   {
<a name="l02686"></a>02686     ptr[0]=ptr[1]=ptr[2]=0;
<a name="l02687"></a>02687     <span class="keywordflow">return</span> TYPE_OK;
<a name="l02688"></a>02688   }
<a name="l02689"></a>02689   type_conversion_status <a class="code" href="classField__newdate.html#a4f741d8531290394ba08ee165498e830">store_packed</a>(longlong nr);
<a name="l02690"></a>02690   longlong val_int(<span class="keywordtype">void</span>);
<a name="l02691"></a>02691   longlong <a class="code" href="classField__newdate.html#aad085aaff8fef3367986f9733b79605c">val_time_temporal</a>();
<a name="l02692"></a>02692   longlong <a class="code" href="classField__newdate.html#a06c3392cc8329a524f544360d789fc3d">val_date_temporal</a>();
<a name="l02693"></a>02693   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l02694"></a>02694   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l02695"></a>02695   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l02696"></a>02696   <span class="keywordtype">void</span> <a class="code" href="classField__newdate.html#ab4b22574c9bcb951970065c7a102eaa8">make_sort_key</a>(uchar *buff, uint length);
<a name="l02697"></a>02697   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> PACK_LENGTH; }
<a name="l02698"></a>02698   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02699"></a>02699   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l02700"></a>02700   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime,uint fuzzydate);
<a name="l02701"></a><a class="code" href="classField__newdate.html#a558e66f12314f2827dae9d21700e4733">02701</a>   <a class="code" href="classField__newdate.html">Field_newdate</a> *<a class="code" href="classField__newdate.html#a2bb7b55b27cbe543080cfd63e31e68fd">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l02702"></a>02702 <span class="keyword">  </span>{
<a name="l02703"></a>02703     DBUG_ASSERT(type() == MYSQL_TYPE_DATE);
<a name="l02704"></a>02704     DBUG_ASSERT(real_type() == MYSQL_TYPE_NEWDATE);
<a name="l02705"></a>02705     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__newdate.html">Field_newdate</a>(*<span class="keyword">this</span>);
<a name="l02706"></a>02706   }
<a name="l02707"></a><a class="code" href="classField__newdate.html#a2bb7b55b27cbe543080cfd63e31e68fd">02707</a>   <a class="code" href="classField__newdate.html">Field_newdate</a> *<a class="code" href="classField__newdate.html#a2bb7b55b27cbe543080cfd63e31e68fd">clone</a>()<span class="keyword"> const</span>
<a name="l02708"></a>02708 <span class="keyword">  </span>{
<a name="l02709"></a>02709     DBUG_ASSERT(type() == MYSQL_TYPE_DATE);
<a name="l02710"></a>02710     DBUG_ASSERT(real_type() == MYSQL_TYPE_NEWDATE);
<a name="l02711"></a>02711     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__newdate.html">Field_newdate</a>(*<span class="keyword">this</span>);
<a name="l02712"></a>02712   }
<a name="l02713"></a>02713 };
<a name="l02714"></a>02714 
<a name="l02715"></a>02715 
<a name="l02719"></a><a class="code" href="classField__time__common.html">02719</a> <span class="keyword">class </span><a class="code" href="classField__time__common.html">Field_time_common</a> :<span class="keyword">public</span> <a class="code" href="classField__temporal.html">Field_temporal</a> {
<a name="l02720"></a>02720 <span class="keyword">protected</span>:
<a name="l02721"></a>02721   <span class="keywordtype">bool</span> <a class="code" href="classField__time__common.html#a37df6d4e5624496f6b4f882cbc2abf87">convert_str_to_TIME</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint len, <span class="keyword">const</span> CHARSET_INFO *cs,
<a name="l02722"></a>02722                            MYSQL_TIME *ltime, MYSQL_TIME_STATUS *status);
<a name="l02728"></a>02728   type_conversion_status <a class="code" href="classField__time__common.html#ab30cf710ffb3f033da46e5e43430490d">convert_number_to_TIME</a>(longlong nr, <span class="keywordtype">bool</span> unsigned_val,
<a name="l02729"></a>02729                                                 <span class="keywordtype">int</span> nanoseconds,
<a name="l02730"></a>02730                                                 MYSQL_TIME *ltime,
<a name="l02731"></a>02731                                                 <span class="keywordtype">int</span> *warning);
<a name="l02736"></a>02736   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField__time__common.html#a86071ced0943d9626dd07e2cdf387875">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime,
<a name="l02737"></a>02737                                                 <span class="keywordtype">int</span> *error)= 0;
<a name="l02742"></a>02742   <span class="keyword">virtual</span> type_conversion_status <a class="code" href="classField__time__common.html#af094223508c3096845af6a1d95caa82c">store_internal_with_round</a>(MYSQL_TIME *ltime,
<a name="l02743"></a>02743                                                            <span class="keywordtype">int</span> *warnings);
<a name="l02744"></a>02744 <span class="keyword">public</span>:
<a name="l02754"></a><a class="code" href="classField__time__common.html#a4dafe0dc9d97419ac274303c339bff04">02754</a>   <a class="code" href="classField__time__common.html#a4dafe0dc9d97419ac274303c339bff04">Field_time_common</a>(uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l02755"></a>02755                     <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02756"></a>02756                     uint8 dec_arg)
<a name="l02757"></a>02757     :<a class="code" href="classField__temporal.html">Field_temporal</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l02758"></a>02758                     unireg_check_arg, field_name_arg,
<a name="l02759"></a>02759                     MAX_TIME_WIDTH, dec_arg)
<a name="l02760"></a>02760     { }
<a name="l02767"></a><a class="code" href="classField__time__common.html#a892bfdd20ae6cc742a79914c12201695">02767</a>   <a class="code" href="classField__time__common.html#a4dafe0dc9d97419ac274303c339bff04">Field_time_common</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02768"></a>02768                     uint8 dec_arg)
<a name="l02769"></a>02769     :<a class="code" href="classField__temporal.html">Field_temporal</a>((uchar *) 0, maybe_null_arg ? (uchar *) <span class="stringliteral">&quot;&quot;</span> : 0, 0,
<a name="l02770"></a>02770                     NONE, field_name_arg, MAX_TIME_WIDTH, dec_arg)
<a name="l02771"></a>02771     { }
<a name="l02772"></a>02772   type_conversion_status <a class="code" href="classField__time__common.html#a679289fc41b3c0f5bf4f20a31d0e67d3">store_time</a>(MYSQL_TIME *ltime, uint8 dec);
<a name="l02773"></a>02773   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*, <a class="code" href="classString.html">String</a> *);
<a name="l02774"></a>02774   <span class="keywordtype">bool</span> <a class="code" href="classField__time__common.html#a55e19055f132727ca880e34c4cdbe0cd">get_date</a>(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l02775"></a>02775   longlong <a class="code" href="classField__time__common.html#a78d985bb5c8a86a8860bff1315839c10">val_date_temporal</a>();
<a name="l02776"></a>02776   <span class="keywordtype">bool</span> send_binary(<a class="code" href="classProtocol.html">Protocol</a> *protocol);
<a name="l02777"></a>02777 };
<a name="l02778"></a>02778 
<a name="l02779"></a>02779 
<a name="l02780"></a>02780 <span class="comment">/*</span>
<a name="l02781"></a>02781 <span class="comment">  Field implementing TIME data type without fractional seconds.</span>
<a name="l02782"></a>02782 <span class="comment">  We will be removed eventually.</span>
<a name="l02783"></a>02783 <span class="comment">*/</span>
<a name="l02784"></a><a class="code" href="classField__time.html">02784</a> <span class="keyword">class </span><a class="code" href="classField__time.html">Field_time</a> :<span class="keyword">public</span> <a class="code" href="classField__time__common.html">Field_time_common</a> {
<a name="l02785"></a>02785 <span class="keyword">protected</span>:
<a name="l02786"></a>02786   type_conversion_status <a class="code" href="classField__time.html#a1589d404d2bc1d05aafc429e05f5308c">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime, <span class="keywordtype">int</span> *error);
<a name="l02787"></a>02787 <span class="keyword">public</span>:
<a name="l02788"></a>02788   <a class="code" href="classField__time.html">Field_time</a>(uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l02789"></a>02789              <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg)
<a name="l02790"></a>02790     :<a class="code" href="classField__time__common.html#a4dafe0dc9d97419ac274303c339bff04">Field_time_common</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l02791"></a>02791                        unireg_check_arg, field_name_arg, 0)
<a name="l02792"></a>02792     { }
<a name="l02793"></a>02793   <a class="code" href="classField__time.html">Field_time</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg)
<a name="l02794"></a>02794     :<a class="code" href="classField__time__common.html#a4dafe0dc9d97419ac274303c339bff04">Field_time_common</a>((uchar *) 0, maybe_null_arg ? (uchar *) <span class="stringliteral">&quot;&quot;</span> : 0, 0,
<a name="l02795"></a>02795                        NONE, field_name_arg, 0)
<a name="l02796"></a>02796     { }
<a name="l02797"></a>02797   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TIME;}
<a name="l02798"></a>02798   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_INT24; }
<a name="l02799"></a>02799   type_conversion_status <a class="code" href="classField__time.html#af220bb15b6679e6c7dfb7964d9521f6e">store_packed</a>(longlong nr);
<a name="l02800"></a>02800   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l02801"></a>02801   {
<a name="l02802"></a>02802     ptr[0]=ptr[1]=ptr[2]=0;
<a name="l02803"></a>02803     <span class="keywordflow">return</span> TYPE_OK;
<a name="l02804"></a>02804   }
<a name="l02805"></a>02805   longlong val_int(<span class="keywordtype">void</span>);
<a name="l02806"></a>02806   longlong <a class="code" href="classField__time.html#a7e15eb097b1cfacdabfa92de7dc3e8ed">val_time_temporal</a>();
<a name="l02807"></a>02807   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime);
<a name="l02808"></a>02808   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l02809"></a>02809   <span class="keywordtype">void</span> <a class="code" href="classField__time.html#aec0841182b12dca39b099ec418596bcf">make_sort_key</a>(uchar *buff, uint length);
<a name="l02810"></a>02810   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 3; }
<a name="l02811"></a>02811   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02812"></a>02812   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l02813"></a><a class="code" href="classField__time.html#a6f7ef8f61f102736062c3ac02e1b8562">02813</a>   <a class="code" href="classField__time.html">Field_time</a> *<a class="code" href="classField__time.html#a6f7ef8f61f102736062c3ac02e1b8562">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l02814"></a>02814     DBUG_ASSERT(type() == MYSQL_TYPE_TIME);
<a name="l02815"></a>02815     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__time.html">Field_time</a>(*<span class="keyword">this</span>);
<a name="l02816"></a>02816   }
<a name="l02817"></a><a class="code" href="classField__time.html#a8abbda0597ca4253c4e07aaeca0ee167">02817</a>   <a class="code" href="classField__time.html">Field_time</a> *<a class="code" href="classField__time.html#a8abbda0597ca4253c4e07aaeca0ee167">clone</a>()<span class="keyword"> const </span>{
<a name="l02818"></a>02818     DBUG_ASSERT(type() == MYSQL_TYPE_TIME);
<a name="l02819"></a>02819     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__time.html">Field_time</a>(*<span class="keyword">this</span>);
<a name="l02820"></a>02820   }
<a name="l02821"></a>02821 };
<a name="l02822"></a>02822 
<a name="l02823"></a>02823 
<a name="l02824"></a>02824 <span class="comment">/*</span>
<a name="l02825"></a>02825 <span class="comment">  Field implementing TIME(N) data type, where N=0..6.</span>
<a name="l02826"></a>02826 <span class="comment">*/</span>
<a name="l02827"></a><a class="code" href="classField__timef.html">02827</a> <span class="keyword">class </span><a class="code" href="classField__timef.html">Field_timef</a> :<span class="keyword">public</span> <a class="code" href="classField__time__common.html">Field_time_common</a> {
<a name="l02828"></a>02828 <span class="keyword">private</span>:
<a name="l02829"></a>02829   <span class="keywordtype">int</span> do_save_field_metadata(uchar *metadata_ptr)
<a name="l02830"></a>02830   {
<a name="l02831"></a>02831     *metadata_ptr= decimals();
<a name="l02832"></a>02832     <span class="keywordflow">return</span> 1;
<a name="l02833"></a>02833   }
<a name="l02834"></a>02834 <span class="keyword">protected</span>:
<a name="l02835"></a>02835   type_conversion_status <a class="code" href="classField__timef.html#a37416bd1f9b3950b45bb0e450f87aa84">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime, <span class="keywordtype">int</span> *error);
<a name="l02836"></a>02836 <span class="keyword">public</span>:
<a name="l02846"></a><a class="code" href="classField__timef.html#a4d61c246c27021f3d76a48267b180d0c">02846</a>   <a class="code" href="classField__timef.html#a4d61c246c27021f3d76a48267b180d0c">Field_timef</a>(uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l02847"></a>02847               <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l02848"></a>02848               uint8 dec_arg)
<a name="l02849"></a>02849     :<a class="code" href="classField__time__common.html">Field_time_common</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l02850"></a>02850                        unireg_check_arg, field_name_arg, dec_arg)
<a name="l02851"></a>02851   { }
<a name="l02858"></a><a class="code" href="classField__timef.html#a8788165732571277b805ca2e29828ac0">02858</a>   <a class="code" href="classField__timef.html#a4d61c246c27021f3d76a48267b180d0c">Field_timef</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg, uint8 dec_arg)
<a name="l02859"></a>02859     :<a class="code" href="classField__time__common.html">Field_time_common</a>((uchar *) 0, maybe_null_arg ? (uchar *) <span class="stringliteral">&quot;&quot;</span> : 0, 0,
<a name="l02860"></a>02860                        NONE, field_name_arg, dec_arg)
<a name="l02861"></a>02861   { }
<a name="l02862"></a><a class="code" href="classField__timef.html#a6d7089aa2eae8b24081a4e4f52fdf894">02862</a>   <a class="code" href="classField__timef.html">Field_timef</a> *<a class="code" href="classField__timef.html#a9a76e8107f72dc9f377183c024498f60">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l02863"></a>02863 <span class="keyword">  </span>{
<a name="l02864"></a>02864     DBUG_ASSERT(type() == MYSQL_TYPE_TIME);
<a name="l02865"></a>02865     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__timef.html#a4d61c246c27021f3d76a48267b180d0c">Field_timef</a>(*<span class="keyword">this</span>);
<a name="l02866"></a>02866   }
<a name="l02867"></a><a class="code" href="classField__timef.html#a9a76e8107f72dc9f377183c024498f60">02867</a>   <a class="code" href="classField__timef.html">Field_timef</a> *<a class="code" href="classField__timef.html#a9a76e8107f72dc9f377183c024498f60">clone</a>()<span class="keyword"> const</span>
<a name="l02868"></a>02868 <span class="keyword">  </span>{
<a name="l02869"></a>02869     DBUG_ASSERT(type() == MYSQL_TYPE_TIME);
<a name="l02870"></a>02870     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__timef.html#a4d61c246c27021f3d76a48267b180d0c">Field_timef</a>(*<span class="keyword">this</span>);
<a name="l02871"></a>02871   }
<a name="l02872"></a>02872   uint decimals()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> dec; }
<a name="l02873"></a>02873   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TIME;}
<a name="l02874"></a>02874   enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TIME2; }
<a name="l02875"></a>02875   enum_field_types binlog_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_TIME2; }
<a name="l02876"></a>02876   type_conversion_status <a class="code" href="classField__timef.html#a02f430536cb0135e28b813aed91579d2">store_packed</a>(longlong nr);
<a name="l02877"></a>02877   type_conversion_status reset();
<a name="l02878"></a>02878   <span class="keywordtype">double</span> val_real();
<a name="l02879"></a>02879   longlong val_int();
<a name="l02880"></a>02880   longlong <a class="code" href="classField__timef.html#a03db4df3722b7e0292b84b982de342e3">val_time_temporal</a>();
<a name="l02881"></a>02881   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime);
<a name="l02882"></a>02882   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l02883"></a>02883   uint32 pack_length()<span class="keyword"> const</span>
<a name="l02884"></a>02884 <span class="keyword">  </span>{
<a name="l02885"></a>02885     <span class="keywordflow">return</span> my_time_binary_length(dec);
<a name="l02886"></a>02886   }
<a name="l02887"></a>02887   <span class="keyword">virtual</span> uint pack_length_from_metadata(uint field_metadata)
<a name="l02888"></a>02888   {
<a name="l02889"></a>02889     DBUG_ENTER(<span class="stringliteral">&quot;Field_timef::pack_length_from_metadata&quot;</span>);
<a name="l02890"></a>02890     uint tmp= my_time_binary_length(field_metadata);
<a name="l02891"></a>02891     DBUG_RETURN(tmp);
<a name="l02892"></a>02892   }
<a name="l02893"></a>02893   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l02894"></a>02894   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02895"></a>02895   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l02896"></a>02896   <span class="keyword">const</span> CHARSET_INFO *sort_charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;my_charset_bin; }
<a name="l02897"></a><a class="code" href="classField__timef.html#a75afe4f062020983d73c679933ae6e06">02897</a>   <span class="keywordtype">void</span> <a class="code" href="classField__timef.html#a75afe4f062020983d73c679933ae6e06">make_sort_key</a>(uchar *to, uint length) { memcpy(to, ptr, length); }
<a name="l02898"></a>02898   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *a_ptr, <span class="keyword">const</span> uchar *b_ptr)
<a name="l02899"></a>02899   {
<a name="l02900"></a>02900     <span class="keywordflow">return</span> memcmp(a_ptr, b_ptr, pack_length());
<a name="l02901"></a>02901   }
<a name="l02902"></a>02902 };
<a name="l02903"></a>02903 
<a name="l02904"></a>02904 
<a name="l02905"></a>02905 <span class="comment">/*</span>
<a name="l02906"></a>02906 <span class="comment">  Field implementing DATETIME data type without fractional seconds.</span>
<a name="l02907"></a>02907 <span class="comment">  We will be removed eventually.</span>
<a name="l02908"></a>02908 <span class="comment">*/</span>
<a name="l02909"></a><a class="code" href="classField__datetime.html">02909</a> <span class="keyword">class </span><a class="code" href="classField__datetime.html">Field_datetime</a> :<span class="keyword">public</span> <a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a> {
<a name="l02910"></a>02910 <span class="keyword">protected</span>:
<a name="l02911"></a>02911   type_conversion_status <a class="code" href="classField__datetime.html#a727cd235b40a644b6110ee16b8cef7df">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime, <span class="keywordtype">int</span> *error);
<a name="l02912"></a>02912   <span class="keywordtype">bool</span> <a class="code" href="classField__datetime.html#ad1b048032be351ce7227d8ab6804fc99">get_date_internal</a>(MYSQL_TIME *ltime);
<a name="l02913"></a>02913   ulonglong <a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">date_flags</a>(<span class="keyword">const</span> THD *thd);
<a name="l02914"></a>02914   <span class="keywordtype">void</span> <a class="code" href="classField__datetime.html#ae05689a45e7e14f5061f75202a6e9280">store_timestamp_internal</a>(<span class="keyword">const</span> <span class="keyword">struct</span> timeval *tm);
<a name="l02915"></a>02915 
<a name="l02916"></a>02916 <span class="keyword">public</span>:
<a name="l02917"></a>02917   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> PACK_LENGTH= 8;
<a name="l02918"></a>02918 
<a name="l02944"></a><a class="code" href="classField__datetime.html#a92f5fa57a245b08c63d8c44d7165a449">02944</a>   <a class="code" href="classField__datetime.html#a92f5fa57a245b08c63d8c44d7165a449">Field_datetime</a>(uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l02945"></a>02945                  <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg)
<a name="l02946"></a>02946     :<a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l02947"></a>02947                                        unireg_check_arg, field_name_arg, 0)
<a name="l02948"></a>02948     {}
<a name="l02949"></a>02949   <a class="code" href="classField__datetime.html#a92f5fa57a245b08c63d8c44d7165a449">Field_datetime</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg)
<a name="l02950"></a>02950     :<a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a>((uchar *) 0,
<a name="l02951"></a>02951                                        maybe_null_arg ? (uchar *) <span class="stringliteral">&quot;&quot;</span> : 0,
<a name="l02952"></a>02952                                        0, NONE, field_name_arg, 0)
<a name="l02953"></a>02953     {}
<a name="l02954"></a>02954   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_DATETIME;}
<a name="l02955"></a>02955 <span class="preprocessor">#ifdef HAVE_LONG_LONG</span>
<a name="l02956"></a>02956 <span class="preprocessor"></span>  <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_ULONGLONG; }
<a name="l02957"></a>02957 <span class="preprocessor">#endif</span>
<a name="l02958"></a>02958 <span class="preprocessor"></span>  <span class="keyword">using</span> <a class="code" href="classField__temporal.html#a15726346f5faf049c097f626d9492407">Field_temporal_with_date_and_time::store</a>; <span class="comment">// Make -Woverloaded-virtual</span>
<a name="l02959"></a>02959   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l02960"></a>02960   type_conversion_status <a class="code" href="classField__datetime.html#aa9d26c9ee5595f5c10303bee4665a9e6">store_packed</a>(longlong nr);
<a name="l02961"></a>02961   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l02962"></a>02962   {
<a name="l02963"></a>02963     ptr[0]=ptr[1]=ptr[2]=ptr[3]=ptr[4]=ptr[5]=ptr[6]=ptr[7]=0;
<a name="l02964"></a>02964     <span class="keywordflow">return</span> TYPE_OK;
<a name="l02965"></a>02965   }
<a name="l02966"></a>02966   longlong val_int(<span class="keywordtype">void</span>);
<a name="l02967"></a>02967   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l02968"></a>02968   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l02969"></a>02969   <span class="keywordtype">void</span> <a class="code" href="classField__datetime.html#ac3dca1d158450606ee72da9e3496ef73">make_sort_key</a>(uchar *buff, uint length);
<a name="l02970"></a>02970   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> PACK_LENGTH; }
<a name="l02971"></a>02971   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l02972"></a>02972   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l02973"></a>02973   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime,uint fuzzydate);
<a name="l02974"></a><a class="code" href="classField__datetime.html#aee7f812b571bda82d173f82d3d3aaba3">02974</a>   <a class="code" href="classField__datetime.html">Field_datetime</a> *<a class="code" href="classField__datetime.html#a2234ff638f3731ae47c9d6c43c57012c">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l02975"></a>02975 <span class="keyword">  </span>{
<a name="l02976"></a>02976     DBUG_ASSERT(type() == MYSQL_TYPE_DATETIME);
<a name="l02977"></a>02977     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__datetime.html#a92f5fa57a245b08c63d8c44d7165a449">Field_datetime</a>(*<span class="keyword">this</span>);
<a name="l02978"></a>02978   }
<a name="l02979"></a><a class="code" href="classField__datetime.html#a2234ff638f3731ae47c9d6c43c57012c">02979</a>   <a class="code" href="classField__datetime.html">Field_datetime</a> *<a class="code" href="classField__datetime.html#a2234ff638f3731ae47c9d6c43c57012c">clone</a>()<span class="keyword"> const</span>
<a name="l02980"></a>02980 <span class="keyword">  </span>{
<a name="l02981"></a>02981     DBUG_ASSERT(type() == MYSQL_TYPE_DATETIME);
<a name="l02982"></a>02982     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__datetime.html#a92f5fa57a245b08c63d8c44d7165a449">Field_datetime</a>(*<span class="keyword">this</span>);
<a name="l02983"></a>02983   }
<a name="l02984"></a>02984   uchar *pack(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l02985"></a>02985               uint max_length __attribute__((unused)), <span class="keywordtype">bool</span> low_byte_first)
<a name="l02986"></a>02986   {
<a name="l02987"></a>02987     <span class="keywordflow">return</span> pack_int64(to, from, low_byte_first);
<a name="l02988"></a>02988   }
<a name="l02989"></a>02989   <span class="keyword">const</span> uchar *unpack(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l02990"></a>02990                       uint param_data __attribute__((unused)),
<a name="l02991"></a>02991                       <span class="keywordtype">bool</span> low_byte_first)
<a name="l02992"></a>02992   {
<a name="l02993"></a>02993     <span class="keywordflow">return</span> unpack_int64(to, from, low_byte_first);
<a name="l02994"></a>02994   }
<a name="l02995"></a>02995 };
<a name="l02996"></a>02996 
<a name="l02997"></a>02997 
<a name="l02998"></a>02998 <span class="comment">/*</span>
<a name="l02999"></a>02999 <span class="comment">  Field implementing DATETIME(N) data type, where N=0..6.</span>
<a name="l03000"></a>03000 <span class="comment">*/</span>
<a name="l03001"></a><a class="code" href="classField__datetimef.html">03001</a> <span class="keyword">class </span><a class="code" href="classField__datetimef.html">Field_datetimef</a> :<span class="keyword">public</span> <a class="code" href="classField__temporal__with__date__and__timef.html">Field_temporal_with_date_and_timef</a> {
<a name="l03002"></a>03002 <span class="keyword">protected</span>:
<a name="l03003"></a>03003   <span class="keywordtype">bool</span> <a class="code" href="classField__datetimef.html#a54497950174c5034fd1ffd97e08bc368">get_date_internal</a>(MYSQL_TIME *ltime);
<a name="l03004"></a>03004   type_conversion_status <a class="code" href="classField__datetimef.html#a15efe08f94a2a01938ceb8b5bed6aa4f">store_internal</a>(<span class="keyword">const</span> MYSQL_TIME *ltime, <span class="keywordtype">int</span> *error);
<a name="l03005"></a>03005   ulonglong <a class="code" href="classField__temporal.html#a3fd2e8fbbf1b594a84ec7c7c784ec665">date_flags</a>(<span class="keyword">const</span> THD *thd);
<a name="l03006"></a>03006   <span class="keywordtype">void</span> <a class="code" href="classField__datetimef.html#adb90beeaafa4b792067cd838084e230f">store_timestamp_internal</a>(<span class="keyword">const</span> <span class="keyword">struct</span> timeval *tm);
<a name="l03007"></a>03007 
<a name="l03008"></a>03008 <span class="keyword">public</span>:
<a name="l03018"></a><a class="code" href="classField__datetimef.html#a5eddf8844d1dfa02238889abc6a9a0a0">03018</a>   <a class="code" href="classField__datetimef.html#a5eddf8844d1dfa02238889abc6a9a0a0">Field_datetimef</a>(uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l03019"></a>03019                  <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03020"></a>03020                  uint8 dec_arg)
<a name="l03021"></a>03021     :<a class="code" href="classField__temporal__with__date__and__timef.html">Field_temporal_with_date_and_timef</a>(ptr_arg, null_ptr_arg, null_bit_arg,
<a name="l03022"></a>03022                                         unireg_check_arg, field_name_arg,
<a name="l03023"></a>03023                                         dec_arg)
<a name="l03024"></a>03024     {}
<a name="l03032"></a><a class="code" href="classField__datetimef.html#a5a465f242f973b0135755f2c19fe2b1c">03032</a>   <a class="code" href="classField__datetimef.html#a5eddf8844d1dfa02238889abc6a9a0a0">Field_datetimef</a>(<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03033"></a>03033                   uint8 dec_arg)
<a name="l03034"></a>03034     :<a class="code" href="classField__temporal__with__date__and__timef.html">Field_temporal_with_date_and_timef</a>((uchar *) 0,
<a name="l03035"></a>03035                                         maybe_null_arg ? (uchar *) <span class="stringliteral">&quot;&quot;</span> : 0, 0,
<a name="l03036"></a>03036                                         NONE, field_name_arg, dec_arg)
<a name="l03037"></a>03037     {}
<a name="l03038"></a><a class="code" href="classField__datetimef.html#a953cad6c020360bc92a89a064139679f">03038</a>   <a class="code" href="classField__datetimef.html">Field_datetimef</a> *<a class="code" href="classField__datetimef.html#a43568c69be128034c29e11543010c8f1">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l03039"></a>03039 <span class="keyword">  </span>{
<a name="l03040"></a>03040     DBUG_ASSERT(type() == MYSQL_TYPE_DATETIME);
<a name="l03041"></a>03041     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__datetimef.html#a5eddf8844d1dfa02238889abc6a9a0a0">Field_datetimef</a>(*<span class="keyword">this</span>);
<a name="l03042"></a>03042   }
<a name="l03043"></a><a class="code" href="classField__datetimef.html#a43568c69be128034c29e11543010c8f1">03043</a>   <a class="code" href="classField__datetimef.html">Field_datetimef</a> *<a class="code" href="classField__datetimef.html#a43568c69be128034c29e11543010c8f1">clone</a>()<span class="keyword"> const</span>
<a name="l03044"></a>03044 <span class="keyword">  </span>{
<a name="l03045"></a>03045     DBUG_ASSERT(type() == MYSQL_TYPE_DATETIME);
<a name="l03046"></a>03046     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__datetimef.html#a5eddf8844d1dfa02238889abc6a9a0a0">Field_datetimef</a>(*<span class="keyword">this</span>);
<a name="l03047"></a>03047   }
<a name="l03048"></a>03048 
<a name="l03049"></a>03049   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_DATETIME;}
<a name="l03050"></a>03050   enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_DATETIME2; }
<a name="l03051"></a>03051   enum_field_types binlog_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_DATETIME2; }
<a name="l03052"></a>03052   uint32 pack_length()<span class="keyword"> const</span>
<a name="l03053"></a>03053 <span class="keyword">  </span>{
<a name="l03054"></a>03054     <span class="keywordflow">return</span> my_datetime_binary_length(dec);
<a name="l03055"></a>03055   }
<a name="l03056"></a>03056   <span class="keyword">virtual</span> uint pack_length_from_metadata(uint field_metadata)
<a name="l03057"></a>03057   {
<a name="l03058"></a>03058     DBUG_ENTER(<span class="stringliteral">&quot;Field_datetimef::pack_length_from_metadata&quot;</span>);
<a name="l03059"></a>03059     uint tmp= my_datetime_binary_length(field_metadata);
<a name="l03060"></a>03060     DBUG_RETURN(tmp);
<a name="l03061"></a>03061   }
<a name="l03062"></a>03062   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l03063"></a>03063 
<a name="l03064"></a>03064   type_conversion_status <a class="code" href="classField__datetimef.html#a16ff3d457851e43787c57916ea614241">store_packed</a>(longlong nr);
<a name="l03065"></a>03065   type_conversion_status reset();
<a name="l03066"></a>03066   longlong <a class="code" href="classField__datetimef.html#aec7455bda53c84017097539ac92c91d2">val_date_temporal</a>();
<a name="l03067"></a>03067   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l03068"></a>03068   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03069"></a>03069 };
<a name="l03070"></a>03070 
<a name="l03071"></a>03071 
<a name="l03072"></a><a class="code" href="classField__string.html">03072</a> <span class="keyword">class </span><a class="code" href="classField__string.html">Field_string</a> :<span class="keyword">public</span> <a class="code" href="classField__longstr.html">Field_longstr</a> {
<a name="l03073"></a>03073 <span class="keyword">public</span>:
<a name="l03074"></a>03074   <span class="keywordtype">bool</span> can_alter_field_type;
<a name="l03075"></a>03075   <a class="code" href="classField__string.html">Field_string</a>(uchar *ptr_arg, uint32 len_arg,uchar *null_ptr_arg,
<a name="l03076"></a>03076                uchar null_bit_arg,
<a name="l03077"></a>03077                <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03078"></a>03078                <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l03079"></a>03079     :<a class="code" href="classField__longstr.html">Field_longstr</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l03080"></a>03080                    unireg_check_arg, field_name_arg, cs),
<a name="l03081"></a>03081      can_alter_field_type(1) {};
<a name="l03082"></a>03082   <a class="code" href="classField__string.html">Field_string</a>(uint32 len_arg,<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03083"></a>03083                <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l03084"></a>03084     :<a class="code" href="classField__longstr.html">Field_longstr</a>((uchar*) 0, len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0, 0,
<a name="l03085"></a>03085                    NONE, field_name_arg, cs),
<a name="l03086"></a>03086      can_alter_field_type(1) {};
<a name="l03087"></a>03087 
<a name="l03088"></a>03088   enum_field_types type()<span class="keyword"> const</span>
<a name="l03089"></a>03089 <span class="keyword">  </span>{
<a name="l03090"></a>03090     <span class="keywordflow">return</span> ((can_alter_field_type &amp;&amp; orig_table &amp;&amp;
<a name="l03091"></a>03091              orig_table-&gt;s-&gt;db_create_options &amp; HA_OPTION_PACK_RECORD &amp;&amp;
<a name="l03092"></a>03092              field_length &gt;= 4) &amp;&amp;
<a name="l03093"></a>03093             orig_table-&gt;s-&gt;frm_version &lt; FRM_VER_TRUE_VARCHAR ?
<a name="l03094"></a>03094             MYSQL_TYPE_VAR_STRING : MYSQL_TYPE_STRING);
<a name="l03095"></a>03095   }
<a name="l03096"></a>03096   <span class="keywordtype">bool</span> match_collation_to_optimize_range()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l03097"></a>03097   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const</span>
<a name="l03098"></a>03098 <span class="keyword">    </span>{ <span class="keywordflow">return</span> binary() ? HA_KEYTYPE_BINARY : HA_KEYTYPE_TEXT; }
<a name="l03099"></a>03099   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l03100"></a>03100   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l03101"></a>03101   {
<a name="l03102"></a>03102     charset()-&gt;cset-&gt;fill(charset(),(<span class="keywordtype">char</span>*) ptr, field_length,
<a name="l03103"></a>03103                           (has_charset() ? <span class="charliteral">&#39; &#39;</span> : 0));
<a name="l03104"></a>03104     <span class="keywordflow">return</span> TYPE_OK;
<a name="l03105"></a>03105   }
<a name="l03106"></a>03106   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to,uint length,
<a name="l03107"></a>03107                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l03108"></a>03108   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l03109"></a>03109   <span class="comment">/* QQ: To be deleted */</span>
<a name="l03110"></a><a class="code" href="classField__string.html#a154a1bcd6578f53da8bccb43cc57cb60">03110</a>   type_conversion_status <a class="code" href="classField__string.html#a154a1bcd6578f53da8bccb43cc57cb60">store</a>(<span class="keywordtype">double</span> nr) { <span class="keywordflow">return</span> <a class="code" href="classField__str.html#ad4b48698ff57cae15a2df92f1145b102">Field_str::store</a>(nr); }
<a name="l03111"></a>03111   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l03112"></a>03112   longlong val_int(<span class="keywordtype">void</span>);
<a name="l03113"></a>03113   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l03114"></a>03114   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l03115"></a>03115   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l03116"></a>03116   <span class="keywordtype">void</span> <a class="code" href="classField__string.html#a46d655749e86144472819d0014abf64d">make_sort_key</a>(uchar *buff, uint length);
<a name="l03117"></a>03117   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03118"></a>03118   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__string.html#a2394757ed93148a4ad7199e93ace382b">pack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l03119"></a>03119                       uint max_length, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03120"></a>03120   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__string.html#a2b13c788916d9efdb0683d9c92b0ccbf">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l03121"></a>03121                               uint param_data, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03122"></a>03122   uint pack_length_from_metadata(uint field_metadata)
<a name="l03123"></a>03123   {
<a name="l03124"></a>03124     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;field_metadata: 0x%04x&quot;</span>, field_metadata));
<a name="l03125"></a>03125     <span class="keywordflow">if</span> (field_metadata == 0)
<a name="l03126"></a>03126       <span class="keywordflow">return</span> row_pack_length();
<a name="l03127"></a>03127     <span class="keywordflow">return</span> (((field_metadata &gt;&gt; 4) &amp; 0x300) ^ 0x300) + (field_metadata &amp; 0x00ff);
<a name="l03128"></a>03128   }
<a name="l03129"></a>03129   <span class="keywordtype">bool</span> <a class="code" href="classField__string.html#aa3397924d82ab8bb0c954b19c12de9a0">compatible_field_size</a>(uint field_metadata, <a class="code" href="classRelay__log__info.html">Relay_log_info</a> *rli,
<a name="l03130"></a>03130                              uint16 mflags, <span class="keywordtype">int</span> *order_var);
<a name="l03131"></a>03131   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> field_length; }
<a name="l03132"></a>03132   <span class="keywordtype">int</span> pack_cmp(<span class="keyword">const</span> uchar *a,<span class="keyword">const</span> uchar *b,uint key_length,
<a name="l03133"></a>03133                my_bool insert_or_update);
<a name="l03134"></a>03134   <span class="keywordtype">int</span> pack_cmp(<span class="keyword">const</span> uchar *b,uint key_length,my_bool insert_or_update);
<a name="l03135"></a>03135   uint packed_col_length(<span class="keyword">const</span> uchar *to, uint length);
<a name="l03136"></a>03136   uint max_packed_col_length(uint max_length);
<a name="l03137"></a>03137   enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_STRING; }
<a name="l03138"></a>03138   <span class="keywordtype">bool</span> has_charset(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03139"></a>03139 <span class="keyword">  </span>{ <span class="keywordflow">return</span> charset() == &amp;my_charset_bin ? FALSE : TRUE; }
<a name="l03140"></a>03140   <a class="code" href="classField.html">Field</a> *new_field(MEM_ROOT *root, <a class="code" href="structTABLE.html">TABLE</a> *new_table, <span class="keywordtype">bool</span> keep_type);
<a name="l03141"></a><a class="code" href="classField__string.html#acf5554388f4f34cd8cb16ce8a5b12c0c">03141</a>   <a class="code" href="classField__string.html">Field_string</a> *<a class="code" href="classField__string.html#acf5554388f4f34cd8cb16ce8a5b12c0c">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l03142"></a>03142     DBUG_ASSERT(real_type() == MYSQL_TYPE_STRING);
<a name="l03143"></a>03143     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__string.html">Field_string</a>(*<span class="keyword">this</span>);
<a name="l03144"></a>03144   }
<a name="l03145"></a><a class="code" href="classField__string.html#ac44b117666d252b4364c7f4d62eb8718">03145</a>   <a class="code" href="classField__string.html">Field_string</a> *<a class="code" href="classField__string.html#ac44b117666d252b4364c7f4d62eb8718">clone</a>()<span class="keyword"> const </span>{
<a name="l03146"></a>03146     DBUG_ASSERT(real_type() == MYSQL_TYPE_STRING);
<a name="l03147"></a>03147     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__string.html">Field_string</a>(*<span class="keyword">this</span>);
<a name="l03148"></a>03148   }
<a name="l03149"></a>03149   <span class="keyword">virtual</span> uint get_key_image(uchar *buff,uint length, imagetype type);
<a name="l03150"></a>03150 <span class="keyword">private</span>:
<a name="l03151"></a>03151   <span class="keywordtype">int</span> do_save_field_metadata(uchar *first_byte);
<a name="l03152"></a>03152 };
<a name="l03153"></a>03153 
<a name="l03154"></a>03154 
<a name="l03155"></a><a class="code" href="classField__varstring.html">03155</a> <span class="keyword">class </span><a class="code" href="classField__varstring.html">Field_varstring</a> :<span class="keyword">public</span> <a class="code" href="classField__longstr.html">Field_longstr</a> {
<a name="l03156"></a>03156 <span class="keyword">public</span>:
<a name="l03157"></a>03157   <span class="comment">/*</span>
<a name="l03158"></a>03158 <span class="comment">    The maximum space available in a Field_varstring, in bytes. See</span>
<a name="l03159"></a>03159 <span class="comment">    length_bytes.</span>
<a name="l03160"></a>03160 <span class="comment">  */</span>
<a name="l03161"></a>03161   <span class="keyword">static</span> <span class="keyword">const</span> uint MAX_SIZE;
<a name="l03162"></a>03162   <span class="comment">/* Store number of bytes used to store length (1 or 2) */</span>
<a name="l03163"></a>03163   uint32 length_bytes;
<a name="l03164"></a>03164   <a class="code" href="classField__varstring.html">Field_varstring</a>(uchar *ptr_arg,
<a name="l03165"></a>03165                   uint32 len_arg, uint length_bytes_arg,
<a name="l03166"></a>03166                   uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l03167"></a>03167                   <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03168"></a>03168                   <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l03169"></a>03169     :<a class="code" href="classField__longstr.html">Field_longstr</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l03170"></a>03170                    unireg_check_arg, field_name_arg, cs),
<a name="l03171"></a>03171      length_bytes(length_bytes_arg)
<a name="l03172"></a>03172   {
<a name="l03173"></a>03173     share-&gt;varchar_fields++;
<a name="l03174"></a>03174   }
<a name="l03175"></a>03175   <a class="code" href="classField__varstring.html">Field_varstring</a>(uint32 len_arg,<span class="keywordtype">bool</span> maybe_null_arg,
<a name="l03176"></a>03176                   <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03177"></a>03177                   <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l03178"></a>03178     :<a class="code" href="classField__longstr.html">Field_longstr</a>((uchar*) 0,len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0, 0,
<a name="l03179"></a>03179                    NONE, field_name_arg, cs),
<a name="l03180"></a>03180      length_bytes(len_arg &lt; 256 ? 1 :2)
<a name="l03181"></a>03181   {
<a name="l03182"></a>03182     share-&gt;varchar_fields++;
<a name="l03183"></a>03183   }
<a name="l03184"></a>03184 
<a name="l03185"></a>03185   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_VARCHAR; }
<a name="l03186"></a>03186   <span class="keywordtype">bool</span> match_collation_to_optimize_range()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l03187"></a>03187   <span class="keyword">enum</span> ha_base_keytype key_type() <span class="keyword">const</span>;
<a name="l03188"></a>03188   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> field_length; }
<a name="l03189"></a>03189   <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l03190"></a>03190   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l03191"></a>03191   {
<a name="l03192"></a>03192     memset(ptr, 0, field_length+length_bytes);
<a name="l03193"></a>03193     <span class="keywordflow">return</span> TYPE_OK;
<a name="l03194"></a>03194   }
<a name="l03195"></a>03195   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint32) field_length+length_bytes; }
<a name="l03196"></a>03196   uint32 key_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint32) field_length; }
<a name="l03197"></a>03197   uint32 sort_length()<span class="keyword"> const</span>
<a name="l03198"></a>03198 <span class="keyword">  </span>{
<a name="l03199"></a>03199     <span class="keywordflow">return</span> (uint32) field_length + (field_charset == &amp;my_charset_bin ?
<a name="l03200"></a>03200                                     length_bytes : 0);
<a name="l03201"></a>03201   }
<a name="l03202"></a>03202   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to,uint length,
<a name="l03203"></a>03203                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l03204"></a>03204   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l03205"></a>03205   <span class="comment">/* QQ: To be deleted */</span>
<a name="l03206"></a><a class="code" href="classField__varstring.html#ad54d8ec0e88d58ffde65168643155434">03206</a>   type_conversion_status <a class="code" href="classField__varstring.html#ad54d8ec0e88d58ffde65168643155434">store</a>(<span class="keywordtype">double</span> nr) { <span class="keywordflow">return</span> <a class="code" href="classField__str.html#ad4b48698ff57cae15a2df92f1145b102">Field_str::store</a>(nr); }
<a name="l03207"></a>03207   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l03208"></a>03208   longlong val_int(<span class="keywordtype">void</span>);
<a name="l03209"></a>03209   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l03210"></a>03210   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l03211"></a>03211   <span class="keywordtype">int</span> cmp_max(<span class="keyword">const</span> uchar *, <span class="keyword">const</span> uchar *, uint max_length);
<a name="l03212"></a>03212   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *a,<span class="keyword">const</span> uchar *b)
<a name="l03213"></a>03213   {
<a name="l03214"></a>03214     <span class="keywordflow">return</span> cmp_max(a, b, ~0L);
<a name="l03215"></a>03215   }
<a name="l03216"></a>03216   <span class="keywordtype">void</span> <a class="code" href="classField__varstring.html#af54dda756afb1b45bb79f813ae7aedbd">make_sort_key</a>(uchar *buff, uint length);
<a name="l03217"></a>03217   uint get_key_image(uchar *buff,uint length, imagetype type);
<a name="l03218"></a>03218   <span class="keywordtype">void</span> set_key_image(<span class="keyword">const</span> uchar *buff,uint length);
<a name="l03219"></a>03219   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03220"></a>03220   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__varstring.html#a4e54b98a33cc68aa2c137a88a317f040">pack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l03221"></a>03221                       uint max_length, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03222"></a>03222   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__varstring.html#a2e40451e305ae25227d1aea8af1ee083">unpack</a>(uchar* to, <span class="keyword">const</span> uchar *from,
<a name="l03223"></a>03223                               uint param_data, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03224"></a>03224   <span class="keywordtype">int</span> cmp_binary(<span class="keyword">const</span> uchar *a,<span class="keyword">const</span> uchar *b, uint32 max_length=~0L);
<a name="l03225"></a>03225   <span class="keywordtype">int</span> <a class="code" href="classField__varstring.html#ad9e0c52fe4e88df9951362b98a0885f2">key_cmp</a>(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar*);
<a name="l03226"></a>03226   <span class="keywordtype">int</span> <a class="code" href="classField__varstring.html#ad9e0c52fe4e88df9951362b98a0885f2">key_cmp</a>(<span class="keyword">const</span> uchar *str, uint length);
<a name="l03227"></a>03227   uint packed_col_length(<span class="keyword">const</span> uchar *to, uint length);
<a name="l03228"></a>03228   uint max_packed_col_length(uint max_length);
<a name="l03229"></a>03229   uint32 data_length();
<a name="l03230"></a>03230   enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_VARCHAR; }
<a name="l03231"></a>03231   <span class="keywordtype">bool</span> has_charset(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03232"></a>03232 <span class="keyword">  </span>{ <span class="keywordflow">return</span> charset() == &amp;my_charset_bin ? FALSE : TRUE; }
<a name="l03233"></a>03233   <a class="code" href="classField.html">Field</a> *new_field(MEM_ROOT *root, <a class="code" href="structTABLE.html">TABLE</a> *new_table, <span class="keywordtype">bool</span> keep_type);
<a name="l03234"></a>03234   <a class="code" href="classField.html">Field</a> *new_key_field(MEM_ROOT *root, <a class="code" href="structTABLE.html">TABLE</a> *new_table,
<a name="l03235"></a>03235                        uchar *new_ptr, uchar *new_null_ptr,
<a name="l03236"></a>03236                        uint new_null_bit);
<a name="l03237"></a><a class="code" href="classField__varstring.html#a9637e9a6281840387238c0a150f79264">03237</a>   <a class="code" href="classField__varstring.html">Field_varstring</a> *<a class="code" href="classField__varstring.html#a9637e9a6281840387238c0a150f79264">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l03238"></a>03238     DBUG_ASSERT(type() == MYSQL_TYPE_VARCHAR);
<a name="l03239"></a>03239     DBUG_ASSERT(real_type() == MYSQL_TYPE_VARCHAR);
<a name="l03240"></a>03240     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__varstring.html">Field_varstring</a>(*<span class="keyword">this</span>);
<a name="l03241"></a>03241   }
<a name="l03242"></a><a class="code" href="classField__varstring.html#ad15d9890587e10ca1ded2533907a499a">03242</a>   <a class="code" href="classField__varstring.html">Field_varstring</a> *<a class="code" href="classField__varstring.html#ad15d9890587e10ca1ded2533907a499a">clone</a>()<span class="keyword"> const </span>{
<a name="l03243"></a>03243     DBUG_ASSERT(type() == MYSQL_TYPE_VARCHAR);
<a name="l03244"></a>03244     DBUG_ASSERT(real_type() == MYSQL_TYPE_VARCHAR);
<a name="l03245"></a>03245     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__varstring.html">Field_varstring</a>(*<span class="keyword">this</span>);
<a name="l03246"></a>03246   }
<a name="l03247"></a>03247   uint <a class="code" href="classField__varstring.html#aa0bfc217f9c90b2cc741cdec8b97dd5c">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l03248"></a>03248   <span class="keywordtype">void</span> hash(ulong *nr, ulong *nr2);
<a name="l03249"></a>03249 <span class="keyword">private</span>:
<a name="l03250"></a>03250   <span class="keywordtype">int</span> do_save_field_metadata(uchar *first_byte);
<a name="l03251"></a>03251 };
<a name="l03252"></a>03252 
<a name="l03253"></a>03253 
<a name="l03254"></a><a class="code" href="classField__blob.html">03254</a> <span class="keyword">class </span><a class="code" href="classField__blob.html">Field_blob</a> :<span class="keyword">public</span> <a class="code" href="classField__longstr.html">Field_longstr</a> {
<a name="l03255"></a>03255   <span class="keyword">virtual</span> type_conversion_status store_internal(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, uint length,
<a name="l03256"></a>03256                                                 <span class="keyword">const</span> CHARSET_INFO *cs);
<a name="l03260"></a>03260   type_conversion_status store_to_mem(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, uint length,
<a name="l03261"></a>03261                                       <span class="keyword">const</span> CHARSET_INFO *cs,
<a name="l03262"></a>03262                                       uint max_length,
<a name="l03263"></a>03263                                       <a class="code" href="classBlob__mem__storage.html">Blob_mem_storage</a> *blob_storage);
<a name="l03264"></a>03264 <span class="keyword">protected</span>:
<a name="l03268"></a><a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">03268</a>   uint <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>;
<a name="l03269"></a>03269   
<a name="l03273"></a><a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">03273</a>   <a class="code" href="classString.html">String</a> <a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>;
<a name="l03274"></a>03274 
<a name="l03278"></a><a class="code" href="classField__blob.html#aecc1c7ac37e12b4eb8eb254795487757">03278</a>   <span class="keywordtype">void</span> <a class="code" href="classField__blob.html#aecc1c7ac37e12b4eb8eb254795487757">store_ptr_and_length</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, uint32 length)
<a name="l03279"></a>03279   {
<a name="l03280"></a>03280     store_length(length);
<a name="l03281"></a>03281     bmove(ptr + <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, &amp;from, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
<a name="l03282"></a>03282   }
<a name="l03283"></a>03283   
<a name="l03284"></a>03284 <span class="keyword">public</span>:
<a name="l03285"></a>03285   <a class="code" href="classField__blob.html">Field_blob</a>(uchar *ptr_arg, uchar *null_ptr_arg, uchar null_bit_arg,
<a name="l03286"></a>03286              <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03287"></a>03287              <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, uint blob_pack_length, <span class="keyword">const</span> CHARSET_INFO *cs);
<a name="l03288"></a>03288   <a class="code" href="classField__blob.html">Field_blob</a>(uint32 len_arg,<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03289"></a>03289              <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l03290"></a>03290     :<a class="code" href="classField__longstr.html">Field_longstr</a>((uchar*) 0, len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0, 0,
<a name="l03291"></a>03291                    NONE, field_name_arg, cs),
<a name="l03292"></a>03292     <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>(4)
<a name="l03293"></a>03293   {
<a name="l03294"></a>03294     flags|= BLOB_FLAG;
<a name="l03295"></a>03295   }
<a name="l03296"></a>03296   <a class="code" href="classField__blob.html">Field_blob</a>(uint32 len_arg,<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03297"></a>03297              <span class="keyword">const</span> CHARSET_INFO *cs, <span class="keywordtype">bool</span> set_packlength)
<a name="l03298"></a>03298     :<a class="code" href="classField__longstr.html">Field_longstr</a>((uchar*) 0,len_arg, maybe_null_arg ? (uchar*) <span class="stringliteral">&quot;&quot;</span>: 0, 0,
<a name="l03299"></a>03299                    NONE, field_name_arg, cs)
<a name="l03300"></a>03300   {
<a name="l03301"></a>03301     flags|= BLOB_FLAG;
<a name="l03302"></a>03302     <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>= 4;
<a name="l03303"></a>03303     <span class="keywordflow">if</span> (set_packlength)
<a name="l03304"></a>03304     {
<a name="l03305"></a>03305       uint32 l_char_length= len_arg/cs-&gt;mbmaxlen;
<a name="l03306"></a>03306       <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>= l_char_length &lt;= 255 ? 1 :
<a name="l03307"></a>03307                   l_char_length &lt;= 65535 ? 2 :
<a name="l03308"></a>03308                   l_char_length &lt;= 16777215 ? 3 : 4;
<a name="l03309"></a>03309     }
<a name="l03310"></a>03310   }
<a name="l03311"></a>03311   <a class="code" href="classField__blob.html">Field_blob</a>(uint32 packlength_arg)
<a name="l03312"></a>03312     :<a class="code" href="classField__longstr.html">Field_longstr</a>((uchar*) 0, 0, (uchar*) <span class="stringliteral">&quot;&quot;</span>, 0, NONE, <span class="stringliteral">&quot;temp&quot;</span>, system_charset_info),
<a name="l03313"></a>03313     <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>(packlength_arg) {}
<a name="l03314"></a>03314   <span class="comment">/* Note that the default copy constructor is used, in clone() */</span>
<a name="l03315"></a>03315   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_BLOB;}
<a name="l03316"></a>03316   <span class="keywordtype">bool</span> match_collation_to_optimize_range()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l03317"></a>03317   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const</span>
<a name="l03318"></a>03318 <span class="keyword">    </span>{ <span class="keywordflow">return</span> binary() ? HA_KEYTYPE_VARBINARY2 : HA_KEYTYPE_VARTEXT2; }
<a name="l03319"></a>03319   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l03320"></a>03320                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l03321"></a>03321   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l03322"></a>03322   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l03323"></a>03323   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l03324"></a>03324   longlong val_int(<span class="keywordtype">void</span>);
<a name="l03325"></a>03325   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l03326"></a>03326   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l03327"></a>03327   <span class="keywordtype">int</span> cmp_max(<span class="keyword">const</span> uchar *, <span class="keyword">const</span> uchar *, uint max_length);
<a name="l03328"></a>03328   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *a,<span class="keyword">const</span> uchar *b)
<a name="l03329"></a>03329     { <span class="keywordflow">return</span> cmp_max(a, b, ~0L); }
<a name="l03330"></a>03330   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *a, uint32 a_length, <span class="keyword">const</span> uchar *b, uint32 b_length);
<a name="l03331"></a>03331   <span class="keywordtype">int</span> cmp_binary(<span class="keyword">const</span> uchar *a,<span class="keyword">const</span> uchar *b, uint32 max_length=~0L);
<a name="l03332"></a>03332   <span class="keywordtype">int</span> key_cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar*);
<a name="l03333"></a>03333   <span class="keywordtype">int</span> key_cmp(<span class="keyword">const</span> uchar *str, uint length);
<a name="l03334"></a>03334   uint32 key_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l03335"></a>03335   <span class="keywordtype">void</span> <a class="code" href="classField__blob.html#a2d6042e676438fcf28dbf16bbb84c276">make_sort_key</a>(uchar *buff, uint length);
<a name="l03336"></a>03336   uint32 pack_length()<span class="keyword"> const</span>
<a name="l03337"></a>03337 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (uint32) (<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a> + portable_sizeof_char_ptr); }
<a name="l03338"></a>03338 
<a name="l03347"></a><a class="code" href="classField__blob.html#a83435cb4a9a4282f411cff11af3c92b2">03347</a>   uint32 <a class="code" href="classField__blob.html#a83435cb4a9a4282f411cff11af3c92b2">pack_length_no_ptr</a>()<span class="keyword"> const</span>
<a name="l03348"></a>03348 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (uint32) (<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>); }
<a name="l03349"></a>03349   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classField__blob.html#a83435cb4a9a4282f411cff11af3c92b2">pack_length_no_ptr</a>(); }
<a name="l03350"></a>03350   uint32 sort_length() <span class="keyword">const</span>;
<a name="l03351"></a><a class="code" href="classField__blob.html#abbdc60f1dc679c72497e3cb308789692">03351</a>   <span class="keyword">virtual</span> uint32 <a class="code" href="classField__blob.html#abbdc60f1dc679c72497e3cb308789692">max_data_length</a>()<span class="keyword"> const</span>
<a name="l03352"></a>03352 <span class="keyword">  </span>{
<a name="l03353"></a>03353     <span class="keywordflow">return</span> (uint32) (((ulonglong) 1 &lt;&lt; (<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>*8)) -1);
<a name="l03354"></a>03354   }
<a name="l03355"></a>03355   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l03356"></a>03356   {
<a name="l03357"></a>03357     memset(ptr, 0, <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>+<span class="keyword">sizeof</span>(uchar*));
<a name="l03358"></a>03358     <span class="keywordflow">return</span> TYPE_OK;
<a name="l03359"></a>03359   }
<a name="l03360"></a>03360   <span class="keywordtype">void</span> reset_fields() { memset(&amp;<a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>)); }
<a name="l03361"></a>03361   uint32 get_field_buffer_size(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> <a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>.alloced_length(); }
<a name="l03362"></a>03362 <span class="preprocessor">#ifndef WORDS_BIGENDIAN</span>
<a name="l03363"></a>03363 <span class="preprocessor"></span>  <span class="keyword">static</span>
<a name="l03364"></a>03364 <span class="preprocessor">#endif</span>
<a name="l03365"></a>03365 <span class="preprocessor"></span>  <span class="keywordtype">void</span> store_length(uchar *i_ptr, uint i_packlength, uint32 i_number, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03366"></a>03366   <span class="keywordtype">void</span> store_length(uchar *i_ptr, uint i_packlength, uint32 i_number)
<a name="l03367"></a>03367   {
<a name="l03368"></a>03368     store_length(i_ptr, i_packlength, i_number, table-&gt;s-&gt;db_low_byte_first);
<a name="l03369"></a>03369   }
<a name="l03370"></a>03370   <span class="keyword">inline</span> <span class="keywordtype">void</span> store_length(uint32 number)
<a name="l03371"></a>03371   {
<a name="l03372"></a>03372     store_length(ptr, <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, number);
<a name="l03373"></a>03373   }
<a name="l03374"></a>03374   <span class="keyword">inline</span> uint32 get_length(uint row_offset= 0)
<a name="l03375"></a>03375   { <span class="keywordflow">return</span> get_length(ptr+row_offset, this-&gt;<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, table-&gt;s-&gt;db_low_byte_first); }
<a name="l03376"></a>03376   uint32 get_length(<span class="keyword">const</span> uchar *ptr, uint <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03377"></a>03377   uint32 get_length(<span class="keyword">const</span> uchar *ptr_arg)
<a name="l03378"></a>03378   { <span class="keywordflow">return</span> get_length(ptr_arg, this-&gt;<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, table-&gt;s-&gt;db_low_byte_first); }
<a name="l03379"></a>03379   <span class="keywordtype">void</span> <a class="code" href="classField__blob.html#aa05f64033ecd31f3392d1a7f7cd1c17a">put_length</a>(uchar *pos, uint32 length);
<a name="l03380"></a>03380   <span class="keyword">inline</span> <span class="keywordtype">void</span> get_ptr(uchar **str)
<a name="l03381"></a>03381     {
<a name="l03382"></a>03382       memcpy(str, ptr+<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, <span class="keyword">sizeof</span>(uchar*));
<a name="l03383"></a>03383     }
<a name="l03384"></a>03384   <span class="keyword">inline</span> <span class="keywordtype">void</span> get_ptr(uchar **str, uint row_offset)
<a name="l03385"></a>03385     {
<a name="l03386"></a>03386       memcpy(str, ptr+<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>+row_offset, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l03387"></a>03387     }
<a name="l03388"></a>03388   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_ptr(uchar *length, uchar *data)
<a name="l03389"></a>03389     {
<a name="l03390"></a>03390       memcpy(ptr,length,<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>);
<a name="l03391"></a>03391       memcpy(ptr+<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, &amp;data,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l03392"></a>03392     }
<a name="l03393"></a>03393   <span class="keywordtype">void</span> set_ptr_offset(my_ptrdiff_t ptr_diff, uint32 length, uchar *data)
<a name="l03394"></a>03394     {
<a name="l03395"></a>03395       uchar *ptr_ofs= ADD_TO_PTR(ptr,ptr_diff,uchar*);
<a name="l03396"></a>03396       store_length(ptr_ofs, <a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, length);
<a name="l03397"></a>03397       memcpy(ptr_ofs+<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, &amp;data, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l03398"></a>03398     }
<a name="l03399"></a>03399   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_ptr(uint32 length, uchar *data)
<a name="l03400"></a>03400     {
<a name="l03401"></a>03401       set_ptr_offset(0, length, data);
<a name="l03402"></a>03402     }
<a name="l03403"></a>03403   uint get_key_image(uchar *buff,uint length, imagetype type);
<a name="l03404"></a>03404   <span class="keywordtype">void</span> set_key_image(<span class="keyword">const</span> uchar *buff,uint length);
<a name="l03405"></a>03405   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03406"></a>03406   <span class="keyword">inline</span> <span class="keywordtype">bool</span> copy()
<a name="l03407"></a>03407   {
<a name="l03408"></a>03408     uchar *tmp;
<a name="l03409"></a>03409     get_ptr(&amp;tmp);
<a name="l03410"></a>03410     <span class="keywordflow">if</span> (<a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>.copy((<span class="keywordtype">char</span>*) tmp, get_length(), charset()))
<a name="l03411"></a>03411     {
<a name="l03412"></a>03412       Field_blob::reset();
<a name="l03413"></a>03413       <span class="keywordflow">return</span> 1;
<a name="l03414"></a>03414     }
<a name="l03415"></a>03415     tmp=(uchar*) <a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>.ptr();
<a name="l03416"></a>03416     memcpy(ptr+<a class="code" href="classField__blob.html#a4752c1fb1007b71582e6698dcea35f19">packlength</a>, &amp;tmp, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>*));
<a name="l03417"></a>03417     <span class="keywordflow">return</span> 0;
<a name="l03418"></a>03418   }
<a name="l03419"></a><a class="code" href="classField__blob.html#a53c441173bb29fe814744324950f300f">03419</a>   <a class="code" href="classField__blob.html">Field_blob</a> *<a class="code" href="classField__blob.html#a53c441173bb29fe814744324950f300f">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l03420"></a>03420     DBUG_ASSERT(type() == MYSQL_TYPE_BLOB);
<a name="l03421"></a>03421     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__blob.html">Field_blob</a>(*<span class="keyword">this</span>);
<a name="l03422"></a>03422   }
<a name="l03423"></a><a class="code" href="classField__blob.html#a0c8fb80f7bc2e5950839d3e299ae2e95">03423</a>   <a class="code" href="classField__blob.html">Field_blob</a> *<a class="code" href="classField__blob.html#a0c8fb80f7bc2e5950839d3e299ae2e95">clone</a>()<span class="keyword"> const </span>{
<a name="l03424"></a>03424     DBUG_ASSERT(type() == MYSQL_TYPE_BLOB);
<a name="l03425"></a>03425     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__blob.html">Field_blob</a>(*<span class="keyword">this</span>);
<a name="l03426"></a>03426   }
<a name="l03427"></a>03427   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__blob.html#ae15681deef846bd350bdb09b5132b120">pack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l03428"></a>03428                       uint max_length, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03429"></a>03429   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__blob.html#a1dc550d11713918f94f12abe0fd36caa">unpack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l03430"></a>03430                               uint param_data, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03431"></a>03431   uint packed_col_length(<span class="keyword">const</span> uchar *col_ptr, uint length);
<a name="l03432"></a>03432   uint max_packed_col_length(uint max_length);
<a name="l03433"></a>03433   <span class="keywordtype">void</span> free() { <a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>.free(); }
<a name="l03434"></a>03434   <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_temporary() { memset(&amp;<a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="classField__blob.html#abc02fd1c1c4a61a46161d1a5e14f5a16">value</a>)); }
<a name="l03435"></a>03435   <span class="keyword">friend</span> type_conversion_status <a class="code" href="classField__blob.html#ac6315ce5b8740662e0c10dd34c659fae">field_conv</a>(<a class="code" href="classField.html">Field</a> *to,<a class="code" href="classField.html">Field</a> *from);
<a name="l03436"></a>03436   <span class="keywordtype">bool</span> has_charset(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<a name="l03437"></a>03437 <span class="keyword">  </span>{ <span class="keywordflow">return</span> charset() == &amp;my_charset_bin ? FALSE : TRUE; }
<a name="l03438"></a>03438   uint32 <a class="code" href="classField__blob.html#a6f8231d7a8e2b8f319cf9bfc1a284252">max_display_length</a>();
<a name="l03439"></a>03439   uint32 <a class="code" href="classField__blob.html#a552428bf4601d34436c6626b998be214">char_length</a>();
<a name="l03440"></a>03440   uint <a class="code" href="classField__blob.html#aad2a7c5fe21d9c7cfd20aeea52c58ed5">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l03441"></a>03441   <span class="keyword">inline</span> <span class="keywordtype">bool</span> in_read_set() { <span class="keywordflow">return</span> bitmap_is_set(table-&gt;read_set, field_index); }
<a name="l03442"></a>03442   <span class="keyword">inline</span> <span class="keywordtype">bool</span> in_write_set() { <span class="keywordflow">return</span> bitmap_is_set(table-&gt;write_set, field_index); }
<a name="l03443"></a>03443 <span class="keyword">private</span>:
<a name="l03444"></a>03444   <span class="keywordtype">int</span> do_save_field_metadata(uchar *first_byte);
<a name="l03445"></a>03445 };
<a name="l03446"></a>03446 
<a name="l03447"></a>03447 
<a name="l03448"></a>03448 <span class="preprocessor">#ifdef HAVE_SPATIAL</span>
<a name="l03449"></a>03449 <span class="preprocessor"></span><span class="keyword">class </span>Field_geom :<span class="keyword">public</span> <a class="code" href="classField__blob.html">Field_blob</a> {
<a name="l03450"></a>03450   <span class="keyword">virtual</span> type_conversion_status store_internal(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, uint length,
<a name="l03451"></a>03451                                                 <span class="keyword">const</span> CHARSET_INFO *cs);
<a name="l03452"></a>03452 <span class="keyword">public</span>:
<a name="l03453"></a>03453   <span class="keyword">enum</span> geometry_type geom_type;
<a name="l03454"></a>03454 
<a name="l03455"></a>03455   Field_geom(uchar *ptr_arg, uchar *null_ptr_arg, uint null_bit_arg,
<a name="l03456"></a>03456              <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03457"></a>03457              <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, uint blob_pack_length,
<a name="l03458"></a>03458              <span class="keyword">enum</span> geometry_type geom_type_arg)
<a name="l03459"></a>03459      :<a class="code" href="classField__blob.html">Field_blob</a>(ptr_arg, null_ptr_arg, null_bit_arg, unireg_check_arg, 
<a name="l03460"></a>03460                  field_name_arg, share, blob_pack_length, &amp;my_charset_bin)
<a name="l03461"></a>03461   { geom_type= geom_type_arg; }
<a name="l03462"></a>03462   Field_geom(uint32 len_arg,<span class="keywordtype">bool</span> maybe_null_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03463"></a>03463              <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <span class="keyword">enum</span> geometry_type geom_type_arg)
<a name="l03464"></a>03464     :<a class="code" href="classField__blob.html">Field_blob</a>(len_arg, maybe_null_arg, field_name_arg, &amp;my_charset_bin)
<a name="l03465"></a>03465   { geom_type= geom_type_arg; }
<a name="l03466"></a>03466   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_VARBINARY2; }
<a name="l03467"></a>03467   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_GEOMETRY; }
<a name="l03468"></a>03468   <span class="keywordtype">bool</span> match_collation_to_optimize_range()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l03469"></a>03469   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03470"></a>03470   <span class="keyword">using</span> Field_blob::store;
<a name="l03471"></a>03471   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l03472"></a>03472   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l03473"></a>03473   type_conversion_status <a class="code" href="classField__longstr.html#accc080bab51e57cdcefc594a17cb13f5">store_decimal</a>(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l03474"></a>03474 
<a name="l03479"></a>03479   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l03480"></a>03480   {
<a name="l03481"></a>03481     type_conversion_status res= Field_blob::reset();
<a name="l03482"></a>03482     <span class="keywordflow">if</span> (res != TYPE_OK)
<a name="l03483"></a>03483       <span class="keywordflow">return</span> res;
<a name="l03484"></a>03484     <span class="keywordflow">return</span> maybe_null() ? TYPE_OK : TYPE_ERR_NULL_CONSTRAINT_VIOLATION;
<a name="l03485"></a>03485   }
<a name="l03486"></a>03486 
<a name="l03487"></a>03487   geometry_type get_geometry_type() { <span class="keywordflow">return</span> geom_type; };
<a name="l03488"></a>03488   Field_geom *<a class="code" href="classField__blob.html#a0c8fb80f7bc2e5950839d3e299ae2e95">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l03489"></a>03489     DBUG_ASSERT(type() == MYSQL_TYPE_GEOMETRY);
<a name="l03490"></a>03490     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) Field_geom(*<span class="keyword">this</span>);
<a name="l03491"></a>03491   }
<a name="l03492"></a>03492   Field_geom *<a class="code" href="classField__blob.html#a0c8fb80f7bc2e5950839d3e299ae2e95">clone</a>()<span class="keyword"> const </span>{ 
<a name="l03493"></a>03493     DBUG_ASSERT(type() == MYSQL_TYPE_GEOMETRY);
<a name="l03494"></a>03494     <span class="keywordflow">return</span> <span class="keyword">new</span> Field_geom(*<span class="keyword">this</span>);
<a name="l03495"></a>03495   }
<a name="l03496"></a>03496   uint <a class="code" href="classField__blob.html#aad2a7c5fe21d9c7cfd20aeea52c58ed5">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l03497"></a>03497 };
<a name="l03498"></a>03498 <span class="preprocessor">#endif </span><span class="comment">/*HAVE_SPATIAL*/</span>
<a name="l03499"></a>03499 
<a name="l03500"></a>03500 
<a name="l03501"></a><a class="code" href="classField__enum.html">03501</a> <span class="keyword">class </span><a class="code" href="classField__enum.html">Field_enum</a> :<span class="keyword">public</span> <a class="code" href="classField__str.html">Field_str</a> {
<a name="l03502"></a>03502 <span class="keyword">protected</span>:
<a name="l03503"></a>03503   uint packlength;
<a name="l03504"></a>03504 <span class="keyword">public</span>:
<a name="l03505"></a>03505   TYPELIB *typelib;
<a name="l03506"></a>03506   <a class="code" href="classField__enum.html">Field_enum</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l03507"></a>03507              uchar null_bit_arg,
<a name="l03508"></a>03508              <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03509"></a>03509              uint packlength_arg,
<a name="l03510"></a>03510              TYPELIB *typelib_arg,
<a name="l03511"></a>03511              <span class="keyword">const</span> CHARSET_INFO *charset_arg)
<a name="l03512"></a>03512     :<a class="code" href="classField__str.html">Field_str</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l03513"></a>03513                unireg_check_arg, field_name_arg, charset_arg),
<a name="l03514"></a>03514     packlength(packlength_arg),typelib(typelib_arg)
<a name="l03515"></a>03515   {
<a name="l03516"></a>03516     flags|=ENUM_FLAG;
<a name="l03517"></a>03517   }
<a name="l03518"></a>03518   <a class="code" href="classField.html">Field</a> *new_field(MEM_ROOT *root, <a class="code" href="structTABLE.html">TABLE</a> *new_table, <span class="keywordtype">bool</span> keep_type);
<a name="l03519"></a>03519   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_STRING; }
<a name="l03520"></a>03520   <span class="keywordtype">bool</span> match_collation_to_optimize_range()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }
<a name="l03521"></a>03521   <span class="keyword">enum</span> Item_result cmp_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l03522"></a>03522   <span class="keyword">enum</span> Item_result cast_to_int_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l03523"></a>03523   <span class="keyword">enum</span> ha_base_keytype key_type() <span class="keyword">const</span>;
<a name="l03524"></a>03524   type_conversion_status <a class="code" href="classField__enum.html#afaf2990ad77c2027ab8c14fbb48634c0">store</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *to,uint length,
<a name="l03525"></a>03525                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l03526"></a>03526   type_conversion_status <a class="code" href="classField__enum.html#afaf2990ad77c2027ab8c14fbb48634c0">store</a>(<span class="keywordtype">double</span> nr);
<a name="l03527"></a>03527   type_conversion_status <a class="code" href="classField__enum.html#afaf2990ad77c2027ab8c14fbb48634c0">store</a>(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l03528"></a>03528   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l03529"></a>03529   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *decimal_value);
<a name="l03530"></a>03530   longlong val_int(<span class="keywordtype">void</span>);
<a name="l03531"></a>03531   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l03532"></a>03532   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *,<span class="keyword">const</span> uchar *);
<a name="l03533"></a>03533   <span class="keywordtype">void</span> <a class="code" href="classField__enum.html#a778aa25069489e46f1ee1d1236bcba85">make_sort_key</a>(uchar *buff, uint length);
<a name="l03534"></a>03534   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint32) packlength; }
<a name="l03535"></a>03535   <span class="keywordtype">void</span> store_type(ulonglong value);
<a name="l03536"></a>03536   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03537"></a>03537   enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_ENUM; }
<a name="l03538"></a>03538   uint pack_length_from_metadata(uint field_metadata)
<a name="l03539"></a>03539   { <span class="keywordflow">return</span> (field_metadata &amp; 0x00ff); }
<a name="l03540"></a>03540   uint row_pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> pack_length(); }
<a name="l03541"></a>03541   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l03542"></a>03542   <span class="keywordtype">bool</span> optimize_range(uint idx, uint part) { <span class="keywordflow">return</span> 0; }
<a name="l03543"></a>03543   <span class="keywordtype">bool</span> <a class="code" href="classField__enum.html#a56dbcedd28fd3cd4ae349235462f1101">eq_def</a>(<a class="code" href="classField.html">Field</a> *field);
<a name="l03544"></a>03544   <span class="keywordtype">bool</span> has_charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> TRUE; }
<a name="l03545"></a>03545   <span class="comment">/* enum and set are sorted as integers */</span>
<a name="l03546"></a>03546   CHARSET_INFO *sort_charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;my_charset_bin; }
<a name="l03547"></a><a class="code" href="classField__enum.html#a4b87671635df40d1668a2457868e5451">03547</a>   <a class="code" href="classField__enum.html">Field_enum</a> *<a class="code" href="classField__enum.html#a4b87671635df40d1668a2457868e5451">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{
<a name="l03548"></a>03548     DBUG_ASSERT(real_type() == MYSQL_TYPE_ENUM);
<a name="l03549"></a>03549     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__enum.html">Field_enum</a>(*<span class="keyword">this</span>);
<a name="l03550"></a>03550   }
<a name="l03551"></a><a class="code" href="classField__enum.html#aa88e8a7b600267a15678000e4377591a">03551</a>   <a class="code" href="classField__enum.html">Field_enum</a> *<a class="code" href="classField__enum.html#aa88e8a7b600267a15678000e4377591a">clone</a>()<span class="keyword"> const </span>{ 
<a name="l03552"></a>03552     DBUG_ASSERT(real_type() == MYSQL_TYPE_ENUM);
<a name="l03553"></a>03553     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__enum.html">Field_enum</a>(*<span class="keyword">this</span>);
<a name="l03554"></a>03554   }
<a name="l03555"></a>03555   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__enum.html#ab9e1135fdf17255f7a96193463d58bdd">pack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l03556"></a>03556                       uint max_length, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03557"></a>03557   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__enum.html#a94bb8c13a4729eb7be3acf8d3c59904c">unpack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l03558"></a>03558                               uint param_data, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03559"></a>03559 
<a name="l03560"></a>03560 <span class="keyword">private</span>:
<a name="l03561"></a>03561   <span class="keywordtype">int</span> do_save_field_metadata(uchar *first_byte);
<a name="l03562"></a>03562   uint is_equal(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l03563"></a>03563 };
<a name="l03564"></a>03564 
<a name="l03565"></a>03565 
<a name="l03566"></a><a class="code" href="classField__set.html">03566</a> <span class="keyword">class </span><a class="code" href="classField__set.html">Field_set</a> :<span class="keyword">public</span> <a class="code" href="classField__enum.html">Field_enum</a> {
<a name="l03567"></a>03567 <span class="keyword">public</span>:
<a name="l03568"></a>03568   <a class="code" href="classField__set.html">Field_set</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l03569"></a>03569             uchar null_bit_arg,
<a name="l03570"></a>03570             <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg,
<a name="l03571"></a>03571             uint32 packlength_arg,
<a name="l03572"></a>03572             TYPELIB *typelib_arg, <span class="keyword">const</span> CHARSET_INFO *charset_arg)
<a name="l03573"></a>03573     :<a class="code" href="classField__enum.html">Field_enum</a>(ptr_arg, len_arg, null_ptr_arg, null_bit_arg,
<a name="l03574"></a>03574                     unireg_check_arg, field_name_arg,
<a name="l03575"></a>03575                 packlength_arg,
<a name="l03576"></a>03576                 typelib_arg,charset_arg),
<a name="l03577"></a>03577       empty_set_string(<span class="stringliteral">&quot;&quot;</span>, 0, charset_arg)
<a name="l03578"></a>03578     {
<a name="l03579"></a>03579       flags= (flags &amp; ~ENUM_FLAG) | SET_FLAG;
<a name="l03580"></a>03580     }
<a name="l03581"></a>03581   type_conversion_status <a class="code" href="classField__set.html#afdae638e035d044ba1baf926d0604d1d">store</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l03582"></a>03582                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l03583"></a><a class="code" href="classField__set.html#a58b1852786b3bfe85a3cd2dd7edbfaf2">03583</a>   type_conversion_status <a class="code" href="classField__set.html#afdae638e035d044ba1baf926d0604d1d">store</a>(<span class="keywordtype">double</span> nr)
<a name="l03584"></a>03584   {
<a name="l03585"></a>03585     <span class="keywordflow">return</span> <a class="code" href="classField__set.html#afdae638e035d044ba1baf926d0604d1d">Field_set::store</a>((longlong) nr, FALSE);
<a name="l03586"></a>03586   }
<a name="l03587"></a>03587   type_conversion_status <a class="code" href="classField__set.html#afdae638e035d044ba1baf926d0604d1d">store</a>(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l03588"></a>03588   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> zero_pack()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 1; }
<a name="l03589"></a>03589   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*,<a class="code" href="classString.html">String</a> *);
<a name="l03590"></a>03590   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03591"></a>03591   enum_field_types real_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_SET; }
<a name="l03592"></a>03592   <span class="keywordtype">bool</span> has_charset(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> TRUE; }
<a name="l03593"></a><a class="code" href="classField__set.html#a0fedd1cea639b75ed2f4328292d8f7a5">03593</a>   <a class="code" href="classField__set.html">Field_set</a> *<a class="code" href="classField__set.html#a0fedd1cea639b75ed2f4328292d8f7a5">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l03594"></a>03594     DBUG_ASSERT(real_type() == MYSQL_TYPE_SET);
<a name="l03595"></a>03595     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__set.html">Field_set</a>(*<span class="keyword">this</span>);
<a name="l03596"></a>03596   }
<a name="l03597"></a><a class="code" href="classField__set.html#a58775a24799b6aff18ac09223c6c09f5">03597</a>   <a class="code" href="classField__set.html">Field_set</a> *<a class="code" href="classField__set.html#a58775a24799b6aff18ac09223c6c09f5">clone</a>()<span class="keyword"> const </span>{
<a name="l03598"></a>03598     DBUG_ASSERT(real_type() == MYSQL_TYPE_SET);
<a name="l03599"></a>03599     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__set.html">Field_set</a>(*<span class="keyword">this</span>);
<a name="l03600"></a>03600   }
<a name="l03601"></a>03601 <span class="keyword">private</span>:
<a name="l03602"></a>03602   <span class="keyword">const</span> <a class="code" href="classString.html">String</a> empty_set_string;
<a name="l03603"></a>03603 };
<a name="l03604"></a>03604 
<a name="l03605"></a>03605 
<a name="l03606"></a>03606 <span class="comment">/*</span>
<a name="l03607"></a>03607 <span class="comment">  Note:</span>
<a name="l03608"></a>03608 <span class="comment">    To use Field_bit::cmp_binary() you need to copy the bits stored in</span>
<a name="l03609"></a>03609 <span class="comment">    the beginning of the record (the NULL bytes) to each memory you</span>
<a name="l03610"></a>03610 <span class="comment">    want to compare (where the arguments point).</span>
<a name="l03611"></a>03611 <span class="comment"></span>
<a name="l03612"></a>03612 <span class="comment">    This is the reason:</span>
<a name="l03613"></a>03613 <span class="comment">    - Field_bit::cmp_binary() is only implemented in the base class</span>
<a name="l03614"></a>03614 <span class="comment">      (Field::cmp_binary()).</span>
<a name="l03615"></a>03615 <span class="comment">    - Field::cmp_binary() currenly use pack_length() to calculate how</span>
<a name="l03616"></a>03616 <span class="comment">      long the data is.</span>
<a name="l03617"></a>03617 <span class="comment">    - pack_length() includes size of the bits stored in the NULL bytes</span>
<a name="l03618"></a>03618 <span class="comment">      of the record.</span>
<a name="l03619"></a>03619 <span class="comment">*/</span>
<a name="l03620"></a><a class="code" href="classField__bit.html">03620</a> <span class="keyword">class </span><a class="code" href="classField__bit.html">Field_bit</a> :<span class="keyword">public</span> <a class="code" href="classField.html">Field</a> {
<a name="l03621"></a>03621 <span class="keyword">public</span>:
<a name="l03622"></a>03622   uchar *bit_ptr;     <span class="comment">// position in record where &#39;uneven&#39; bits store</span>
<a name="l03623"></a>03623   uchar bit_ofs;      <span class="comment">// offset to &#39;uneven&#39; high bits</span>
<a name="l03624"></a>03624   uint bit_len;       <span class="comment">// number of &#39;uneven&#39; high bits</span>
<a name="l03625"></a>03625   uint bytes_in_rec;
<a name="l03626"></a>03626   <a class="code" href="classField__bit.html">Field_bit</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l03627"></a>03627             uchar null_bit_arg, uchar *bit_ptr_arg, uchar bit_ofs_arg,
<a name="l03628"></a>03628             <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg);
<a name="l03629"></a>03629   enum_field_types type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_BIT; }
<a name="l03630"></a>03630   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_BIT; }
<a name="l03631"></a>03631   uint32 key_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint32) (field_length + 7) / 8; }
<a name="l03632"></a><a class="code" href="classField__bit.html#adb46a9d96a7eb3d04587bbbb2cad3b7e">03632</a>   uint32 <a class="code" href="classField__bit.html#adb46a9d96a7eb3d04587bbbb2cad3b7e">max_data_length</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (field_length + 7) / 8; }
<a name="l03633"></a>03633   uint32 max_display_length() { <span class="keywordflow">return</span> field_length; }
<a name="l03634"></a>03634   Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l03635"></a>03635   type_conversion_status reset(<span class="keywordtype">void</span>)
<a name="l03636"></a>03636   {
<a name="l03637"></a>03637     memset(ptr, 0, bytes_in_rec);
<a name="l03638"></a>03638     <span class="keywordflow">if</span> (bit_ptr &amp;&amp; (bit_len &gt; 0))  <span class="comment">// reset odd bits among null bits</span>
<a name="l03639"></a>03639       clr_rec_bits(bit_ptr, bit_ofs, bit_len);
<a name="l03640"></a>03640     <span class="keywordflow">return</span> TYPE_OK;
<a name="l03641"></a>03641   }
<a name="l03642"></a>03642   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l03643"></a>03643                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l03644"></a>03644   type_conversion_status store(<span class="keywordtype">double</span> nr);
<a name="l03645"></a>03645   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val);
<a name="l03646"></a>03646   type_conversion_status store_decimal(<span class="keyword">const</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l03647"></a>03647   <span class="keywordtype">double</span> val_real(<span class="keywordtype">void</span>);
<a name="l03648"></a>03648   longlong val_int(<span class="keywordtype">void</span>);
<a name="l03649"></a>03649   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*, <a class="code" href="classString.html">String</a> *);
<a name="l03650"></a>03650   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> str_needs_quotes() { <span class="keywordflow">return</span> TRUE; }
<a name="l03651"></a>03651   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l03652"></a>03652   <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> uchar *a, <span class="keyword">const</span> uchar *b)
<a name="l03653"></a>03653   {
<a name="l03654"></a>03654     DBUG_ASSERT(ptr == a || ptr == b);
<a name="l03655"></a>03655     <span class="keywordflow">if</span> (ptr == a)
<a name="l03656"></a>03656       <span class="keywordflow">return</span> Field_bit::key_cmp(b, bytes_in_rec+MY_TEST(bit_len));
<a name="l03657"></a>03657     <span class="keywordflow">else</span>
<a name="l03658"></a>03658       <span class="keywordflow">return</span> Field_bit::key_cmp(a, bytes_in_rec+MY_TEST(bit_len)) * -1;
<a name="l03659"></a>03659   }
<a name="l03660"></a>03660   <span class="keywordtype">int</span> cmp_binary_offset(uint row_offset)
<a name="l03661"></a>03661   { <span class="keywordflow">return</span> cmp_offset(row_offset); }
<a name="l03662"></a>03662   <span class="keywordtype">int</span> cmp_max(<span class="keyword">const</span> uchar *a, <span class="keyword">const</span> uchar *b, uint max_length);
<a name="l03663"></a>03663   <span class="keywordtype">int</span> key_cmp(<span class="keyword">const</span> uchar *a, <span class="keyword">const</span> uchar *b)
<a name="l03664"></a>03664   { <span class="keywordflow">return</span> cmp_binary((uchar *) a, (uchar *) b); }
<a name="l03665"></a>03665   <span class="keywordtype">int</span> key_cmp(<span class="keyword">const</span> uchar *str, uint length);
<a name="l03666"></a>03666   <span class="keywordtype">int</span> cmp_offset(uint row_offset);
<a name="l03667"></a>03667   <span class="keywordtype">void</span> get_image(uchar *buff, uint length, <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l03668"></a>03668   { get_key_image(buff, length, itRAW); }   
<a name="l03669"></a>03669   <span class="keywordtype">void</span> set_image(<span class="keyword">const</span> uchar *buff,uint length, <span class="keyword">const</span> CHARSET_INFO *cs)
<a name="l03670"></a>03670   { Field_bit::store((<span class="keywordtype">char</span> *) buff, length, cs); }
<a name="l03671"></a>03671   uint get_key_image(uchar *buff, uint length, imagetype type);
<a name="l03672"></a>03672   <span class="keywordtype">void</span> set_key_image(<span class="keyword">const</span> uchar *buff, uint length)
<a name="l03673"></a>03673   { Field_bit::store((<span class="keywordtype">char</span>*) buff, length, &amp;my_charset_bin); }
<a name="l03674"></a><a class="code" href="classField__bit.html#a61e2e112053985d3ad43334ef03a5103">03674</a>   <span class="keywordtype">void</span> <a class="code" href="classField__bit.html#a61e2e112053985d3ad43334ef03a5103">make_sort_key</a>(uchar *buff, uint length)
<a name="l03675"></a>03675   { get_key_image(buff, length, itRAW); }
<a name="l03676"></a>03676   uint32 pack_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint32) (field_length + 7) / 8; }
<a name="l03677"></a>03677   uint32 pack_length_in_rec()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> bytes_in_rec; }
<a name="l03678"></a>03678   uint <a class="code" href="classField__bit.html#abb93169009e3b74b3b94a2ae33c9b802">pack_length_from_metadata</a>(uint field_metadata);
<a name="l03679"></a>03679   uint row_pack_length()<span class="keyword"> const</span>
<a name="l03680"></a>03680 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (bytes_in_rec + ((bit_len &gt; 0) ? 1 : 0)); }
<a name="l03681"></a>03681   <span class="keywordtype">bool</span> <a class="code" href="classField__bit.html#abc1d459f116ca15efd4d0e84c5fc65fd">compatible_field_size</a>(uint metadata, <a class="code" href="classRelay__log__info.html">Relay_log_info</a> *rli,
<a name="l03682"></a>03682                              uint16 mflags, <span class="keywordtype">int</span> *order_var);
<a name="l03683"></a>03683   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03684"></a>03684   <span class="keyword">virtual</span> uchar *<a class="code" href="classField__bit.html#a330cb15674837be6c0487ffcbbdc9ba4">pack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l03685"></a>03685                       uint max_length, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03686"></a>03686   <span class="keyword">virtual</span> <span class="keyword">const</span> uchar *<a class="code" href="classField__bit.html#ae770942d4124955fc0e4cfae31ea932d">unpack</a>(uchar *to, <span class="keyword">const</span> uchar *from,
<a name="l03687"></a>03687                               uint param_data, <span class="keywordtype">bool</span> low_byte_first);
<a name="l03688"></a>03688   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_default();
<a name="l03689"></a>03689 
<a name="l03690"></a>03690   <a class="code" href="classField.html">Field</a> *new_key_field(MEM_ROOT *root, <a class="code" href="structTABLE.html">TABLE</a> *new_table,
<a name="l03691"></a>03691                        uchar *new_ptr, uchar *new_null_ptr,
<a name="l03692"></a>03692                        uint new_null_bit);
<a name="l03693"></a>03693   <span class="keywordtype">void</span> set_bit_ptr(uchar *bit_ptr_arg, uchar bit_ofs_arg)
<a name="l03694"></a>03694   {
<a name="l03695"></a>03695     bit_ptr= bit_ptr_arg;
<a name="l03696"></a>03696     bit_ofs= bit_ofs_arg;
<a name="l03697"></a>03697   }
<a name="l03698"></a>03698   <span class="keywordtype">bool</span> eq(<a class="code" href="classField.html">Field</a> *field)
<a name="l03699"></a>03699   {
<a name="l03700"></a>03700     <span class="keywordflow">return</span> (Field::eq(field) &amp;&amp;
<a name="l03701"></a>03701             bit_ptr == ((<a class="code" href="classField__bit.html">Field_bit</a> *)field)-&gt;bit_ptr &amp;&amp;
<a name="l03702"></a>03702             bit_ofs == ((<a class="code" href="classField__bit.html">Field_bit</a> *)field)-&gt;bit_ofs);
<a name="l03703"></a>03703   }
<a name="l03704"></a>03704   uint <a class="code" href="classField__bit.html#a92ecc819aaa815e8bd059db03c17d680">is_equal</a>(<a class="code" href="classCreate__field.html">Create_field</a> *new_field);
<a name="l03705"></a>03705   <span class="keywordtype">void</span> move_field_offset(my_ptrdiff_t ptr_diff)
<a name="l03706"></a>03706   {
<a name="l03707"></a>03707     Field::move_field_offset(ptr_diff);
<a name="l03708"></a>03708     bit_ptr= ADD_TO_PTR(bit_ptr, ptr_diff, uchar*);
<a name="l03709"></a>03709   }
<a name="l03710"></a>03710   <span class="keywordtype">void</span> hash(ulong *nr, ulong *nr2);
<a name="l03711"></a><a class="code" href="classField__bit.html#aa242ed997e18ba4129c3ae2ae92b2897">03711</a>   <a class="code" href="classField__bit.html">Field_bit</a> *<a class="code" href="classField__bit.html#aa242ed997e18ba4129c3ae2ae92b2897">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l03712"></a>03712     DBUG_ASSERT(type() == MYSQL_TYPE_BIT);
<a name="l03713"></a>03713     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__bit.html">Field_bit</a>(*<span class="keyword">this</span>);
<a name="l03714"></a>03714   }
<a name="l03715"></a><a class="code" href="classField__bit.html#a8eef409a6f6ef000f70be2dceabf0a48">03715</a>   <a class="code" href="classField__bit.html">Field_bit</a> *<a class="code" href="classField__bit.html#a8eef409a6f6ef000f70be2dceabf0a48">clone</a>()<span class="keyword"> const </span>{
<a name="l03716"></a>03716     DBUG_ASSERT(type() == MYSQL_TYPE_BIT);
<a name="l03717"></a>03717     <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__bit.html">Field_bit</a>(*<span class="keyword">this</span>);
<a name="l03718"></a>03718   }
<a name="l03719"></a>03719 <span class="keyword">private</span>:
<a name="l03720"></a>03720   <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> do_last_null_byte() <span class="keyword">const</span>;
<a name="l03721"></a>03721   <span class="keywordtype">int</span> do_save_field_metadata(uchar *first_byte);
<a name="l03722"></a>03722 };
<a name="l03723"></a>03723 
<a name="l03724"></a>03724 
<a name="l03732"></a><a class="code" href="classField__bit__as__char.html">03732</a> <span class="keyword">class </span><a class="code" href="classField__bit__as__char.html">Field_bit_as_char</a>: <span class="keyword">public</span> <a class="code" href="classField__bit.html">Field_bit</a> {
<a name="l03733"></a>03733 <span class="keyword">public</span>:
<a name="l03734"></a>03734   <a class="code" href="classField__bit__as__char.html">Field_bit_as_char</a>(uchar *ptr_arg, uint32 len_arg, uchar *null_ptr_arg,
<a name="l03735"></a>03735                     uchar null_bit_arg,
<a name="l03736"></a>03736                     <span class="keyword">enum</span> utype unireg_check_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name_arg);
<a name="l03737"></a>03737   <span class="keyword">enum</span> ha_base_keytype key_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> HA_KEYTYPE_BINARY; }
<a name="l03738"></a>03738   type_conversion_status store(<span class="keyword">const</span> <span class="keywordtype">char</span> *to, uint length,
<a name="l03739"></a>03739                                <span class="keyword">const</span> CHARSET_INFO *charset);
<a name="l03740"></a>03740   type_conversion_status store(<span class="keywordtype">double</span> nr) { <span class="keywordflow">return</span> Field_bit::store(nr); }
<a name="l03741"></a>03741   type_conversion_status store(longlong nr, <span class="keywordtype">bool</span> unsigned_val)
<a name="l03742"></a>03742   { <span class="keywordflow">return</span> Field_bit::store(nr, unsigned_val); }
<a name="l03743"></a>03743   <span class="keywordtype">void</span> sql_type(<a class="code" href="classString.html">String</a> &amp;str) <span class="keyword">const</span>;
<a name="l03744"></a><a class="code" href="classField__bit__as__char.html#ae46e5425a30d7076fd89ee3a4bff3df7">03744</a>   <a class="code" href="classField__bit__as__char.html">Field_bit_as_char</a> *<a class="code" href="classField__bit__as__char.html#ae46e5425a30d7076fd89ee3a4bff3df7">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const </span>{ 
<a name="l03745"></a>03745     <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classField__bit__as__char.html">Field_bit_as_char</a>(*<span class="keyword">this</span>);
<a name="l03746"></a>03746   }
<a name="l03747"></a><a class="code" href="classField__bit__as__char.html#a77884f74a230a0cd3fbe83b9d067ca4d">03747</a>   <a class="code" href="classField__bit__as__char.html">Field_bit_as_char</a> *<a class="code" href="classField__bit__as__char.html#a77884f74a230a0cd3fbe83b9d067ca4d">clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classField__bit__as__char.html">Field_bit_as_char</a>(*<span class="keyword">this</span>); }
<a name="l03748"></a>03748 };
<a name="l03749"></a>03749 
<a name="l03750"></a>03750 
<a name="l03751"></a>03751 <span class="comment">/*</span>
<a name="l03752"></a>03752 <span class="comment">  Create field class for CREATE TABLE</span>
<a name="l03753"></a>03753 <span class="comment">*/</span>
<a name="l03754"></a>03754 
<a name="l03755"></a><a class="code" href="classCreate__field.html">03755</a> <span class="keyword">class </span><a class="code" href="classCreate__field.html">Create_field</a> :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l03756"></a>03756 {
<a name="l03757"></a>03757 <span class="keyword">public</span>:
<a name="l03758"></a>03758   <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name;
<a name="l03759"></a>03759   <span class="keyword">const</span> <span class="keywordtype">char</span> *change;                   <span class="comment">// If done with alter table</span>
<a name="l03760"></a>03760   <span class="keyword">const</span> <span class="keywordtype">char</span> *after;                    <span class="comment">// Put column after this one</span>
<a name="l03761"></a>03761   LEX_STRING comment;                   <span class="comment">// Comment for field</span>
<a name="l03762"></a>03762 
<a name="l03771"></a><a class="code" href="classCreate__field.html#add6934550bcdc4bd48101899066afcf7">03771</a>   <a class="code" href="classItem.html">Item</a> *<a class="code" href="classCreate__field.html#add6934550bcdc4bd48101899066afcf7">def</a>;
<a name="l03772"></a>03772   <span class="keyword">enum</span>  enum_field_types sql_type;
<a name="l03773"></a>03773   <span class="comment">/*</span>
<a name="l03774"></a>03774 <span class="comment">    At various stages in execution this can be length of field in bytes or</span>
<a name="l03775"></a>03775 <span class="comment">    max number of characters. </span>
<a name="l03776"></a>03776 <span class="comment">  */</span>
<a name="l03777"></a>03777   ulong length;
<a name="l03778"></a>03778   <span class="comment">/*</span>
<a name="l03779"></a>03779 <span class="comment">    The value of `length&#39; as set by parser: is the number of characters</span>
<a name="l03780"></a>03780 <span class="comment">    for most of the types, or of bytes for BLOBs or numeric types.</span>
<a name="l03781"></a>03781 <span class="comment">  */</span>
<a name="l03782"></a>03782   uint32 char_length;
<a name="l03783"></a>03783   uint  decimals, flags, pack_length, key_length;
<a name="l03784"></a>03784   Field::utype unireg_check;
<a name="l03785"></a>03785   TYPELIB *interval;                    <span class="comment">// Which interval to use</span>
<a name="l03786"></a>03786   TYPELIB *save_interval;               <span class="comment">// Temporary copy for the above</span>
<a name="l03787"></a>03787                                         <span class="comment">// Used only for UCS2 intervals</span>
<a name="l03788"></a>03788   <a class="code" href="classList.html">List&lt;String&gt;</a> interval_list;
<a name="l03789"></a>03789   <span class="keyword">const</span> CHARSET_INFO *charset;
<a name="l03790"></a>03790   Field::geometry_type geom_type;
<a name="l03791"></a>03791   <a class="code" href="classField.html">Field</a> *field;                         <span class="comment">// For alter table</span>
<a name="l03792"></a>03792 
<a name="l03793"></a>03793   uint8 row,col,sc_length,interval_id;  <span class="comment">// For rea_create_table</span>
<a name="l03794"></a>03794   uint  offset,pack_flag;
<a name="l03795"></a>03795   <a class="code" href="classCreate__field.html">Create_field</a>() :after(NULL) {}
<a name="l03796"></a>03796   <a class="code" href="classCreate__field.html">Create_field</a>(<a class="code" href="classField.html">Field</a> *field, <a class="code" href="classField.html">Field</a> *orig_field);
<a name="l03797"></a>03797   <span class="comment">/* Used to make a clone of this object for ALTER/CREATE TABLE */</span>
<a name="l03798"></a>03798   <a class="code" href="classCreate__field.html">Create_field</a> *clone(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l03799"></a>03799 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classCreate__field.html">Create_field</a>(*<span class="keyword">this</span>); }
<a name="l03800"></a>03800   <span class="keywordtype">void</span> <a class="code" href="classCreate__field.html#a19af2570fa554626f604637ad2a98894">create_length_to_internal_length</a>(<span class="keywordtype">void</span>);
<a name="l03801"></a>03801 
<a name="l03802"></a>03802   <span class="comment">/* Init for a tmp table field. To be extended if need be. */</span>
<a name="l03803"></a>03803   <span class="keywordtype">void</span> <a class="code" href="classCreate__field.html#ac65e50b2515b9ab1f50430f152d889e0">init_for_tmp_table</a>(enum_field_types sql_type_arg,
<a name="l03804"></a>03804                           uint32 max_length, uint32 decimals,
<a name="l03805"></a>03805                           <span class="keywordtype">bool</span> maybe_null, <span class="keywordtype">bool</span> is_unsigned,
<a name="l03806"></a>03806                           uint pack_length = ~0U);
<a name="l03807"></a>03807 
<a name="l03808"></a>03808   <span class="keywordtype">bool</span> <a class="code" href="classCreate__field.html#a0147cec88d62c8111e19fbcd4653eaa0">init</a>(THD *thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name, enum_field_types type,
<a name="l03809"></a>03809             <span class="keyword">const</span> <span class="keywordtype">char</span> *length, <span class="keyword">const</span> <span class="keywordtype">char</span> *decimals, uint type_modifier,
<a name="l03810"></a>03810             <a class="code" href="classItem.html">Item</a> *default_value, <a class="code" href="classItem.html">Item</a> *on_update_value, LEX_STRING *comment,
<a name="l03811"></a>03811             <span class="keyword">const</span> <span class="keywordtype">char</span> *change, <a class="code" href="classList.html">List&lt;String&gt;</a> *interval_list,
<a name="l03812"></a>03812             <span class="keyword">const</span> CHARSET_INFO *cs, uint uint_geom_type);
<a name="l03813"></a>03813 
<a name="l03814"></a>03814   ha_storage_media field_storage_type()<span class="keyword"> const</span>
<a name="l03815"></a>03815 <span class="keyword">  </span>{
<a name="l03816"></a>03816     <span class="keywordflow">return</span> (ha_storage_media)
<a name="l03817"></a>03817       ((flags &gt;&gt; FIELD_FLAGS_STORAGE_MEDIA) &amp; 3);
<a name="l03818"></a>03818   }
<a name="l03819"></a>03819 
<a name="l03820"></a>03820   column_format_type column_format()<span class="keyword"> const</span>
<a name="l03821"></a>03821 <span class="keyword">  </span>{
<a name="l03822"></a>03822     <span class="keywordflow">return</span> (column_format_type)
<a name="l03823"></a>03823       ((flags &gt;&gt; FIELD_FLAGS_COLUMN_FORMAT) &amp; 3);
<a name="l03824"></a>03824   }
<a name="l03825"></a>03825 };
<a name="l03826"></a>03826 
<a name="l03827"></a>03827 
<a name="l03828"></a>03828 <span class="comment">/*</span>
<a name="l03829"></a>03829 <span class="comment">  A class for sending info to the client</span>
<a name="l03830"></a>03830 <span class="comment">*/</span>
<a name="l03831"></a>03831 
<a name="l03832"></a><a class="code" href="classSend__field.html">03832</a> <span class="keyword">class </span><a class="code" href="classSend__field.html">Send_field</a> :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a> {
<a name="l03833"></a>03833  <span class="keyword">public</span>:
<a name="l03834"></a>03834   <span class="keyword">const</span> <span class="keywordtype">char</span> *db_name;
<a name="l03835"></a>03835   <span class="keyword">const</span> <span class="keywordtype">char</span> *table_name,*org_table_name;
<a name="l03836"></a>03836   <span class="keyword">const</span> <span class="keywordtype">char</span> *col_name,*org_col_name;
<a name="l03837"></a>03837   ulong length;
<a name="l03838"></a>03838   uint charsetnr, flags, decimals;
<a name="l03839"></a>03839   enum_field_types type;
<a name="l03840"></a>03840   <a class="code" href="classSend__field.html">Send_field</a>() {}
<a name="l03841"></a>03841 };
<a name="l03842"></a>03842 
<a name="l03843"></a>03843 
<a name="l03844"></a>03844 <span class="comment">/*</span>
<a name="l03845"></a>03845 <span class="comment">  A class for quick copying data to fields</span>
<a name="l03846"></a>03846 <span class="comment">*/</span>
<a name="l03847"></a>03847 
<a name="l03848"></a><a class="code" href="classCopy__field.html">03848</a> <span class="keyword">class </span><a class="code" href="classCopy__field.html">Copy_field</a> :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a> {
<a name="l03853"></a>03853   <span class="keyword">typedef</span> <span class="keywordtype">void</span> Copy_func(<a class="code" href="classCopy__field.html">Copy_field</a>*);
<a name="l03854"></a>03854   Copy_func *get_copy_func(<a class="code" href="classField.html">Field</a> *to, <a class="code" href="classField.html">Field</a> *from);
<a name="l03855"></a>03855 <span class="keyword">public</span>:
<a name="l03856"></a>03856   uchar *from_ptr,*to_ptr;
<a name="l03857"></a>03857   uchar *from_null_ptr,*to_null_ptr;
<a name="l03858"></a>03858   my_bool *null_row;
<a name="l03859"></a>03859   uint  from_bit,to_bit;
<a name="l03877"></a><a class="code" href="classCopy__field.html#ac7b01609e9c8c1f9cb8d7a1ca5ed301c">03877</a>   uint <a class="code" href="classCopy__field.html#ac7b01609e9c8c1f9cb8d7a1ca5ed301c">from_length</a>,to_length;
<a name="l03878"></a>03878   <a class="code" href="classField.html">Field</a> *from_field,*to_field;
<a name="l03879"></a>03879   <a class="code" href="classString.html">String</a> tmp;                                   <span class="comment">// For items</span>
<a name="l03880"></a>03880 
<a name="l03881"></a>03881   <a class="code" href="classCopy__field.html">Copy_field</a>() {}
<a name="l03882"></a>03882   ~<a class="code" href="classCopy__field.html">Copy_field</a>() {}
<a name="l03883"></a>03883   <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="classField.html">Field</a> *to,<a class="code" href="classField.html">Field</a> *from,<span class="keywordtype">bool</span> save);    <span class="comment">// Field to field </span>
<a name="l03884"></a>03884   <span class="keywordtype">void</span> <span class="keyword">set</span>(uchar *to,<a class="code" href="classField.html">Field</a> *from);              <span class="comment">// Field to string</span>
<a name="l03885"></a>03885   void (*do_copy)(<a class="code" href="classCopy__field.html">Copy_field</a> *);
<a name="l03886"></a>03886   void (*do_copy2)(<a class="code" href="classCopy__field.html">Copy_field</a> *);               <span class="comment">// Used to handle null values</span>
<a name="l03887"></a>03887 };
<a name="l03888"></a>03888 
<a name="l03889"></a>03889 
<a name="l03890"></a>03890 <a class="code" href="classField.html">Field</a> *make_field(<a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, uchar *ptr, uint32 field_length,
<a name="l03891"></a>03891                   uchar *null_pos, uchar null_bit,
<a name="l03892"></a>03892                   uint pack_flag, enum_field_types field_type,
<a name="l03893"></a>03893                   <span class="keyword">const</span> CHARSET_INFO *cs,
<a name="l03894"></a>03894                   Field::geometry_type geom_type,
<a name="l03895"></a>03895                   Field::utype unireg_check,
<a name="l03896"></a>03896                   TYPELIB *interval, <span class="keyword">const</span> <span class="keywordtype">char</span> *field_name);
<a name="l03897"></a>03897 uint pack_length_to_packflag(uint type);
<a name="l03898"></a>03898 enum_field_types get_blob_type_from_length(ulong length);
<a name="l03899"></a>03899 uint32 calc_pack_length(enum_field_types type,uint32 length);
<a name="l03900"></a>03900 type_conversion_status set_field_to_null(<a class="code" href="classField.html">Field</a> *field);
<a name="l03901"></a>03901 type_conversion_status <a class="code" href="field__conv_8cc.html#a599acd756b800d3f7fe93820cc9d0c66">set_field_to_null_with_conversions</a>(<a class="code" href="classField.html">Field</a> *field,
<a name="l03902"></a>03902                                                           <span class="keywordtype">bool</span> no_conversions);
<a name="l03903"></a>03903 
<a name="l03904"></a>03904 <span class="comment">/*</span>
<a name="l03905"></a>03905 <span class="comment">  The following are for the interface with the .frm file</span>
<a name="l03906"></a>03906 <span class="comment">*/</span>
<a name="l03907"></a>03907 
<a name="l03908"></a>03908 <span class="preprocessor">#define FIELDFLAG_DECIMAL               1</span>
<a name="l03909"></a>03909 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_BINARY                1       // Shares same flag</span>
<a name="l03910"></a>03910 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_NUMBER                2</span>
<a name="l03911"></a>03911 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_ZEROFILL              4</span>
<a name="l03912"></a>03912 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_PACK                  120     // Bits used for packing</span>
<a name="l03913"></a>03913 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_INTERVAL              256     // mangled with decimals!</span>
<a name="l03914"></a>03914 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_BITFIELD              512     // mangled with decimals!</span>
<a name="l03915"></a>03915 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_BLOB                  1024    // mangled with decimals!</span>
<a name="l03916"></a>03916 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_GEOM                  2048    // mangled with decimals!</span>
<a name="l03917"></a>03917 <span class="preprocessor"></span>
<a name="l03918"></a>03918 <span class="preprocessor">#define FIELDFLAG_TREAT_BIT_AS_CHAR     4096    </span><span class="comment">/* use Field_bit_as_char */</span>
<a name="l03919"></a>03919 
<a name="l03920"></a>03920 <span class="preprocessor">#define FIELDFLAG_LEFT_FULLSCREEN       8192</span>
<a name="l03921"></a>03921 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_RIGHT_FULLSCREEN      16384</span>
<a name="l03922"></a>03922 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_FORMAT_NUMBER         16384   // predit: ###,,## in output</span>
<a name="l03923"></a>03923 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_NO_DEFAULT            16384   </span><span class="comment">/* sql */</span>
<a name="l03924"></a>03924 <span class="preprocessor">#define FIELDFLAG_SUM                   ((uint) 32768)// predit: +#fieldflag</span>
<a name="l03925"></a>03925 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_MAYBE_NULL            ((uint) 32768)// sql</span>
<a name="l03926"></a>03926 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_HEX_ESCAPE            ((uint) 0x10000)</span>
<a name="l03927"></a>03927 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_PACK_SHIFT            3</span>
<a name="l03928"></a>03928 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_DEC_SHIFT             8</span>
<a name="l03929"></a>03929 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_MAX_DEC               31</span>
<a name="l03930"></a>03930 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_NUM_SCREEN_TYPE       0x7F01</span>
<a name="l03931"></a>03931 <span class="preprocessor"></span><span class="preprocessor">#define FIELDFLAG_ALFA_SCREEN_TYPE      0x7800</span>
<a name="l03932"></a>03932 <span class="preprocessor"></span>
<a name="l03933"></a>03933 <span class="preprocessor">#define MTYP_TYPENR(type) (type &amp; 127)  </span><span class="comment">/* Remove bits from type */</span>
<a name="l03934"></a>03934 
<a name="l03935"></a>03935 <span class="preprocessor">#define f_is_dec(x)             ((x) &amp; FIELDFLAG_DECIMAL)</span>
<a name="l03936"></a>03936 <span class="preprocessor"></span><span class="preprocessor">#define f_is_num(x)             ((x) &amp; FIELDFLAG_NUMBER)</span>
<a name="l03937"></a>03937 <span class="preprocessor"></span><span class="preprocessor">#define f_is_zerofill(x)        ((x) &amp; FIELDFLAG_ZEROFILL)</span>
<a name="l03938"></a>03938 <span class="preprocessor"></span><span class="preprocessor">#define f_is_packed(x)          ((x) &amp; FIELDFLAG_PACK)</span>
<a name="l03939"></a>03939 <span class="preprocessor"></span><span class="preprocessor">#define f_packtype(x)           (((x) &gt;&gt; FIELDFLAG_PACK_SHIFT) &amp; 15)</span>
<a name="l03940"></a>03940 <span class="preprocessor"></span><span class="preprocessor">#define f_decimals(x)           ((uint8) (((x) &gt;&gt; FIELDFLAG_DEC_SHIFT) &amp; FIELDFLAG_MAX_DEC))</span>
<a name="l03941"></a>03941 <span class="preprocessor"></span><span class="preprocessor">#define f_is_alpha(x)           (!f_is_num(x))</span>
<a name="l03942"></a>03942 <span class="preprocessor"></span><span class="preprocessor">#define f_is_binary(x)          ((x) &amp; FIELDFLAG_BINARY) // 4.0- compatibility</span>
<a name="l03943"></a>03943 <span class="preprocessor"></span><span class="preprocessor">#define f_is_enum(x)            (((x) &amp; (FIELDFLAG_INTERVAL | FIELDFLAG_NUMBER)) == FIELDFLAG_INTERVAL)</span>
<a name="l03944"></a>03944 <span class="preprocessor"></span><span class="preprocessor">#define f_is_bitfield(x)        (((x) &amp; (FIELDFLAG_BITFIELD | FIELDFLAG_NUMBER)) == FIELDFLAG_BITFIELD)</span>
<a name="l03945"></a>03945 <span class="preprocessor"></span><span class="preprocessor">#define f_is_blob(x)            (((x) &amp; (FIELDFLAG_BLOB | FIELDFLAG_NUMBER)) == FIELDFLAG_BLOB)</span>
<a name="l03946"></a>03946 <span class="preprocessor"></span><span class="preprocessor">#define f_is_geom(x)            (((x) &amp; (FIELDFLAG_GEOM | FIELDFLAG_NUMBER)) == FIELDFLAG_GEOM)</span>
<a name="l03947"></a>03947 <span class="preprocessor"></span><span class="preprocessor">#define f_is_equ(x)             ((x) &amp; (1+2+FIELDFLAG_PACK+31*256))</span>
<a name="l03948"></a>03948 <span class="preprocessor"></span><span class="preprocessor">#define f_settype(x)            (((int) x) &lt;&lt; FIELDFLAG_PACK_SHIFT)</span>
<a name="l03949"></a>03949 <span class="preprocessor"></span><span class="preprocessor">#define f_maybe_null(x)         (x &amp; FIELDFLAG_MAYBE_NULL)</span>
<a name="l03950"></a>03950 <span class="preprocessor"></span><span class="preprocessor">#define f_no_default(x)         (x &amp; FIELDFLAG_NO_DEFAULT)</span>
<a name="l03951"></a>03951 <span class="preprocessor"></span><span class="preprocessor">#define f_bit_as_char(x)        ((x) &amp; FIELDFLAG_TREAT_BIT_AS_CHAR)</span>
<a name="l03952"></a>03952 <span class="preprocessor"></span><span class="preprocessor">#define f_is_hex_escape(x)      ((x) &amp; FIELDFLAG_HEX_ESCAPE)</span>
<a name="l03953"></a>03953 <span class="preprocessor"></span>
<a name="l03954"></a>03954 <span class="preprocessor">#endif </span><span class="comment">/* FIELD_INCLUDED */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:44 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
