<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: ha_ndbcluster Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">ha_ndbcluster Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ha_ndbcluster" --><!-- doxytag: inherits="handler" --><div class="dynheader">
Inheritance diagram for ha_ndbcluster:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classha__ndbcluster.png" usemap="#ha_ndbcluster_map" alt=""/>
  <map id="ha_ndbcluster_map" name="ha_ndbcluster_map">
<area href="classhandler.html" alt="handler" shape="rect" coords="0,56,92,80"/>
<area href="classSql__alloc.html" alt="Sql_alloc" shape="rect" coords="0,0,92,24"/>
</map>
 </div></div>

<p><a href="classha__ndbcluster-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b5b76fc70957260d19c8a39feb39bcc"></a><!-- doxytag: member="ha_ndbcluster::PARTITION_STATS" ref="a2b5b76fc70957260d19c8a39feb39bcc" args="" -->
typedef PARTITION_INFO&#160;</td><td class="memItemRight" valign="bottom"><b>PARTITION_STATS</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a743f4c09bc748bd6d1fce84520472614"></a><!-- doxytag: member="ha_ndbcluster::ha_ndbcluster" ref="a743f4c09bc748bd6d1fce84520472614" args="(handlerton *hton, TABLE_SHARE *table)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>ha_ndbcluster</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e1e0e1c8aa3764c955f46b8845b7a1a"></a><!-- doxytag: member="ha_ndbcluster::open" ref="a5e1e0e1c8aa3764c955f46b8845b7a1a" args="(const char *name, int mode, uint test_if_locked)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>open</b> (const char *name, int mode, uint test_if_locked)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac65e17ed6b647f78ca2a933546a5c353"></a><!-- doxytag: member="ha_ndbcluster::close" ref="ac65e17ed6b647f78ca2a933546a5c353" args="(void)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5921b0992ea58b7698d649fcc7d50c1"></a><!-- doxytag: member="ha_ndbcluster::local_close" ref="ac5921b0992ea58b7698d649fcc7d50c1" args="(THD *thd, bool release_metadata)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>local_close</b> (THD *thd, bool release_metadata)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadffcd5f17a0b869bea7260425573df6"></a><!-- doxytag: member="ha_ndbcluster::optimize" ref="aadffcd5f17a0b869bea7260425573df6" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1499ebf91623f1a275a7c205cd1fa90f"></a><!-- doxytag: member="ha_ndbcluster::analyze" ref="a1499ebf91623f1a275a7c205cd1fa90f" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0417e2c67e5734e072ea5f2f015d3dc7"></a><!-- doxytag: member="ha_ndbcluster::analyze_index" ref="a0417e2c67e5734e072ea5f2f015d3dc7" args="(THD *thd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze_index</b> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5407251181eef104fdf5e2014f040ce2"></a><!-- doxytag: member="ha_ndbcluster::write_row" ref="a5407251181eef104fdf5e2014f040ce2" args="(uchar *buf)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>write_row</b> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7569a9e0da9ec2f5863b15185f401ed0"></a><!-- doxytag: member="ha_ndbcluster::update_row" ref="a7569a9e0da9ec2f5863b15185f401ed0" args="(const uchar *old_data, uchar *new_data)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47cd9427fba75e9340dc3572b1798901"></a><!-- doxytag: member="ha_ndbcluster::delete_row" ref="a47cd9427fba75e9340dc3572b1798901" args="(const uchar *buf)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>delete_row</b> (const uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae705539c642116cf2fb1f4e325d74892"></a><!-- doxytag: member="ha_ndbcluster::index_init" ref="ae705539c642116cf2fb1f4e325d74892" args="(uint index, bool sorted)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_init</b> (uint index, bool sorted)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa2a69f18014dc4e424beefb06bd4155"></a><!-- doxytag: member="ha_ndbcluster::index_end" ref="aaa2a69f18014dc4e424beefb06bd4155" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a3287fe133e918396f19004472c3b8afa">index_read_idx_map</a> (uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#a3287fe133e918396f19004472c3b8afa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0fc1fdfefdf8315fca2ebac5ad296e08"></a><!-- doxytag: member="ha_ndbcluster::index_read" ref="a0fc1fdfefdf8315fca2ebac5ad296e08" args="(uchar *buf, const uchar *key, uint key_len, enum ha_rkey_function find_flag)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read</b> (uchar *buf, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a865afdc25ee4ca42fafde872e476e0ff">index_next</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a824559f84d7f256052f0394e9276774f">index_prev</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a1d3598345c3543f684c566f79a61cedc">index_first</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a6f6e9347ec700ee952a998fa88ae68b2">index_last</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95ff7d09fb74bbdde730f809d3f14021"></a><!-- doxytag: member="ha_ndbcluster::index_read_last" ref="a95ff7d09fb74bbdde730f809d3f14021" args="(uchar *buf, const uchar *key, uint key_len)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_last</b> (uchar *buf, const uchar *key, uint key_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#acb923144766720049d59f97cd70286fd">rnd_init</a> (bool scan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1248b6b7c4b6515a2dafd930d57bcd4b"></a><!-- doxytag: member="ha_ndbcluster::rnd_end" ref="a1248b6b7c4b6515a2dafd930d57bcd4b" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#adc93bae43a800cc5ba5057b306136de1">rnd_next</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a8980053ce56e386ced321a1ad88d1cc2">rnd_pos</a> (uchar *buf, uchar *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae47b8413b29048108a6ee92af729ea46"></a><!-- doxytag: member="ha_ndbcluster::position" ref="ae47b8413b29048108a6ee92af729ea46" args="(const uchar *record)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (const uchar *record)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a184b8fcfc296599d9a82b0d36444ec30">read_first_row</a> (uchar *buf, uint primary_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99d0a5a286df6042eb35c779835ee527"></a><!-- doxytag: member="ha_ndbcluster::cmp_ref" ref="a99d0a5a286df6042eb35c779835ee527" args="(const uchar *ref1, const uchar *ref2)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_ref</b> (const uchar *ref1, const uchar *ref2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a4ebf9b2b84870f08b62e5e3f5465aae8">read_range_first</a> (const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges. Store ranges for future calls to read_range_next.  <a href="#a4ebf9b2b84870f08b62e5e3f5465aae8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99cfd1df9bc17dc77186affe8fdd0718"></a><!-- doxytag: member="ha_ndbcluster::read_range_first_to_buf" ref="a99cfd1df9bc17dc77186affe8fdd0718" args="(const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted, uchar *buf)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>read_range_first_to_buf</b> (const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted, uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ac4ca12e4aa287eaf6a50c43219a1c776">read_range_next</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#ac4ca12e4aa287eaf6a50c43219a1c776"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a0eabf09df945dac921b6bc5ea7b7a24c">read_multi_range_first</a> (KEY_MULTI_RANGE **found_range_p, KEY_MULTI_RANGE *ranges, uint range_count, bool sorted, <a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae67f181f0acbf81534cb1610d48ed4d6"></a><!-- doxytag: member="ha_ndbcluster::read_multi_range_next" ref="ae67f181f0acbf81534cb1610d48ed4d6" args="(KEY_MULTI_RANGE **found_range_p)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>read_multi_range_next</b> (KEY_MULTI_RANGE **found_range_p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20a5bbe782c9596f83829615b0c8486e"></a><!-- doxytag: member="ha_ndbcluster::null_value_index_search" ref="a20a5bbe782c9596f83829615b0c8486e" args="(KEY_MULTI_RANGE *ranges, KEY_MULTI_RANGE *end_range, HANDLER_BUFFER *buffer)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>null_value_index_search</b> (KEY_MULTI_RANGE *ranges, KEY_MULTI_RANGE *end_range, <a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *buffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a31a5f675ffb30d67ba91bb1cb9ec9dc8">get_error_message</a> (int error, <a class="el" href="classString.html">String</a> *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#afbffd5437c38bf4be8e08e1797324711">records</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a59555b02c52fc703e99a41d3ee3a04c3">estimate_rows_upper_bound</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28bab52bf2367f3b04d5d71b355d9930"></a><!-- doxytag: member="ha_ndbcluster::info" ref="a28bab52bf2367f3b04d5d71b355d9930" args="(uint)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>info</b> (uint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16bb75ce35d257d7b70aab5b01f72fe7"></a><!-- doxytag: member="ha_ndbcluster::get_dynamic_partition_info" ref="a16bb75ce35d257d7b70aab5b01f72fe7" args="(PARTITION_STATS *stat_info, uint part_id)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_dynamic_partition_info</b> (PARTITION_STATS *stat_info, uint part_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a760735b18201562efec1aa930e70bc07"></a><!-- doxytag: member="ha_ndbcluster::calculate_key_hash_value" ref="a760735b18201562efec1aa930e70bc07" args="(Field **field_array)" -->
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_key_hash_value</b> (<a class="el" href="classField.html">Field</a> **field_array)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a55b76e2e6595d838981a54951aa3f002">start_read_removal</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a81e58b0a19c7cc7d857a3f00e039ae37">end_read_removal</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c393d6b4b1359047c5cf21298ab562f"></a><!-- doxytag: member="ha_ndbcluster::extra" ref="a9c393d6b4b1359047c5cf21298ab562f" args="(enum ha_extra_function operation)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>extra</b> (enum ha_extra_function operation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ce8f87aba5f88e2a7b586b0f392870b"></a><!-- doxytag: member="ha_ndbcluster::extra_opt" ref="a2ce8f87aba5f88e2a7b586b0f392870b" args="(enum ha_extra_function operation, ulong cache_size)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_opt</b> (enum ha_extra_function operation, ulong cache_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a72ae34dfc88079bca1c85bfcd718b118">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabe3a7ba06ff1e775e3715c7aff104bb"></a><!-- doxytag: member="ha_ndbcluster::external_lock" ref="aabe3a7ba06ff1e775e3715c7aff104bb" args="(THD *thd, int lock_type)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>external_lock</b> (THD *thd, int lock_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecef434c45b2c6c35a584274c5079e4b"></a><!-- doxytag: member="ha_ndbcluster::unlock_row" ref="aecef434c45b2c6c35a584274c5079e4b" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_row</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8f1c0c15ca6a002403699eec20f24e6"></a><!-- doxytag: member="ha_ndbcluster::start_stmt" ref="aa8f1c0c15ca6a002403699eec20f24e6" args="(THD *thd, thr_lock_type lock_type)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>start_stmt</b> (THD *thd, thr_lock_type lock_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1da5294f30d3fd5b8d06fa3177b78a3"></a><!-- doxytag: member="ha_ndbcluster::update_create_info" ref="aa1da5294f30d3fd5b8d06fa3177b78a3" args="(HA_CREATE_INFO *create_info)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_create_info</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ab4b4b9ed3726be8a4a0887785a5ed530">print_error</a> (int error, myf errflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aa545546481cd90b1ea4564229d65034c">table_type</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aed09d12596bd65b85c2c6648a9ae2abd">bas_ext</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05f717149c1c5a932d0de822a7a33f4f"></a><!-- doxytag: member="ha_ndbcluster::table_flags" ref="a05f717149c1c5a932d0de822a7a33f4f" args="(void) const " -->
ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>table_flags</b> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a6c97f86be447b33a8f9a5fbfc63209"></a><!-- doxytag: member="ha_ndbcluster::set_part_info" ref="a5a6c97f86be447b33a8f9a5fbfc63209" args="(partition_info *part_info, bool early)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_part_info</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, bool early)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68c333d9f553bd15d5eff4b5c7c76f8a"></a><!-- doxytag: member="ha_ndbcluster::index_flags" ref="a68c333d9f553bd15d5eff4b5c7c76f8a" args="(uint idx, uint part, bool all_parts) const " -->
ulong&#160;</td><td class="memItemRight" valign="bottom"><b>index_flags</b> (uint idx, uint part, bool all_parts) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adfe1c99749c9718d4e5b5869b6cf281b"></a><!-- doxytag: member="ha_ndbcluster::keys_to_use_for_scanning" ref="adfe1c99749c9718d4e5b5869b6cf281b" args="()" -->
virtual const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keys_to_use_for_scanning</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63da211fdd2938aecb2581b5e9a13c40"></a><!-- doxytag: member="ha_ndbcluster::primary_key_is_clustered" ref="a63da211fdd2938aecb2581b5e9a13c40" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>primary_key_is_clustered</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17cb72aa31c7518baa44b4bd26bd3897"></a><!-- doxytag: member="ha_ndbcluster::max_supported_record_length" ref="a17cb72aa31c7518baa44b4bd26bd3897" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_record_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67666329f6072997776edd13dfb0214f"></a><!-- doxytag: member="ha_ndbcluster::max_supported_keys" ref="a67666329f6072997776edd13dfb0214f" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_keys</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa93b93f06de2e4fdf7a990632a45d06d"></a><!-- doxytag: member="ha_ndbcluster::max_supported_key_parts" ref="aa93b93f06de2e4fdf7a990632a45d06d" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_parts</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae89c529b320cbf089d532716699e80ae"></a><!-- doxytag: member="ha_ndbcluster::max_supported_key_length" ref="ae89c529b320cbf089d532716699e80ae" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5a55f419c738c00f1754e8c570fac97"></a><!-- doxytag: member="ha_ndbcluster::max_supported_key_part_length" ref="af5a55f419c738c00f1754e8c570fac97" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_part_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a5609bf8b91966dacc3610fc7ceffc314">rename_table</a> (const char *from, const char *to)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a4d32721908372dc62c490e14a005e03c">delete_table</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac74383fcb359c0f2d06acf101bb4d4b0"></a><!-- doxytag: member="ha_ndbcluster::create" ref="ac74383fcb359c0f2d06acf101bb4d4b0" args="(const char *name, TABLE *form, HA_CREATE_INFO *info)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *name, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52a700b4a2207df9e27dfa652e348a1f"></a><!-- doxytag: member="ha_ndbcluster::get_default_no_partitions" ref="a52a700b4a2207df9e27dfa652e348a1f" args="(HA_CREATE_INFO *info)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_default_no_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ad4c8240f36397911132c71d6080c0659">get_no_parts</a> (const char *name, uint *no_parts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4dd685a40d9b655b70e3d42a95e08da"></a><!-- doxytag: member="ha_ndbcluster::set_auto_partitions" ref="ac4dd685a40d9b655b70e3d42a95e08da" args="(partition_info *part_info)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_auto_partitions</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a176722dc40003b949613f8a6e253445d">is_fatal_error</a> (int error, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">THR_LOCK_DATA **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a66a20a04ade6a21ac16a81c12d021659">store_lock</a> (THD *thd, THR_LOCK_DATA **to, enum thr_lock_type lock_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6c9184a5ef18fc7cde3734757ef68f9"></a><!-- doxytag: member="ha_ndbcluster::low_byte_first" ref="ab6c9184a5ef18fc7cde3734757ef68f9" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>low_byte_first</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66cfbe5b786681d5535cec67d9a20aea"></a><!-- doxytag: member="ha_ndbcluster::index_type" ref="a66cfbe5b786681d5535cec67d9a20aea" args="(uint key_number)" -->
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> (uint key_number)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21574780af8b6cdc0bbcf8dc5ccb5164"></a><!-- doxytag: member="ha_ndbcluster::scan_time" ref="a21574780af8b6cdc0bbcf8dc5ccb5164" args="()" -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>scan_time</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acba30a6612e51eb9b5bd9a205d90a505"></a><!-- doxytag: member="ha_ndbcluster::records_in_range" ref="acba30a6612e51eb9b5bd9a205d90a505" args="(uint inx, key_range *min_key, key_range *max_key)" -->
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>records_in_range</b> (uint inx, key_range *min_key, key_range *max_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e0f10c9eef4ca971b4af597c4b93c56"></a><!-- doxytag: member="ha_ndbcluster::start_bulk_insert" ref="a0e0f10c9eef4ca971b4af597c4b93c56" args="(ha_rows rows)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>start_bulk_insert</b> (ha_rows rows)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38b1458caf3677f93276073e22669aeb"></a><!-- doxytag: member="ha_ndbcluster::end_bulk_insert" ref="a38b1458caf3677f93276073e22669aeb" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>end_bulk_insert</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aa852a48bce2fe6fbbe70b83022d74ed2">start_bulk_update</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a89cbc7ca67dcd89d07693186f5de7ca5">bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a5c9f552924c7168373ab0d1c2ba0e049">exec_bulk_update</a> (uint *dup_key_found)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a3c3b80b72e921059f62aed3eda1db911">end_bulk_update</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46052fa7fa300d669f28e0302494c532"></a><!-- doxytag: member="ha_ndbcluster::ndb_update_row" ref="a46052fa7fa300d669f28e0302494c532" args="(const uchar *old_data, uchar *new_data, int is_bulk_update)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndb_update_row</b> (const uchar *old_data, uchar *new_data, int is_bulk_update)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a37925498bba3ddd31b4afee378c640b1">cond_push</a> (const <a class="el" href="classItem.html">Item</a> *cond)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a0de805435e8251f27ba3394052f6b1c7">cond_pop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a116fe3936663f26718ef7720030bb5d8"></a><!-- doxytag: member="ha_ndbcluster::maybe_pushable_join" ref="a116fe3936663f26718ef7720030bb5d8" args="(const char *&amp;reason) const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>maybe_pushable_join</b> (const char *&amp;reason) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8392198f6ff1b83f32ee480b257566a9"></a><!-- doxytag: member="ha_ndbcluster::assign_pushed_join" ref="a8392198f6ff1b83f32ee480b257566a9" args="(const ndb_pushed_join *pushed_join)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>assign_pushed_join</b> (const <a class="el" href="classndb__pushed__join.html">ndb_pushed_join</a> *pushed_join)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a0659ab063c018e687c3d25a1b9a6352b">number_of_pushed_joins</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a0e13f467924c64f4929dc6db8b9d1dd3">root_of_pushed_join</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#aa53823a45dfd6e3f1cd372c65a9486bc">parent_of_pushed_join</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa7c34f1ba38d98ac501de119c7933dce"></a><!-- doxytag: member="ha_ndbcluster::index_read_pushed" ref="aa7c34f1ba38d98ac501de119c7933dce" args="(uchar *buf, const uchar *key, key_part_map keypart_map)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_pushed</b> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c12adc1c87097562760e06689e7ec38"></a><!-- doxytag: member="ha_ndbcluster::index_next_pushed" ref="a8c12adc1c87097562760e06689e7ec38" args="(uchar *buf)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>index_next_pushed</b> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#ac3a23eb89230938663a59fcf8fbe908b">table_cache_type</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f83a53f5cfa11ef6159a6b493cee6b1"></a><!-- doxytag: member="ha_ndbcluster::ndb_err" ref="a4f83a53f5cfa11ef6159a6b493cee6b1" args="(NdbTransaction *, bool have_lock=FALSE)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndb_err</b> (NdbTransaction *, bool have_lock=FALSE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__ndbcluster.html#a678f400a15ca14442e0ad11c39748de0">register_query_cache_table</a> (THD *thd, char *table_key, uint key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a named table with a call back function to the query cache.  <a href="#a678f400a15ca14442e0ad11c39748de0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6734ce1b2cac2b3a1d4ea46b288f9199"></a><!-- doxytag: member="ha_ndbcluster::check_if_supported_alter" ref="a6734ce1b2cac2b3a1d4ea46b288f9199" args="(TABLE *altered_table, HA_CREATE_INFO *create_info, Alter_info *alter_info, HA_ALTER_FLAGS *alter_flags, uint table_changes)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_if_supported_alter</b> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, <a class="el" href="classAlter__info.html">Alter_info</a> *alter_info, HA_ALTER_FLAGS *alter_flags, uint table_changes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8259c7c422a03d503a8bc49281efe40"></a><!-- doxytag: member="ha_ndbcluster::alter_table_phase1" ref="ae8259c7c422a03d503a8bc49281efe40" args="(THD *thd, TABLE *altered_table, HA_CREATE_INFO *create_info, HA_ALTER_INFO *alter_info, HA_ALTER_FLAGS *alter_flags)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>alter_table_phase1</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, HA_ALTER_INFO *alter_info, HA_ALTER_FLAGS *alter_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad52e65e45032786303c9b5d4941959e5"></a><!-- doxytag: member="ha_ndbcluster::alter_table_phase2" ref="ad52e65e45032786303c9b5d4941959e5" args="(THD *thd, TABLE *altered_table, HA_CREATE_INFO *create_info, HA_ALTER_INFO *alter_info, HA_ALTER_FLAGS *alter_flags)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>alter_table_phase2</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, HA_ALTER_INFO *alter_info, HA_ALTER_FLAGS *alter_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addcd60a5aae9fc354c080f8fd30cf041"></a><!-- doxytag: member="ha_ndbcluster::alter_table_phase3" ref="addcd60a5aae9fc354c080f8fd30cf041" args="(THD *thd, TABLE *table, HA_CREATE_INFO *create_info, HA_ALTER_INFO *alter_info, HA_ALTER_FLAGS *alter_flags)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>alter_table_phase3</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, HA_ALTER_INFO *alter_info, HA_ALTER_FLAGS *alter_flags)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a417449f095608116da907d1e544ccf5d"></a><!-- doxytag: member="ha_ndbcluster::set_dbname" ref="a417449f095608116da907d1e544ccf5d" args="(const char *pathname, char *dbname)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_dbname</b> (const char *pathname, char *dbname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a12def1d812f27926e0865caace0708bb"></a><!-- doxytag: member="ha_ndbcluster::set_tabname" ref="a12def1d812f27926e0865caace0708bb" args="(const char *pathname, char *tabname)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><b>set_tabname</b> (const char *pathname, char *tabname)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2c995e68447a91b50acb40b01ddd780a"></a><!-- doxytag: member="ha_ndbcluster::release_completed_operations" ref="a2c995e68447a91b50acb40b01ddd780a" args="(NdbTransaction *)" -->
static void&#160;</td><td class="memItemRight" valign="bottom"><b>release_completed_operations</b> (NdbTransaction *)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83f7116a2471d8f8ea1c29ef9f66d01f"></a><!-- doxytag: member="ha_ndbcluster::ndb_pushed_builder_ctx" ref="a83f7116a2471d8f8ea1c29ef9f66d01f" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>ndb_pushed_builder_ctx</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81d2867500d8a5c574e4e22d1b407d80"></a><!-- doxytag: member="ha_ndbcluster::ndbcluster_drop_database_impl" ref="a81d2867500d8a5c574e4e22d1b407d80" args="(THD *thd, const char *path)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndbcluster_drop_database_impl</b> (THD *thd, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0913ba36f453c2162dc3de911b14fa57"></a><!-- doxytag: member="ha_ndbcluster::ndb_handle_schema_change" ref="a0913ba36f453c2162dc3de911b14fa57" args="(THD *thd, Ndb *ndb, NdbEventOperation *pOp, NDB_SHARE *share)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndb_handle_schema_change</b> (THD *thd, Ndb *ndb, NdbEventOperation *pOp, <a class="el" href="structNDB__SHARE.html">NDB_SHARE</a> *share)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abacd62dc79483d9590e2250286e714e4"></a><!-- doxytag: member="ha_ndbcluster::g_get_ndb_blobs_value" ref="abacd62dc79483d9590e2250286e714e4" args="(NdbBlob *ndb_blob, void *arg)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>g_get_ndb_blobs_value</b> (NdbBlob *ndb_blob, void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98eb7dd1da4f4878ea3f774df43fcb20"></a><!-- doxytag: member="ha_ndbcluster::check_completed_operations_pre_commit" ref="a98eb7dd1da4f4878ea3f774df43fcb20" args="(Thd_ndb *, NdbTransaction *, const NdbOperation *, uint *ignore_count)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_completed_operations_pre_commit</b> (<a class="el" href="classThd__ndb.html">Thd_ndb</a> *, NdbTransaction *, const NdbOperation *, uint *ignore_count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2bd9470fe7beb5dc3481654718f39b7"></a><!-- doxytag: member="ha_ndbcluster::ndbcluster_commit" ref="ae2bd9470fe7beb5dc3481654718f39b7" args="(handlerton *hton, THD *thd, bool all)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ndbcluster_commit</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, THD *thd, bool all)</td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aed09d12596bd65b85c2c6648a9ae2abd"></a><!-- doxytag: member="ha_ndbcluster::bas_ext" ref="aed09d12596bd65b85c2c6648a9ae2abd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char** <a class="el" href="classha__ndbcluster.html#aed09d12596bd65b85c2c6648a9ae2abd">ha_ndbcluster::bas_ext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If frm_error() is called then we will use this to find out what file extentions exist for the storage engine. This is also used by the default rename_table and delete_table method in <a class="el" href="handler_8cc.html" title="Handler-calling-functions.">handler.cc</a>.</p>
<p>For engines that have two file name extentions (separate meta/index file and data file), the order of elements is relevant. First element of engine file name extentions array should be meta/index file extention. Second element - data file extention. This order is assumed by prepare_for_repair() when REPAIR <a class="el" href="structTABLE.html">TABLE</a> ... USE_FRM is issued. </p>

<p>Implements <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a89cbc7ca67dcd89d07693186f5de7ca5"></a><!-- doxytag: member="ha_ndbcluster::bulk_update_row" ref="a89cbc7ca67dcd89d07693186f5de7ca5" args="(const uchar *old_data, uchar *new_data, uint *dup_key_found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a89cbc7ca67dcd89d07693186f5de7ca5">ha_ndbcluster::bulk_update_row</a> </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is similar to update_row, however the handler doesn't need to execute the updates at this point in time. The handler can be certain that another call to bulk_update_row will occur OR a call to exec_bulk_update before the set of updates in this query is concluded.</p>
<p>Note: If HA_ERR_FOUND_DUPP_KEY is returned, the handler must read all columns of the row so MySQL can create an error message. If the columns required for the error message are not read, the error message will contain garbage.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">old_data</td><td>Old record </td></tr>
    <tr><td class="paramname">new_data</td><td>New record </td></tr>
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a0de805435e8251f27ba3394052f6b1c7"></a><!-- doxytag: member="ha_ndbcluster::cond_pop" ref="a0de805435e8251f27ba3394052f6b1c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classha__ndbcluster.html#a0de805435e8251f27ba3394052f6b1c7">ha_ndbcluster::cond_pop</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pop the top condition from the condition stack of the handler instance.</p>
<p>Pops the top if condition stack, if stack is not empty. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a37925498bba3ddd31b4afee378c640b1"></a><!-- doxytag: member="ha_ndbcluster::cond_push" ref="a37925498bba3ddd31b4afee378c640b1" args="(const Item *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classItem.html">Item</a>* <a class="el" href="classha__ndbcluster.html#a37925498bba3ddd31b4afee378c640b1">ha_ndbcluster::cond_push</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push condition down to the table handler.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to be pushed. The condition tree must not be modified by the by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 'remainder' condition that caller must use to filter out records. NULL means the handler will not return rows that do not match the passed condition.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The pushed conditions form a stack (from which one can remove the last pushed condition using cond_pop). The table handler filters out rows using (pushed_cond1 AND pushed_cond2 AND ... AND pushed_condN) or less restrictive condition, depending on handler's capabilities.</dd></dl>
<p>handler-&gt;<a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42" title="Check handler usage and reset state of file to after &#39;open&#39;.">ha_reset()</a> call empties the condition stack. Calls to rnd_init/rnd_end, index_init/index_end etc do not affect the condition stack. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a4d32721908372dc62c490e14a005e03c"></a><!-- doxytag: member="ha_ndbcluster::delete_table" ref="a4d32721908372dc62c490e14a005e03c" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a4d32721908372dc62c490e14a005e03c">ha_ndbcluster::delete_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a table in the engine. Called for base as well as temporary tables.</p>
<p>Delete all files with extension from <a class="el" href="classha__ndbcluster.html#aed09d12596bd65b85c2c6648a9ae2abd">bas_ext()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Base name of table</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>We assume that the handler may return more extensions than was actually used for the file.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If we successfully deleted at least one file from base_ext and didn't get any other errors than ENOENT </td></tr>
    <tr><td class="paramname">!0</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a3c3b80b72e921059f62aed3eda1db911"></a><!-- doxytag: member="ha_ndbcluster::end_bulk_update" ref="a3c3b80b72e921059f62aed3eda1db911" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classha__ndbcluster.html#a3c3b80b72e921059f62aed3eda1db911">ha_ndbcluster::end_bulk_update</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform any needed clean-up, no outstanding updates are there at the moment. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a81e58b0a19c7cc7d857a3f00e039ae37"></a><!-- doxytag: member="ha_ndbcluster::end_read_removal" ref="a81e58b0a19c7cc7d857a3f00e039ae37" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows <a class="el" href="classha__ndbcluster.html#a81e58b0a19c7cc7d857a3f00e039ae37">ha_ndbcluster::end_read_removal</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>End read (before write) removal and return the number of rows really written </p>
<dl class="see"><dt><b>See also:</b></dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a59555b02c52fc703e99a41d3ee3a04c3"></a><!-- doxytag: member="ha_ndbcluster::estimate_rows_upper_bound" ref="a59555b02c52fc703e99a41d3ee3a04c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows <a class="el" href="classha__ndbcluster.html#a59555b02c52fc703e99a41d3ee3a04c3">ha_ndbcluster::estimate_rows_upper_bound</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return upper bound of current number of records in the table (max. of how many records one will retrieve when doing a full table scan) If upper bound is not known, HA_POS_ERROR should be returned as a max possible upper bound. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a5c9f552924c7168373ab0d1c2ba0e049"></a><!-- doxytag: member="ha_ndbcluster::exec_bulk_update" ref="a5c9f552924c7168373ab0d1c2ba0e049" args="(uint *dup_key_found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a5c9f552924c7168373ab0d1c2ba0e049">ha_ndbcluster::exec_bulk_update</a> </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call all outstanding updates must be performed. The number of duplicate key errors are reported in the duplicate key parameter. It is allowed to continue to the batched update after this call, the handler has to wait until end_bulk_update with changing state.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a31a5f675ffb30d67ba91bb1cb9ec9dc8"></a><!-- doxytag: member="ha_ndbcluster::get_error_message" ref="a31a5f675ffb30d67ba91bb1cb9ec9dc8" args="(int error, String *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classha__ndbcluster.html#a31a5f675ffb30d67ba91bb1cb9ec9dc8">ha_ndbcluster::get_error_message</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an error message specific to this handler.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code previously returned by handler </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to <a class="el" href="classString.html">String</a> where to add error message</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if this is a temporary error </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ad4c8240f36397911132c71d6080c0659"></a><!-- doxytag: member="ha_ndbcluster::get_no_parts" ref="ad4c8240f36397911132c71d6080c0659" args="(const char *name, uint *no_parts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classha__ndbcluster.html#ad4c8240f36397911132c71d6080c0659">ha_ndbcluster::get_no_parts</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>no_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get number of partitions for table in SE</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>normalized path(same as open) to the table</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">no_parts</td><td>Number of partitions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>for success </td></tr>
    <tr><td class="paramname">true</td><td>for failure, for example table didn't exist in engine </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a1d3598345c3543f684c566f79a61cedc"></a><!-- doxytag: member="ha_ndbcluster::index_first" ref="a1d3598345c3543f684c566f79a61cedc" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a1d3598345c3543f684c566f79a61cedc">ha_ndbcluster::index_first</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a6f6e9347ec700ee952a998fa88ae68b2"></a><!-- doxytag: member="ha_ndbcluster::index_last" ref="a6f6e9347ec700ee952a998fa88ae68b2" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a6f6e9347ec700ee952a998fa88ae68b2">ha_ndbcluster::index_last</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a865afdc25ee4ca42fafde872e476e0ff"></a><!-- doxytag: member="ha_ndbcluster::index_next" ref="a865afdc25ee4ca42fafde872e476e0ff" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a865afdc25ee4ca42fafde872e476e0ff">ha_ndbcluster::index_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a824559f84d7f256052f0394e9276774f"></a><!-- doxytag: member="ha_ndbcluster::index_prev" ref="a824559f84d7f256052f0394e9276774f" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a824559f84d7f256052f0394e9276774f">ha_ndbcluster::index_prev</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a3287fe133e918396f19004472c3b8afa"></a><!-- doxytag: member="ha_ndbcluster::index_read_idx_map" ref="a3287fe133e918396f19004472c3b8afa" args="(uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a3287fe133e918396f19004472c3b8afa">ha_ndbcluster::index_read_idx_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a176722dc40003b949613f8a6e253445d"></a><!-- doxytag: member="ha_ndbcluster::is_fatal_error" ref="a176722dc40003b949613f8a6e253445d" args="(int error, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__ndbcluster.html#a176722dc40003b949613f8a6e253445d">ha_ndbcluster::is_fatal_error</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is used to analyse the error to see whether the error is ignorable or not, certain handlers can have more error that are ignorable than others. E.g. the partition handler can get inserts into a range where there is no partition and this is an ignorable error. HA_ERR_FOUND_DUP_UNIQUE is a special case in MyISAM that means the same thing as HA_ERR_FOUND_DUP_KEY but can in some cases lead to a slightly different error message. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a0659ab063c018e687c3d25a1b9a6352b"></a><!-- doxytag: member="ha_ndbcluster::number_of_pushed_joins" ref="a0659ab063c018e687c3d25a1b9a6352b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="classha__ndbcluster.html#a0659ab063c018e687c3d25a1b9a6352b">ha_ndbcluster::number_of_pushed_joins</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reports #tables included in pushed join which this handler instance is part of. ==0 -&gt; Not pushed </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a243ce6f51c5538c6d1dae81db1bb1658">handler</a>.</p>

</div>
</div>
<a class="anchor" id="aa53823a45dfd6e3f1cd372c65a9486bc"></a><!-- doxytag: member="ha_ndbcluster::parent_of_pushed_join" ref="aa53823a45dfd6e3f1cd372c65a9486bc" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="classha__ndbcluster.html#aa53823a45dfd6e3f1cd372c65a9486bc">ha_ndbcluster::parent_of_pushed_join</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this handler instance is a child in a pushed join sequence returned <a class="el" href="structTABLE.html">TABLE</a> instance being my parent? </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a915706fa5bb7e07752cc2d89ec467977">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ab4b4b9ed3726be8a4a0887785a5ed530"></a><!-- doxytag: member="ha_ndbcluster::print_error" ref="ab4b4b9ed3726be8a4a0887785a5ed530" args="(int error, myf errflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classha__ndbcluster.html#ab4b4b9ed3726be8a4a0887785a5ed530">ha_ndbcluster::print_error</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">myf&#160;</td>
          <td class="paramname"><em>errflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print error that we got from handler function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In case of delete table it's only safe to use the following parts of the 'table' structure:<ul>
<li>table-&gt;s-&gt;path</li>
<li>table-&gt;alias </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a184b8fcfc296599d9a82b0d36444ec30"></a><!-- doxytag: member="ha_ndbcluster::read_first_row" ref="a184b8fcfc296599d9a82b0d36444ec30" args="(uchar *buf, uint primary_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a184b8fcfc296599d9a82b0d36444ec30">ha_ndbcluster::read_first_row</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>primary_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read first row (only) from a table.</p>
<p>This is never called for InnoDB tables, as these table types has the HA_STATS_RECORDS_IS_EXACT set. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a0eabf09df945dac921b6bc5ea7b7a24c"></a><!-- doxytag: member="ha_ndbcluster::read_multi_range_first" ref="a0eabf09df945dac921b6bc5ea7b7a24c" args="(KEY_MULTI_RANGE **found_range_p, KEY_MULTI_RANGE *ranges, uint range_count, bool sorted, HANDLER_BUFFER *buffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a0eabf09df945dac921b6bc5ea7b7a24c">ha_ndbcluster::read_multi_range_first</a> </td>
          <td>(</td>
          <td class="paramtype">KEY_MULTI_RANGE **&#160;</td>
          <td class="paramname"><em>found_range_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KEY_MULTI_RANGE *&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>range_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multi range stuff </p>

</div>
</div>
<a class="anchor" id="a4ebf9b2b84870f08b62e5e3f5465aae8"></a><!-- doxytag: member="ha_ndbcluster::read_range_first" ref="a4ebf9b2b84870f08b62e5e3f5465aae8" args="(const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a4ebf9b2b84870f08b62e5e3f5465aae8">ha_ndbcluster::read_range_first</a> </td>
          <td>(</td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read first row between two ranges. Store ranges for future calls to read_range_next. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname">\::</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ac4ca12e4aa287eaf6a50c43219a1c776"></a><!-- doxytag: member="ha_ndbcluster::read_range_next" ref="ac4ca12e4aa287eaf6a50c43219a1c776" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#ac4ca12e4aa287eaf6a50c43219a1c776">ha_ndbcluster::read_range_next</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname">\::</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">handler</a>.</p>

</div>
</div>
<a class="anchor" id="afbffd5437c38bf4be8e08e1797324711"></a><!-- doxytag: member="ha_ndbcluster::records" ref="afbffd5437c38bf4be8e08e1797324711" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows <a class="el" href="classha__ndbcluster.html#afbffd5437c38bf4be8e08e1797324711">ha_ndbcluster::records</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of rows in table. It will only be called if (table_flags() &amp; (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT)) != 0 </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a678f400a15ca14442e0ad11c39748de0"></a><!-- doxytag: member="ha_ndbcluster::register_query_cache_table" ref="a678f400a15ca14442e0ad11c39748de0" args="(THD *thd, char *table_key, uint key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">my_bool <a class="el" href="classha__ndbcluster.html#a678f400a15ca14442e0ad11c39748de0">ha_ndbcluster::register_query_cache_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qc_engine_callback *&#160;</td>
          <td class="paramname"><em>engine_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>engine_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a named table with a call back function to the query cache. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_key</td><td>A pointer to the table name in the table cache </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_length</td><td>The length of the table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_callback</td><td>The pointer to the storage engine call back function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_data</td><td>Storage engine specific data which could be anything</td></tr>
  </table>
  </dd>
</dl>
<p>This method offers the storage engine, the possibility to store a reference to a table name which is going to be used with query cache. The method is called each time a statement is written to the cache and can be used to verify if a specific statement is cachable. It also offers the possibility to register a generic (but static) call back function which is called each time a statement is matched against the query cache.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If engine_data supplied with this function is different from engine_data supplied with the callback function, and the callback returns FALSE, a table invalidation on the current table will occur.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Upon success the engine_callback will point to the storage engine call back function, if any, and engine_data will point to any storage engine data used in the specific implementation. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Success </td></tr>
    <tr><td class="paramname">FALSE</td><td>The specified table or current statement should not be cached </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a5609bf8b91966dacc3610fc7ceffc314"></a><!-- doxytag: member="ha_ndbcluster::rename_table" ref="a5609bf8b91966dacc3610fc7ceffc314" args="(const char *from, const char *to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a5609bf8b91966dacc3610fc7ceffc314">ha_ndbcluster::rename_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default <a class="el" href="classha__ndbcluster.html#a5609bf8b91966dacc3610fc7ceffc314">rename_table()</a> and <a class="el" href="classha__ndbcluster.html#a4d32721908372dc62c490e14a005e03c">delete_table()</a> rename/delete files with a given name and extensions from <a class="el" href="classha__ndbcluster.html#aed09d12596bd65b85c2c6648a9ae2abd">bas_ext()</a>.</p>
<p>These methods can be overridden, but their default implementation provide useful functionality. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a72ae34dfc88079bca1c85bfcd718b118"></a><!-- doxytag: member="ha_ndbcluster::reset" ref="a72ae34dfc88079bca1c85bfcd718b118" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a72ae34dfc88079bca1c85bfcd718b118">ha_ndbcluster::reset</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset state of file to after 'open'. This function is called after every statement for all tables used by that statement. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a class="anchor" id="acb923144766720049d59f97cd70286fd"></a><!-- doxytag: member="ha_ndbcluster::rnd_init" ref="acb923144766720049d59f97cd70286fd" args="(bool scan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#acb923144766720049d59f97cd70286fd">ha_ndbcluster::rnd_init</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classha__ndbcluster.html#acb923144766720049d59f97cd70286fd">rnd_init()</a> can be called two times without rnd_end() in between (it only makes sense if scan=1). then the second call should prepare for the new table scan (e.g if rnd_init allocates the cursor, second call should position it to the start of the table, no need to deallocate and allocate it again </p>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a class="anchor" id="adc93bae43a800cc5ba5057b306136de1"></a><!-- doxytag: member="ha_ndbcluster::rnd_next" ref="adc93bae43a800cc5ba5057b306136de1" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#adc93bae43a800cc5ba5057b306136de1">ha_ndbcluster::rnd_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a8980053ce56e386ced321a1ad88d1cc2"></a><!-- doxytag: member="ha_ndbcluster::rnd_pos" ref="a8980053ce56e386ced321a1ad88d1cc2" args="(uchar *buf, uchar *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classha__ndbcluster.html#a8980053ce56e386ced321a1ad88d1cc2">ha_ndbcluster::rnd_pos</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a0e13f467924c64f4929dc6db8b9d1dd3"></a><!-- doxytag: member="ha_ndbcluster::root_of_pushed_join" ref="a0e13f467924c64f4929dc6db8b9d1dd3" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="classha__ndbcluster.html#a0e13f467924c64f4929dc6db8b9d1dd3">ha_ndbcluster::root_of_pushed_join</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this handler instance is part of a pushed join sequence returned <a class="el" href="structTABLE.html">TABLE</a> instance being root of the pushed query? </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ae1bf0cbd806508954db72a5707732ee6">handler</a>.</p>

</div>
</div>
<a class="anchor" id="aa852a48bce2fe6fbbe70b83022d74ed2"></a><!-- doxytag: member="ha_ndbcluster::start_bulk_update" ref="aa852a48bce2fe6fbbe70b83022d74ed2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classha__ndbcluster.html#aa852a48bce2fe6fbbe70b83022d74ed2">ha_ndbcluster::start_bulk_update</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Bulk update used by handler </td></tr>
    <tr><td class="paramname">1</td><td>Bulk update not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a55b76e2e6595d838981a54951aa3f002"></a><!-- doxytag: member="ha_ndbcluster::start_read_removal" ref="a55b76e2e6595d838981a54951aa3f002" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classha__ndbcluster.html#a55b76e2e6595d838981a54951aa3f002">ha_ndbcluster::start_read_removal</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start read (before write) removal on the current table. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a66a20a04ade6a21ac16a81c12d021659"></a><!-- doxytag: member="ha_ndbcluster::store_lock" ref="a66a20a04ade6a21ac16a81c12d021659" args="(THD *thd, THR_LOCK_DATA **to, enum thr_lock_type lock_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">THR_LOCK_DATA** <a class="el" href="classha__ndbcluster.html#a66a20a04ade6a21ac16a81c12d021659">ha_ndbcluster::store_lock</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THR_LOCK_DATA **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is not invoked for non-transactional temporary tables.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classha__ndbcluster.html#a66a20a04ade6a21ac16a81c12d021659">store_lock()</a> can return more than one lock if the table is MERGE or partitioned.</dd>
<dd>
that one can NOT rely on table-&gt;in_use in <a class="el" href="classha__ndbcluster.html#a66a20a04ade6a21ac16a81c12d021659">store_lock()</a>. It may refer to a different thread if called from <a class="el" href="group__Locking.html#ga321511c56502643e5aecbe6ed3e43b58">mysql_lock_abort_for_thread()</a>.</dd>
<dd>
If the table is MERGE, <a class="el" href="classha__ndbcluster.html#a66a20a04ade6a21ac16a81c12d021659">store_lock()</a> can return less locks than <a class="el" href="classhandler.html#a13f5a2b8ba9e4b9f9255243f0f1cd525">lock_count()</a> claimed. This can happen when the MERGE children are not attached when this is called from another thread. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ac3a23eb89230938663a59fcf8fbe908b"></a><!-- doxytag: member="ha_ndbcluster::table_cache_type" ref="ac3a23eb89230938663a59fcf8fbe908b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 <a class="el" href="classha__ndbcluster.html#ac3a23eb89230938663a59fcf8fbe908b">ha_ndbcluster::table_cache_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type of table for caching query </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">handler</a>.</p>

</div>
</div>
<a class="anchor" id="aa545546481cd90b1ea4564229d65034c"></a><!-- doxytag: member="ha_ndbcluster::table_type" ref="aa545546481cd90b1ea4564229d65034c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classha__ndbcluster.html#aa545546481cd90b1ea4564229d65034c">ha_ndbcluster::table_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The following can be called without an open handler </p>

<p>Implements <a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">handler</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ha__ndbcluster_8h_source.html">ha_ndbcluster.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:35:44 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
