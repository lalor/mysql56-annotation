<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: ha_partition Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">ha_partition Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ha_partition" --><!-- doxytag: inherits="handler" --><div class="dynheader">
Inheritance diagram for ha_partition:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classha__partition.png" usemap="#ha_partition_map" alt=""/>
  <map id="ha_partition_map" name="ha_partition_map">
<area href="classhandler.html" alt="handler" shape="rect" coords="0,56,78,80"/>
<area href="classSql__alloc.html" alt="Sql_alloc" shape="rect" coords="0,0,78,24"/>
</map>
 </div></div>

<p><a href="classha__partition-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6803596d872baa81045ee4a9c0694c0"></a><!-- doxytag: member="ha_partition::get_part_share" ref="af6803596d872baa81045ee4a9c0694c0" args="()" -->
<a class="el" href="classPartition__share.html">Partition_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_part_share</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59a53483496f68b8d44c120414db1f20"></a><!-- doxytag: member="ha_partition::clone" ref="a59a53483496f68b8d44c120414db1f20" args="(const char *name, MEM_ROOT *mem_root)" -->
<a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> (const char *name, MEM_ROOT *mem_root)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefcc90572e55257dc82499aa1168079a"></a><!-- doxytag: member="ha_partition::set_part_info" ref="aefcc90572e55257dc82499aa1168079a" args="(partition_info *part_info, bool early)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_part_info</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, bool early)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8490262a2f4deafaa07d8d7eeb6110e9"></a><!-- doxytag: member="ha_partition::ha_partition" ref="a8490262a2f4deafaa07d8d7eeb6110e9" args="(handlerton *hton, TABLE_SHARE *table)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>ha_partition</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56d21e7f4c644b40aae4d6089e637ab4"></a><!-- doxytag: member="ha_partition::ha_partition" ref="a56d21e7f4c644b40aae4d6089e637ab4" args="(handlerton *hton, partition_info *part_info)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>ha_partition</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="classpartition__info.html">partition_info</a> *part_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40d768a1777093ccde7ecce3677cad2d"></a><!-- doxytag: member="ha_partition::ha_partition" ref="a40d768a1777093ccde7ecce3677cad2d" args="(handlerton *hton, TABLE_SHARE *share, partition_info *part_info_arg, ha_partition *clone_arg, MEM_ROOT *clone_mem_root_arg)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>ha_partition</b> (<a class="el" href="structhandlerton.html">handlerton</a> *hton, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <a class="el" href="classpartition__info.html">partition_info</a> *part_info_arg, <a class="el" href="classha__partition.html">ha_partition</a> *clone_arg, MEM_ROOT *clone_mem_root_arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5f589be346d6a1cc22d02bb6fd55ae"></a><!-- doxytag: member="ha_partition::initialize_partition" ref="afa5f589be346d6a1cc22d02bb6fd55ae" args="(MEM_ROOT *mem_root)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initialize_partition</b> (MEM_ROOT *mem_root)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aafdb3caedb579b35d9cda963b7a3c25f">delete_table</a> (const char *from)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7dbc26903dfbc0128c0d5a7e68d3681b">rename_table</a> (const char *from, const char *to)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75a47fa739883b50c802d7b7731a2783"></a><!-- doxytag: member="ha_partition::create" ref="a75a47fa739883b50c802d7b7731a2783" args="(const char *name, TABLE *form, HA_CREATE_INFO *create_info)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *name, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad1a209a58b239d6fab299adbb347d70e"></a><!-- doxytag: member="ha_partition::create_handler_files" ref="ad1a209a58b239d6fab299adbb347d70e" args="(const char *name, const char *old_name, int action_flag, HA_CREATE_INFO *create_info)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create_handler_files</b> (const char *name, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab56a3b571d71004409881cf4a54c1a16"></a><!-- doxytag: member="ha_partition::update_create_info" ref="ab56a3b571d71004409881cf4a54c1a16" args="(HA_CREATE_INFO *create_info)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>update_create_info</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dc862beba6055a3f2f64f20c60085de"></a><!-- doxytag: member="ha_partition::update_table_comment" ref="a8dc862beba6055a3f2f64f20c60085de" args="(const char *comment)" -->
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><b>update_table_comment</b> (const char *comment)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e0318a9d8d97e84ecd28f37cc29405b"></a><!-- doxytag: member="ha_partition::change_partitions" ref="a5e0318a9d8d97e84ecd28f37cc29405b" args="(HA_CREATE_INFO *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>change_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8b4ba0f54dde5d6259f7144e9f3df4d"></a><!-- doxytag: member="ha_partition::drop_partitions" ref="ab8b4ba0f54dde5d6259f7144e9f3df4d" args="(const char *path)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>drop_partitions</b> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a152d4ec6a0bfd43f7d6fbff72bd174cf"></a><!-- doxytag: member="ha_partition::rename_partitions" ref="a152d4ec6a0bfd43f7d6fbff72bd174cf" args="(const char *path)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rename_partitions</b> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a36ca395ca5c6066f00b30a9ccedfc43d">get_no_parts</a> (const char *name, uint *num_parts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9d96fbe82c767c02bb81ef569b7bc3c"></a><!-- doxytag: member="ha_partition::change_table_ptr" ref="af9d96fbe82c767c02bb81ef569b7bc3c" args="(TABLE *table_arg, TABLE_SHARE *share)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>change_table_ptr</b> (<a class="el" href="structTABLE.html">TABLE</a> *table_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a66a9fc27dbc3652fec1fab4c7d9c077c">check_if_incompatible_data</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, uint table_changes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a70beac6714c1abca828bcbabbe6bf190"></a><!-- doxytag: member="ha_partition::open" ref="a70beac6714c1abca828bcbabbe6bf190" args="(const char *name, int mode, uint test_if_locked)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>open</b> (const char *name, int mode, uint test_if_locked)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a208357e1474ef88323597c867399aa"></a><!-- doxytag: member="ha_partition::close" ref="a6a208357e1474ef88323597c867399aa" args="(void)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual THR_LOCK_DATA **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">store_lock</a> (THD *thd, THR_LOCK_DATA **to, enum thr_lock_type lock_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23c3cd020a08eca662a3fe09df371d0b"></a><!-- doxytag: member="ha_partition::external_lock" ref="a23c3cd020a08eca662a3fe09df371d0b" args="(THD *thd, int lock_type)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>external_lock</b> (THD *thd, int lock_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac27278995a01cd7ceb1589226042cbe1"></a><!-- doxytag: member="ha_partition::start_stmt" ref="ac27278995a01cd7ceb1589226042cbe1" args="(THD *thd, thr_lock_type lock_type)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>start_stmt</b> (THD *thd, thr_lock_type lock_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a94af2b65d4d966d480185f2a80009f38">lock_count</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5e4eb4cddc860809124d44d18335735"></a><!-- doxytag: member="ha_partition::unlock_row" ref="af5e4eb4cddc860809124d44d18335735" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_row</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a2a059c1ac08f3cd71b7087b876664e18">was_semi_consistent_read</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a45235c1c364a4b1ac4a2b97134f7a4b4">try_semi_consistent_read</a> (bool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d60dde334dc67cdc7e7515c0d7d22a7"></a><!-- doxytag: member="ha_partition::write_row" ref="a2d60dde334dc67cdc7e7515c0d7d22a7" args="(uchar *buf)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>write_row</b> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77f735d915addfb3d9381a2959c31627"></a><!-- doxytag: member="ha_partition::update_row" ref="a77f735d915addfb3d9381a2959c31627" args="(const uchar *old_data, uchar *new_data)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0afdb18e852abb6b174807e1386873e8"></a><!-- doxytag: member="ha_partition::delete_row" ref="a0afdb18e852abb6b174807e1386873e8" args="(const uchar *buf)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>delete_row</b> (const uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ad162b32125ed0d7fb4b5b8167ce0269d">delete_all_rows</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a42819e5cf989a23c0ade56feece2bcf4">truncate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee5fd3ae994fb440ffbb428b61a547fa"></a><!-- doxytag: member="ha_partition::start_bulk_insert" ref="aee5fd3ae994fb440ffbb428b61a547fa" args="(ha_rows rows)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>start_bulk_insert</b> (ha_rows rows)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b6d95b4f15b8add5f5861369642a228"></a><!-- doxytag: member="ha_partition::end_bulk_insert" ref="a8b6d95b4f15b8add5f5861369642a228" args="()" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>end_bulk_insert</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c01259c896144ad73923ee040e8b250"></a><!-- doxytag: member="ha_partition::truncate_partition" ref="a6c01259c896144ad73923ee040e8b250" args="(Alter_info *, bool *binlog_stmt)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>truncate_partition</b> (<a class="el" href="classAlter__info.html">Alter_info</a> *, bool *binlog_stmt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a18e8ff8fce23b0ca305755e60d960cd9">is_fatal_error</a> (int error, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a0f1716a11f635614b7772b9b0711a1ff">rnd_init</a> (bool scan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33d1115f4e995902c6026f08f1b0c995"></a><!-- doxytag: member="ha_partition::rnd_end" ref="a33d1115f4e995902c6026f08f1b0c995" args="()" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ad468c67dd2f37885994530f9e2ad2266">rnd_next</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7b052173ced1b88687dafba28a170335">rnd_pos</a> (uchar *buf, uchar *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a58bbc7153fa41de3b53872cb8f4b4e6e">rnd_pos_by_record</a> (uchar *record)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af141cad25dc072898fa699e7b4cd2e33"></a><!-- doxytag: member="ha_partition::position" ref="af141cad25dc072898fa699e7b4cd2e33" args="(const uchar *record)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (const uchar *record)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3">index_read_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#a7e153d8c7280e6d4440b09c61976e7f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47563fa6bac6a69ab66f79b18b40c7a3"></a><!-- doxytag: member="ha_partition::index_init" ref="a47563fa6bac6a69ab66f79b18b40c7a3" args="(uint idx, bool sorted)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_init</b> (uint idx, bool sorted)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a388eb1eb01753bff5130d5b7aa265d6a"></a><!-- doxytag: member="ha_partition::index_end" ref="a388eb1eb01753bff5130d5b7aa265d6a" args="()" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aee13430aea3946ffa6cf2c00104ba19c">index_read_idx_map</a> (uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a6a599d1fe239ff7d7dba0b3984fc8bea">index_next</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a25706609cb26f778dd90cc2611b112fd">index_prev</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#acc714b62d79e24a9c1d4f3db712322b1">index_first</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4e4defdf04378b86f231928ed21e017b">index_last</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a2769f8f7dd54eebb15c6baa6c4651b2b">index_next_same</a> (uchar *buf, const uchar *key, uint keylen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ae28896451f43f7b821e441413936c93c">index_read_last_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="#ae28896451f43f7b821e441413936c93c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aa0217cd2a331904f87fbfcbe4dde5800">read_range_first</a> (const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges. Store ranges for future calls to read_range_next.  <a href="#aa0217cd2a331904f87fbfcbe4dde5800"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ae77ce0688d4d2c0451dcb930e6ca42bc">read_range_next</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#ae77ce0688d4d2c0451dcb930e6ca42bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aca42c32f4f86c02ecd6a6b50ea8069ef"></a><!-- doxytag: member="ha_partition::info" ref="aca42c32f4f86c02ecd6a6b50ea8069ef" args="(uint)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>info</b> (uint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bfcb1d03a905441a9e19f346b138e46"></a><!-- doxytag: member="ha_partition::get_dynamic_partition_info" ref="a5bfcb1d03a905441a9e19f346b138e46" args="(PARTITION_STATS *stat_info, uint part_id)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_dynamic_partition_info</b> (<a class="el" href="structPARTITION__STATS.html">PARTITION_STATS</a> *stat_info, uint part_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7739999a9b890dabd3d100b266b5021f"></a><!-- doxytag: member="ha_partition::extra" ref="a7739999a9b890dabd3d100b266b5021f" args="(enum ha_extra_function operation)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra</b> (enum ha_extra_function operation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbd6a052f1c518cc47275debb830ca5d"></a><!-- doxytag: member="ha_partition::extra_opt" ref="acbd6a052f1c518cc47275debb830ca5d" args="(enum ha_extra_function operation, ulong cachesize)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_opt</b> (enum ha_extra_function operation, ulong cachesize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a0dd96d4f1ecc4e63d6afbcc6d6d4c243">reset</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4673b0434ccbcd97542e1f7636d61db2">register_query_cache_table</a> (THD *thd, char *table_key, uint key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a named table with a call back function to the query cache.  <a href="#a4673b0434ccbcd97542e1f7636d61db2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a206e311288c7006bfc19ba1a63435c34"></a><!-- doxytag: member="ha_partition::keys_to_use_for_scanning" ref="a206e311288c7006bfc19ba1a63435c34" args="()" -->
virtual const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keys_to_use_for_scanning</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9da2487666ad4209a0cd2002f6a6714b"></a><!-- doxytag: member="ha_partition::scan_time" ref="a9da2487666ad4209a0cd2002f6a6714b" args="()" -->
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>scan_time</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ae2cd9274cdcf243f53efc8c236bb8379">read_time</a> (uint index, uint ranges, ha_rows rows)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80f108027df076f8ba593c60c08d3c98"></a><!-- doxytag: member="ha_partition::records_in_range" ref="a80f108027df076f8ba593c60c08d3c98" args="(uint inx, key_range *min_key, key_range *max_key)" -->
virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>records_in_range</b> (uint inx, key_range *min_key, key_range *max_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a663485370abf958b89641924402db405">estimate_rows_upper_bound</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a2b4f4002504f73ed3ae195729b95603b">table_cache_type</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ada684ff4029d92f8b693952ccb780948">records</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a324b474174eed94b5b6af6be57391883"></a><!-- doxytag: member="ha_partition::calculate_key_hash_value" ref="a324b474174eed94b5b6af6be57391883" args="(Field **field_array)" -->
uint32&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_key_hash_value</b> (<a class="el" href="classField.html">Field</a> **field_array)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a355d772428660165c27f30457a3ce6ae"></a><!-- doxytag: member="ha_partition::index_type" ref="a355d772428660165c27f30457a3ce6ae" args="(uint inx)" -->
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> (uint inx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4cb39c8b7ba6dabe242f3205c86f59f2">table_type</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual enum row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a8c2bdc154c11f31207e3636c1a3ad3e2">get_row_type</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#afbddb8246029958806a6078b3ea71b32">print_error</a> (int error, myf errflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4fb5ad51d61c07878d5626a315534497">get_error_message</a> (int error, <a class="el" href="classString.html">String</a> *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e98f14365c4248856d3088cff3e00b1"></a><!-- doxytag: member="ha_partition::table_flags" ref="a3e98f14365c4248856d3088cff3e00b1" args="() const " -->
virtual Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>table_flags</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae25aa76cb8be37f77602d8c7be768083"></a><!-- doxytag: member="ha_partition::index_flags" ref="ae25aa76cb8be37f77602d8c7be768083" args="(uint inx, uint part, bool all_parts) const " -->
virtual ulong&#160;</td><td class="memItemRight" valign="bottom"><b>index_flags</b> (uint inx, uint part, bool all_parts) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a1e6624f8a6246ce09553fece606d05df">alter_table_flags</a> (uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a439691aabff67557603a69a6318806b7">bas_ext</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3f9ba28f26ade85e0be8daa4e3545a1"></a><!-- doxytag: member="ha_partition::min_of_the_max_uint" ref="ad3f9ba28f26ade85e0be8daa4e3545a1" args="(uint(handler::*operator_func)(void) const) const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_of_the_max_uint</b> (uint(handler::*operator_func)(void) const) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a360580da0bb208e6be2272f0911df5dc"></a><!-- doxytag: member="ha_partition::max_supported_record_length" ref="a360580da0bb208e6be2272f0911df5dc" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_record_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a090a8db2b19f8877ad6b1faec4fb2b7c"></a><!-- doxytag: member="ha_partition::max_supported_keys" ref="a090a8db2b19f8877ad6b1faec4fb2b7c" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_keys</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab02a0abc442611b0b6da1c851ac30df"></a><!-- doxytag: member="ha_partition::max_supported_key_parts" ref="aab02a0abc442611b0b6da1c851ac30df" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_parts</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab27734ff15c3e9a7b62ff471294b3636"></a><!-- doxytag: member="ha_partition::max_supported_key_length" ref="ab27734ff15c3e9a7b62ff471294b3636" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75220522c0fb08785ceb6e5bcb37707c"></a><!-- doxytag: member="ha_partition::max_supported_key_part_length" ref="a75220522c0fb08785ceb6e5bcb37707c" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_part_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed30cd032c1201274e5d0581089b0e59"></a><!-- doxytag: member="ha_partition::low_byte_first" ref="aed30cd032c1201274e5d0581089b0e59" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>low_byte_first</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f6f43288261cb70faae79b97c8dee31"></a><!-- doxytag: member="ha_partition::extra_rec_buf_length" ref="a2f6f43288261cb70faae79b97c8dee31" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>extra_rec_buf_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0394cb1c6e30de47d0f040a3c2dc8b12"></a><!-- doxytag: member="ha_partition::min_record_length" ref="a0394cb1c6e30de47d0f040a3c2dc8b12" args="(uint options) const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_record_length</b> (uint options) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14e725f6ebb1ff10140a3f6cddc7a35a"></a><!-- doxytag: member="ha_partition::primary_key_is_clustered" ref="a14e725f6ebb1ff10140a3f6cddc7a35a" args="()" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>primary_key_is_clustered</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1014411cda7052e73ee1044b4b8a4be4"></a><!-- doxytag: member="ha_partition::cmp_ref" ref="a1014411cda7052e73ee1044b4b8a4be4" args="(const uchar *ref1, const uchar *ref2)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_ref</b> (const uchar *ref1, const uchar *ref2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a7668775be94bce9d7cf799c051096380">get_auto_increment</a> (ulonglong offset, ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value, ulonglong *nb_reserved_values)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09641064fc782d4092e1e4033018da5e"></a><!-- doxytag: member="ha_partition::release_auto_increment" ref="a09641064fc782d4092e1e4033018da5e" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>release_auto_increment</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cefc229e5b84f939d5fee99729b778b"></a><!-- doxytag: member="ha_partition::init_table_handle_for_HANDLER" ref="a9cefc229e5b84f939d5fee99729b778b" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init_table_handle_for_HANDLER</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a8b83aeaba7dadd1b28c22457ac67f43b">can_switch_engines</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual enum_alter_inplace_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">check_if_supported_inplace_alter</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#a4350de763daa055bf18a26267664bda2">notify_table_changed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d15223b48ade93d606dcfef85c9ac0f"></a><!-- doxytag: member="ha_partition::optimize" ref="a3d15223b48ade93d606dcfef85c9ac0f" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbb6912ff086e35ce623ea01749af8b3"></a><!-- doxytag: member="ha_partition::analyze" ref="adbb6912ff086e35ce623ea01749af8b3" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5788666b99cae30b065a5513b4107f6"></a><!-- doxytag: member="ha_partition::check" ref="af5788666b99cae30b065a5513b4107f6" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>check</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#ab7908bdcad420cac9f0d696e528ba8e1">repair</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fa8df6e2a631ce726af759bd7a572c4"></a><!-- doxytag: member="ha_partition::check_and_repair" ref="a7fa8df6e2a631ce726af759bd7a572c4" args="(THD *thd)" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_and_repair</b> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f1c0a4b4368e860277b1806cc45dd3d"></a><!-- doxytag: member="ha_partition::auto_repair" ref="a1f1c0a4b4368e860277b1806cc45dd3d" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>auto_repair</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a008c8c620eac14ac5fe4f3e4f3e64d04"></a><!-- doxytag: member="ha_partition::is_crashed" ref="a008c8c620eac14ac5fe4f3e4f3e64d04" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_crashed</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classha__partition.html#af912fe341244ec80ccdf21c9b87e4e02">check_for_upgrade</a> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17c02d72e9b729ab75427998539c6148"></a><!-- doxytag: member="ha_partition::checksum" ref="a17c02d72e9b729ab75427998539c6148" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>checksum</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1ce76e5900ed99b3594fa70c64ac8b1"></a><!-- doxytag: member="ha_partition::assign_to_keycache" ref="ae1ce76e5900ed99b3594fa70c64ac8b1" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>assign_to_keycache</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98a0db0ca494639b9abcb49d873783ec"></a><!-- doxytag: member="ha_partition::preload_keys" ref="a98a0db0ca494639b9abcb49d873783ec" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>preload_keys</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a9ea02fe8323cf6b3a0e70fa92e07c6"></a><!-- doxytag: member="ha_partition::disable_indexes" ref="a7a9ea02fe8323cf6b3a0e70fa92e07c6" args="(uint mode)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>disable_indexes</b> (uint mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c857a562d30c7e46f4ce72ce98ed2db"></a><!-- doxytag: member="ha_partition::enable_indexes" ref="a4c857a562d30c7e46f4ce72ce98ed2db" args="(uint mode)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>enable_indexes</b> (uint mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a250323102fde609b86058497893b5033"></a><!-- doxytag: member="ha_partition::indexes_are_disabled" ref="a250323102fde609b86058497893b5033" args="(void)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>indexes_are_disabled</b> (void)</td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1e6624f8a6246ce09553fece606d05df"></a><!-- doxytag: member="ha_partition::alter_table_flags" ref="a1e6624f8a6246ce09553fece606d05df" args="(uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint <a class="el" href="classha__partition.html#a1e6624f8a6246ce09553fece606d05df">ha_partition::alter_table_flags</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>wrapper function for handlerton alter_table_flags, since the ha_partition_hton cannot know all its capabilities </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a439691aabff67557603a69a6318806b7"></a><!-- doxytag: member="ha_partition::bas_ext" ref="a439691aabff67557603a69a6318806b7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char** <a class="el" href="classha__partition.html#a439691aabff67557603a69a6318806b7">ha_partition::bas_ext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If frm_error() is called then we will use this to find out what file extentions exist for the storage engine. This is also used by the default rename_table and delete_table method in <a class="el" href="handler_8cc.html" title="Handler-calling-functions.">handler.cc</a>.</p>
<p>For engines that have two file name extentions (separate meta/index file and data file), the order of elements is relevant. First element of engine file name extentions array should be meta/index file extention. Second element - data file extention. This order is assumed by prepare_for_repair() when REPAIR <a class="el" href="structTABLE.html">TABLE</a> ... USE_FRM is issued. </p>

<p>Implements <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a8b83aeaba7dadd1b28c22457ac67f43b"></a><!-- doxytag: member="ha_partition::can_switch_engines" ref="a8b83aeaba7dadd1b28c22457ac67f43b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__partition.html#a8b83aeaba7dadd1b28c22457ac67f43b">ha_partition::can_switch_engines</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used in ALTER <a class="el" href="structTABLE.html">TABLE</a> to check if changing storage engine is allowed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Called without holding thr_lock.c lock.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Changing storage engine is allowed. </td></tr>
    <tr><td class="paramname">false</td><td>Changing storage engine not allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">handler</a>.</p>

</div>
</div>
<a class="anchor" id="af912fe341244ec80ccdf21c9b87e4e02"></a><!-- doxytag: member="ha_partition::check_for_upgrade" ref="af912fe341244ec80ccdf21c9b87e4e02" args="(HA_CHECK_OPT *check_opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#af912fe341244ec80ccdf21c9b87e4e02">ha_partition::check_for_upgrade</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>admin commands - called from mysql_admin_table </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a66a9fc27dbc3652fec1fab4c7d9c077c"></a><!-- doxytag: member="ha_partition::check_if_incompatible_data" ref="a66a9fc27dbc3652fec1fab4c7d9c077c" args="(HA_CREATE_INFO *create_info, uint table_changes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__partition.html#a66a9fc27dbc3652fec1fab4c7d9c077c">ha_partition::check_if_incompatible_data</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Part of old, deprecated in-place ALTER API. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">handler</a>.</p>

</div>
</div>
<a class="anchor" id="aeeb5f75cddb82102a64ac36bfceaef57"></a><!-- doxytag: member="ha_partition::check_if_supported_inplace_alter" ref="aeeb5f75cddb82102a64ac36bfceaef57" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum_alter_inplace_result <a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">ha_partition::check_if_supported_inplace_alter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if a storage engine supports a particular alter table in-place</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ALTER_ERROR</td><td>Unexpected error. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NOT_SUPPORTED</td><td>Not supported, must use copy. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_EXCLUSIVE_LOCK</td><td>Supported, but requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</td><td>Supported, but requires SNW lock during main phase. Prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK</td><td>Supported, but requires SNW lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE</td><td>Supported, concurrent reads/writes allowed. However, prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK</td><td>Supported, concurrent reads/writes allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The default implementation uses the old in-place ALTER API to determine if the storage engine supports in-place ALTER or not.</dd>
<dd>
Called without holding thr_lock.c lock. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">handler</a>.</p>

</div>
</div>
<a class="anchor" id="aa1797e0d681f755287d7858157a646e3"></a><!-- doxytag: member="ha_partition::commit_inplace_alter_table" ref="aa1797e0d681f755287d7858157a646e3" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info, bool commit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">ha_partition::commit_inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Commit or rollback the changes made during <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a> and <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">inplace_alter_table()</a> inside the storage engine. Note that in case of rollback the allowed level of concurrency during this operation will be the same as for <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">inplace_alter_table()</a> and thus might be higher than during <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a>. (For example, concurrent writes were blocked during prepare, but might not be during rollback).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function with commit= true reports error, it will be called again with commit= false.</dd>
<dd>
In case of partitioning, this function might be called for rollback without <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a> having been called first. Also partitioned tables sets ha_alter_info-&gt;group_commit_ctx to a NULL terminated array of the partitions handlers and if all of them are committed as one, then group_commit_ctx should be set to NULL to indicate to the partitioning handler that all partitions handlers are committed. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">commit</td><td>True =&gt; Commit, False =&gt; Rollback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ad162b32125ed0d7fb4b5b8167ce0269d"></a><!-- doxytag: member="ha_partition::delete_all_rows" ref="ad162b32125ed0d7fb4b5b8167ce0269d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#ad162b32125ed0d7fb4b5b8167ce0269d">ha_partition::delete_all_rows</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is called to delete all rows in a table If the handler don't support this, then this function will return HA_ERR_WRONG_COMMAND and MySQL will delete the rows one by one. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">handler</a>.</p>

</div>
</div>
<a class="anchor" id="aafdb3caedb579b35d9cda963b7a3c25f"></a><!-- doxytag: member="ha_partition::delete_table" ref="aafdb3caedb579b35d9cda963b7a3c25f" args="(const char *from)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#aafdb3caedb579b35d9cda963b7a3c25f">ha_partition::delete_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a table in the engine. Called for base as well as temporary tables.</p>
<p>Delete all files with extension from <a class="el" href="classha__partition.html#a439691aabff67557603a69a6318806b7">bas_ext()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Base name of table</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>We assume that the handler may return more extensions than was actually used for the file.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If we successfully deleted at least one file from base_ext and didn't get any other errors than ENOENT </td></tr>
    <tr><td class="paramname">!0</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a663485370abf958b89641924402db405"></a><!-- doxytag: member="ha_partition::estimate_rows_upper_bound" ref="a663485370abf958b89641924402db405" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows <a class="el" href="classha__partition.html#a663485370abf958b89641924402db405">ha_partition::estimate_rows_upper_bound</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return upper bound of current number of records in the table (max. of how many records one will retrieve when doing a full table scan) If upper bound is not known, HA_POS_ERROR should be returned as a max possible upper bound. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a7668775be94bce9d7cf799c051096380"></a><!-- doxytag: member="ha_partition::get_auto_increment" ref="a7668775be94bce9d7cf799c051096380" args="(ulonglong offset, ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value, ulonglong *nb_reserved_values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classha__partition.html#a7668775be94bce9d7cf799c051096380">ha_partition::get_auto_increment</a> </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserves an interval of auto_increment values from the handler.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>offset (modulus increment) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">increment</td><td>increment between calls </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_desired_values</td><td>how many values we want </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_value</td><td>the first value reserved by the handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_reserved_values</td><td>how many values the handler reserved</td></tr>
  </table>
  </dd>
</dl>
<p>offset and increment means that we want values to be of the form offset + N * increment, where N&gt;=0 is integer. If the function sets *first_value to ULONGLONG_MAX it means an error. If the function sets *nb_reserved_values to ULONGLONG_MAX it means it has reserved to "positive infinite". </p>

<p>Reimplemented from <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a4fb5ad51d61c07878d5626a315534497"></a><!-- doxytag: member="ha_partition::get_error_message" ref="a4fb5ad51d61c07878d5626a315534497" args="(int error, String *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__partition.html#a4fb5ad51d61c07878d5626a315534497">ha_partition::get_error_message</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an error message specific to this handler.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code previously returned by handler </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to <a class="el" href="classString.html">String</a> where to add error message</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if this is a temporary error </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a36ca395ca5c6066f00b30a9ccedfc43d"></a><!-- doxytag: member="ha_partition::get_no_parts" ref="a36ca395ca5c6066f00b30a9ccedfc43d" args="(const char *name, uint *num_parts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classha__partition.html#a36ca395ca5c6066f00b30a9ccedfc43d">ha_partition::get_no_parts</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>no_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get number of partitions for table in SE</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>normalized path(same as open) to the table</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">no_parts</td><td>Number of partitions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>for success </td></tr>
    <tr><td class="paramname">true</td><td>for failure, for example table didn't exist in engine </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a8c2bdc154c11f31207e3636c1a3ad3e2"></a><!-- doxytag: member="ha_partition::get_row_type" ref="a8c2bdc154c11f31207e3636c1a3ad3e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum row_type <a class="el" href="classha__partition.html#a8c2bdc154c11f31207e3636c1a3ad3e2">ha_partition::get_row_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the row type from the storage engine. If this method returns ROW_TYPE_NOT_USED, the information in HA_CREATE_INFO should be used. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a0b8caf0f3c35db1b63d81fd121793d49">handler</a>.</p>

</div>
</div>
<a class="anchor" id="acc714b62d79e24a9c1d4f3db712322b1"></a><!-- doxytag: member="ha_partition::index_first" ref="acc714b62d79e24a9c1d4f3db712322b1" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#acc714b62d79e24a9c1d4f3db712322b1">ha_partition::index_first</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a4e4defdf04378b86f231928ed21e017b"></a><!-- doxytag: member="ha_partition::index_last" ref="a4e4defdf04378b86f231928ed21e017b" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a4e4defdf04378b86f231928ed21e017b">ha_partition::index_last</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a6a599d1fe239ff7d7dba0b3984fc8bea"></a><!-- doxytag: member="ha_partition::index_next" ref="a6a599d1fe239ff7d7dba0b3984fc8bea" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a6a599d1fe239ff7d7dba0b3984fc8bea">ha_partition::index_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a2769f8f7dd54eebb15c6baa6c4651b2b"></a><!-- doxytag: member="ha_partition::index_next_same" ref="a2769f8f7dd54eebb15c6baa6c4651b2b" args="(uchar *buf, const uchar *key, uint keylen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a2769f8f7dd54eebb15c6baa6c4651b2b">ha_partition::index_next_same</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a25706609cb26f778dd90cc2611b112fd"></a><!-- doxytag: member="ha_partition::index_prev" ref="a25706609cb26f778dd90cc2611b112fd" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a25706609cb26f778dd90cc2611b112fd">ha_partition::index_prev</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">handler</a>.</p>

</div>
</div>
<a class="anchor" id="aee13430aea3946ffa6cf2c00104ba19c"></a><!-- doxytag: member="ha_partition::index_read_idx_map" ref="aee13430aea3946ffa6cf2c00104ba19c" args="(uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#aee13430aea3946ffa6cf2c00104ba19c">ha_partition::index_read_idx_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Positions an index cursor to the index specified in the hanlde. Fetches the row if available. If the key value is null, begin at first key of the index. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ae28896451f43f7b821e441413936c93c"></a><!-- doxytag: member="ha_partition::index_read_last_map" ref="ae28896451f43f7b821e441413936c93c" args="(uchar *buf, const uchar *key, key_part_map keypart_map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#ae28896451f43f7b821e441413936c93c">ha_partition::index_read_last_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The following functions works like index_read, but it find the last row with the current key value or prefix. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a7e153d8c7280e6d4440b09c61976e7f3"></a><!-- doxytag: member="ha_partition::index_read_map" ref="a7e153d8c7280e6d4440b09c61976e7f3" args="(uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3">ha_partition::index_read_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success (found a record, and function has set table-&gt;status to 0); non-zero if no record (function has set table-&gt;status to STATUS_NOT_FOUND). </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a772afdad3f8e79ecf0c176dfee5c95d2"></a><!-- doxytag: member="ha_partition::inplace_alter_table" ref="a772afdad3f8e79ecf0c176dfee5c95d2" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">ha_partition::inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a>. The level of concurrency allowed during this operation depends on the return value from <a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">check_if_supported_inplace_alter()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table()</a> will be called with commit= false.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a18e8ff8fce23b0ca305755e60d960cd9"></a><!-- doxytag: member="ha_partition::is_fatal_error" ref="a18e8ff8fce23b0ca305755e60d960cd9" args="(int error, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__partition.html#a18e8ff8fce23b0ca305755e60d960cd9">ha_partition::is_fatal_error</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is used to analyse the error to see whether the error is ignorable or not, certain handlers can have more error that are ignorable than others. E.g. the partition handler can get inserts into a range where there is no partition and this is an ignorable error. HA_ERR_FOUND_DUP_UNIQUE is a special case in MyISAM that means the same thing as HA_ERR_FOUND_DUP_KEY but can in some cases lead to a slightly different error message. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a94af2b65d4d966d480185f2a80009f38"></a><!-- doxytag: member="ha_partition::lock_count" ref="a94af2b65d4d966d480185f2a80009f38" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint <a class="el" href="classha__partition.html#a94af2b65d4d966d480185f2a80009f38">ha_partition::lock_count</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classha__partition.html#a94af2b65d4d966d480185f2a80009f38">lock_count()</a> can return &gt; 1 if the table is MERGE or partitioned. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a13f5a2b8ba9e4b9f9255243f0f1cd525">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a4350de763daa055bf18a26267664bda2"></a><!-- doxytag: member="ha_partition::notify_table_changed" ref="a4350de763daa055bf18a26267664bda2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classha__partition.html#a4350de763daa055bf18a26267664bda2">ha_partition::notify_table_changed</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify the storage engine that the table structure (.FRM) has been updated.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>No errors are allowed during <a class="el" href="classha__partition.html#a4350de763daa055bf18a26267664bda2">notify_table_changed()</a>. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a60893ae5e2153faa3f35ffde0460d9d6"></a><!-- doxytag: member="ha_partition::prepare_inplace_alter_table" ref="a60893ae5e2153faa3f35ffde0460d9d6" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">ha_partition::prepare_inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the storage engine to update internal structures with concurrent writes blocked. If <a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">check_if_supported_inplace_alter()</a> returns HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE or HA_ALTER_INPLACE_SHARED_AFTER_PREPARE, this function is called with exclusive lock otherwise the same level of locking as for <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">inplace_alter_table()</a> will be used.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table()</a> will be called with commit= false.</dd>
<dd>
For partitioning, failing to prepare one partition, means that <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table()</a> will be called to roll back changes for all partitions. This means that <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">commit_inplace_alter_table()</a> might be called without <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">prepare_inplace_alter_table()</a> having been called first for a given partition.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">handler</a>.</p>

</div>
</div>
<a class="anchor" id="afbddb8246029958806a6078b3ea71b32"></a><!-- doxytag: member="ha_partition::print_error" ref="afbddb8246029958806a6078b3ea71b32" args="(int error, myf errflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classha__partition.html#afbddb8246029958806a6078b3ea71b32">ha_partition::print_error</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">myf&#160;</td>
          <td class="paramname"><em>errflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print error that we got from handler function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In case of delete table it's only safe to use the following parts of the 'table' structure:<ul>
<li>table-&gt;s-&gt;path</li>
<li>table-&gt;alias </li>
</ul>
</dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">handler</a>.</p>

</div>
</div>
<a class="anchor" id="aa0217cd2a331904f87fbfcbe4dde5800"></a><!-- doxytag: member="ha_partition::read_range_first" ref="aa0217cd2a331904f87fbfcbe4dde5800" args="(const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#aa0217cd2a331904f87fbfcbe4dde5800">ha_partition::read_range_first</a> </td>
          <td>(</td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read first row between two ranges. Store ranges for future calls to read_range_next. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname">\::</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ae77ce0688d4d2c0451dcb930e6ca42bc"></a><!-- doxytag: member="ha_partition::read_range_next" ref="ae77ce0688d4d2c0451dcb930e6ca42bc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#ae77ce0688d4d2c0451dcb930e6ca42bc">ha_partition::read_range_next</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname">\::</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ae2cd9274cdcf243f53efc8c236bb8379"></a><!-- doxytag: member="ha_partition::read_time" ref="ae2cd9274cdcf243f53efc8c236bb8379" args="(uint index, uint ranges, ha_rows rows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classha__partition.html#ae2cd9274cdcf243f53efc8c236bb8379">ha_partition::read_time</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The cost of reading a set of ranges from the table using an index to access it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index number. </td></tr>
    <tr><td class="paramname">ranges</td><td>The number of ranges to be read. </td></tr>
    <tr><td class="paramname">rows</td><td>Total number of rows to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used to calculate the total cost of scanning a table using an index by calling it using read_time(index, 1, table_size). </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ada684ff4029d92f8b693952ccb780948"></a><!-- doxytag: member="ha_partition::records" ref="ada684ff4029d92f8b693952ccb780948" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows <a class="el" href="classha__partition.html#ada684ff4029d92f8b693952ccb780948">ha_partition::records</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of rows in table. It will only be called if (table_flags() &amp; (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT)) != 0 </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a4673b0434ccbcd97542e1f7636d61db2"></a><!-- doxytag: member="ha_partition::register_query_cache_table" ref="a4673b0434ccbcd97542e1f7636d61db2" args="(THD *thd, char *table_key, uint key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual my_bool <a class="el" href="classha__partition.html#a4673b0434ccbcd97542e1f7636d61db2">ha_partition::register_query_cache_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qc_engine_callback *&#160;</td>
          <td class="paramname"><em>engine_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>engine_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a named table with a call back function to the query cache. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_key</td><td>A pointer to the table name in the table cache </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_length</td><td>The length of the table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_callback</td><td>The pointer to the storage engine call back function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_data</td><td>Storage engine specific data which could be anything</td></tr>
  </table>
  </dd>
</dl>
<p>This method offers the storage engine, the possibility to store a reference to a table name which is going to be used with query cache. The method is called each time a statement is written to the cache and can be used to verify if a specific statement is cachable. It also offers the possibility to register a generic (but static) call back function which is called each time a statement is matched against the query cache.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If engine_data supplied with this function is different from engine_data supplied with the callback function, and the callback returns FALSE, a table invalidation on the current table will occur.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Upon success the engine_callback will point to the storage engine call back function, if any, and engine_data will point to any storage engine data used in the specific implementation. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Success </td></tr>
    <tr><td class="paramname">FALSE</td><td>The specified table or current statement should not be cached </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a7dbc26903dfbc0128c0d5a7e68d3681b"></a><!-- doxytag: member="ha_partition::rename_table" ref="a7dbc26903dfbc0128c0d5a7e68d3681b" args="(const char *from, const char *to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a7dbc26903dfbc0128c0d5a7e68d3681b">ha_partition::rename_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default <a class="el" href="classha__partition.html#a7dbc26903dfbc0128c0d5a7e68d3681b">rename_table()</a> and <a class="el" href="classha__partition.html#aafdb3caedb579b35d9cda963b7a3c25f">delete_table()</a> rename/delete files with a given name and extensions from <a class="el" href="classha__partition.html#a439691aabff67557603a69a6318806b7">bas_ext()</a>.</p>
<p>These methods can be overridden, but their default implementation provide useful functionality. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ab7908bdcad420cac9f0d696e528ba8e1"></a><!-- doxytag: member="ha_partition::repair" ref="ab7908bdcad420cac9f0d696e528ba8e1" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#ab7908bdcad420cac9f0d696e528ba8e1">ha_partition::repair</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In this method check_opt can be modified to specify CHECK option to use to call check() upon the table. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a0dd96d4f1ecc4e63d6afbcc6d6d4c243"></a><!-- doxytag: member="ha_partition::reset" ref="a0dd96d4f1ecc4e63d6afbcc6d6d4c243" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a0dd96d4f1ecc4e63d6afbcc6d6d4c243">ha_partition::reset</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset state of file to after 'open'. This function is called after every statement for all tables used by that statement. </p>

<p>Reimplemented from <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a0f1716a11f635614b7772b9b0711a1ff"></a><!-- doxytag: member="ha_partition::rnd_init" ref="a0f1716a11f635614b7772b9b0711a1ff" args="(bool scan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a0f1716a11f635614b7772b9b0711a1ff">ha_partition::rnd_init</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classha__partition.html#a0f1716a11f635614b7772b9b0711a1ff">rnd_init()</a> can be called two times without rnd_end() in between (it only makes sense if scan=1). then the second call should prepare for the new table scan (e.g if rnd_init allocates the cursor, second call should position it to the start of the table, no need to deallocate and allocate it again </p>

<p>Implements <a class="el" href="classhandler.html">handler</a>.</p>

</div>
</div>
<a class="anchor" id="ad468c67dd2f37885994530f9e2ad2266"></a><!-- doxytag: member="ha_partition::rnd_next" ref="ad468c67dd2f37885994530f9e2ad2266" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#ad468c67dd2f37885994530f9e2ad2266">ha_partition::rnd_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a7b052173ced1b88687dafba28a170335"></a><!-- doxytag: member="ha_partition::rnd_pos" ref="a7b052173ced1b88687dafba28a170335" args="(uchar *buf, uchar *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a7b052173ced1b88687dafba28a170335">ha_partition::rnd_pos</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a58bbc7153fa41de3b53872cb8f4b4e6e"></a><!-- doxytag: member="ha_partition::rnd_pos_by_record" ref="a58bbc7153fa41de3b53872cb8f4b4e6e" args="(uchar *record)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a58bbc7153fa41de3b53872cb8f4b4e6e">ha_partition::rnd_pos_by_record</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function only works for handlers having HA_PRIMARY_KEY_REQUIRED_FOR_POSITION set. It will return the row with the PK given in the record argument. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a590ff604823725a59b5b7dd1fa83ac35"></a><!-- doxytag: member="ha_partition::store_lock" ref="a590ff604823725a59b5b7dd1fa83ac35" args="(THD *thd, THR_LOCK_DATA **to, enum thr_lock_type lock_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual THR_LOCK_DATA** <a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">ha_partition::store_lock</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THR_LOCK_DATA **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is not invoked for non-transactional temporary tables.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">store_lock()</a> can return more than one lock if the table is MERGE or partitioned.</dd>
<dd>
that one can NOT rely on table-&gt;in_use in <a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">store_lock()</a>. It may refer to a different thread if called from <a class="el" href="group__Locking.html#ga321511c56502643e5aecbe6ed3e43b58">mysql_lock_abort_for_thread()</a>.</dd>
<dd>
If the table is MERGE, <a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">store_lock()</a> can return less locks than <a class="el" href="classha__partition.html#a94af2b65d4d966d480185f2a80009f38">lock_count()</a> claimed. This can happen when the MERGE children are not attached when this is called from another thread. </dd></dl>

<p>Implements <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a2b4f4002504f73ed3ae195729b95603b"></a><!-- doxytag: member="ha_partition::table_cache_type" ref="a2b4f4002504f73ed3ae195729b95603b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8 <a class="el" href="classha__partition.html#a2b4f4002504f73ed3ae195729b95603b">ha_partition::table_cache_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type of table for caching query </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a4cb39c8b7ba6dabe242f3205c86f59f2"></a><!-- doxytag: member="ha_partition::table_type" ref="a4cb39c8b7ba6dabe242f3205c86f59f2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classha__partition.html#a4cb39c8b7ba6dabe242f3205c86f59f2">ha_partition::table_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The following can be called without an open handler </p>

<p>Implements <a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a42819e5cf989a23c0ade56feece2bcf4"></a><!-- doxytag: member="ha_partition::truncate" ref="a42819e5cf989a23c0ade56feece2bcf4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classha__partition.html#a42819e5cf989a23c0ade56feece2bcf4">ha_partition::truncate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Quickly remove all rows from a table.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method is responsible for implementing MySQL's TRUNCATE <a class="el" href="structTABLE.html">TABLE</a> statement, which is a DDL operation. As such, a engine can bypass certain integrity checks and in some cases avoid fine-grained locking (e.g. row locks) which would normally be required for a DELETE statement.</dd>
<dd>
Typically, truncate is not used if it can result in integrity violation. For example, truncate is not used when a foreign key references the table, but it might be used if foreign key checks are disabled.</dd>
<dd>
Engine is responsible for resetting the auto-increment counter.</dd>
<dd>
The table is locked in exclusive mode. </dd></dl>

<p>Reimplemented from <a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a45235c1c364a4b1ac4a2b97134f7a4b4"></a><!-- doxytag: member="ha_partition::try_semi_consistent_read" ref="a45235c1c364a4b1ac4a2b97134f7a4b4" args="(bool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classha__partition.html#a45235c1c364a4b1ac4a2b97134f7a4b4">ha_partition::try_semi_consistent_read</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tell the engine whether it should avoid unnecessary lock waits. If yes, in an UPDATE or DELETE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">handler</a>.</p>

</div>
</div>
<a class="anchor" id="a2a059c1ac08f3cd71b7087b876664e18"></a><!-- doxytag: member="ha_partition::was_semi_consistent_read" ref="a2a059c1ac08f3cd71b7087b876664e18" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classha__partition.html#a2a059c1ac08f3cd71b7087b876664e18">ha_partition::was_semi_consistent_read</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In an UPDATE or DELETE, if the row under the cursor was locked by another transaction, and the engine used an optimistic read of the last committed row value under the cursor, then the engine returns 1 from this function. MySQL must NOT try to update this optimistic value. If the optimistic value does not match the WHERE condition, MySQL can decide to skip over this row. Currently only works for InnoDB. This can be used to avoid unnecessary lock waits.</p>
<p>If this method returns nonzero, it will also signal the storage engine that the next read will be a locking re-read of the row. </p>

<p>Reimplemented from <a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">handler</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="ha__partition_8h_source.html">ha_partition.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:35:44 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
