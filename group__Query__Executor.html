<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: Query Executor</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Executor</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1cc817dd0c7e9e7ba403b55f4b20a3fb"></a><!-- doxytag: member="Query_Executor::prepare_sum_aggregators" ref="ga1cc817dd0c7e9e7ba403b55f4b20a3fb" args="(Item_sum **func_ptr, bool need_distinct)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>prepare_sum_aggregators</b> (<a class="el" href="classItem__sum.html">Item_sum</a> **func_ptr, bool need_distinct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1b1125b75ed00a408f039bb83de7c480">setup_sum_funcs</a> (THD *thd, <a class="el" href="classItem__sum.html">Item_sum</a> **func_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga83ce4c7b8a149e93d6112527d0416aa7">copy_funcs</a> (<a class="el" href="classItem.html">Item</a> **func_ptr, const THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga25deeac7a2e0e4cd9623bfcf539e44f7">setup_tmptable_write_func</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup write_func of <a class="el" href="classQEP__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further...">QEP_tmp_table</a> object.  <a href="#ga25deeac7a2e0e4cd9623bfcf539e44f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Next_select_func&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga19817b01781d428b21cf4c3a3f42467b">setup_end_select_func</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gacb3f583dd255c4288df81b3ab1628a1c">sub_select_op</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate full or partial join result in operation and send operation's result further.  <a href="#gacb3f583dd255c4288df81b3ab1628a1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaf5c3a10fb1e79511b38573124e0ec107">sub_select</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4c3b77b483fa5b7bcefe0f38587480c8">do_sj_dups_weedout</a> (THD *thd, <a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *sjtbl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga4fb800e0e68d03a1b49a9cf66fda4006">report_handler_error</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, int error)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1142f17ec7f7382f97e566f23eb6531d"></a><!-- doxytag: member="Query_Executor::safe_index_read" ref="ga1142f17ec7f7382f97e566f23eb6531d" args="(JOIN_TAB *tab)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>safe_index_read</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga39c30d89f411ee0d12ecd4824f9aae1a">join_read_const_table</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="structst__position.html">POSITION</a> *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga59ac23de91637b8c89139c7ddeb81a6e">join_read_key_unlock_row</a> (<a class="el" href="structst__join__table.html">st_join_table</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gae7a4e01fdaf11685248def35552484ac">join_read_last_key</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4478c7766644e31523194a220460a9f2"></a><!-- doxytag: member="Query_Executor::join_read_prev_same" ref="ga4478c7766644e31523194a220460a9f2" args="(READ_RECORD *info)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_prev_same</b> (<a class="el" href="structREAD__RECORD.html">READ_RECORD</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac643027fd4d1f99f03055061a05b05e4"></a><!-- doxytag: member="Query_Executor::join_init_quick_read_record" ref="gac643027fd4d1f99f03055061a05b05e4" args="(JOIN_TAB *tab)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_init_quick_read_record</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabde71b02635ed97c198671fff32e9154"></a><!-- doxytag: member="Query_Executor::read_first_record_seq" ref="gabde71b02635ed97c198671fff32e9154" args="(JOIN_TAB *tab)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>read_first_record_seq</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga941e1255d38b156bbed1693a97545414">join_init_read_record</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare table for reading rows and read first record.  <a href="#ga941e1255d38b156bbed1693a97545414"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa0bd7c50bcdd52a0d9e49c3985f06e3"></a><!-- doxytag: member="Query_Executor::join_materialize_derived" ref="gaaa0bd7c50bcdd52a0d9e49c3985f06e3" args="(JOIN_TAB *tab)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_materialize_derived</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafdf823c5bb814153d289d4f3c0a7c63a"></a><!-- doxytag: member="Query_Executor::join_materialize_semijoin" ref="gafdf823c5bb814153d289d4f3c0a7c63a" args="(JOIN_TAB *tab)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_materialize_semijoin</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeee74a413899e386bc8fc01e00b1786d"></a><!-- doxytag: member="Query_Executor::join_read_first" ref="gaeee74a413899e386bc8fc01e00b1786d" args="(JOIN_TAB *tab)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_first</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacf8b2e69e78e1f0e7bfa1f4432d7c3ae"></a><!-- doxytag: member="Query_Executor::join_read_last" ref="gacf8b2e69e78e1f0e7bfa1f4432d7c3ae" args="(JOIN_TAB *tab)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>join_read_last</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga2a5c993c8b1846da161af3022c82a734">pick_table_access_method</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5daf7637bb6b89ea2965089eacc33b88"></a><!-- doxytag: member="Query_Executor::end_send_group" ref="ga5daf7637bb6b89ea2965089eacc33b88" args="(JOIN *join, JOIN_TAB *join_tab __attribute__((unused)), bool end_of_records)" -->
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_send_group</b> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab __attribute__((unused)), bool end_of_records)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga78e9746df25070df8400039a7cdb1cd6"></a><!-- doxytag: member="Query_Executor::end_write_group" ref="ga78e9746df25070df8400039a7cdb1cd6" args="(JOIN *join, JOIN_TAB *join_tab, bool end_of_records)" -->
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>end_write_group</b> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab, bool end_of_records)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8ce1ad15977cc2105276ffca627a3824"></a><!-- doxytag: member="Query_Executor::cp_buffer_from_ref" ref="ga8ce1ad15977cc2105276ffca627a3824" args="(THD *thd, TABLE *table, TABLE_REF *ref)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_buffer_from_ref</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="structst__table__ref.html">TABLE_REF</a> *ref)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaa0bd2dbcf106da50227e2eb4932b588d">make_group_fields</a> (<a class="el" href="classJOIN.html">JOIN</a> *main_join, <a class="el" href="classJOIN.html">JOIN</a> *curr_join)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga108fbed43151ab58878335fbb84503c1">alloc_group_fields</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *group)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1389fe70c557f844809a7bd780fc545a"></a><!-- doxytag: member="Query_Executor::test_if_item_cache_changed" ref="ga1389fe70c557f844809a7bd780fc545a" args="(List&lt; Cached_item &gt; &amp;list)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>test_if_item_cache_changed</b> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classCached__item.html">Cached_item</a> &gt; &amp;list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gabf6f9870d5d7d18698a9fed0295393f4">setup_copy_fields</a> (THD *thd, TMP_TABLE_PARAM *param, <a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga85cf2346de8420668cb7988a62d43b1c">copy_fields</a> (TMP_TABLE_PARAM *param)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1e985adce1ee0b0c97f2351330ba0b45">change_to_use_tmp_fields</a> (THD *thd, <a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gae27d7837289ad61f55a8649b343d2ffe">change_refs_to_tmp_fields</a> (THD *thd, <a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_selected_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;res_all_fields, uint elements, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;all_fields)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga31581f58624b85919d7c6cd632157929">JOIN::exec</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga148b2123bee3ebd0718d334e9f109db8">JOIN::rollup_send_data</a> (uint idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga15c9baf548fef3d59f993a3c13575593">JOIN::rollup_write_data</a> (uint idx, <a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#gaeee113ec47170e3e0d774c0a04beafc3">st_join_table::prepare_scan</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare table to be scanned.  <a href="#gaeee113ec47170e3e0d774c0a04beafc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga62fae26d0e5c875d2992257ce44e4d38">st_join_table::use_order</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Use ordering provided by chosen index?  <a href="#ga62fae26d0e5c875d2992257ce44e4d38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06940835e20546f1d3866b9341828e06"></a><!-- doxytag: member="Query_Executor::sort_table" ref="ga06940835e20546f1d3866b9341828e06" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>st_join_table::sort_table</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaedeb5c57d26a961a68a1bdabe11ae770"></a><!-- doxytag: member="Query_Executor::remove_duplicates" ref="gaedeb5c57d26a961a68a1bdabe11ae770" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>st_join_table::remove_duplicates</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Executor.html#ga1cbaa4a44140f41c161eaab87c25f473">QEP_tmp_table::end_send</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish rnd/index scan after accumulating records, switch ref_array, and send accumulated records further.  <a href="#ga1cbaa4a44140f41c161eaab87c25f473"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga108fbed43151ab58878335fbb84503c1"></a><!-- doxytag: member="sql_executor.cc::alloc_group_fields" ref="ga108fbed43151ab58878335fbb84503c1" args="(JOIN *join, ORDER *group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#ga108fbed43151ab58878335fbb84503c1">alloc_group_fields</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of buffers for saveing last group.</p>
<p>Groups are saved in reverse order for easyer check loop. </p>

</div>
</div>
<a class="anchor" id="gae27d7837289ad61f55a8649b343d2ffe"></a><!-- doxytag: member="sql_executor.cc::change_refs_to_tmp_fields" ref="gae27d7837289ad61f55a8649b343d2ffe" args="(THD *thd, Ref_ptr_array ref_pointer_array, List&lt; Item &gt; &amp;res_selected_fields, List&lt; Item &gt; &amp;res_all_fields, uint elements, List&lt; Item &gt; &amp;all_fields)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#gae27d7837289ad61f55a8649b343d2ffe">change_refs_to_tmp_fields</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change all sum_func refs to fields to point at fields in tmp table. Change all funcs to be fields in tmp table.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1e985adce1ee0b0c97f2351330ba0b45"></a><!-- doxytag: member="sql_executor.cc::change_to_use_tmp_fields" ref="ga1e985adce1ee0b0c97f2351330ba0b45" args="(THD *thd, Ref_ptr_array ref_pointer_array, List&lt; Item &gt; &amp;res_selected_fields, List&lt; Item &gt; &amp;res_all_fields, uint elements, List&lt; Item &gt; &amp;all_fields)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#ga1e985adce1ee0b0c97f2351330ba0b45">change_to_use_tmp_fields</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change all funcs and sum_funcs to fields in tmp table, and create new list of all items.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">!=0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga85cf2346de8420668cb7988a62d43b1c"></a><!-- doxytag: member="sql_executor.cc::copy_fields" ref="ga85cf2346de8420668cb7988a62d43b1c" args="(TMP_TABLE_PARAM *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Executor.html#ga85cf2346de8420668cb7988a62d43b1c">copy_fields</a> </td>
          <td>(</td>
          <td class="paramtype">TMP_TABLE_PARAM *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make a copy of all simple SELECT'ed items.</p>
<p>This is done at the start of a new group so that we can retrieve these later when the group changes. </p>

</div>
</div>
<a class="anchor" id="ga83ce4c7b8a149e93d6112527d0416aa7"></a><!-- doxytag: member="sql_executor.cc::copy_funcs" ref="ga83ce4c7b8a149e93d6112527d0416aa7" args="(Item **func_ptr, const THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#ga83ce4c7b8a149e93d6112527d0416aa7">copy_funcs</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const THD *&#160;</td>
          <td class="paramname"><em>thd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy result of functions to record in tmp_table.</p>
<p>Uses the thread pointer to check for errors in some of the val_xxx() methods called by the save_in_result_field() function. TODO: make the Item::val_xxx() return error code</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">func_ptr</td><td>array of the function Items to copy to the tmp table </td></tr>
    <tr><td class="paramname">thd</td><td>pointer to the current thread for error checking </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c3b77b483fa5b7bcefe0f38587480c8"></a><!-- doxytag: member="sql_executor.cc::do_sj_dups_weedout" ref="ga4c3b77b483fa5b7bcefe0f38587480c8" args="(THD *thd, SJ_TMP_TABLE *sjtbl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Executor.html#ga4c3b77b483fa5b7bcefe0f38587480c8">do_sj_dups_weedout</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSJ__TMP__TABLE.html">SJ_TMP_TABLE</a> *&#160;</td>
          <td class="paramname"><em>sjtbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>SemiJoinDuplicateElimination: Weed out duplicate row combinations</p>
<p>SYNPOSIS <a class="el" href="group__Query__Executor.html#ga4c3b77b483fa5b7bcefe0f38587480c8">do_sj_dups_weedout()</a> thd Thread handle sjtbl Duplicate weedout table</p>
<p>DESCRIPTION Try storing current record combination of outer tables (i.e. their rowids) in the temporary table. This records the fact that we've seen this record combination and also tells us if we've seen it before.</p>
<p>RETURN -1 Error 1 The row combination is a duplicate (discard it) 0 The row combination is not a duplicate (continue) </p>

</div>
</div>
<a class="anchor" id="ga1cbaa4a44140f41c161eaab87c25f473"></a><!-- doxytag: member="QEP_tmp_table::end_send" ref="ga1cbaa4a44140f41c161eaab87c25f473" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state <a class="el" href="group__Query__Executor.html#ga1cbaa4a44140f41c161eaab87c25f473">QEP_tmp_table::end_send</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finish rnd/index scan after accumulating records, switch ref_array, and send accumulated records further. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>return one of enum_nested_loop_state. </dd></dl>

<p>Implements <a class="el" href="classQEP__operation.html#a4faf706cddaf3ae613fe92434776df5e">QEP_operation</a>.</p>

</div>
</div>
<a class="anchor" id="ga31581f58624b85919d7c6cd632157929"></a><!-- doxytag: member="JOIN::exec" ref="ga31581f58624b85919d7c6cd632157929" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Executor.html#ga31581f58624b85919d7c6cd632157929">JOIN::exec</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Execute select, executor entry point.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000075">Todo:</a></b></dt><dd>When can we have here thd-&gt;net.report_error not zero? </dd></dl>

</div>
</div>
<a class="anchor" id="ga941e1255d38b156bbed1693a97545414"></a><!-- doxytag: member="sql_executor.cc::join_init_read_record" ref="ga941e1255d38b156bbed1693a97545414" args="(JOIN_TAB *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Executor.html#ga941e1255d38b156bbed1693a97545414">join_init_read_record</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare table for reading rows and read first record. </p>
<p>Prior to reading the table following tasks are done, (in the order of execution): .) derived tables are materialized .) duplicates removed (tmp tables only) .) table is sorted with filesort (both non-tmp and tmp tables) After this have been done this function resets quick select, if it's present, sets up table reading functions, and reads first record.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Ok </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga39c30d89f411ee0d12ecd4824f9aae1a"></a><!-- doxytag: member="sql_executor.cc::join_read_const_table" ref="ga39c30d89f411ee0d12ecd4824f9aae1a" args="(JOIN_TAB *tab, POSITION *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Executor.html#ga39c30d89f411ee0d12ecd4824f9aae1a">join_read_const_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__position.html">POSITION</a> *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads content of constant table </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>table </td></tr>
    <tr><td class="paramname">pos</td><td>position of table in query plan </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok, one row was found or one NULL-complemented row was created </td></tr>
    <tr><td class="paramname">-1</td><td>ok, no row was found and no NULL-complemented row was created </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59ac23de91637b8c89139c7ddeb81a6e"></a><!-- doxytag: member="sql_executor.cc::join_read_key_unlock_row" ref="ga59ac23de91637b8c89139c7ddeb81a6e" args="(st_join_table *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Executor.html#ga59ac23de91637b8c89139c7ddeb81a6e">join_read_key_unlock_row</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">st_join_table</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Since join_read_key may buffer a record, do not unlock it if it was not used in this invocation of join_read_key(). Only count locks, thus remembering if the record was left unused, and unlock already when pruning the current value of TABLE_REF buffer. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>join_read_key() </dd></dl>

</div>
</div>
<a class="anchor" id="gae7a4e01fdaf11685248def35552484ac"></a><!-- doxytag: member="sql_executor.cc::join_read_last_key" ref="gae7a4e01fdaf11685248def35552484ac" args="(JOIN_TAB *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Executor.html#gae7a4e01fdaf11685248def35552484ac">join_read_last_key</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used when optimizing away ORDER BY in SELECT * FROM t1 WHERE a=1 ORDER BY a DESC,b DESC. </p>

</div>
</div>
<a class="anchor" id="gaa0bd2dbcf106da50227e2eb4932b588d"></a><!-- doxytag: member="sql_executor.cc::make_group_fields" ref="gaa0bd2dbcf106da50227e2eb4932b588d" args="(JOIN *main_join, JOIN *curr_join)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#gaa0bd2dbcf106da50227e2eb4932b588d">make_group_fields</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>main_join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>curr_join</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>allocate group fields or take prepared (cached).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">main_join</td><td>join of current select </td></tr>
    <tr><td class="paramname">curr_join</td><td>current join (join of current select or temporary copy of it)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>failed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2a5c993c8b1846da161af3022c82a734"></a><!-- doxytag: member="sql_executor.cc::pick_table_access_method" ref="ga2a5c993c8b1846da161af3022c82a734" args="(JOIN_TAB *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Executor.html#ga2a5c993c8b1846da161af3022c82a734">pick_table_access_method</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pick the appropriate access method functions</p>
<p>Sets the functions for the selected table access method</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>Table reference to put access method </td></tr>
  </table>
  </dd>
</dl>
<p>Set up modified access function for children of pushed joins.</p>
<p>Is child of a pushed join operation: Replace access functions with its linked counterpart. ... Which is effectively a NOOP as the row is already fetched together with the root of the linked operation.</p>
<p>Already set to some non-default value in <a class="el" href="sql__select_8cc.html" title="mysql_select and join optimization">sql_select.cc</a>? TODO: Move these settings into <a class="el" href="group__Query__Executor.html#ga2a5c993c8b1846da161af3022c82a734">pick_table_access_method()</a> also</p>

</div>
</div>
<a class="anchor" id="gaeee113ec47170e3e0d774c0a04beafc3"></a><!-- doxytag: member="st_join_table::prepare_scan" ref="gaeee113ec47170e3e0d774c0a04beafc3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#gaeee113ec47170e3e0d774c0a04beafc3">JOIN_TAB::prepare_scan</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Prepare table to be scanned. </p>
<p>This function is the place to do any work on the table that needs to be done before table can be scanned. Currently it only materialized derived tables and semi-joined subqueries and binds buffer for current rowid.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false - Ok, true - error </dd></dl>

</div>
</div>
<a class="anchor" id="ga4fb800e0e68d03a1b49a9cf66fda4006"></a><!-- doxytag: member="sql_executor.cc::report_handler_error" ref="ga4fb800e0e68d03a1b49a9cf66fda4006" args="(TABLE *table, int error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Executor.html#ga4fb800e0e68d03a1b49a9cf66fda4006">report_handler_error</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Help function when we get some an error from the table handler. </p>

</div>
</div>
<a class="anchor" id="ga148b2123bee3ebd0718d334e9f109db8"></a><!-- doxytag: member="JOIN::rollup_send_data" ref="ga148b2123bee3ebd0718d334e9f109db8" args="(uint idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Executor.html#ga148b2123bee3ebd0718d334e9f109db8">JOIN::rollup_send_data</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send all rollup levels higher than the current one to the client.</p>
<p><b>SAMPLE</b> </p>
<div class="fragment"><pre class="fragment">      SELECT a, b, c SUM(b) FROM t1 GROUP BY a,b WITH <a class="code" href="structst__rollup.html">ROLLUP</a>
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Level we are on:<ul>
<li>0 = Total sum level</li>
<li>1 = First group changed (a)</li>
<li>2 = Second group changed (a,b)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>If send_data_failed() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga15c9baf548fef3d59f993a3c13575593"></a><!-- doxytag: member="JOIN::rollup_write_data" ref="ga15c9baf548fef3d59f993a3c13575593" args="(uint idx, TABLE *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Executor.html#ga15c9baf548fef3d59f993a3c13575593">JOIN::rollup_write_data</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write all rollup levels higher than the current one to a temp table.</p>
<p><b>SAMPLE</b> </p>
<div class="fragment"><pre class="fragment">      SELECT a, b, SUM(c) FROM t1 GROUP BY a,b WITH <a class="code" href="structst__rollup.html">ROLLUP</a>
</pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Level we are on:<ul>
<li>0 = Total sum level</li>
<li>1 = First group changed (a)</li>
<li>2 = Second group changed (a,b) </li>
</ul>
</td></tr>
    <tr><td class="paramname">table</td><td>reference to temp table</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>if write_data_failed() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabf6f9870d5d7d18698a9fed0295393f4"></a><!-- doxytag: member="sql_executor.cc::setup_copy_fields" ref="gabf6f9870d5d7d18698a9fed0295393f4" args="(THD *thd, TMP_TABLE_PARAM *param, Ref_ptr_array ref_pointer_array, List&lt; Item &gt; &amp;res_selected_fields, List&lt; Item &gt; &amp;res_all_fields, uint elements, List&lt; Item &gt; &amp;all_fields)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#gabf6f9870d5d7d18698a9fed0295393f4">setup_copy_fields</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMP_TABLE_PARAM *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a>&#160;</td>
          <td class="paramname"><em>ref_pointer_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_selected_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res_all_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup copy_fields to save fields at start of new group.</p>
<p>Setup copy_fields to save fields at start of new group</p>
<p>Only FIELD_ITEM:s and FUNC_ITEM:s needs to be saved between groups. Change old item_field to use a new field with points at saved fieldvalue This function is only called before use of send_result_set_metadata.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">param</td><td>temporary table parameters </td></tr>
    <tr><td class="paramname">ref_pointer_array</td><td>array of pointers to top elements of filed list </td></tr>
    <tr><td class="paramname">res_selected_fields</td><td>new list of items of select item list </td></tr>
    <tr><td class="paramname">res_all_fields</td><td>new list of all items </td></tr>
    <tr><td class="paramname">elements</td><td>number of elements in select item list </td></tr>
    <tr><td class="paramname">all_fields</td><td>all fields list</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000076">Todo:</a></b></dt><dd>In most cases this result will be sent to the user. This should be changed to use copy_int or copy_real depending on how the value is to be used: In some cases this may be an argument in a group function, like: IF(ISNULL(col),0,COUNT(*))</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">!=0</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga19817b01781d428b21cf4c3a3f42467b"></a><!-- doxytag: member="sql_executor.cc::setup_end_select_func" ref="ga19817b01781d428b21cf4c3a3f42467b" args="(JOIN *join, JOIN_TAB *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Next_select_func <a class="el" href="group__Query__Executor.html#ga19817b01781d428b21cf4c3a3f42467b">setup_end_select_func</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rows produced by a join sweep may end up in a temporary table or be sent to a client. Setup the function of the nested loop join algorithm which handles final fully constructed and matched records.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>join to setup the function for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>end_select function to use. This function can't fail. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1b1125b75ed00a408f039bb83de7c480"></a><!-- doxytag: member="sql_executor.cc::setup_sum_funcs" ref="ga1b1125b75ed00a408f039bb83de7c480" args="(THD *thd, Item_sum **func_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#ga1b1125b75ed00a408f039bb83de7c480">setup_sum_funcs</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> **&#160;</td>
          <td class="paramname"><em>func_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call ::setup for all sum functions.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">func_ptr</td><td>sum function list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>ok </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga25deeac7a2e0e4cd9623bfcf539e44f7"></a><!-- doxytag: member="sql_executor.cc::setup_tmptable_write_func" ref="ga25deeac7a2e0e4cd9623bfcf539e44f7" args="(JOIN_TAB *tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Executor.html#ga25deeac7a2e0e4cd9623bfcf539e44f7">setup_tmptable_write_func</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setup write_func of <a class="el" href="classQEP__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further...">QEP_tmp_table</a> object. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">join_tab</td><td>JOIN_TAB of a tmp table</td></tr>
  </table>
  </dd>
</dl>
<p>Function sets up write_func according to how <a class="el" href="classQEP__tmp__table.html" title="Class for accumulating join result in a tmp table, grouping them if necessary, and sending further...">QEP_tmp_table</a> object that is attached to the given join_tab will be used in the query. </p>

</div>
</div>
<a class="anchor" id="gaf5c3a10fb1e79511b38573124e0ec107"></a><!-- doxytag: member="sql_executor.cc::sub_select" ref="gaf5c3a10fb1e79511b38573124e0ec107" args="(JOIN *join, JOIN_TAB *join_tab, bool end_of_records)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state <a class="el" href="group__Query__Executor.html#gaf5c3a10fb1e79511b38573124e0ec107">sub_select</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve records ends with a given beginning from the result of a join.</p>
<p>SYNPOSIS <a class="el" href="group__Query__Executor.html#gaf5c3a10fb1e79511b38573124e0ec107">sub_select()</a> join pointer to the structure providing all context info for the query join_tab the first next table of the execution plan to be retrieved end_records true when we need to perform final steps of retrival</p>
<p>DESCRIPTION For a given partial join record consisting of records from the tables preceding the table join_tab in the execution plan, the function retrieves all matching full records from the result set and send them to the result set stream.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function effectively implements the final (n-k) nested loops of nested loops join algorithm, where k is the ordinal number of the join_tab table and n is the total number of tables in the join query. It performs nested loops joins with all conjunctive predicates from the where condition pushed as low to the tables as possible. E.g. for the query <div class="fragment"><pre class="fragment">      SELECT * FROM t1,t2,t3
      WHERE t1.a=t2.a AND t2.b=t3.b AND t1.a BETWEEN 5 AND 9
</pre></div> the predicate (t1.a BETWEEN 5 AND 9) will be pushed to table t1, given the selected plan prescribes to nest retrievals of the joined tables in the following order: t1,t2,t3. A pushed down predicate are attached to the table which it pushed to, at the field join_tab-&gt;cond. When executing a nested loop of level k the function runs through the rows of 'join_tab' and for each row checks the pushed condition attached to the table. If it is false the function moves to the next row of the table. If the condition is true the function recursively executes (n-k-1) remaining embedded nested loops. The situation becomes more complicated if outer joins are involved in the execution plan. In this case the pushed down predicates can be checked only at certain conditions. Suppose for the query <div class="fragment"><pre class="fragment">      SELECT * FROM t1 LEFT <a class="code" href="classJOIN.html">JOIN</a> (t2,t3) ON t3.a=t1.a
      WHERE t1&gt;2 AND (t2.b&gt;5 OR t2.b IS NULL)
</pre></div> the optimizer has chosen a plan with the table order t1,t2,t3. The predicate P1=t1&gt;2 will be pushed down to the table t1, while the predicate P2=(t2.b&gt;5 OR t2.b IS NULL) will be attached to the table t2. But the second predicate can not be unconditionally tested right after a row from t2 has been read. This can be done only after the first row with t3.a=t1.a has been encountered. Thus, the second predicate P2 is supplied with a guarded value that are stored in the field 'found' of the first inner table for the outer join (table t2). When the first row with t3.a=t1.a for the current row of table t1 appears, the value becomes true. For now on the predicate is evaluated immediately after the row of table t2 has been read. When the first row with t3.a=t1.a has been encountered all conditions attached to the inner tables t2,t3 must be evaluated. Only when all of them are true the row is sent to the output stream. If not, the function returns to the lowest nest level that has a false attached condition. The predicates from on expressions are also pushed down. If in the the above example the on expression were (t3.a=t1.a AND t2.a=t1.a), then t1.a=t2.a would be pushed down to table t2, and without any guard. If after the run through all rows of table t2, the first inner table for the outer join operation, it turns out that no matches are found for the current row of t1, then current row from table t1 is complemented by nulls for t2 and t3. Then the pushed down predicates are checked for the composed row almost in the same way as it had been done for the first row with a match. The only difference is the predicates from on expressions are not checked.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>IMPLEMENTATION</b> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The function forms output rows for a current partial join of k tables tables recursively. For each partial join record ending with a certain row from join_tab it calls sub_select that builds all possible matching tails from the result set. To be able check predicates conditionally items of the class <a class="el" href="classItem__func__trig__cond.html">Item_func_trig_cond</a> are employed. An object of this class is constructed from an item of class COND and a pointer to a guarding boolean variable. When the value of the guard variable is true the value of the object is the same as the value of the predicate, otherwise it's just returns true. To carry out a return to a nested loop level of join table t the pointer to t is remembered in the field 'return_tab' of the join structure. Consider the following query: <div class="fragment"><pre class="fragment">        SELECT * FROM t1,
                      LEFT <a class="code" href="classJOIN.html">JOIN</a>
                      (t2, t3 LEFT <a class="code" href="classJOIN.html">JOIN</a> (t4,t5) ON t5.a=t3.a)
                      ON t4.a=t2.a
           WHERE (t2.b=5 OR t2.b IS NULL) AND (t4.b=2 OR t4.b IS NULL)
</pre></div> Suppose the chosen execution plan dictates the order t1,t2,t3,t4,t5 and suppose for a given joined rows from tables t1,t2,t3 there are no rows in the result set yet. When first row from t5 that satisfies the on condition t5.a=t3.a is found, the pushed down predicate t4.b=2 OR t4.b IS NULL becomes 'activated', as well the predicate t4.a=t2.a. But the predicate (t2.b=5 OR t2.b IS NULL) can not be checked until t4.a=t2.a becomes true. In order not to re-evaluate the predicates that were already evaluated as attached pushed down predicates, a pointer to the the first most inner unmatched table is maintained in join_tab-&gt;first_unmatched. Thus, when the first row from t5 with t5.a=t3.a is found this pointer for t5 is changed from t4 to t2.</dd></dl>
<dl class="user"><dt><b></b></dt><dd><b>STRUCTURE</b> <b>NOTES</b> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>join_tab-&gt;first_unmatched points always backwards to the first inner table of the embedding nested join, if any.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>pointer to the structure providing all context info for the query </td></tr>
    <tr><td class="paramname">join_tab</td><td>the first next table of the execution plan to be retrieved </td></tr>
    <tr><td class="paramname">end_records</td><td>true when we need to perform final steps of retrival</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>return one of enum_nested_loop_state, except NESTED_LOOP_NO_MORE_ROWS. </dd></dl>

</div>
</div>
<a class="anchor" id="gacb3f583dd255c4288df81b3ab1628a1c"></a><!-- doxytag: member="sql_executor.cc::sub_select_op" ref="gacb3f583dd255c4288df81b3ab1628a1c" args="(JOIN *join, JOIN_TAB *join_tab, bool end_of_records)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_nested_loop_state <a class="el" href="group__Query__Executor.html#gacb3f583dd255c4288df81b3ab1628a1c">sub_select_op</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>end_of_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accumulate full or partial join result in operation and send operation's result further. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>pointer to the structure providing all context info for the query </td></tr>
    <tr><td class="paramname">join_tab</td><td>the JOIN_TAB object to which the operation is attached </td></tr>
    <tr><td class="paramname">end_records</td><td>TRUE &lt;=&gt; all records were accumulated, send them further</td></tr>
  </table>
  </dd>
</dl>
<p>This function accumulates records, one by one, in QEP operation's buffer by calling op-&gt;put_record(). When there is no more records to save, in this case the end_of_records argument == true, function tells QEP operation to send records further by calling op-&gt;send_records(). When all records are sent this function passes 'end_of_records' signal further by calling <a class="el" href="group__Query__Executor.html#gaf5c3a10fb1e79511b38573124e0ec107">sub_select()</a> with end_of_records argument set to true. After that op-&gt;end_send() is called to tell QEP operation that it could end internal buffer scan.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is not expected to be called when dynamic range scan is used to scan join_tab because join cache is disabled for such scan and range scans aren't used for tmp tables. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>setup_join_buffering For caches the function implements the algorithmic schema for both Blocked Nested Loop Join and Batched <a class="el" href="classKey.html">Key</a> Access Join. The difference can be seen only at the level of of the implementation of the put_record and send_records virtual methods for the cache object associated with the join_tab.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>return one of enum_nested_loop_state. </dd></dl>

</div>
</div>
<a class="anchor" id="ga62fae26d0e5c875d2992257ce44e4d38"></a><!-- doxytag: member="st_join_table::use_order" ref="ga62fae26d0e5c875d2992257ce44e4d38" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Executor.html#ga62fae26d0e5c875d2992257ce44e4d38">JOIN_TAB::use_order</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Use ordering provided by chosen index? </p>
<p>Check if access to this JOIN_TAB has to retrieve rows in sorted order as defined by the ordered index used to access this table. </p>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:47 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
