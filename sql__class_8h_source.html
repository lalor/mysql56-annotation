<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: sql_class.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">sql_class.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights</span>
<a name="l00002"></a>00002 <span class="comment">   reserved.</span>
<a name="l00003"></a>00003 <span class="comment"></span>
<a name="l00004"></a>00004 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00005"></a>00005 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00006"></a>00006 <span class="comment">   the Free Software Foundation; version 2 of the License.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00009"></a>00009 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00010"></a>00010 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00011"></a>00011 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00014"></a>00014 <span class="comment">   along with this program; if not, write to the Free Software</span>
<a name="l00015"></a>00015 <span class="comment">   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#ifndef SQL_CLASS_INCLUDED</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define SQL_CLASS_INCLUDED</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span>
<a name="l00020"></a>00020 <span class="comment">/* Classes in mysql */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;my_global.h&quot;</span>                          <span class="comment">/* NO_EMBEDDED_ACCESS_CHECKS */</span>
<a name="l00023"></a>00023 <span class="preprocessor">#ifdef MYSQL_SERVER</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#include &quot;unireg.h&quot;</span>                    <span class="comment">// REQUIRED: for other includes</span>
<a name="l00025"></a>00025 <span class="preprocessor">#endif</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#include &quot;<a class="code" href="sql__const_8h.html">sql_const.h</a>&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;mysql/plugin_audit.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;log.h&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;rpl_tblmap.h&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;mdl.h&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;sql_locale.h&quot;</span>                         <span class="comment">/* my_locale_st */</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;sql_profile.h&quot;</span>                   <span class="comment">/* PROFILING */</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;scheduler.h&quot;</span>                     <span class="comment">/* thd_scheduler */</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;protocol.h&quot;</span>             <span class="comment">/* Protocol_text, Protocol_binary */</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;violite.h&quot;</span>              <span class="comment">/* vio_is_connected */</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;thr_lock.h&quot;</span>             <span class="comment">/* thr_lock_type, THR_LOCK_DATA,</span>
<a name="l00037"></a>00037 <span class="comment">                                     THR_LOCK_INFO */</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;<a class="code" href="opt__trace__context_8h.html">opt_trace_context.h</a>&quot;</span>    <span class="comment">/* Opt_trace_context */</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;rpl_gtid.h&quot;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;sql_digest_stream.h&quot;</span>            <span class="comment">// sql_digest_state</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;mysql/psi/mysql_stage.h&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;mysql/psi/mysql_statement.h&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &lt;mysql/psi/mysql_idle.h&gt;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &lt;mysql_com_server.h&gt;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="sql__data__change_8h.html">sql_data_change.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;my_atomic.h&quot;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="preprocessor">#define FLAGSTR(V,F) ((V)&amp;(F)?#F&quot; &quot;:&quot;&quot;)</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00056"></a>00056 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l00057"></a>00057 <span class="keyword">const</span> <span class="keywordtype">char</span> *set_thd_proc_info(<span class="keywordtype">void</span> *thd_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *info,
<a name="l00058"></a>00058                               <span class="keyword">const</span> <span class="keywordtype">char</span> *calling_func,
<a name="l00059"></a>00059                               <span class="keyword">const</span> <span class="keywordtype">char</span> *calling_file,
<a name="l00060"></a>00060                               <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> calling_line);
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="preprocessor">#define thd_proc_info(thd, msg) \</span>
<a name="l00063"></a>00063 <span class="preprocessor">  set_thd_proc_info(thd, msg, __func__, __FILE__, __LINE__)</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span>
<a name="l00065"></a>00065 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l00066"></a>00066 <span class="keywordtype">void</span> set_thd_stage_info(<span class="keywordtype">void</span> *thd,
<a name="l00067"></a>00067                         <span class="keyword">const</span> PSI_stage_info *new_stage,
<a name="l00068"></a>00068                         PSI_stage_info *old_stage,
<a name="l00069"></a>00069                         <span class="keyword">const</span> <span class="keywordtype">char</span> *calling_func,
<a name="l00070"></a>00070                         <span class="keyword">const</span> <span class="keywordtype">char</span> *calling_file,
<a name="l00071"></a>00071                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> calling_line);
<a name="l00072"></a>00072                         
<a name="l00073"></a>00073 <span class="preprocessor">#define THD_STAGE_INFO(thd, stage) \</span>
<a name="l00074"></a>00074 <span class="preprocessor">  (thd)-&gt;enter_stage(&amp; stage, NULL, __func__, __FILE__, __LINE__)</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>
<a name="l00076"></a>00076 <span class="keyword">class </span><a class="code" href="classReprepare__observer.html">Reprepare_observer</a>;
<a name="l00077"></a>00077 <span class="keyword">class </span><a class="code" href="classRelay__log__info.html">Relay_log_info</a>;
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="keyword">class </span><a class="code" href="classQuery__log__event.html">Query_log_event</a>;
<a name="l00080"></a>00080 <span class="keyword">class </span><a class="code" href="classLoad__log__event.html">Load_log_event</a>;
<a name="l00081"></a>00081 <span class="keyword">class </span><a class="code" href="classsp__rcontext.html">sp_rcontext</a>;
<a name="l00082"></a>00082 <span class="keyword">class </span><a class="code" href="classsp__cache.html">sp_cache</a>;
<a name="l00083"></a>00083 <span class="keyword">class </span>Parser_state;
<a name="l00084"></a>00084 <span class="keyword">class </span><a class="code" href="classRows__log__event.html">Rows_log_event</a>;
<a name="l00085"></a>00085 <span class="keyword">class </span><a class="code" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a>;
<a name="l00086"></a>00086 <span class="keyword">class </span><a class="code" href="classUser__level__lock.html">User_level_lock</a>;
<a name="l00087"></a>00087 <span class="keyword">class </span>user_var_entry;
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="keyword">enum</span> enum_ha_read_modes { RFIRST, RNEXT, RPREV, RLAST, RKEY, RNEXT_SAME };
<a name="l00090"></a>00090 
<a name="l00091"></a>00091 <span class="keyword">enum</span> enum_delay_key_write { DELAY_KEY_WRITE_NONE, DELAY_KEY_WRITE_ON,
<a name="l00092"></a>00092                             DELAY_KEY_WRITE_ALL };
<a name="l00093"></a>00093 <span class="keyword">enum</span> enum_slave_exec_mode { SLAVE_EXEC_MODE_STRICT,
<a name="l00094"></a>00094                             SLAVE_EXEC_MODE_IDEMPOTENT,
<a name="l00095"></a>00095                             SLAVE_EXEC_MODE_LAST_BIT };
<a name="l00096"></a>00096 <span class="keyword">enum</span> enum_slave_type_conversions { SLAVE_TYPE_CONVERSIONS_ALL_LOSSY,
<a name="l00097"></a>00097                                    SLAVE_TYPE_CONVERSIONS_ALL_NON_LOSSY,
<a name="l00098"></a>00098                                    SLAVE_TYPE_CONVERSIONS_ALL_UNSIGNED,
<a name="l00099"></a>00099                                    SLAVE_TYPE_CONVERSIONS_ALL_SIGNED};
<a name="l00100"></a>00100 <span class="keyword">enum</span> enum_slave_rows_search_algorithms { SLAVE_ROWS_TABLE_SCAN = (1U &lt;&lt; 0),
<a name="l00101"></a>00101                                          SLAVE_ROWS_INDEX_SCAN = (1U &lt;&lt; 1),
<a name="l00102"></a>00102                                          SLAVE_ROWS_HASH_SCAN  = (1U &lt;&lt; 2)};
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="keyword">enum</span> enum_mark_columns
<a name="l00105"></a>00105 { MARK_COLUMNS_NONE, MARK_COLUMNS_READ, MARK_COLUMNS_WRITE};
<a name="l00106"></a>00106 <span class="keyword">enum</span> enum_filetype { FILETYPE_CSV, FILETYPE_XML };
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="comment">/* Bits for different SQL modes modes (including ANSI mode) */</span>
<a name="l00109"></a>00109 <span class="preprocessor">#define MODE_REAL_AS_FLOAT              1</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="preprocessor">#define MODE_PIPES_AS_CONCAT            2</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span><span class="preprocessor">#define MODE_ANSI_QUOTES                4</span>
<a name="l00112"></a>00112 <span class="preprocessor"></span><span class="preprocessor">#define MODE_IGNORE_SPACE               8</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NOT_USED                   16</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#define MODE_ONLY_FULL_GROUP_BY         32</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_UNSIGNED_SUBTRACTION    64</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_DIR_IN_CREATE           128</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span><span class="preprocessor">#define MODE_POSTGRESQL                 256</span>
<a name="l00118"></a>00118 <span class="preprocessor"></span><span class="preprocessor">#define MODE_ORACLE                     512</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor">#define MODE_MSSQL                      1024</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span><span class="preprocessor">#define MODE_DB2                        2048</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span><span class="preprocessor">#define MODE_MAXDB                      4096</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_KEY_OPTIONS             8192</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_TABLE_OPTIONS           16384</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_FIELD_OPTIONS           32768</span>
<a name="l00125"></a>00125 <span class="preprocessor"></span><span class="preprocessor">#define MODE_MYSQL323                   65536L</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="preprocessor">#define MODE_MYSQL40                    (MODE_MYSQL323*2)</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="preprocessor">#define MODE_ANSI                       (MODE_MYSQL40*2)</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_AUTO_VALUE_ON_ZERO      (MODE_ANSI*2)</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_BACKSLASH_ESCAPES       (MODE_NO_AUTO_VALUE_ON_ZERO*2)</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span><span class="preprocessor">#define MODE_STRICT_TRANS_TABLES        (MODE_NO_BACKSLASH_ESCAPES*2)</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span><span class="preprocessor">#define MODE_STRICT_ALL_TABLES          (MODE_STRICT_TRANS_TABLES*2)</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_ZERO_IN_DATE            (MODE_STRICT_ALL_TABLES*2)</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_ZERO_DATE               (MODE_NO_ZERO_IN_DATE*2)</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#define MODE_INVALID_DATES              (MODE_NO_ZERO_DATE*2)</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span><span class="preprocessor">#define MODE_ERROR_FOR_DIVISION_BY_ZERO (MODE_INVALID_DATES*2)</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span><span class="preprocessor">#define MODE_TRADITIONAL                (MODE_ERROR_FOR_DIVISION_BY_ZERO*2)</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_AUTO_CREATE_USER        (MODE_TRADITIONAL*2)</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span><span class="preprocessor">#define MODE_HIGH_NOT_PRECEDENCE        (MODE_NO_AUTO_CREATE_USER*2)</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span><span class="preprocessor">#define MODE_NO_ENGINE_SUBSTITUTION     (MODE_HIGH_NOT_PRECEDENCE*2)</span>
<a name="l00140"></a>00140 <span class="preprocessor"></span><span class="preprocessor">#define MODE_PAD_CHAR_TO_FULL_LENGTH    (ULL(1) &lt;&lt; 31)</span>
<a name="l00141"></a>00141 <span class="preprocessor"></span>
<a name="l00142"></a>00142 <span class="keyword">extern</span> <span class="keywordtype">char</span> internal_table_name[2];
<a name="l00143"></a>00143 <span class="keyword">extern</span> <span class="keywordtype">char</span> empty_c_string[1];
<a name="l00144"></a>00144 <span class="keyword">extern</span> LEX_STRING EMPTY_STR;
<a name="l00145"></a>00145 <span class="keyword">extern</span> LEX_STRING NULL_STR;
<a name="l00146"></a>00146 <span class="keyword">extern</span> MYSQL_PLUGIN_IMPORT <span class="keyword">const</span> <span class="keywordtype">char</span> **errmesg;
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <span class="keyword">volatile</span> shutdown_in_progress;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> LEX_STRING * thd_query_string (MYSQL_THD thd);
<a name="l00151"></a>00151 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">char</span> **thd_query(MYSQL_THD thd);
<a name="l00152"></a>00152 
<a name="l00157"></a><a class="code" href="classCSET__STRING.html">00157</a> <span class="keyword">class </span><a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a>
<a name="l00158"></a>00158 {
<a name="l00159"></a>00159 <span class="keyword">private</span>:
<a name="l00160"></a>00160   LEX_STRING string;
<a name="l00161"></a>00161   <span class="keyword">const</span> CHARSET_INFO *cs;
<a name="l00162"></a>00162 <span class="keyword">public</span>:
<a name="l00163"></a>00163   <a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a>() : cs(&amp;my_charset_bin)
<a name="l00164"></a>00164   {
<a name="l00165"></a>00165     <span class="keywordtype">string</span>.str= NULL;
<a name="l00166"></a>00166     <span class="keywordtype">string</span>.length= 0;
<a name="l00167"></a>00167   }
<a name="l00168"></a>00168   <a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a>(<span class="keywordtype">char</span> *str_arg, <span class="keywordtype">size_t</span> length_arg, <span class="keyword">const</span> CHARSET_INFO *cs_arg) :
<a name="l00169"></a>00169   cs(cs_arg)
<a name="l00170"></a>00170   {
<a name="l00171"></a>00171     DBUG_ASSERT(cs_arg != NULL);
<a name="l00172"></a>00172     <span class="keywordtype">string</span>.str= str_arg;
<a name="l00173"></a>00173     <span class="keywordtype">string</span>.length= length_arg;
<a name="l00174"></a>00174   }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176   <span class="keyword">inline</span> <span class="keywordtype">char</span> *str()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keywordtype">string</span>.str; }
<a name="l00177"></a>00177   <span class="keyword">inline</span> <span class="keywordtype">size_t</span> length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keywordtype">string</span>.length; }
<a name="l00178"></a>00178   <span class="keyword">const</span> CHARSET_INFO *charset()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cs; }
<a name="l00179"></a>00179 
<a name="l00180"></a>00180   <span class="keyword">friend</span> LEX_STRING * thd_query_string (MYSQL_THD thd);
<a name="l00181"></a>00181   <span class="keyword">friend</span> <span class="keywordtype">char</span> **thd_query(MYSQL_THD thd);
<a name="l00182"></a>00182 };
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="preprocessor">#define TC_LOG_PAGE_SIZE   8192</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span><span class="preprocessor">#define TC_LOG_MIN_SIZE    (3*TC_LOG_PAGE_SIZE)</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>
<a name="l00188"></a>00188 <span class="preprocessor">#define TC_HEURISTIC_RECOVER_COMMIT   1</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span><span class="preprocessor">#define TC_HEURISTIC_RECOVER_ROLLBACK 2</span>
<a name="l00190"></a>00190 <span class="preprocessor"></span><span class="keyword">extern</span> ulong tc_heuristic_recover;
<a name="l00191"></a>00191 
<a name="l00192"></a><a class="code" href="structst__user__var__events.html">00192</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__user__var__events.html">st_user_var_events</a>
<a name="l00193"></a>00193 {
<a name="l00194"></a>00194   user_var_entry *user_var_event;
<a name="l00195"></a>00195   <span class="keywordtype">char</span> *value;
<a name="l00196"></a>00196   ulong length;
<a name="l00197"></a>00197   Item_result type;
<a name="l00198"></a>00198   uint charset_number;
<a name="l00199"></a>00199   <span class="keywordtype">bool</span> unsigned_flag;
<a name="l00200"></a>00200 } <a class="code" href="structst__user__var__events.html">BINLOG_USER_VAR_EVENT</a>;
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 
<a name="l00203"></a><a class="code" href="classKey__part__spec.html">00203</a> <span class="keyword">class </span><a class="code" href="classKey__part__spec.html">Key_part_spec</a> :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a> {
<a name="l00204"></a>00204 <span class="keyword">public</span>:
<a name="l00205"></a>00205   LEX_STRING field_name;
<a name="l00206"></a>00206   uint length;
<a name="l00207"></a>00207   <a class="code" href="classKey__part__spec.html">Key_part_spec</a>(<span class="keyword">const</span> LEX_STRING &amp;name, uint len)
<a name="l00208"></a>00208     : field_name(name), length(len)
<a name="l00209"></a>00209   {}
<a name="l00210"></a>00210   <a class="code" href="classKey__part__spec.html">Key_part_spec</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">size_t</span> name_len, uint len)
<a name="l00211"></a>00211     : length(len)
<a name="l00212"></a>00212   { field_name.str= (<span class="keywordtype">char</span> *)name; field_name.length= name_len; }
<a name="l00213"></a>00213   <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classKey__part__spec.html">Key_part_spec</a>&amp; other) <span class="keyword">const</span>;
<a name="l00223"></a><a class="code" href="classKey__part__spec.html#a6005ead9aa320c2222e8eba60ddf70fe">00223</a>   <a class="code" href="classKey__part__spec.html">Key_part_spec</a> *<a class="code" href="classKey__part__spec.html#a6005ead9aa320c2222e8eba60ddf70fe">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l00224"></a>00224 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classKey__part__spec.html">Key_part_spec</a>(*<span class="keyword">this</span>); }
<a name="l00225"></a>00225 };
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 
<a name="l00228"></a><a class="code" href="classAlter__drop.html">00228</a> <span class="keyword">class </span><a class="code" href="classAlter__drop.html">Alter_drop</a> :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a> {
<a name="l00229"></a>00229 <span class="keyword">public</span>:
<a name="l00230"></a>00230   <span class="keyword">enum</span> drop_type {<a class="code" href="structst__key.html">KEY</a>, COLUMN, FOREIGN_KEY };
<a name="l00231"></a>00231   <span class="keyword">const</span> <span class="keywordtype">char</span> *name;
<a name="l00232"></a>00232   <span class="keyword">enum</span> drop_type type;
<a name="l00233"></a>00233   <a class="code" href="classAlter__drop.html">Alter_drop</a>(<span class="keyword">enum</span> drop_type par_type,<span class="keyword">const</span> <span class="keywordtype">char</span> *par_name)
<a name="l00234"></a>00234     :name(par_name), type(par_type)
<a name="l00235"></a>00235   {
<a name="l00236"></a>00236     DBUG_ASSERT(par_name != NULL);
<a name="l00237"></a>00237   }
<a name="l00242"></a><a class="code" href="classAlter__drop.html#a51f49d076746707326e72c1398f34488">00242</a>   <a class="code" href="classAlter__drop.html">Alter_drop</a> *<a class="code" href="classAlter__drop.html#a51f49d076746707326e72c1398f34488">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l00243"></a>00243 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classAlter__drop.html">Alter_drop</a>(*<span class="keyword">this</span>); }
<a name="l00244"></a>00244 };
<a name="l00245"></a>00245 
<a name="l00246"></a>00246 
<a name="l00247"></a><a class="code" href="classAlter__column.html">00247</a> <span class="keyword">class </span><a class="code" href="classAlter__column.html">Alter_column</a> :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a> {
<a name="l00248"></a>00248 <span class="keyword">public</span>:
<a name="l00249"></a>00249   <span class="keyword">const</span> <span class="keywordtype">char</span> *name;
<a name="l00250"></a>00250   <a class="code" href="classItem.html">Item</a> *def;
<a name="l00251"></a>00251   <a class="code" href="classAlter__column.html">Alter_column</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *par_name,<a class="code" href="classItem.html">Item</a> *literal)
<a name="l00252"></a>00252     :name(par_name), def(literal) {}
<a name="l00257"></a><a class="code" href="classAlter__column.html#a6540420683f0f8efd8ca0405333c561a">00257</a>   <a class="code" href="classAlter__column.html">Alter_column</a> *<a class="code" href="classAlter__column.html#a6540420683f0f8efd8ca0405333c561a">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l00258"></a>00258 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classAlter__column.html">Alter_column</a>(*<span class="keyword">this</span>); }
<a name="l00259"></a>00259 };
<a name="l00260"></a>00260 
<a name="l00261"></a>00261 
<a name="l00262"></a><a class="code" href="classKey.html">00262</a> <span class="keyword">class </span><a class="code" href="classKey.html">Key</a> :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a> {
<a name="l00263"></a>00263 <span class="keyword">public</span>:
<a name="l00264"></a>00264   <span class="keyword">enum</span> Keytype { PRIMARY, UNIQUE, MULTIPLE, FULLTEXT, SPATIAL, FOREIGN_KEY};
<a name="l00265"></a>00265   <span class="keyword">enum</span> Keytype type;
<a name="l00266"></a>00266   <a class="code" href="structst__key__create__information.html">KEY_CREATE_INFO</a> key_create_info;
<a name="l00267"></a>00267   <a class="code" href="classList.html">List&lt;Key_part_spec&gt;</a> columns;
<a name="l00268"></a>00268   LEX_STRING name;
<a name="l00269"></a>00269   <span class="keywordtype">bool</span> generated;
<a name="l00270"></a>00270 
<a name="l00271"></a>00271   <a class="code" href="classKey.html">Key</a>(<span class="keyword">enum</span> Keytype type_par, <span class="keyword">const</span> LEX_STRING &amp;name_arg,
<a name="l00272"></a>00272       <a class="code" href="structst__key__create__information.html">KEY_CREATE_INFO</a> *key_info_arg,
<a name="l00273"></a>00273       <span class="keywordtype">bool</span> generated_arg, <a class="code" href="classList.html">List&lt;Key_part_spec&gt;</a> &amp;cols)
<a name="l00274"></a>00274     :type(type_par), key_create_info(*key_info_arg), columns(cols),
<a name="l00275"></a>00275     name(name_arg), generated(generated_arg)
<a name="l00276"></a>00276   {}
<a name="l00277"></a>00277   <a class="code" href="classKey.html">Key</a>(<span class="keyword">enum</span> Keytype type_par, <span class="keyword">const</span> <span class="keywordtype">char</span> *name_arg, <span class="keywordtype">size_t</span> name_len_arg,
<a name="l00278"></a>00278       <a class="code" href="structst__key__create__information.html">KEY_CREATE_INFO</a> *key_info_arg, <span class="keywordtype">bool</span> generated_arg,
<a name="l00279"></a>00279       <a class="code" href="classList.html">List&lt;Key_part_spec&gt;</a> &amp;cols)
<a name="l00280"></a>00280     :type(type_par), key_create_info(*key_info_arg), columns(cols),
<a name="l00281"></a>00281     generated(generated_arg)
<a name="l00282"></a>00282   {
<a name="l00283"></a>00283     name.str= (<span class="keywordtype">char</span> *)name_arg;
<a name="l00284"></a>00284     name.length= name_len_arg;
<a name="l00285"></a>00285   }
<a name="l00286"></a>00286   <a class="code" href="classKey.html">Key</a>(<span class="keyword">const</span> <a class="code" href="classKey.html">Key</a> &amp;rhs, MEM_ROOT *mem_root);
<a name="l00287"></a>00287   <span class="keyword">virtual</span> ~<a class="code" href="classKey.html">Key</a>() {}
<a name="l00288"></a>00288   <span class="comment">/* Equality comparison of keys (ignoring name) */</span>
<a name="l00289"></a>00289   <span class="keyword">friend</span> <span class="keywordtype">bool</span> foreign_key_prefix(<a class="code" href="classKey.html">Key</a> *a, <a class="code" href="classKey.html">Key</a> *b);
<a name="l00294"></a><a class="code" href="classKey.html#ae6b8dae15736d833321ec1c1275a0a74">00294</a>   <span class="keyword">virtual</span> <a class="code" href="classKey.html">Key</a> *<a class="code" href="classKey.html#ae6b8dae15736d833321ec1c1275a0a74">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l00295"></a>00295 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classKey.html">Key</a>(*<span class="keyword">this</span>, mem_root); }
<a name="l00296"></a>00296 };
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="keyword">class </span>Table_ident;
<a name="l00299"></a>00299 
<a name="l00300"></a><a class="code" href="classForeign__key.html">00300</a> <span class="keyword">class </span><a class="code" href="classForeign__key.html">Foreign_key</a>: <span class="keyword">public</span> <a class="code" href="classKey.html">Key</a> {
<a name="l00301"></a>00301 <span class="keyword">public</span>:
<a name="l00302"></a>00302   <span class="keyword">enum</span> fk_match_opt { FK_MATCH_UNDEF, FK_MATCH_FULL,
<a name="l00303"></a>00303                       FK_MATCH_PARTIAL, FK_MATCH_SIMPLE};
<a name="l00304"></a>00304   <span class="keyword">enum</span> fk_option { FK_OPTION_UNDEF, FK_OPTION_RESTRICT, FK_OPTION_CASCADE,
<a name="l00305"></a>00305                    FK_OPTION_SET_NULL, FK_OPTION_NO_ACTION, FK_OPTION_DEFAULT};
<a name="l00306"></a>00306 
<a name="l00307"></a>00307   LEX_STRING ref_db;
<a name="l00308"></a>00308   LEX_STRING ref_table;
<a name="l00309"></a>00309   <a class="code" href="classList.html">List&lt;Key_part_spec&gt;</a> ref_columns;
<a name="l00310"></a>00310   uint delete_opt, update_opt, match_opt;
<a name="l00311"></a>00311   <a class="code" href="classForeign__key.html">Foreign_key</a>(<span class="keyword">const</span> LEX_STRING &amp;name_arg, <a class="code" href="classList.html">List&lt;Key_part_spec&gt;</a> &amp;cols,
<a name="l00312"></a>00312               <span class="keyword">const</span> LEX_STRING &amp;ref_db_arg, <span class="keyword">const</span> LEX_STRING &amp;ref_table_arg,
<a name="l00313"></a>00313               <a class="code" href="classList.html">List&lt;Key_part_spec&gt;</a> &amp;ref_cols,
<a name="l00314"></a>00314               uint delete_opt_arg, uint update_opt_arg, uint match_opt_arg)
<a name="l00315"></a>00315     :<a class="code" href="classKey.html">Key</a>(FOREIGN_KEY, name_arg, &amp;default_key_create_info, 0, cols),
<a name="l00316"></a>00316     ref_db(ref_db_arg), ref_table(ref_table_arg), ref_columns(ref_cols),
<a name="l00317"></a>00317     delete_opt(delete_opt_arg), update_opt(update_opt_arg),
<a name="l00318"></a>00318     match_opt(match_opt_arg)
<a name="l00319"></a>00319   {
<a name="l00320"></a>00320     <span class="comment">// We don&#39;t check for duplicate FKs.</span>
<a name="l00321"></a>00321     key_create_info.<a class="code" href="structst__key__create__information.html#afb3cc6d51dba1814dff322bb7a771a99">check_for_duplicate_indexes</a>= <span class="keyword">false</span>;
<a name="l00322"></a>00322   }
<a name="l00323"></a>00323   <a class="code" href="classForeign__key.html">Foreign_key</a>(<span class="keyword">const</span> <a class="code" href="classForeign__key.html">Foreign_key</a> &amp;rhs, MEM_ROOT *mem_root);
<a name="l00328"></a><a class="code" href="classForeign__key.html#aa38502182b0b1d23f5df1c7daf1ca3e6">00328</a>   <span class="keyword">virtual</span> <a class="code" href="classKey.html">Key</a> *<a class="code" href="classForeign__key.html#aa38502182b0b1d23f5df1c7daf1ca3e6">clone</a>(MEM_ROOT *mem_root)<span class="keyword"> const</span>
<a name="l00329"></a>00329 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> (mem_root) <a class="code" href="classForeign__key.html">Foreign_key</a>(*<span class="keyword">this</span>, mem_root); }
<a name="l00330"></a>00330 };
<a name="l00331"></a>00331 
<a name="l00332"></a><a class="code" href="structst__mysql__lock.html">00332</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__mysql__lock.html">st_mysql_lock</a>
<a name="l00333"></a>00333 {
<a name="l00334"></a>00334   <a class="code" href="structTABLE.html">TABLE</a> **table;
<a name="l00335"></a>00335   uint table_count,lock_count;
<a name="l00336"></a>00336   THR_LOCK_DATA **locks;
<a name="l00337"></a>00337 } <a class="code" href="structst__mysql__lock.html">MYSQL_LOCK</a>;
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 
<a name="l00340"></a><a class="code" href="classLEX__COLUMN.html">00340</a> <span class="keyword">class </span><a class="code" href="classLEX__COLUMN.html">LEX_COLUMN</a> : <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l00341"></a>00341 {
<a name="l00342"></a>00342 <span class="keyword">public</span>:
<a name="l00343"></a>00343   <a class="code" href="classString.html">String</a> column;
<a name="l00344"></a>00344   uint rights;
<a name="l00345"></a>00345   <a class="code" href="classLEX__COLUMN.html">LEX_COLUMN</a> (<span class="keyword">const</span> <a class="code" href="classString.html">String</a>&amp; x,<span class="keyword">const</span>  uint&amp; y ): column (x),rights (y) {}
<a name="l00346"></a>00346 };
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 <span class="keyword">class </span><a class="code" href="classMY__LOCALE.html">MY_LOCALE</a>;
<a name="l00349"></a>00349 
<a name="l00354"></a>00354 <span class="keyword">struct </span><a class="code" href="structQuery__cache__block.html">Query_cache_block</a>;
<a name="l00355"></a>00355 
<a name="l00356"></a><a class="code" href="structQuery__cache__tls.html">00356</a> <span class="keyword">struct </span><a class="code" href="structQuery__cache__tls.html">Query_cache_tls</a>
<a name="l00357"></a>00357 {
<a name="l00358"></a>00358   <span class="comment">/*</span>
<a name="l00359"></a>00359 <span class="comment">    &#39;first_query_block&#39; should be accessed only via query cache</span>
<a name="l00360"></a>00360 <span class="comment">    functions and methods to maintain proper locking.</span>
<a name="l00361"></a>00361 <span class="comment">  */</span>
<a name="l00362"></a>00362   <a class="code" href="structQuery__cache__block.html">Query_cache_block</a> *first_query_block;
<a name="l00363"></a>00363   <span class="keywordtype">void</span> set_first_query_block(<a class="code" href="structQuery__cache__block.html">Query_cache_block</a> *first_query_block_arg)
<a name="l00364"></a>00364   {
<a name="l00365"></a>00365     first_query_block= first_query_block_arg;
<a name="l00366"></a>00366   }
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <a class="code" href="structQuery__cache__tls.html">Query_cache_tls</a>() :first_query_block(NULL) {}
<a name="l00369"></a>00369 };
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="comment">/* SIGNAL / RESIGNAL / GET DIAGNOSTICS */</span>
<a name="l00372"></a>00372 
<a name="l00377"></a>00377 <span class="keyword">typedef</span> <span class="keyword">enum</span> enum_diag_condition_item_name
<a name="l00378"></a>00378 {
<a name="l00379"></a>00379   <span class="comment">/*</span>
<a name="l00380"></a>00380 <span class="comment">    Conditions that can be set by the user (SIGNAL/RESIGNAL),</span>
<a name="l00381"></a>00381 <span class="comment">    and by the server implementation.</span>
<a name="l00382"></a>00382 <span class="comment">  */</span>
<a name="l00383"></a>00383 
<a name="l00384"></a>00384   DIAG_CLASS_ORIGIN= 0,
<a name="l00385"></a>00385   FIRST_DIAG_SET_PROPERTY= DIAG_CLASS_ORIGIN,
<a name="l00386"></a>00386   DIAG_SUBCLASS_ORIGIN= 1,
<a name="l00387"></a>00387   DIAG_CONSTRAINT_CATALOG= 2,
<a name="l00388"></a>00388   DIAG_CONSTRAINT_SCHEMA= 3,
<a name="l00389"></a>00389   DIAG_CONSTRAINT_NAME= 4,
<a name="l00390"></a>00390   DIAG_CATALOG_NAME= 5,
<a name="l00391"></a>00391   DIAG_SCHEMA_NAME= 6,
<a name="l00392"></a>00392   DIAG_TABLE_NAME= 7,
<a name="l00393"></a>00393   DIAG_COLUMN_NAME= 8,
<a name="l00394"></a>00394   DIAG_CURSOR_NAME= 9,
<a name="l00395"></a>00395   DIAG_MESSAGE_TEXT= 10,
<a name="l00396"></a>00396   DIAG_MYSQL_ERRNO= 11,
<a name="l00397"></a>00397   LAST_DIAG_SET_PROPERTY= DIAG_MYSQL_ERRNO
<a name="l00398"></a>00398 } Diag_condition_item_name;
<a name="l00399"></a>00399 
<a name="l00404"></a>00404 <span class="keyword">extern</span> <span class="keyword">const</span> LEX_STRING Diag_condition_item_names[];
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="preprocessor">#include &quot;sql_lex.h&quot;</span>                            <span class="comment">/* Must be here */</span>
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 <span class="keyword">extern</span> LEX_CSTRING sql_statement_names[(uint) SQLCOM_END + 1];
<a name="l00409"></a>00409 <span class="keyword">class </span><a class="code" href="classDelayed__insert.html">Delayed_insert</a>;
<a name="l00410"></a>00410 <span class="keyword">class </span>select_result;
<a name="l00411"></a>00411 <span class="keyword">class </span><a class="code" href="classTime__zone.html">Time_zone</a>;
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 <span class="preprocessor">#define THD_SENTRY_MAGIC 0xfeedd1ff</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span><span class="preprocessor">#define THD_SENTRY_GONE  0xdeadbeef</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>
<a name="l00416"></a>00416 <span class="preprocessor">#define THD_CHECK_SENTRY(thd) DBUG_ASSERT(thd-&gt;dbug_sentry == THD_SENTRY_MAGIC)</span>
<a name="l00417"></a>00417 <span class="preprocessor"></span>
<a name="l00418"></a>00418 <span class="keyword">typedef</span> ulonglong sql_mode_t;
<a name="l00419"></a>00419 
<a name="l00420"></a><a class="code" href="structsystem__variables.html">00420</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structsystem__variables.html">system_variables</a>
<a name="l00421"></a>00421 {
<a name="l00422"></a>00422   <span class="comment">/*</span>
<a name="l00423"></a>00423 <span class="comment">    How dynamically allocated system variables are handled:</span>
<a name="l00424"></a>00424 <span class="comment">    </span>
<a name="l00425"></a>00425 <span class="comment">    The global_system_variables and max_system_variables are &quot;authoritative&quot;</span>
<a name="l00426"></a>00426 <span class="comment">    They both should have the same &#39;version&#39; and &#39;size&#39;.</span>
<a name="l00427"></a>00427 <span class="comment">    When attempting to access a dynamic variable, if the session version</span>
<a name="l00428"></a>00428 <span class="comment">    is out of date, then the session version is updated and realloced if</span>
<a name="l00429"></a>00429 <span class="comment">    neccessary and bytes copied from global to make up for missing data.</span>
<a name="l00430"></a>00430 <span class="comment">  */</span> 
<a name="l00431"></a>00431   ulong dynamic_variables_version;
<a name="l00432"></a>00432   <span class="keywordtype">char</span>* dynamic_variables_ptr;
<a name="l00433"></a>00433   uint dynamic_variables_head;    <span class="comment">/* largest valid variable offset */</span>
<a name="l00434"></a>00434   uint dynamic_variables_size;    <span class="comment">/* how many bytes are in use */</span>
<a name="l00435"></a>00435   LIST *dynamic_variables_allocs; <span class="comment">/* memory hunks for PLUGIN_VAR_MEMALLOC */</span>
<a name="l00436"></a>00436   
<a name="l00437"></a>00437   ulonglong max_heap_table_size;
<a name="l00438"></a>00438   ulonglong tmp_table_size;
<a name="l00439"></a>00439   ulonglong long_query_time;
<a name="l00440"></a>00440   my_bool end_markers_in_json;
<a name="l00441"></a>00441   <span class="comment">/* A bitmap for switching optimizations on/off */</span>
<a name="l00442"></a>00442   ulonglong optimizer_switch;
<a name="l00443"></a><a class="code" href="structsystem__variables.html#a885b8367335d72fa20b96c15299e84fe">00443</a>   ulonglong <a class="code" href="structsystem__variables.html#a885b8367335d72fa20b96c15299e84fe" title="bitmap to tune optimizer tracing">optimizer_trace</a>; 
<a name="l00444"></a><a class="code" href="structsystem__variables.html#afb344b6d5243a551afd58289f94dfdc5">00444</a>   ulonglong <a class="code" href="structsystem__variables.html#afb344b6d5243a551afd58289f94dfdc5" title="bitmap to select features to trace">optimizer_trace_features</a>; 
<a name="l00445"></a>00445   <span class="keywordtype">long</span>      optimizer_trace_offset;
<a name="l00446"></a>00446   <span class="keywordtype">long</span>      optimizer_trace_limit;
<a name="l00447"></a>00447   ulong     optimizer_trace_max_mem_size;
<a name="l00448"></a><a class="code" href="structsystem__variables.html#a2c95143a1f46cb1e88fd6f9785ac739c">00448</a>   sql_mode_t <a class="code" href="structsystem__variables.html#a2c95143a1f46cb1e88fd6f9785ac739c" title="which non-standard SQL behaviour should be enabled">sql_mode</a>; 
<a name="l00449"></a><a class="code" href="structsystem__variables.html#a4eb214ff2c0b9d4cccf21394095d28dc">00449</a>   ulonglong <a class="code" href="structsystem__variables.html#a4eb214ff2c0b9d4cccf21394095d28dc" title="OPTION_xxx constants, e.g. OPTION_PROFILING.">option_bits</a>; 
<a name="l00450"></a>00450   ha_rows select_limit;
<a name="l00451"></a>00451   ha_rows max_join_size;
<a name="l00452"></a>00452   ulong auto_increment_increment, auto_increment_offset;
<a name="l00453"></a>00453   ulong bulk_insert_buff_size;
<a name="l00454"></a>00454   uint  eq_range_index_dive_limit;
<a name="l00455"></a>00455   ulong join_buff_size;
<a name="l00456"></a>00456   ulong lock_wait_timeout;
<a name="l00457"></a>00457   ulong max_allowed_packet;
<a name="l00458"></a>00458   ulong max_error_count;
<a name="l00459"></a>00459   ulong max_length_for_sort_data;
<a name="l00460"></a>00460   ulong max_sort_length;
<a name="l00461"></a>00461   ulong max_tmp_tables;
<a name="l00462"></a>00462   ulong max_insert_delayed_threads;
<a name="l00463"></a>00463   ulong min_examined_row_limit;
<a name="l00464"></a>00464   ulong multi_range_count;
<a name="l00465"></a>00465   ulong myisam_repair_threads;
<a name="l00466"></a>00466   ulong myisam_sort_buff_size;
<a name="l00467"></a>00467   ulong myisam_stats_method;
<a name="l00468"></a>00468   ulong net_buffer_length;
<a name="l00469"></a>00469   ulong net_interactive_timeout;
<a name="l00470"></a>00470   ulong net_read_timeout;
<a name="l00471"></a>00471   ulong net_retry_count;
<a name="l00472"></a>00472   ulong net_wait_timeout;
<a name="l00473"></a>00473   ulong net_write_timeout;
<a name="l00474"></a>00474   ulong optimizer_prune_level;
<a name="l00475"></a>00475   ulong optimizer_search_depth;
<a name="l00476"></a>00476   ulong preload_buff_size;
<a name="l00477"></a>00477   ulong profiling_history_size;
<a name="l00478"></a>00478   ulong read_buff_size;
<a name="l00479"></a>00479   ulong read_rnd_buff_size;
<a name="l00480"></a>00480   ulong div_precincrement;
<a name="l00481"></a>00481   ulong sortbuff_size;
<a name="l00482"></a>00482   ulong max_sp_recursion_depth;
<a name="l00483"></a>00483   ulong default_week_format;
<a name="l00484"></a>00484   ulong max_seeks_for_key;
<a name="l00485"></a>00485   ulong range_alloc_block_size;
<a name="l00486"></a>00486   ulong query_alloc_block_size;
<a name="l00487"></a>00487   ulong query_prealloc_size;
<a name="l00488"></a>00488   ulong trans_alloc_block_size;
<a name="l00489"></a>00489   ulong trans_prealloc_size;
<a name="l00490"></a>00490   ulong group_concat_max_len;
<a name="l00491"></a>00491 
<a name="l00492"></a><a class="code" href="structsystem__variables.html#a76e0cfd8d6117b905cb117190b427391">00492</a>   ulong <a class="code" href="structsystem__variables.html#a76e0cfd8d6117b905cb117190b427391" title="binlog format for this thd (see enum_binlog_format)">binlog_format</a>; 
<a name="l00493"></a>00493   my_bool binlog_direct_non_trans_update;
<a name="l00494"></a>00494   ulong binlog_row_image; 
<a name="l00495"></a>00495   my_bool sql_log_bin;
<a name="l00496"></a>00496   ulong completion_type;
<a name="l00497"></a>00497   ulong query_cache_type;
<a name="l00498"></a>00498   ulong tx_isolation;
<a name="l00499"></a>00499   ulong updatable_views_with_limit;
<a name="l00500"></a>00500   uint max_user_connections;
<a name="l00501"></a>00501   ulong my_aes_mode;
<a name="l00502"></a>00502 
<a name="l00507"></a><a class="code" href="structsystem__variables.html#af5efac8655d8d7d14c0f8954eedbdaae">00507</a>   my_thread_id <a class="code" href="structsystem__variables.html#af5efac8655d8d7d14c0f8954eedbdaae">pseudo_thread_id</a>;
<a name="l00511"></a><a class="code" href="structsystem__variables.html#ab2489ca441b76309299e895f0eef2238">00511</a>   my_bool <a class="code" href="structsystem__variables.html#ab2489ca441b76309299e895f0eef2238">tx_read_only</a>;
<a name="l00512"></a>00512   my_bool low_priority_updates;
<a name="l00513"></a>00513   my_bool new_mode;
<a name="l00514"></a>00514   my_bool query_cache_wlock_invalidate;
<a name="l00515"></a>00515   my_bool engine_condition_pushdown;
<a name="l00516"></a>00516   my_bool keep_files_on_create;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   my_bool old_alter_table;
<a name="l00519"></a>00519   uint old_passwords;
<a name="l00520"></a>00520   my_bool big_tables;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522   <a class="code" href="structst__plugin__int.html">plugin_ref</a> table_plugin;
<a name="l00523"></a>00523   <a class="code" href="structst__plugin__int.html">plugin_ref</a> temp_table_plugin;
<a name="l00524"></a>00524 
<a name="l00525"></a>00525   <span class="comment">/* Only charset part of these variables is sensible */</span>
<a name="l00526"></a>00526   <span class="keyword">const</span> CHARSET_INFO *character_set_filesystem;
<a name="l00527"></a>00527   <span class="keyword">const</span> CHARSET_INFO *character_set_client;
<a name="l00528"></a>00528   <span class="keyword">const</span> CHARSET_INFO *character_set_results;
<a name="l00529"></a>00529 
<a name="l00530"></a>00530   <span class="comment">/* Both charset and collation parts of these variables are important */</span>
<a name="l00531"></a>00531   <span class="keyword">const</span> CHARSET_INFO  *collation_server;
<a name="l00532"></a>00532   <span class="keyword">const</span> CHARSET_INFO  *collation_database;
<a name="l00533"></a>00533   <span class="keyword">const</span> CHARSET_INFO  *collation_connection;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   <span class="comment">/* Error messages */</span>
<a name="l00536"></a>00536   <a class="code" href="classMY__LOCALE.html">MY_LOCALE</a> *lc_messages;
<a name="l00537"></a>00537   <span class="comment">/* Locale Support */</span>
<a name="l00538"></a>00538   <a class="code" href="classMY__LOCALE.html">MY_LOCALE</a> *lc_time_names;
<a name="l00539"></a>00539 
<a name="l00540"></a>00540   <a class="code" href="classTime__zone.html">Time_zone</a> *time_zone;
<a name="l00541"></a>00541   <span class="comment">/*</span>
<a name="l00542"></a>00542 <span class="comment">    TIMESTAMP fields are by default created with DEFAULT clauses</span>
<a name="l00543"></a>00543 <span class="comment">    implicitly without users request. This flag when set, disables</span>
<a name="l00544"></a>00544 <span class="comment">    implicit default values and expect users to provide explicit</span>
<a name="l00545"></a>00545 <span class="comment">    default clause. i.e., when set columns are defined as NULL,</span>
<a name="l00546"></a>00546 <span class="comment">    instead of NOT NULL by default.</span>
<a name="l00547"></a>00547 <span class="comment">  */</span>
<a name="l00548"></a>00548   my_bool explicit_defaults_for_timestamp;
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   my_bool sysdate_is_now;
<a name="l00551"></a>00551   my_bool binlog_rows_query_log_events;
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="keywordtype">double</span> long_query_time_double;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555   my_bool pseudo_slave_mode;
<a name="l00556"></a>00556 
<a name="l00557"></a>00557   <a class="code" href="structGtid__specification.html">Gtid_specification</a> gtid_next;
<a name="l00558"></a>00558   <a class="code" href="structGtid__set__or__null.html">Gtid_set_or_null</a> gtid_next_list;
<a name="l00564"></a><a class="code" href="structsystem__variables.html#abf0021568f7fe0b7f4f6ea91d6e164fb">00564</a>   my_bool <a class="code" href="structsystem__variables.html#abf0021568f7fe0b7f4f6ea91d6e164fb">show_old_temporals</a>;
<a name="l00565"></a>00565 } <a class="code" href="structsystem__variables.html">SV</a>;
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 
<a name="l00574"></a><a class="code" href="structsystem__status__var.html">00574</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structsystem__status__var.html">system_status_var</a>
<a name="l00575"></a>00575 {
<a name="l00576"></a>00576   ulonglong created_tmp_disk_tables;
<a name="l00577"></a>00577   ulonglong created_tmp_tables;
<a name="l00578"></a>00578   ulonglong ha_commit_count;
<a name="l00579"></a>00579   ulonglong ha_delete_count;
<a name="l00580"></a>00580   ulonglong ha_read_first_count;
<a name="l00581"></a>00581   ulonglong ha_read_last_count;
<a name="l00582"></a>00582   ulonglong ha_read_key_count;
<a name="l00583"></a>00583   ulonglong ha_read_next_count;
<a name="l00584"></a>00584   ulonglong ha_read_prev_count;
<a name="l00585"></a>00585   ulonglong ha_read_rnd_count;
<a name="l00586"></a>00586   ulonglong ha_read_rnd_next_count;
<a name="l00587"></a>00587   <span class="comment">/*</span>
<a name="l00588"></a>00588 <span class="comment">    This number doesn&#39;t include calls to the default implementation and</span>
<a name="l00589"></a>00589 <span class="comment">    calls made by range access. The intent is to count only calls made by</span>
<a name="l00590"></a>00590 <span class="comment">    BatchedKeyAccess.</span>
<a name="l00591"></a>00591 <span class="comment">  */</span>
<a name="l00592"></a>00592   ulonglong ha_multi_range_read_init_count;
<a name="l00593"></a>00593   ulonglong ha_rollback_count;
<a name="l00594"></a>00594   ulonglong ha_update_count;
<a name="l00595"></a>00595   ulonglong ha_write_count;
<a name="l00596"></a>00596   ulonglong ha_prepare_count;
<a name="l00597"></a>00597   ulonglong ha_discover_count;
<a name="l00598"></a>00598   ulonglong ha_savepoint_count;
<a name="l00599"></a>00599   ulonglong ha_savepoint_rollback_count;
<a name="l00600"></a>00600   ulonglong ha_external_lock_count;
<a name="l00601"></a>00601   ulonglong opened_tables;
<a name="l00602"></a>00602   ulonglong opened_shares;
<a name="l00603"></a>00603   ulonglong table_open_cache_hits;
<a name="l00604"></a>00604   ulonglong table_open_cache_misses;
<a name="l00605"></a>00605   ulonglong table_open_cache_overflows;
<a name="l00606"></a>00606   ulonglong select_full_join_count;
<a name="l00607"></a>00607   ulonglong select_full_range_join_count;
<a name="l00608"></a>00608   ulonglong select_range_count;
<a name="l00609"></a>00609   ulonglong select_range_check_count;
<a name="l00610"></a>00610   ulonglong select_scan_count;
<a name="l00611"></a>00611   ulonglong long_query_count;
<a name="l00612"></a>00612   ulonglong filesort_merge_passes;
<a name="l00613"></a>00613   ulonglong filesort_range_count;
<a name="l00614"></a>00614   ulonglong filesort_rows;
<a name="l00615"></a>00615   ulonglong filesort_scan_count;
<a name="l00616"></a>00616   <span class="comment">/* Prepared statements and binary protocol */</span>
<a name="l00617"></a>00617   ulonglong com_stmt_prepare;
<a name="l00618"></a>00618   ulonglong com_stmt_reprepare;
<a name="l00619"></a>00619   ulonglong com_stmt_execute;
<a name="l00620"></a>00620   ulonglong com_stmt_send_long_data;
<a name="l00621"></a>00621   ulonglong com_stmt_fetch;
<a name="l00622"></a>00622   ulonglong com_stmt_reset;
<a name="l00623"></a>00623   ulonglong com_stmt_close;
<a name="l00624"></a>00624 
<a name="l00625"></a>00625   ulonglong bytes_received;
<a name="l00626"></a>00626   ulonglong bytes_sent;
<a name="l00627"></a>00627   <span class="comment">/*</span>
<a name="l00628"></a>00628 <span class="comment">    Number of statements sent from the client</span>
<a name="l00629"></a>00629 <span class="comment">  */</span>
<a name="l00630"></a>00630   ulonglong questions;
<a name="l00631"></a>00631 
<a name="l00632"></a>00632   ulong com_other;
<a name="l00633"></a>00633   ulong com_stat[(uint) SQLCOM_END];
<a name="l00634"></a>00634 
<a name="l00635"></a>00635   <span class="comment">/*</span>
<a name="l00636"></a>00636 <span class="comment">    IMPORTANT!</span>
<a name="l00637"></a>00637 <span class="comment">    SEE last_system_status_var DEFINITION BELOW.</span>
<a name="l00638"></a>00638 <span class="comment">    Below &#39;last_system_status_var&#39; are all variables that cannot be handled</span>
<a name="l00639"></a>00639 <span class="comment">    automatically by add_to_status()/add_diff_to_status().</span>
<a name="l00640"></a>00640 <span class="comment">  */</span>
<a name="l00641"></a>00641   <span class="keywordtype">double</span> last_query_cost;
<a name="l00642"></a>00642   ulonglong last_query_partial_plans;
<a name="l00643"></a>00643 } <a class="code" href="structsystem__status__var.html">STATUS_VAR</a>;
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 <span class="comment">/*</span>
<a name="l00646"></a>00646 <span class="comment">  This is used for &#39;SHOW STATUS&#39;. It must be updated to the last ulong</span>
<a name="l00647"></a>00647 <span class="comment">  variable in system_status_var which is makes sens to add to the global</span>
<a name="l00648"></a>00648 <span class="comment">  counter</span>
<a name="l00649"></a>00649 <span class="comment">*/</span>
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 <span class="preprocessor">#define last_system_status_var questions</span>
<a name="l00652"></a>00652 <span class="preprocessor"></span>
<a name="l00653"></a>00653 
<a name="l00662"></a>00662 <span class="keyword">inline</span> CHARSET_INFO *
<a name="l00663"></a>00663 mysqld_collation_get_by_name(<span class="keyword">const</span> <span class="keywordtype">char</span> *name,
<a name="l00664"></a>00664                              CHARSET_INFO *name_cs= system_charset_info)
<a name="l00665"></a>00665 {
<a name="l00666"></a>00666   CHARSET_INFO *cs;
<a name="l00667"></a>00667   MY_CHARSET_LOADER loader;
<a name="l00668"></a>00668   my_charset_loader_init_mysys(&amp;loader);
<a name="l00669"></a>00669   <span class="keywordflow">if</span> (!(cs= my_collation_get_by_name(&amp;loader, name, MYF(0))))
<a name="l00670"></a>00670   {
<a name="l00671"></a>00671     <a class="code" href="classErrConvString.html">ErrConvString</a> err(name, name_cs);
<a name="l00672"></a>00672     my_error(ER_UNKNOWN_COLLATION, MYF(0), err.ptr());
<a name="l00673"></a>00673     <span class="keywordflow">if</span> (loader.error[0])
<a name="l00674"></a>00674       push_warning_printf(current_thd,
<a name="l00675"></a>00675                           Sql_condition::WARN_LEVEL_WARN,
<a name="l00676"></a>00676                           ER_UNKNOWN_COLLATION, <span class="stringliteral">&quot;%s&quot;</span>, loader.error);
<a name="l00677"></a>00677   }
<a name="l00678"></a>00678   <span class="keywordflow">return</span> cs;
<a name="l00679"></a>00679 }
<a name="l00680"></a>00680 
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="preprocessor">#ifdef MYSQL_SERVER</span>
<a name="l00683"></a>00683 <span class="preprocessor"></span>
<a name="l00684"></a>00684 <span class="keywordtype">void</span> free_tmp_table(THD *thd, <a class="code" href="structTABLE.html">TABLE</a> *entry);
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 <span class="comment">/* The following macro is to make init of Query_arena simpler */</span>
<a name="l00688"></a>00688 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00689"></a>00689 <span class="preprocessor"></span><span class="preprocessor">#define INIT_ARENA_DBUG_INFO is_backup_arena= 0; is_reprepared= FALSE;</span>
<a name="l00690"></a>00690 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00691"></a>00691 <span class="preprocessor"></span><span class="preprocessor">#define INIT_ARENA_DBUG_INFO</span>
<a name="l00692"></a>00692 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00693"></a>00693 <span class="preprocessor"></span>
<a name="l00694"></a>00694 <span class="keyword">class </span>Query_arena
<a name="l00695"></a>00695 {
<a name="l00696"></a>00696 <span class="keyword">public</span>:
<a name="l00697"></a>00697   <span class="comment">/*</span>
<a name="l00698"></a>00698 <span class="comment">    List of items created in the parser for this query. Every item puts</span>
<a name="l00699"></a>00699 <span class="comment">    itself to the list on creation (see Item::Item() for details))</span>
<a name="l00700"></a>00700 <span class="comment">  */</span>
<a name="l00701"></a>00701   <a class="code" href="classItem.html">Item</a> *free_list;
<a name="l00702"></a>00702   MEM_ROOT *mem_root;                   <span class="comment">// Pointer to current memroot</span>
<a name="l00703"></a>00703 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span>  <span class="keywordtype">bool</span> is_backup_arena; <span class="comment">/* True if this arena is used for backup. */</span>
<a name="l00705"></a>00705   <span class="keywordtype">bool</span> is_reprepared;
<a name="l00706"></a>00706 <span class="preprocessor">#endif</span>
<a name="l00707"></a>00707 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l00708"></a>00708 <span class="comment">    The states relfects three diffrent life cycles for three</span>
<a name="l00709"></a>00709 <span class="comment">    different types of statements:</span>
<a name="l00710"></a>00710 <span class="comment">    Prepared statement: STMT_INITIALIZED -&gt; STMT_PREPARED -&gt; STMT_EXECUTED.</span>
<a name="l00711"></a>00711 <span class="comment">    Stored procedure:   STMT_INITIALIZED_FOR_SP -&gt; STMT_EXECUTED.</span>
<a name="l00712"></a>00712 <span class="comment">    Other statements:   STMT_CONVENTIONAL_EXECUTION never changes.</span>
<a name="l00713"></a>00713 <span class="comment">  */</span>
<a name="l00714"></a>00714   <span class="keyword">enum</span> enum_state
<a name="l00715"></a>00715   {
<a name="l00716"></a>00716     STMT_INITIALIZED= 0, STMT_INITIALIZED_FOR_SP= 1, STMT_PREPARED= 2,
<a name="l00717"></a>00717     STMT_CONVENTIONAL_EXECUTION= 3, STMT_EXECUTED= 4, STMT_ERROR= -1
<a name="l00718"></a>00718   };
<a name="l00719"></a>00719 
<a name="l00720"></a>00720   enum_state state;
<a name="l00721"></a>00721 
<a name="l00722"></a>00722   <span class="comment">/* We build without RTTI, so dynamic_cast can&#39;t be used. */</span>
<a name="l00723"></a>00723   <span class="keyword">enum</span> Type
<a name="l00724"></a>00724   {
<a name="l00725"></a>00725     STATEMENT, PREPARED_STATEMENT, STORED_PROCEDURE
<a name="l00726"></a>00726   };
<a name="l00727"></a>00727 
<a name="l00728"></a>00728   Query_arena(MEM_ROOT *mem_root_arg, <span class="keyword">enum</span> enum_state state_arg) :
<a name="l00729"></a>00729     free_list(0), mem_root(mem_root_arg), state(state_arg)
<a name="l00730"></a>00730   { INIT_ARENA_DBUG_INFO; }
<a name="l00731"></a>00731   <span class="comment">/*</span>
<a name="l00732"></a>00732 <span class="comment">    This constructor is used only when Query_arena is created as</span>
<a name="l00733"></a>00733 <span class="comment">    backup storage for another instance of Query_arena.</span>
<a name="l00734"></a>00734 <span class="comment">  */</span>
<a name="l00735"></a>00735   Query_arena() { INIT_ARENA_DBUG_INFO; }
<a name="l00736"></a>00736 
<a name="l00737"></a>00737   <span class="keyword">virtual</span> Type type() <span class="keyword">const</span>;
<a name="l00738"></a>00738   <span class="keyword">virtual</span> ~Query_arena() {};
<a name="l00739"></a>00739 
<a name="l00740"></a>00740   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_stmt_prepare()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> state == STMT_INITIALIZED; }
<a name="l00741"></a>00741   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_stmt_prepare_or_first_sp_execute()<span class="keyword"> const</span>
<a name="l00742"></a>00742 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)state &lt; (int)STMT_PREPARED; }
<a name="l00743"></a>00743   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_stmt_prepare_or_first_stmt_execute()<span class="keyword"> const</span>
<a name="l00744"></a>00744 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)state &lt;= (int)STMT_PREPARED; }
<a name="l00745"></a>00745   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_conventional()<span class="keyword"> const</span>
<a name="l00746"></a>00746 <span class="keyword">  </span>{ <span class="keywordflow">return</span> state == STMT_CONVENTIONAL_EXECUTION; }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748   <span class="keyword">inline</span> <span class="keywordtype">void</span>* alloc(<span class="keywordtype">size_t</span> size) { <span class="keywordflow">return</span> alloc_root(mem_root,size); }
<a name="l00749"></a>00749   <span class="keyword">inline</span> <span class="keywordtype">void</span>* calloc(<span class="keywordtype">size_t</span> size)
<a name="l00750"></a>00750   {
<a name="l00751"></a>00751     <span class="keywordtype">void</span> *ptr;
<a name="l00752"></a>00752     <span class="keywordflow">if</span> ((ptr=alloc_root(mem_root,size)))
<a name="l00753"></a>00753       memset(ptr, 0, size);
<a name="l00754"></a>00754     <span class="keywordflow">return</span> ptr;
<a name="l00755"></a>00755   }
<a name="l00756"></a>00756   <span class="keyword">inline</span> <span class="keywordtype">char</span> *strdup(<span class="keyword">const</span> <span class="keywordtype">char</span> *str)
<a name="l00757"></a>00757   { <span class="keywordflow">return</span> strdup_root(mem_root,str); }
<a name="l00758"></a>00758   <span class="keyword">inline</span> <span class="keywordtype">char</span> *strmake(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">size_t</span> size)
<a name="l00759"></a>00759   { <span class="keywordflow">return</span> strmake_root(mem_root,str,size); }
<a name="l00760"></a>00760   <span class="keyword">inline</span> <span class="keywordtype">void</span> *memdup(<span class="keyword">const</span> <span class="keywordtype">void</span> *str, <span class="keywordtype">size_t</span> size)
<a name="l00761"></a>00761   { <span class="keywordflow">return</span> memdup_root(mem_root,str,size); }
<a name="l00762"></a>00762   <span class="keyword">inline</span> <span class="keywordtype">void</span> *memdup_w_gap(<span class="keyword">const</span> <span class="keywordtype">void</span> *str, <span class="keywordtype">size_t</span> size, uint gap)
<a name="l00763"></a>00763   {
<a name="l00764"></a>00764     <span class="keywordtype">void</span> *ptr;
<a name="l00765"></a>00765     <span class="keywordflow">if</span> ((ptr= alloc_root(mem_root,size+gap)))
<a name="l00766"></a>00766       memcpy(ptr,str,size);
<a name="l00767"></a>00767     <span class="keywordflow">return</span> ptr;
<a name="l00768"></a>00768   }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770   <span class="keywordtype">void</span> set_query_arena(Query_arena *<span class="keyword">set</span>);
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   <span class="keywordtype">void</span> free_items();
<a name="l00773"></a>00773   <span class="comment">/* Close the active state associated with execution of this statement */</span>
<a name="l00774"></a>00774   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cleanup_stmt();
<a name="l00775"></a>00775 };
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="keyword">class </span><a class="code" href="classServer__side__cursor.html">Server_side_cursor</a>;
<a name="l00779"></a>00779 
<a name="l00796"></a>00796 <span class="keyword">class </span>Statement: <span class="keyword">public</span> Query_arena
<a name="l00797"></a>00797 {
<a name="l00798"></a>00798   Statement(<span class="keyword">const</span> Statement &amp;rhs);              <span class="comment">/* not implemented: */</span>
<a name="l00799"></a>00799   Statement &amp;operator=(<span class="keyword">const</span> Statement &amp;rhs);   <span class="comment">/* non-copyable */</span>
<a name="l00800"></a>00800 <span class="keyword">public</span>:
<a name="l00801"></a>00801   <span class="comment">/*</span>
<a name="l00802"></a>00802 <span class="comment">    Uniquely identifies each statement object in thread scope; change during</span>
<a name="l00803"></a>00803 <span class="comment">    statement lifetime. FIXME: must be const</span>
<a name="l00804"></a>00804 <span class="comment">  */</span>
<a name="l00805"></a>00805    ulong id;
<a name="l00806"></a>00806 
<a name="l00807"></a>00807   <span class="comment">/*</span>
<a name="l00808"></a>00808 <span class="comment">    MARK_COLUMNS_NONE:  Means mark_used_colums is not set and no indicator to</span>
<a name="l00809"></a>00809 <span class="comment">                        handler of fields used is set</span>
<a name="l00810"></a>00810 <span class="comment">    MARK_COLUMNS_READ:  Means a bit in read set is set to inform handler</span>
<a name="l00811"></a>00811 <span class="comment">                        that the field is to be read. If field list contains</span>
<a name="l00812"></a>00812 <span class="comment">                        duplicates, then thd-&gt;dup_field is set to point</span>
<a name="l00813"></a>00813 <span class="comment">                        to the last found duplicate.</span>
<a name="l00814"></a>00814 <span class="comment">    MARK_COLUMNS_WRITE: Means a bit is set in write set to inform handler</span>
<a name="l00815"></a>00815 <span class="comment">                        that it needs to update this field in write_row</span>
<a name="l00816"></a>00816 <span class="comment">                        and update_row.</span>
<a name="l00817"></a>00817 <span class="comment">  */</span>
<a name="l00818"></a>00818   <span class="keyword">enum</span> enum_mark_columns mark_used_columns;
<a name="l00819"></a>00819 
<a name="l00820"></a>00820   LEX_STRING name; <span class="comment">/* name for named prepared statements */</span>
<a name="l00821"></a>00821   LEX *lex;                                     <span class="comment">// parse tree descriptor</span>
<a name="l00822"></a>00822   <span class="comment">/*</span>
<a name="l00823"></a>00823 <span class="comment">    Points to the query associated with this statement. It&#39;s const, but</span>
<a name="l00824"></a>00824 <span class="comment">    we need to declare it char * because all table handlers are written</span>
<a name="l00825"></a>00825 <span class="comment">    in C and need to point to it.</span>
<a name="l00826"></a>00826 <span class="comment"></span>
<a name="l00827"></a>00827 <span class="comment">    Note that if we set query = NULL, we must at the same time set</span>
<a name="l00828"></a>00828 <span class="comment">    query_length = 0, and protect the whole operation with</span>
<a name="l00829"></a>00829 <span class="comment">    LOCK_thd_data mutex. To avoid crashes in races, if we do not</span>
<a name="l00830"></a>00830 <span class="comment">    know that thd-&gt;query cannot change at the moment, we should print</span>
<a name="l00831"></a>00831 <span class="comment">    thd-&gt;query like this:</span>
<a name="l00832"></a>00832 <span class="comment">      (1) reserve the LOCK_thd_data mutex;</span>
<a name="l00833"></a>00833 <span class="comment">      (2) print or copy the value of query and query_length</span>
<a name="l00834"></a>00834 <span class="comment">      (3) release LOCK_thd_data mutex.</span>
<a name="l00835"></a>00835 <span class="comment">    This printing is needed at least in SHOW PROCESSLIST and SHOW</span>
<a name="l00836"></a>00836 <span class="comment">    ENGINE INNODB STATUS.</span>
<a name="l00837"></a>00837 <span class="comment">  */</span>
<a name="l00838"></a>00838   <a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a> query_string;
<a name="l00839"></a>00839 
<a name="l00840"></a>00840   <span class="comment">/*</span>
<a name="l00841"></a>00841 <span class="comment">    In some cases, we may want to modify the query (i.e. replace</span>
<a name="l00842"></a>00842 <span class="comment">    passwords with their hashes before logging the statement etc.).</span>
<a name="l00843"></a>00843 <span class="comment"></span>
<a name="l00844"></a>00844 <span class="comment">    In case the query was rewritten, the original query will live in</span>
<a name="l00845"></a>00845 <span class="comment">    query_string, while the rewritten query lives in rewritten_query.</span>
<a name="l00846"></a>00846 <span class="comment">    If rewritten_query is empty, query_string should be logged.</span>
<a name="l00847"></a>00847 <span class="comment">    If rewritten_query is non-empty, the rewritten query it contains</span>
<a name="l00848"></a>00848 <span class="comment">    should be used in logs (general log, slow query log, binary log).</span>
<a name="l00849"></a>00849 <span class="comment"></span>
<a name="l00850"></a>00850 <span class="comment">    Currently, password obfuscation is the only rewriting we do; more</span>
<a name="l00851"></a>00851 <span class="comment">    may follow at a later date, both pre- and post parsing of the query.</span>
<a name="l00852"></a>00852 <span class="comment">    Rewriting of binloggable statements must preserve all pertinent</span>
<a name="l00853"></a>00853 <span class="comment">    information.</span>
<a name="l00854"></a>00854 <span class="comment">  */</span>
<a name="l00855"></a>00855   <a class="code" href="classString.html">String</a>      rewritten_query;
<a name="l00856"></a>00856 
<a name="l00857"></a>00857   <span class="keyword">inline</span> <span class="keywordtype">char</span> *query()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> query_string.str(); }
<a name="l00858"></a>00858   <span class="keyword">inline</span> uint32 query_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (uint32)query_string.length(); }
<a name="l00859"></a>00859   <span class="keyword">const</span> CHARSET_INFO *query_charset()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> query_string.charset(); }
<a name="l00860"></a>00860   <span class="keywordtype">void</span> set_query_inner(<span class="keyword">const</span> <a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a> &amp;string_arg)
<a name="l00861"></a>00861   {
<a name="l00862"></a>00862     query_string= string_arg;
<a name="l00863"></a>00863   }
<a name="l00864"></a>00864   <span class="keywordtype">void</span> set_query_inner(<span class="keywordtype">char</span> *query_arg, uint32 query_length_arg,
<a name="l00865"></a>00865                        <span class="keyword">const</span> CHARSET_INFO *cs_arg)
<a name="l00866"></a>00866   {
<a name="l00867"></a>00867     set_query_inner(<a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a>(query_arg, query_length_arg, cs_arg));
<a name="l00868"></a>00868   }
<a name="l00869"></a>00869   <span class="keywordtype">void</span> reset_query_inner()
<a name="l00870"></a>00870   {
<a name="l00871"></a>00871     set_query_inner(<a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a>());
<a name="l00872"></a>00872   }
<a name="l00886"></a>00886   <span class="keywordtype">char</span> *db;
<a name="l00887"></a>00887   <span class="keywordtype">size_t</span> db_length;
<a name="l00888"></a>00888 
<a name="l00889"></a>00889 <span class="keyword">public</span>:
<a name="l00890"></a>00890 
<a name="l00891"></a>00891   <span class="comment">/* This constructor is called for backup statements */</span>
<a name="l00892"></a>00892   Statement() {}
<a name="l00893"></a>00893 
<a name="l00894"></a>00894   Statement(LEX *lex_arg, MEM_ROOT *mem_root_arg,
<a name="l00895"></a>00895             enum_state state_arg, ulong id_arg);
<a name="l00896"></a>00896   <span class="keyword">virtual</span> ~Statement();
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   <span class="comment">/* Assign execution context (note: not all members) of given stmt to self */</span>
<a name="l00899"></a>00899   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_statement(Statement *stmt);
<a name="l00900"></a>00900   <span class="keywordtype">void</span> set_n_backup_statement(Statement *stmt, Statement *backup);
<a name="l00901"></a>00901   <span class="keywordtype">void</span> restore_backup_statement(Statement *stmt, Statement *backup);
<a name="l00902"></a>00902   <span class="comment">/* return class type */</span>
<a name="l00903"></a>00903   <span class="keyword">virtual</span> Type type() <span class="keyword">const</span>;
<a name="l00904"></a>00904 };
<a name="l00905"></a>00905 
<a name="l00906"></a>00906 
<a name="l00918"></a>00918 <span class="keyword">class </span>Statement_map
<a name="l00919"></a>00919 {
<a name="l00920"></a>00920 <span class="keyword">public</span>:
<a name="l00921"></a>00921   Statement_map();
<a name="l00922"></a>00922 
<a name="l00923"></a>00923   <span class="keywordtype">int</span> insert(THD *thd, Statement *statement);
<a name="l00924"></a>00924 
<a name="l00925"></a>00925   Statement *find_by_name(LEX_STRING *name)
<a name="l00926"></a>00926   {
<a name="l00927"></a>00927     Statement *stmt;
<a name="l00928"></a>00928     stmt= (Statement*)my_hash_search(&amp;names_hash, (uchar*)name-&gt;str,
<a name="l00929"></a>00929                                      name-&gt;length);
<a name="l00930"></a>00930     <span class="keywordflow">return</span> stmt;
<a name="l00931"></a>00931   }
<a name="l00932"></a>00932 
<a name="l00933"></a>00933   Statement *find(ulong <span class="keywordtype">id</span>)
<a name="l00934"></a>00934   {
<a name="l00935"></a>00935     <span class="keywordflow">if</span> (last_found_statement == 0 || <span class="keywordtype">id</span> != last_found_statement-&gt;id)
<a name="l00936"></a>00936     {
<a name="l00937"></a>00937       Statement *stmt;
<a name="l00938"></a>00938       stmt= (Statement *) my_hash_search(&amp;st_hash, (uchar *) &amp;id, <span class="keyword">sizeof</span>(id));
<a name="l00939"></a>00939       <span class="keywordflow">if</span> (stmt &amp;&amp; stmt-&gt;name.str)
<a name="l00940"></a>00940         <span class="keywordflow">return</span> NULL;
<a name="l00941"></a>00941       last_found_statement= stmt;
<a name="l00942"></a>00942     }
<a name="l00943"></a>00943     <span class="keywordflow">return</span> last_found_statement;
<a name="l00944"></a>00944   }
<a name="l00945"></a>00945   <span class="comment">/*</span>
<a name="l00946"></a>00946 <span class="comment">    Close all cursors of this connection that use tables of a storage</span>
<a name="l00947"></a>00947 <span class="comment">    engine that has transaction-specific state and therefore can not</span>
<a name="l00948"></a>00948 <span class="comment">    survive COMMIT or ROLLBACK. Currently all but MyISAM cursors are closed.</span>
<a name="l00949"></a>00949 <span class="comment">    CURRENTLY NOT IMPLEMENTED!</span>
<a name="l00950"></a>00950 <span class="comment">  */</span>
<a name="l00951"></a>00951   <span class="keywordtype">void</span> close_transient_cursors();
<a name="l00952"></a>00952   <span class="keywordtype">void</span> erase(Statement *statement);
<a name="l00953"></a>00953   <span class="comment">/* Erase all statements (calls Statement destructor) */</span>
<a name="l00954"></a>00954   <span class="keywordtype">void</span> reset();
<a name="l00955"></a>00955   ~Statement_map();
<a name="l00956"></a>00956 <span class="keyword">private</span>:
<a name="l00957"></a>00957   HASH st_hash;
<a name="l00958"></a>00958   HASH names_hash;
<a name="l00959"></a>00959   Statement *last_found_statement;
<a name="l00960"></a>00960 };
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 <span class="keyword">class </span>Ha_trx_info;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964 <span class="keyword">struct </span>THD_TRANS
<a name="l00965"></a>00965 {
<a name="l00966"></a>00966   <span class="comment">/* true is not all entries in the ht[] support 2pc */</span>
<a name="l00967"></a>00967   <span class="keywordtype">bool</span>        no_2pc;
<a name="l00968"></a>00968   <span class="keywordtype">int</span>         rw_ha_count;
<a name="l00969"></a>00969   <span class="comment">/* storage engines that registered in this transaction */</span>
<a name="l00970"></a>00970   Ha_trx_info *ha_list;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 <span class="keyword">private</span>:
<a name="l00973"></a>00973   <span class="comment">/* </span>
<a name="l00974"></a>00974 <span class="comment">    The purpose of this member variable (i.e. flag) is to keep track of</span>
<a name="l00975"></a>00975 <span class="comment">    statements which cannot be rolled back safely(completely).</span>
<a name="l00976"></a>00976 <span class="comment">    For example,</span>
<a name="l00977"></a>00977 <span class="comment"></span>
<a name="l00978"></a>00978 <span class="comment">    * statements that modified non-transactional tables. The value</span>
<a name="l00979"></a>00979 <span class="comment">    MODIFIED_NON_TRANS_TABLE is set within mysql_insert, mysql_update,</span>
<a name="l00980"></a>00980 <span class="comment">    mysql_delete, etc if a non-transactional table is modified.</span>
<a name="l00981"></a>00981 <span class="comment"></span>
<a name="l00982"></a>00982 <span class="comment">    * &#39;DROP TEMPORARY TABLE&#39; and &#39;CREATE TEMPORARY TABLE&#39; statements.</span>
<a name="l00983"></a>00983 <span class="comment">    The former sets the value CREATED_TEMP_TABLE is set and the latter</span>
<a name="l00984"></a>00984 <span class="comment">    the value DROPPED_TEMP_TABLE.</span>
<a name="l00985"></a>00985 <span class="comment">    </span>
<a name="l00986"></a>00986 <span class="comment">    The tracked statements are modified in scope of:</span>
<a name="l00987"></a>00987 <span class="comment"></span>
<a name="l00988"></a>00988 <span class="comment">    * transaction, when the variable is a member of THD::transaction.all</span>
<a name="l00989"></a>00989 <span class="comment">    </span>
<a name="l00990"></a>00990 <span class="comment">    * top-level statement or sub-statement, when the variable is a</span>
<a name="l00991"></a>00991 <span class="comment">    member of THD::transaction.stmt</span>
<a name="l00992"></a>00992 <span class="comment"></span>
<a name="l00993"></a>00993 <span class="comment">    This member has the following life cycle:</span>
<a name="l00994"></a>00994 <span class="comment"></span>
<a name="l00995"></a>00995 <span class="comment">    * stmt.m_unsafe_rollback_flags is used to keep track of top-level statements</span>
<a name="l00996"></a>00996 <span class="comment">    which cannot be rolled back safely. At the end of the statement, the value</span>
<a name="l00997"></a>00997 <span class="comment">    of stmt.m_unsafe_rollback_flags is merged with all.m_unsafe_rollback_flags</span>
<a name="l00998"></a>00998 <span class="comment">    and gets reset.</span>
<a name="l00999"></a>00999 <span class="comment">    </span>
<a name="l01000"></a>01000 <span class="comment">    * all.cannot_safely_rollback is reset at the end of transaction</span>
<a name="l01001"></a>01001 <span class="comment"></span>
<a name="l01002"></a>01002 <span class="comment">    * Since we do not have a dedicated context for execution of a sub-statement,</span>
<a name="l01003"></a>01003 <span class="comment">    to keep track of non-transactional changes in a sub-statement, we re-use</span>
<a name="l01004"></a>01004 <span class="comment">    stmt.m_unsafe_rollback_flags. At entrance into a sub-statement, a copy of</span>
<a name="l01005"></a>01005 <span class="comment">    the value of stmt.m_unsafe_rollback_flags (containing the changes of the</span>
<a name="l01006"></a>01006 <span class="comment">    outer statement) is saved on stack.  Then stmt.m_unsafe_rollback_flags is</span>
<a name="l01007"></a>01007 <span class="comment">    reset to 0 and the substatement is executed. Then the new value is merged</span>
<a name="l01008"></a>01008 <span class="comment">    with the saved value.</span>
<a name="l01009"></a>01009 <span class="comment">  */</span>
<a name="l01010"></a>01010 
<a name="l01011"></a>01011   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_unsafe_rollback_flags;
<a name="l01012"></a>01012   <span class="comment">/*</span>
<a name="l01013"></a>01013 <span class="comment">    Define the type of statemens which cannot be rolled back safely.</span>
<a name="l01014"></a>01014 <span class="comment">    Each type occupies one bit in m_unsafe_rollback_flags.</span>
<a name="l01015"></a>01015 <span class="comment">  */</span>
<a name="l01016"></a>01016   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> MODIFIED_NON_TRANS_TABLE= 0x01;
<a name="l01017"></a>01017   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> CREATED_TEMP_TABLE= 0x02;
<a name="l01018"></a>01018   <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> DROPPED_TEMP_TABLE= 0x04;
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 <span class="keyword">public</span>:
<a name="l01021"></a>01021 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l01022"></a>01022 <span class="preprocessor"></span>  <span class="keywordtype">void</span> dbug_unsafe_rollback_flags(<span class="keyword">const</span> <span class="keywordtype">char</span>* msg)<span class="keyword"> const</span>
<a name="l01023"></a>01023 <span class="keyword">  </span>{
<a name="l01024"></a>01024     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;%s.unsafe_rollback_flags: %s%s%s&quot;</span>,
<a name="l01025"></a>01025                          msg,
<a name="l01026"></a>01026                          FLAGSTR(m_unsafe_rollback_flags, MODIFIED_NON_TRANS_TABLE),
<a name="l01027"></a>01027                          FLAGSTR(m_unsafe_rollback_flags, CREATED_TEMP_TABLE),
<a name="l01028"></a>01028                          FLAGSTR(m_unsafe_rollback_flags, DROPPED_TEMP_TABLE)));
<a name="l01029"></a>01029   }
<a name="l01030"></a>01030 <span class="preprocessor">#endif</span>
<a name="l01031"></a>01031 <span class="preprocessor"></span>
<a name="l01032"></a>01032   <span class="keywordtype">bool</span> cannot_safely_rollback()<span class="keyword"> const</span>
<a name="l01033"></a>01033 <span class="keyword">  </span>{
<a name="l01034"></a>01034     <span class="keywordflow">return</span> m_unsafe_rollback_flags &gt; 0;
<a name="l01035"></a>01035   }
<a name="l01036"></a>01036   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> get_unsafe_rollback_flags()<span class="keyword"> const</span>
<a name="l01037"></a>01037 <span class="keyword">  </span>{
<a name="l01038"></a>01038     <span class="keywordflow">return</span> m_unsafe_rollback_flags;
<a name="l01039"></a>01039   }
<a name="l01040"></a>01040   <span class="keywordtype">void</span> set_unsafe_rollback_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
<a name="l01041"></a>01041   {
<a name="l01042"></a>01042     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;set_unsafe_rollback_flags: %d&quot;</span>, flags));
<a name="l01043"></a>01043     m_unsafe_rollback_flags= flags;
<a name="l01044"></a>01044   }
<a name="l01045"></a>01045   <span class="keywordtype">void</span> add_unsafe_rollback_flags(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
<a name="l01046"></a>01046   {
<a name="l01047"></a>01047     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;add_unsafe_rollback_flags: %d&quot;</span>, flags));
<a name="l01048"></a>01048     m_unsafe_rollback_flags|= flags;
<a name="l01049"></a>01049   }
<a name="l01050"></a>01050   <span class="keywordtype">void</span> reset_unsafe_rollback_flags()
<a name="l01051"></a>01051   {
<a name="l01052"></a>01052     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;reset_unsafe_rollback_flags&quot;</span>));
<a name="l01053"></a>01053     m_unsafe_rollback_flags= 0;
<a name="l01054"></a>01054   }
<a name="l01055"></a>01055   <span class="keywordtype">void</span> mark_modified_non_trans_table()
<a name="l01056"></a>01056   {
<a name="l01057"></a>01057     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;mark_modified_non_trans_table&quot;</span>));
<a name="l01058"></a>01058     m_unsafe_rollback_flags|= MODIFIED_NON_TRANS_TABLE;
<a name="l01059"></a>01059   }
<a name="l01060"></a>01060   <span class="keywordtype">bool</span> has_modified_non_trans_table()<span class="keyword"> const</span>
<a name="l01061"></a>01061 <span class="keyword">  </span>{
<a name="l01062"></a>01062     <span class="keywordflow">return</span> m_unsafe_rollback_flags &amp; MODIFIED_NON_TRANS_TABLE;
<a name="l01063"></a>01063   }
<a name="l01064"></a>01064   <span class="keywordtype">void</span> mark_created_temp_table()
<a name="l01065"></a>01065   {
<a name="l01066"></a>01066     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;mark_created_temp_table&quot;</span>));
<a name="l01067"></a>01067     m_unsafe_rollback_flags|= CREATED_TEMP_TABLE;
<a name="l01068"></a>01068   }
<a name="l01069"></a>01069   <span class="keywordtype">bool</span> has_created_temp_table()<span class="keyword"> const</span>
<a name="l01070"></a>01070 <span class="keyword">  </span>{
<a name="l01071"></a>01071     <span class="keywordflow">return</span> m_unsafe_rollback_flags &amp; CREATED_TEMP_TABLE;
<a name="l01072"></a>01072   }
<a name="l01073"></a>01073   <span class="keywordtype">void</span> mark_dropped_temp_table()
<a name="l01074"></a>01074   {
<a name="l01075"></a>01075     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;mark_dropped_temp_table&quot;</span>));
<a name="l01076"></a>01076     m_unsafe_rollback_flags|= DROPPED_TEMP_TABLE;
<a name="l01077"></a>01077   }
<a name="l01078"></a>01078   <span class="keywordtype">bool</span> has_dropped_temp_table()<span class="keyword"> const</span>
<a name="l01079"></a>01079 <span class="keyword">  </span>{
<a name="l01080"></a>01080     <span class="keywordflow">return</span> m_unsafe_rollback_flags &amp; DROPPED_TEMP_TABLE;
<a name="l01081"></a>01081   }
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <span class="keywordtype">void</span> reset()
<a name="l01084"></a>01084   {
<a name="l01085"></a>01085     no_2pc= FALSE;
<a name="l01086"></a>01086     rw_ha_count= 0;
<a name="l01087"></a>01087     reset_unsafe_rollback_flags();
<a name="l01088"></a>01088   }
<a name="l01089"></a>01089   <span class="keywordtype">bool</span> is_empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ha_list == NULL; }
<a name="l01090"></a>01090 };
<a name="l01091"></a>01091 
<a name="l01109"></a>01109 <span class="keyword">class </span>Ha_trx_info
<a name="l01110"></a>01110 {
<a name="l01111"></a>01111 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l01112"></a>01112 <span class="preprocessor"></span>  <span class="keyword">friend</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *
<a name="l01113"></a>01113   ha_list_names(Ha_trx_info *ha_list, <span class="keywordtype">char</span> *<span class="keyword">const</span> buf_arg)
<a name="l01114"></a>01114   {
<a name="l01115"></a>01115     <span class="keywordtype">char</span> *buf = buf_arg;
<a name="l01116"></a>01116     <span class="keywordflow">while</span> (ha_list)
<a name="l01117"></a>01117     {
<a name="l01118"></a>01118       buf += sprintf(buf, <span class="stringliteral">&quot;%s&quot;</span>, ha_legacy_type_name(ha_list-&gt;m_ht-&gt;db_type));
<a name="l01119"></a>01119       ha_list = ha_list-&gt;m_next;
<a name="l01120"></a>01120       <span class="keywordflow">if</span> (ha_list)
<a name="l01121"></a>01121         buf += sprintf(buf, <span class="stringliteral">&quot;, &quot;</span>);
<a name="l01122"></a>01122     }
<a name="l01123"></a>01123     <span class="keywordflow">if</span> (buf == buf_arg)
<a name="l01124"></a>01124       sprintf(buf, <span class="stringliteral">&quot;&lt;NONE&gt;&quot;</span>);
<a name="l01125"></a>01125     <span class="keywordflow">return</span> buf_arg;
<a name="l01126"></a>01126   }
<a name="l01127"></a>01127 <span class="preprocessor">#endif</span>
<a name="l01128"></a>01128 <span class="preprocessor"></span>
<a name="l01129"></a>01129 <span class="keyword">public</span>:
<a name="l01131"></a>01131   <span class="keywordtype">void</span> register_ha(THD_TRANS *trans, <a class="code" href="structhandlerton.html">handlerton</a> *ht_arg)
<a name="l01132"></a>01132   {
<a name="l01133"></a>01133     DBUG_ENTER(<span class="stringliteral">&quot;Ha_trx_info::register_ha&quot;</span>);
<a name="l01134"></a>01134     DBUG_PRINT(<span class="stringliteral">&quot;enter&quot;</span>, (<span class="stringliteral">&quot;trans: 0x%llx, ht: 0x%llx (%s)&quot;</span>,
<a name="l01135"></a>01135                          (ulonglong) trans, (ulonglong) ht_arg,
<a name="l01136"></a>01136                          ha_legacy_type_name(ht_arg-&gt;db_type)));
<a name="l01137"></a>01137     DBUG_ASSERT(m_flags == 0);
<a name="l01138"></a>01138     DBUG_ASSERT(m_ht == NULL);
<a name="l01139"></a>01139     DBUG_ASSERT(m_next == NULL);
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     m_ht= ht_arg;
<a name="l01142"></a>01142     m_flags= (int) TRX_READ_ONLY; <span class="comment">/* Assume read-only at start. */</span>
<a name="l01143"></a>01143 
<a name="l01144"></a>01144     m_next= trans-&gt;ha_list;
<a name="l01145"></a>01145     trans-&gt;ha_list= <span class="keyword">this</span>;
<a name="l01146"></a>01146     DBUG_VOID_RETURN;
<a name="l01147"></a>01147   }
<a name="l01148"></a>01148 
<a name="l01150"></a>01150   <span class="keywordtype">void</span> reset()
<a name="l01151"></a>01151   {
<a name="l01152"></a>01152     DBUG_ENTER(<span class="stringliteral">&quot;Ha_trx_info::reset&quot;</span>);
<a name="l01153"></a>01153     m_next= NULL;
<a name="l01154"></a>01154     m_ht= NULL;
<a name="l01155"></a>01155     m_flags= 0;
<a name="l01156"></a>01156     DBUG_VOID_RETURN;
<a name="l01157"></a>01157   }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159   Ha_trx_info() { reset(); }
<a name="l01160"></a>01160 
<a name="l01161"></a>01161   <span class="keywordtype">void</span> set_trx_read_write()
<a name="l01162"></a>01162   {
<a name="l01163"></a>01163     DBUG_ASSERT(is_started());
<a name="l01164"></a>01164     m_flags|= (int) TRX_READ_WRITE;
<a name="l01165"></a>01165   }
<a name="l01166"></a>01166   <span class="keywordtype">bool</span> is_trx_read_write()<span class="keyword"> const</span>
<a name="l01167"></a>01167 <span class="keyword">  </span>{
<a name="l01168"></a>01168     DBUG_ASSERT(is_started());
<a name="l01169"></a>01169     <span class="keywordflow">return</span> m_flags &amp; (int) TRX_READ_WRITE;
<a name="l01170"></a>01170   }
<a name="l01171"></a>01171   <span class="keywordtype">bool</span> is_started()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_ht != NULL; }
<a name="l01173"></a>01173   <span class="keywordtype">void</span> coalesce_trx_with(<span class="keyword">const</span> Ha_trx_info *stmt_trx)
<a name="l01174"></a>01174   {
<a name="l01175"></a>01175     <span class="comment">/*</span>
<a name="l01176"></a>01176 <span class="comment">      Must be called only after the transaction has been started.</span>
<a name="l01177"></a>01177 <span class="comment">      Can be called many times, e.g. when we have many</span>
<a name="l01178"></a>01178 <span class="comment">      read-write statements in a transaction.</span>
<a name="l01179"></a>01179 <span class="comment">    */</span>
<a name="l01180"></a>01180     DBUG_ASSERT(is_started());
<a name="l01181"></a>01181     <span class="keywordflow">if</span> (stmt_trx-&gt;is_trx_read_write())
<a name="l01182"></a>01182       set_trx_read_write();
<a name="l01183"></a>01183   }
<a name="l01184"></a>01184   Ha_trx_info *next()<span class="keyword"> const</span>
<a name="l01185"></a>01185 <span class="keyword">  </span>{
<a name="l01186"></a>01186     DBUG_ASSERT(is_started());
<a name="l01187"></a>01187     <span class="keywordflow">return</span> m_next;
<a name="l01188"></a>01188   }
<a name="l01189"></a>01189   <a class="code" href="structhandlerton.html">handlerton</a> *ht()<span class="keyword"> const</span>
<a name="l01190"></a>01190 <span class="keyword">  </span>{
<a name="l01191"></a>01191     DBUG_ASSERT(is_started());
<a name="l01192"></a>01192     <span class="keywordflow">return</span> m_ht;
<a name="l01193"></a>01193   }
<a name="l01194"></a>01194 <span class="keyword">private</span>:
<a name="l01195"></a>01195   <span class="keyword">enum</span> { TRX_READ_ONLY= 0, TRX_READ_WRITE= 1 };
<a name="l01197"></a>01197   Ha_trx_info *m_next;
<a name="l01203"></a>01203   <a class="code" href="structhandlerton.html">handlerton</a> *m_ht;
<a name="l01209"></a>01209   uchar       m_flags;
<a name="l01210"></a>01210 };
<a name="l01211"></a>01211 
<a name="l01212"></a>01212 <span class="keyword">struct </span>st_savepoint {
<a name="l01213"></a>01213   <span class="keyword">struct </span>st_savepoint *prev;
<a name="l01214"></a>01214   <span class="keywordtype">char</span>                *name;
<a name="l01215"></a>01215   uint                 length;
<a name="l01216"></a>01216   Ha_trx_info         *ha_list;
<a name="l01218"></a>01218   <a class="code" href="classMDL__savepoint.html">MDL_savepoint</a>        mdl_savepoint;
<a name="l01219"></a>01219 };
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 <span class="keyword">enum</span> xa_states {XA_NOTR=0, XA_ACTIVE, XA_IDLE, XA_PREPARED, XA_ROLLBACK_ONLY};
<a name="l01222"></a>01222 <span class="keyword">extern</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *xa_state_names[];
<a name="l01223"></a>01223 
<a name="l01224"></a>01224 <span class="keyword">typedef</span> <span class="keyword">struct </span>st_xid_state {
<a name="l01225"></a>01225   <span class="comment">/* For now, this is only used to catch duplicated external xids */</span>
<a name="l01226"></a>01226   <a class="code" href="structxid__t.html">XID</a>  xid;                           <span class="comment">// transaction identifier</span>
<a name="l01227"></a>01227   <span class="keyword">enum</span> xa_states xa_state;            <span class="comment">// used by external XA only</span>
<a name="l01228"></a>01228   <span class="keywordtype">bool</span> in_thd;
<a name="l01229"></a>01229   <span class="comment">/* Error reported by the Resource Manager (RM) to the Transaction Manager. */</span>
<a name="l01230"></a>01230   uint rm_error;
<a name="l01231"></a>01231 } XID_STATE;
<a name="l01232"></a>01232 
<a name="l01233"></a>01233 <span class="keyword">extern</span> mysql_mutex_t LOCK_xid_cache;
<a name="l01234"></a>01234 <span class="keyword">extern</span> HASH xid_cache;
<a name="l01235"></a>01235 <span class="keywordtype">bool</span> xid_cache_init(<span class="keywordtype">void</span>);
<a name="l01236"></a>01236 <span class="keywordtype">void</span> xid_cache_free(<span class="keywordtype">void</span>);
<a name="l01237"></a>01237 XID_STATE *xid_cache_search(<a class="code" href="structxid__t.html">XID</a> *xid);
<a name="l01238"></a>01238 <span class="keywordtype">bool</span> xid_cache_insert(<a class="code" href="structxid__t.html">XID</a> *xid, <span class="keyword">enum</span> xa_states xa_state);
<a name="l01239"></a>01239 <span class="keywordtype">bool</span> xid_cache_insert(XID_STATE *xid_state);
<a name="l01240"></a>01240 <span class="keywordtype">void</span> xid_cache_delete(XID_STATE *xid_state);
<a name="l01241"></a>01241 
<a name="l01247"></a>01247 <span class="keyword">class </span>Security_context {
<a name="l01248"></a>01248 <span class="keyword">private</span>:
<a name="l01249"></a>01249 
<a name="l01250"></a>01250 <a class="code" href="classString.html">String</a> host;
<a name="l01251"></a>01251 <a class="code" href="classString.html">String</a> ip;
<a name="l01252"></a>01252 <a class="code" href="classString.html">String</a> external_user;
<a name="l01253"></a>01253 <span class="keyword">public</span>:
<a name="l01254"></a>01254   Security_context() {}                       <span class="comment">/* Remove gcc warning */</span>
<a name="l01255"></a>01255   <span class="comment">/*</span>
<a name="l01256"></a>01256 <span class="comment">    host - host of the client</span>
<a name="l01257"></a>01257 <span class="comment">    user - user of the client, set to NULL until the user has been read from</span>
<a name="l01258"></a>01258 <span class="comment">    the connection</span>
<a name="l01259"></a>01259 <span class="comment">    priv_user - The user privilege we are using. May be &quot;&quot; for anonymous user.</span>
<a name="l01260"></a>01260 <span class="comment">    ip - client IP</span>
<a name="l01261"></a>01261 <span class="comment">  */</span>
<a name="l01262"></a>01262   <span class="keywordtype">char</span>   *user;
<a name="l01263"></a>01263   <span class="keywordtype">char</span>   priv_user[USERNAME_LENGTH];
<a name="l01264"></a>01264   <span class="keywordtype">char</span>   proxy_user[USERNAME_LENGTH + MAX_HOSTNAME + 5];
<a name="l01265"></a>01265   <span class="comment">/* The host privilege we are using */</span>
<a name="l01266"></a>01266   <span class="keywordtype">char</span>   priv_host[MAX_HOSTNAME];
<a name="l01267"></a>01267   <span class="comment">/* points to host if host is available, otherwise points to ip */</span>
<a name="l01268"></a>01268   <span class="keyword">const</span> <span class="keywordtype">char</span> *host_or_ip;
<a name="l01269"></a>01269   ulong master_access;                 <span class="comment">/* Global privileges from mysql.user */</span>
<a name="l01270"></a>01270   ulong db_access;                     <span class="comment">/* Privileges for current db */</span>
<a name="l01271"></a>01271   <span class="comment">/*</span>
<a name="l01272"></a>01272 <span class="comment">    This flag is set according to connecting user&#39;s context and not the</span>
<a name="l01273"></a>01273 <span class="comment">    effective user.</span>
<a name="l01274"></a>01274 <span class="comment">  */</span>
<a name="l01275"></a>01275   <span class="keywordtype">bool</span> password_expired;               <span class="comment">/* password expiration flag */</span>
<a name="l01276"></a>01276 
<a name="l01277"></a>01277   <span class="keywordtype">void</span> init();
<a name="l01278"></a>01278   <span class="keywordtype">void</span> destroy();
<a name="l01279"></a>01279   <span class="keywordtype">void</span> skip_grants();
<a name="l01280"></a>01280   <span class="keyword">inline</span> <span class="keywordtype">char</span> *priv_host_name()
<a name="l01281"></a>01281   {
<a name="l01282"></a>01282     <span class="keywordflow">return</span> (*priv_host ? priv_host : (<span class="keywordtype">char</span> *)<span class="stringliteral">&quot;%&quot;</span>);
<a name="l01283"></a>01283   }
<a name="l01284"></a>01284   
<a name="l01285"></a>01285   <span class="keywordtype">bool</span> set_user(<span class="keywordtype">char</span> *user_arg);
<a name="l01286"></a>01286   <a class="code" href="classString.html">String</a> *get_host();
<a name="l01287"></a>01287   <a class="code" href="classString.html">String</a> *get_ip();
<a name="l01288"></a>01288   <a class="code" href="classString.html">String</a> *get_external_user();
<a name="l01289"></a>01289   <span class="keywordtype">void</span> set_host(<span class="keyword">const</span> <span class="keywordtype">char</span> *p);
<a name="l01290"></a>01290   <span class="keywordtype">void</span> set_ip(<span class="keyword">const</span> <span class="keywordtype">char</span> *p);
<a name="l01291"></a>01291   <span class="keywordtype">void</span> set_external_user(<span class="keyword">const</span> <span class="keywordtype">char</span> *p);
<a name="l01292"></a>01292   <span class="keywordtype">void</span> set_host(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">size_t</span> len);
<a name="l01293"></a>01293 <span class="preprocessor">#ifndef NO_EMBEDDED_ACCESS_CHECKS</span>
<a name="l01294"></a>01294 <span class="preprocessor"></span>  <span class="keywordtype">bool</span>
<a name="l01295"></a>01295   change_security_context(THD *thd,
<a name="l01296"></a>01296                           LEX_STRING *definer_user,
<a name="l01297"></a>01297                           LEX_STRING *definer_host,
<a name="l01298"></a>01298                           LEX_STRING *db,
<a name="l01299"></a>01299                           Security_context **backup);
<a name="l01300"></a>01300 
<a name="l01301"></a>01301   <span class="keywordtype">void</span>
<a name="l01302"></a>01302   restore_security_context(THD *thd, Security_context *backup);
<a name="l01303"></a>01303 <span class="preprocessor">#endif</span>
<a name="l01304"></a>01304 <span class="preprocessor"></span>  <span class="keywordtype">bool</span> user_matches(Security_context *);
<a name="l01305"></a>01305 };
<a name="l01306"></a>01306 
<a name="l01307"></a>01307 
<a name="l01313"></a>01313 <span class="keyword">class </span>Log_throttle
<a name="l01314"></a>01314 {
<a name="l01318"></a>01318   ulonglong window_end;
<a name="l01319"></a>01319 
<a name="l01324"></a>01324   <span class="keyword">const</span> ulong window_size;
<a name="l01325"></a>01325 
<a name="l01332"></a>01332   ulong count;
<a name="l01333"></a>01333 
<a name="l01334"></a>01334 <span class="keyword">protected</span>:
<a name="l01339"></a>01339   <span class="keyword">const</span> <span class="keywordtype">char</span> *summary_template;
<a name="l01340"></a>01340 
<a name="l01344"></a>01344   <span class="keywordtype">void</span> new_window(ulonglong now);
<a name="l01345"></a>01345 
<a name="l01354"></a>01354   <span class="keywordtype">bool</span> inc_log_count(ulong rate) { <span class="keywordflow">return</span> (++count &gt; rate); }
<a name="l01355"></a>01355 
<a name="l01361"></a>01361   <span class="keywordtype">bool</span> in_window(ulonglong now)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (now &lt; window_end); };
<a name="l01362"></a>01362 
<a name="l01373"></a>01373   ulong prepare_summary(ulong rate);
<a name="l01374"></a>01374 
<a name="l01379"></a>01379   Log_throttle(ulong window_usecs, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg)
<a name="l01380"></a>01380               : window_end(0), window_size(window_usecs),
<a name="l01381"></a>01381                 count(0), summary_template(msg)
<a name="l01382"></a>01382   {}
<a name="l01383"></a>01383 
<a name="l01384"></a>01384 <span class="keyword">public</span>:
<a name="l01389"></a>01389   <span class="keyword">static</span> <span class="keyword">const</span> ulong LOG_THROTTLE_WINDOW_SIZE= 60000000;
<a name="l01390"></a>01390 };
<a name="l01391"></a>01391 
<a name="l01392"></a>01392 
<a name="l01398"></a>01398 <span class="keyword">class </span>Slow_log_throttle : <span class="keyword">public</span> Log_throttle
<a name="l01399"></a>01399 {
<a name="l01400"></a>01400 <span class="keyword">private</span>:
<a name="l01407"></a>01407   Security_context aggregate_sctx;
<a name="l01408"></a>01408 
<a name="l01413"></a>01413   ulonglong total_exec_time;
<a name="l01414"></a>01414 
<a name="l01419"></a>01419   ulonglong total_lock_time;
<a name="l01420"></a>01420 
<a name="l01425"></a>01425   ulong *rate;
<a name="l01426"></a>01426 
<a name="l01431"></a>01431   bool (*log_summary)(THD *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, uint);
<a name="l01432"></a>01432 
<a name="l01436"></a>01436   mysql_mutex_t *LOCK_log_throttle;
<a name="l01437"></a>01437 
<a name="l01441"></a>01441   <span class="keywordtype">void</span> new_window(ulonglong now);
<a name="l01442"></a>01442 
<a name="l01446"></a>01446   <span class="keywordtype">void</span> print_summary(THD *thd, ulong suppressed,
<a name="l01447"></a>01447                      ulonglong print_lock_time,
<a name="l01448"></a>01448                      ulonglong print_exec_time);
<a name="l01449"></a>01449 
<a name="l01450"></a>01450 <span class="keyword">public</span>:
<a name="l01451"></a>01451 
<a name="l01458"></a>01458   Slow_log_throttle(ulong *threshold, mysql_mutex_t *lock, ulong window_usecs,
<a name="l01459"></a>01459                     <span class="keywordtype">bool</span> (*logger)(THD *, <span class="keyword">const</span> <span class="keywordtype">char</span> *, uint),
<a name="l01460"></a>01460                     <span class="keyword">const</span> <span class="keywordtype">char</span> *msg);
<a name="l01461"></a>01461 
<a name="l01475"></a>01475   <span class="keywordtype">bool</span> flush(THD *thd);
<a name="l01476"></a>01476 
<a name="l01484"></a>01484   <span class="keywordtype">bool</span> log(THD *thd, <span class="keywordtype">bool</span> eligible);
<a name="l01485"></a>01485 };
<a name="l01486"></a>01486 
<a name="l01487"></a>01487 
<a name="l01493"></a>01493 <span class="keyword">class </span>Error_log_throttle : <span class="keyword">public</span> Log_throttle
<a name="l01494"></a>01494 {
<a name="l01495"></a>01495 <span class="keyword">private</span>:
<a name="l01499"></a>01499   void (*log_summary)(<span class="keyword">const</span> <span class="keywordtype">char</span> *, ...);
<a name="l01500"></a>01500 
<a name="l01504"></a>01504   <span class="keywordtype">void</span> print_summary(ulong suppressed)
<a name="l01505"></a>01505   {
<a name="l01506"></a>01506     (*log_summary)(summary_template, suppressed);
<a name="l01507"></a>01507   }
<a name="l01508"></a>01508 
<a name="l01509"></a>01509 <span class="keyword">public</span>:
<a name="l01515"></a>01515   Error_log_throttle(ulong window_usecs,
<a name="l01516"></a>01516                      <span class="keywordtype">void</span> (*logger)(<span class="keyword">const</span> <span class="keywordtype">char</span>*, ...),
<a name="l01517"></a>01517                      <span class="keyword">const</span> <span class="keywordtype">char</span> *msg)
<a name="l01518"></a>01518   : Log_throttle(window_usecs, msg), log_summary(logger)
<a name="l01519"></a>01519   {}
<a name="l01520"></a>01520 
<a name="l01531"></a>01531   <span class="keywordtype">bool</span> flush(THD *thd);
<a name="l01532"></a>01532 
<a name="l01539"></a>01539   <span class="keywordtype">bool</span> log(THD *thd);
<a name="l01540"></a>01540 };
<a name="l01541"></a>01541 
<a name="l01542"></a>01542 
<a name="l01543"></a>01543 <span class="keyword">extern</span> Slow_log_throttle log_throttle_qni;
<a name="l01544"></a>01544 
<a name="l01545"></a>01545 
<a name="l01553"></a>01553 <span class="keyword">struct </span>Item_change_record: <span class="keyword">public</span> <a class="code" href="classilink.html">ilink</a>&lt;Item_change_record&gt;
<a name="l01554"></a>01554 {
<a name="l01555"></a>01555   <a class="code" href="classItem.html">Item</a> **place;
<a name="l01556"></a>01556   <a class="code" href="classItem.html">Item</a> *old_value;
<a name="l01557"></a>01557 };
<a name="l01558"></a>01558 
<a name="l01559"></a>01559 <span class="keyword">typedef</span> <a class="code" href="classI__List.html">I_List&lt;Item_change_record&gt;</a> Item_change_list;
<a name="l01560"></a>01560 
<a name="l01561"></a>01561 
<a name="l01567"></a>01567 <span class="keyword">enum</span> enum_locked_tables_mode
<a name="l01568"></a>01568 {
<a name="l01569"></a>01569   LTM_NONE= 0,
<a name="l01570"></a>01570   LTM_LOCK_TABLES,
<a name="l01571"></a>01571   LTM_PRELOCKED,
<a name="l01572"></a>01572   LTM_PRELOCKED_UNDER_LOCK_TABLES
<a name="l01573"></a>01573 };
<a name="l01574"></a>01574 
<a name="l01575"></a>01575 
<a name="l01582"></a>01582 <span class="keyword">class </span>Open_tables_state
<a name="l01583"></a>01583 {
<a name="l01584"></a>01584 <span class="keyword">private</span>:
<a name="l01605"></a>01605   <a class="code" href="classDynamic__array.html">Dynamic_array&lt;Reprepare_observer *&gt;</a> m_reprepare_observers;
<a name="l01606"></a>01606 
<a name="l01607"></a>01607 <span class="keyword">public</span>:
<a name="l01608"></a>01608   <a class="code" href="classReprepare__observer.html">Reprepare_observer</a> *get_reprepare_observer()<span class="keyword"> const</span>
<a name="l01609"></a>01609 <span class="keyword">  </span>{
<a name="l01610"></a>01610     <span class="keywordflow">return</span>
<a name="l01611"></a>01611       m_reprepare_observers.elements() &gt; 0 ?
<a name="l01612"></a>01612       *m_reprepare_observers.back() :
<a name="l01613"></a>01613       NULL;
<a name="l01614"></a>01614   }
<a name="l01615"></a>01615 
<a name="l01616"></a>01616   <span class="keywordtype">void</span> push_reprepare_observer(<a class="code" href="classReprepare__observer.html">Reprepare_observer</a> *o)
<a name="l01617"></a>01617   { m_reprepare_observers.append(o); }
<a name="l01618"></a>01618 
<a name="l01619"></a>01619   <a class="code" href="classReprepare__observer.html">Reprepare_observer</a> *pop_reprepare_observer()
<a name="l01620"></a>01620   { <span class="keywordflow">return</span> m_reprepare_observers.pop(); }
<a name="l01621"></a>01621 
<a name="l01622"></a>01622   <span class="keywordtype">void</span> reset_reprepare_observers()
<a name="l01623"></a>01623   { m_reprepare_observers.clear(); }
<a name="l01624"></a>01624 
<a name="l01625"></a>01625 <span class="keyword">public</span>:
<a name="l01630"></a>01630   <a class="code" href="structTABLE.html">TABLE</a> *<a class="code" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables</a>;
<a name="l01638"></a>01638   <a class="code" href="structTABLE.html">TABLE</a> *temporary_tables;
<a name="l01639"></a>01639   <a class="code" href="structTABLE.html">TABLE</a> *derived_tables;
<a name="l01640"></a>01640   <span class="comment">/*</span>
<a name="l01641"></a>01641 <span class="comment">    During a MySQL session, one can lock tables in two modes: automatic</span>
<a name="l01642"></a>01642 <span class="comment">    or manual. In automatic mode all necessary tables are locked just before</span>
<a name="l01643"></a>01643 <span class="comment">    statement execution, and all acquired locks are stored in &#39;lock&#39;</span>
<a name="l01644"></a>01644 <span class="comment">    member. Unlocking takes place automatically as well, when the</span>
<a name="l01645"></a>01645 <span class="comment">    statement ends.</span>
<a name="l01646"></a>01646 <span class="comment">    Manual mode comes into play when a user issues a &#39;LOCK TABLES&#39;</span>
<a name="l01647"></a>01647 <span class="comment">    statement. In this mode the user can only use the locked tables.</span>
<a name="l01648"></a>01648 <span class="comment">    Trying to use any other tables will give an error.</span>
<a name="l01649"></a>01649 <span class="comment">    The locked tables are also stored in this member, however,</span>
<a name="l01650"></a>01650 <span class="comment">    thd-&gt;locked_tables_mode is turned on.  Manual locking is described in</span>
<a name="l01651"></a>01651 <span class="comment">    the &#39;LOCK_TABLES&#39; chapter of the MySQL manual.</span>
<a name="l01652"></a>01652 <span class="comment">    See also lock_tables() for details.</span>
<a name="l01653"></a>01653 <span class="comment">  */</span>
<a name="l01654"></a>01654   <a class="code" href="structst__mysql__lock.html">MYSQL_LOCK</a> *lock;
<a name="l01655"></a>01655 
<a name="l01656"></a>01656   <span class="comment">/*</span>
<a name="l01657"></a>01657 <span class="comment">    CREATE-SELECT keeps an extra lock for the table being</span>
<a name="l01658"></a>01658 <span class="comment">    created. This field is used to keep the extra lock available for</span>
<a name="l01659"></a>01659 <span class="comment">    lower level routines, which would otherwise miss that lock.</span>
<a name="l01660"></a>01660 <span class="comment">   */</span>
<a name="l01661"></a>01661   <a class="code" href="structst__mysql__lock.html">MYSQL_LOCK</a> *extra_lock;
<a name="l01662"></a>01662 
<a name="l01663"></a>01663   <span class="comment">/*</span>
<a name="l01664"></a>01664 <span class="comment">    Enum enum_locked_tables_mode and locked_tables_mode member are</span>
<a name="l01665"></a>01665 <span class="comment">    used to indicate whether the so-called &quot;locked tables mode&quot; is on,</span>
<a name="l01666"></a>01666 <span class="comment">    and what kind of mode is active.</span>
<a name="l01667"></a>01667 <span class="comment"></span>
<a name="l01668"></a>01668 <span class="comment">    Locked tables mode is used when it&#39;s necessary to open and</span>
<a name="l01669"></a>01669 <span class="comment">    lock many tables at once, for usage across multiple</span>
<a name="l01670"></a>01670 <span class="comment">    (sub-)statements.</span>
<a name="l01671"></a>01671 <span class="comment">    This may be necessary either for queries that use stored functions</span>
<a name="l01672"></a>01672 <span class="comment">    and triggers, in which case the statements inside functions and</span>
<a name="l01673"></a>01673 <span class="comment">    triggers may be executed many times, or for implementation of</span>
<a name="l01674"></a>01674 <span class="comment">    LOCK TABLES, in which case the opened tables are reused by all</span>
<a name="l01675"></a>01675 <span class="comment">    subsequent statements until a call to UNLOCK TABLES.</span>
<a name="l01676"></a>01676 <span class="comment"></span>
<a name="l01677"></a>01677 <span class="comment">    The kind of locked tables mode employed for stored functions and</span>
<a name="l01678"></a>01678 <span class="comment">    triggers is also called &quot;prelocked mode&quot;.</span>
<a name="l01679"></a>01679 <span class="comment">    In this mode, first open_tables() call to open the tables used</span>
<a name="l01680"></a>01680 <span class="comment">    in a statement analyses all functions used by the statement</span>
<a name="l01681"></a>01681 <span class="comment">    and adds all indirectly used tables to the list of tables to</span>
<a name="l01682"></a>01682 <span class="comment">    open and lock.</span>
<a name="l01683"></a>01683 <span class="comment">    It also marks the parse tree of the statement as requiring</span>
<a name="l01684"></a>01684 <span class="comment">    prelocking. After that, lock_tables() locks the entire list</span>
<a name="l01685"></a>01685 <span class="comment">    of tables and changes THD::locked_tables_modeto LTM_PRELOCKED.</span>
<a name="l01686"></a>01686 <span class="comment">    All statements executed inside functions or triggers</span>
<a name="l01687"></a>01687 <span class="comment">    use the prelocked tables, instead of opening their own ones.</span>
<a name="l01688"></a>01688 <span class="comment">    Prelocked mode is turned off automatically once close_thread_tables()</span>
<a name="l01689"></a>01689 <span class="comment">    of the main statement is called.</span>
<a name="l01690"></a>01690 <span class="comment">  */</span>
<a name="l01691"></a>01691   <span class="keyword">enum</span> enum_locked_tables_mode locked_tables_mode;
<a name="l01692"></a>01692   uint current_tablenr;
<a name="l01693"></a>01693 
<a name="l01694"></a>01694   <span class="keyword">enum</span> enum_flags {
<a name="l01695"></a>01695     BACKUPS_AVAIL = (1U &lt;&lt; 0)     <span class="comment">/* There are backups available */</span>
<a name="l01696"></a>01696   };
<a name="l01697"></a>01697 
<a name="l01698"></a>01698   <span class="comment">/*</span>
<a name="l01699"></a>01699 <span class="comment">    Flags with information about the open tables state.</span>
<a name="l01700"></a>01700 <span class="comment">  */</span>
<a name="l01701"></a>01701   uint state_flags;
<a name="l01708"></a>01708   Open_tables_state() : state_flags(0U) { }
<a name="l01709"></a>01709 
<a name="l01710"></a>01710   <span class="keywordtype">void</span> set_open_tables_state(Open_tables_state *state);
<a name="l01711"></a>01711 
<a name="l01712"></a>01712   <span class="keywordtype">void</span> reset_open_tables_state();
<a name="l01713"></a>01713 };
<a name="l01714"></a>01714 
<a name="l01715"></a>01715 
<a name="l01722"></a>01722 <span class="keyword">class </span>Open_tables_backup: <span class="keyword">public</span> Open_tables_state
<a name="l01723"></a>01723 {
<a name="l01724"></a>01724 <span class="keyword">public</span>:
<a name="l01732"></a>01732   <a class="code" href="classMDL__savepoint.html">MDL_savepoint</a> mdl_system_tables_svp;
<a name="l01733"></a>01733 };
<a name="l01734"></a>01734 
<a name="l01740"></a>01740 <span class="comment">/* Defines used for Sub_statement_state::in_sub_stmt */</span>
<a name="l01741"></a>01741 
<a name="l01742"></a>01742 <span class="preprocessor">#define SUB_STMT_TRIGGER 1</span>
<a name="l01743"></a>01743 <span class="preprocessor"></span><span class="preprocessor">#define SUB_STMT_FUNCTION 2</span>
<a name="l01744"></a>01744 <span class="preprocessor"></span>
<a name="l01745"></a>01745 
<a name="l01746"></a>01746 <span class="keyword">class </span>Sub_statement_state
<a name="l01747"></a>01747 {
<a name="l01748"></a>01748 <span class="keyword">public</span>:
<a name="l01749"></a>01749   ulonglong option_bits;
<a name="l01750"></a>01750   ulonglong first_successful_insert_id_in_prev_stmt;
<a name="l01751"></a>01751   ulonglong first_successful_insert_id_in_cur_stmt, insert_id_for_cur_row;
<a name="l01752"></a>01752   <a class="code" href="classDiscrete__interval.html">Discrete_interval</a> auto_inc_interval_for_cur_row;
<a name="l01753"></a>01753   <a class="code" href="classDiscrete__intervals__list.html" title="List of Discrete_interval objects.">Discrete_intervals_list</a> auto_inc_intervals_forced;
<a name="l01754"></a>01754   ulonglong limit_found_rows;
<a name="l01755"></a>01755   ha_rows    cuted_fields, sent_row_count, examined_row_count;
<a name="l01756"></a>01756   ulong client_capabilities;
<a name="l01757"></a>01757   uint in_sub_stmt;
<a name="l01758"></a>01758   <span class="keywordtype">bool</span> enable_slow_log;
<a name="l01759"></a>01759   <span class="keywordtype">bool</span> last_insert_id_used;
<a name="l01760"></a>01760   SAVEPOINT *savepoints;
<a name="l01761"></a>01761   <span class="keyword">enum</span> enum_check_fields count_cuted_fields;
<a name="l01762"></a>01762 };
<a name="l01763"></a>01763 
<a name="l01764"></a>01764 
<a name="l01765"></a>01765 <span class="comment">/* Flags for the THD::system_thread variable */</span>
<a name="l01766"></a>01766 <span class="keyword">enum</span> enum_thread_type
<a name="l01767"></a>01767 {
<a name="l01768"></a>01768   NON_SYSTEM_THREAD= 0,
<a name="l01769"></a>01769   SYSTEM_THREAD_DELAYED_INSERT= 1,
<a name="l01770"></a>01770   SYSTEM_THREAD_SLAVE_IO= 2,
<a name="l01771"></a>01771   SYSTEM_THREAD_SLAVE_SQL= 4,
<a name="l01772"></a>01772   SYSTEM_THREAD_NDBCLUSTER_BINLOG= 8,
<a name="l01773"></a>01773   SYSTEM_THREAD_EVENT_SCHEDULER= 16,
<a name="l01774"></a>01774   SYSTEM_THREAD_EVENT_WORKER= 32,
<a name="l01775"></a>01775   SYSTEM_THREAD_INFO_REPOSITORY= 64,
<a name="l01776"></a>01776   SYSTEM_THREAD_SLAVE_WORKER= 128
<a name="l01777"></a>01777 };
<a name="l01778"></a>01778 
<a name="l01779"></a>01779 <span class="keyword">inline</span> <span class="keywordtype">char</span> <span class="keyword">const</span> *
<a name="l01780"></a>01780 show_system_thread(enum_thread_type thread)
<a name="l01781"></a>01781 {
<a name="l01782"></a>01782 <span class="preprocessor">#define RETURN_NAME_AS_STRING(NAME) case (NAME): return #NAME</span>
<a name="l01783"></a>01783 <span class="preprocessor"></span>  <span class="keywordflow">switch</span> (thread) {
<a name="l01784"></a>01784     <span class="keyword">static</span> <span class="keywordtype">char</span> buf[64];
<a name="l01785"></a>01785     RETURN_NAME_AS_STRING(NON_SYSTEM_THREAD);
<a name="l01786"></a>01786     RETURN_NAME_AS_STRING(SYSTEM_THREAD_DELAYED_INSERT);
<a name="l01787"></a>01787     RETURN_NAME_AS_STRING(SYSTEM_THREAD_SLAVE_IO);
<a name="l01788"></a>01788     RETURN_NAME_AS_STRING(SYSTEM_THREAD_SLAVE_SQL);
<a name="l01789"></a>01789     RETURN_NAME_AS_STRING(SYSTEM_THREAD_NDBCLUSTER_BINLOG);
<a name="l01790"></a>01790     RETURN_NAME_AS_STRING(SYSTEM_THREAD_EVENT_SCHEDULER);
<a name="l01791"></a>01791     RETURN_NAME_AS_STRING(SYSTEM_THREAD_EVENT_WORKER);
<a name="l01792"></a>01792     RETURN_NAME_AS_STRING(SYSTEM_THREAD_INFO_REPOSITORY);
<a name="l01793"></a>01793     RETURN_NAME_AS_STRING(SYSTEM_THREAD_SLAVE_WORKER);
<a name="l01794"></a>01794   <span class="keywordflow">default</span>:
<a name="l01795"></a>01795     sprintf(buf, <span class="stringliteral">&quot;&lt;UNKNOWN SYSTEM THREAD: %d&gt;&quot;</span>, thread);
<a name="l01796"></a>01796     <span class="keywordflow">return</span> buf;
<a name="l01797"></a>01797   }
<a name="l01798"></a>01798 <span class="preprocessor">#undef RETURN_NAME_AS_STRING</span>
<a name="l01799"></a>01799 <span class="preprocessor"></span>}
<a name="l01800"></a>01800 
<a name="l01806"></a>01806 <span class="keyword">class </span>Internal_error_handler
<a name="l01807"></a>01807 {
<a name="l01808"></a>01808 <span class="keyword">protected</span>:
<a name="l01809"></a>01809   Internal_error_handler() :
<a name="l01810"></a>01810     m_prev_internal_handler(NULL)
<a name="l01811"></a>01811   {}
<a name="l01812"></a>01812 
<a name="l01813"></a>01813   <span class="keyword">virtual</span> ~Internal_error_handler() {}
<a name="l01814"></a>01814 
<a name="l01815"></a>01815 <span class="keyword">public</span>:
<a name="l01840"></a>01840   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> handle_condition(THD *thd,
<a name="l01841"></a>01841                                 uint sql_errno,
<a name="l01842"></a>01842                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* sqlstate,
<a name="l01843"></a>01843                                 Sql_condition::enum_warning_level level,
<a name="l01844"></a>01844                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* msg,
<a name="l01845"></a>01845                                 <a class="code" href="classSql__condition.html">Sql_condition</a> ** cond_hdl) = 0;
<a name="l01846"></a>01846 
<a name="l01847"></a>01847 <span class="keyword">private</span>:
<a name="l01848"></a>01848   Internal_error_handler *m_prev_internal_handler;
<a name="l01849"></a>01849   <span class="keyword">friend</span> <span class="keyword">class </span>THD;
<a name="l01850"></a>01850 };
<a name="l01851"></a>01851 
<a name="l01852"></a>01852 
<a name="l01858"></a>01858 <span class="keyword">class </span>Dummy_error_handler : <span class="keyword">public</span> Internal_error_handler
<a name="l01859"></a>01859 {
<a name="l01860"></a>01860 <span class="keyword">public</span>:
<a name="l01861"></a>01861   <span class="keywordtype">bool</span> handle_condition(THD *thd,
<a name="l01862"></a>01862                         uint sql_errno,
<a name="l01863"></a>01863                         <span class="keyword">const</span> <span class="keywordtype">char</span>* sqlstate,
<a name="l01864"></a>01864                         Sql_condition::enum_warning_level level,
<a name="l01865"></a>01865                         <span class="keyword">const</span> <span class="keywordtype">char</span>* msg,
<a name="l01866"></a>01866                         <a class="code" href="classSql__condition.html">Sql_condition</a> ** cond_hdl)
<a name="l01867"></a>01867   {
<a name="l01868"></a>01868     <span class="comment">/* Ignore error */</span>
<a name="l01869"></a>01869     <span class="keywordflow">return</span> TRUE;
<a name="l01870"></a>01870   }
<a name="l01871"></a>01871 };
<a name="l01872"></a>01872 
<a name="l01873"></a>01873 
<a name="l01881"></a>01881 <span class="keyword">class </span>Drop_table_error_handler : <span class="keyword">public</span> Internal_error_handler
<a name="l01882"></a>01882 {
<a name="l01883"></a>01883 <span class="keyword">public</span>:
<a name="l01884"></a>01884   Drop_table_error_handler() {}
<a name="l01885"></a>01885 
<a name="l01886"></a>01886 <span class="keyword">public</span>:
<a name="l01887"></a>01887   <span class="keywordtype">bool</span> handle_condition(THD *thd,
<a name="l01888"></a>01888                         uint sql_errno,
<a name="l01889"></a>01889                         <span class="keyword">const</span> <span class="keywordtype">char</span>* sqlstate,
<a name="l01890"></a>01890                         Sql_condition::enum_warning_level level,
<a name="l01891"></a>01891                         <span class="keyword">const</span> <span class="keywordtype">char</span>* msg,
<a name="l01892"></a>01892                         <a class="code" href="classSql__condition.html">Sql_condition</a> ** cond_hdl);
<a name="l01893"></a>01893 
<a name="l01894"></a>01894 <span class="keyword">private</span>:
<a name="l01895"></a>01895 };
<a name="l01896"></a>01896 
<a name="l01897"></a>01897 
<a name="l01923"></a>01923 <span class="keyword">class </span>Locked_tables_list
<a name="l01924"></a>01924 {
<a name="l01925"></a>01925 <span class="keyword">private</span>:
<a name="l01926"></a>01926   MEM_ROOT m_locked_tables_root;
<a name="l01927"></a>01927   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *m_locked_tables;
<a name="l01928"></a>01928   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> **m_locked_tables_last;
<a name="l01930"></a>01930   <a class="code" href="structTABLE.html">TABLE</a> **m_reopen_array;
<a name="l01937"></a>01937   <span class="keywordtype">size_t</span> m_locked_tables_count;
<a name="l01938"></a>01938 <span class="keyword">public</span>:
<a name="l01939"></a>01939   Locked_tables_list()
<a name="l01940"></a>01940     :m_locked_tables(NULL),
<a name="l01941"></a>01941     m_locked_tables_last(&amp;m_locked_tables),
<a name="l01942"></a>01942     m_reopen_array(NULL),
<a name="l01943"></a>01943     m_locked_tables_count(0)
<a name="l01944"></a>01944   {
<a name="l01945"></a>01945     init_sql_alloc(&amp;m_locked_tables_root, MEM_ROOT_BLOCK_SIZE, 0);
<a name="l01946"></a>01946   }
<a name="l01947"></a>01947   <span class="keywordtype">void</span> unlock_locked_tables(THD *thd);
<a name="l01948"></a>01948   ~Locked_tables_list()
<a name="l01949"></a>01949   {
<a name="l01950"></a>01950     unlock_locked_tables(0);
<a name="l01951"></a>01951   }
<a name="l01952"></a>01952   <span class="keywordtype">bool</span> init_locked_tables(THD *thd);
<a name="l01953"></a>01953   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *locked_tables() { <span class="keywordflow">return</span> m_locked_tables; }
<a name="l01954"></a>01954   <span class="keywordtype">void</span> unlink_from_list(THD *thd, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list,
<a name="l01955"></a>01955                         <span class="keywordtype">bool</span> remove_from_locked_tables);
<a name="l01956"></a>01956   <span class="keywordtype">void</span> unlink_all_closed_tables(THD *thd,
<a name="l01957"></a>01957                                 <a class="code" href="structst__mysql__lock.html">MYSQL_LOCK</a> *lock,
<a name="l01958"></a>01958                                 <span class="keywordtype">size_t</span> reopen_count);
<a name="l01959"></a>01959   <span class="keywordtype">bool</span> reopen_tables(THD *thd);
<a name="l01960"></a>01960 };
<a name="l01961"></a>01961 
<a name="l01962"></a>01962 
<a name="l01967"></a>01967 <span class="keyword">struct </span>Ha_data
<a name="l01968"></a>01968 {
<a name="l01973"></a>01973   <span class="keywordtype">void</span> *ha_ptr;
<a name="l01984"></a>01984   Ha_trx_info ha_info[2];
<a name="l01989"></a>01989   <a class="code" href="structst__plugin__int.html">plugin_ref</a> lock;
<a name="l01990"></a>01990   Ha_data() :ha_ptr(NULL) {}
<a name="l01991"></a>01991 };
<a name="l01992"></a>01992 
<a name="l01998"></a>01998 <span class="keyword">class </span>Global_read_lock
<a name="l01999"></a>01999 {
<a name="l02000"></a>02000 <span class="keyword">public</span>:
<a name="l02001"></a>02001   <span class="keyword">enum</span> enum_grl_state
<a name="l02002"></a>02002   {
<a name="l02003"></a>02003     GRL_NONE,
<a name="l02004"></a>02004     GRL_ACQUIRED,
<a name="l02005"></a>02005     GRL_ACQUIRED_AND_BLOCKS_COMMIT
<a name="l02006"></a>02006   };
<a name="l02007"></a>02007 
<a name="l02008"></a>02008   Global_read_lock()
<a name="l02009"></a>02009     : m_state(GRL_NONE),
<a name="l02010"></a>02010       m_mdl_global_shared_lock(NULL),
<a name="l02011"></a>02011       m_mdl_blocks_commits_lock(NULL)
<a name="l02012"></a>02012   {}
<a name="l02013"></a>02013 
<a name="l02014"></a>02014   <span class="keywordtype">bool</span> lock_global_read_lock(THD *thd);
<a name="l02015"></a>02015   <span class="keywordtype">void</span> unlock_global_read_lock(THD *thd);
<a name="l02016"></a>02016 
<a name="l02021"></a>02021   <span class="keyword">static</span> <span class="keywordtype">bool</span> global_read_lock_active()
<a name="l02022"></a>02022   {
<a name="l02023"></a>02023     <span class="keywordflow">return</span> my_atomic_load32(&amp;m_active_requests) ? <span class="keyword">true</span> : <span class="keyword">false</span>;
<a name="l02024"></a>02024   }
<a name="l02025"></a>02025 
<a name="l02030"></a>02030   <span class="keywordtype">bool</span> can_acquire_protection()<span class="keyword"> const</span>
<a name="l02031"></a>02031 <span class="keyword">  </span>{
<a name="l02032"></a>02032     <span class="keywordflow">if</span> (m_state)
<a name="l02033"></a>02033     {
<a name="l02034"></a>02034       my_error(ER_CANT_UPDATE_WITH_READLOCK, MYF(0));
<a name="l02035"></a>02035       <span class="keywordflow">return</span> TRUE;
<a name="l02036"></a>02036     }
<a name="l02037"></a>02037     <span class="keywordflow">return</span> FALSE;
<a name="l02038"></a>02038   }
<a name="l02039"></a>02039   <span class="keywordtype">bool</span> make_global_read_lock_block_commit(THD *thd);
<a name="l02040"></a>02040   <span class="keywordtype">bool</span> is_acquired()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_state != GRL_NONE; }
<a name="l02041"></a>02041   <span class="keywordtype">void</span> set_explicit_lock_duration(THD *thd);
<a name="l02042"></a>02042 <span class="keyword">private</span>:
<a name="l02043"></a>02043   <span class="keyword">volatile</span> <span class="keyword">static</span> int32 m_active_requests;
<a name="l02044"></a>02044   enum_grl_state m_state;
<a name="l02050"></a>02050   <a class="code" href="classMDL__ticket.html">MDL_ticket</a> *m_mdl_global_shared_lock;
<a name="l02056"></a>02056   <a class="code" href="classMDL__ticket.html">MDL_ticket</a> *m_mdl_blocks_commits_lock;
<a name="l02057"></a>02057 };
<a name="l02058"></a>02058 
<a name="l02059"></a>02059 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> my_message_sql(uint error, <span class="keyword">const</span> <span class="keywordtype">char</span> *str, myf MyFlags);
<a name="l02060"></a>02060 
<a name="l02061"></a>02061 
<a name="l02062"></a>02062 <span class="comment">/*</span>
<a name="l02063"></a>02063 <span class="comment">  Convert microseconds since epoch to timeval.</span>
<a name="l02064"></a>02064 <span class="comment">  @param     micro_time  Microseconds.</span>
<a name="l02065"></a>02065 <span class="comment">  @param OUT tm          A timeval variable to write to.</span>
<a name="l02066"></a>02066 <span class="comment">*/</span>
<a name="l02067"></a>02067 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l02068"></a>02068 my_micro_time_to_timeval(ulonglong micro_time, <span class="keyword">struct</span> timeval *tm)
<a name="l02069"></a>02069 {
<a name="l02070"></a>02070   tm-&gt;tv_sec=  (long) (micro_time / 1000000);
<a name="l02071"></a>02071   tm-&gt;tv_usec= (long) (micro_time % 1000000);
<a name="l02072"></a>02072 }
<a name="l02073"></a>02073 
<a name="l02080"></a>02080 <span class="keyword">class </span>THD :<span class="keyword">public</span> <a class="code" href="classMDL__context__owner.html">MDL_context_owner</a>,
<a name="l02081"></a>02081            <span class="keyword">public</span> Statement,
<a name="l02082"></a>02082            <span class="keyword">public</span> Open_tables_state
<a name="l02083"></a>02083 {
<a name="l02084"></a>02084 <span class="keyword">private</span>:
<a name="l02085"></a>02085   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_stmt_prepare()<span class="keyword"> const</span>
<a name="l02086"></a>02086 <span class="keyword">  </span>{ DBUG_ASSERT(0); <span class="keywordflow">return</span> Statement::is_stmt_prepare(); }
<a name="l02087"></a>02087 
<a name="l02088"></a>02088   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_stmt_prepare_or_first_sp_execute()<span class="keyword"> const</span>
<a name="l02089"></a>02089 <span class="keyword">  </span>{ DBUG_ASSERT(0); <span class="keywordflow">return</span> Statement::is_stmt_prepare_or_first_sp_execute(); }
<a name="l02090"></a>02090 
<a name="l02091"></a>02091   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_stmt_prepare_or_first_stmt_execute()<span class="keyword"> const</span>
<a name="l02092"></a>02092 <span class="keyword">  </span>{ DBUG_ASSERT(0); <span class="keywordflow">return</span> Statement::is_stmt_prepare_or_first_stmt_execute(); }
<a name="l02093"></a>02093 
<a name="l02094"></a>02094   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_conventional()<span class="keyword"> const</span>
<a name="l02095"></a>02095 <span class="keyword">  </span>{ DBUG_ASSERT(0); <span class="keywordflow">return</span> Statement::is_conventional(); }
<a name="l02096"></a>02096 
<a name="l02097"></a>02097 <span class="keyword">public</span>:
<a name="l02098"></a>02098   <a class="code" href="classMDL__context.html">MDL_context</a> mdl_context;
<a name="l02099"></a>02099 
<a name="l02100"></a>02100   <span class="comment">/* Used to execute base64 coded binlog events in MySQL server */</span>
<a name="l02101"></a>02101   <a class="code" href="classRelay__log__info.html">Relay_log_info</a>* rli_fake;
<a name="l02102"></a>02102   <span class="comment">/* Slave applier execution context */</span>
<a name="l02103"></a>02103   <a class="code" href="classRelay__log__info.html">Relay_log_info</a>* rli_slave;
<a name="l02104"></a>02104 
<a name="l02105"></a>02105   <span class="keywordtype">void</span> reset_for_next_command();
<a name="l02106"></a>02106   <span class="comment">/*</span>
<a name="l02107"></a>02107 <span class="comment">    Constant for THD::where initialization in the beginning of every query.</span>
<a name="l02108"></a>02108 <span class="comment"></span>
<a name="l02109"></a>02109 <span class="comment">    It&#39;s needed because we do not save/restore THD::where normally during</span>
<a name="l02110"></a>02110 <span class="comment">    primary (non subselect) query execution.</span>
<a name="l02111"></a>02111 <span class="comment">  */</span>
<a name="l02112"></a>02112   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> DEFAULT_WHERE;
<a name="l02113"></a>02113 
<a name="l02114"></a>02114 <span class="preprocessor">#ifdef EMBEDDED_LIBRARY</span>
<a name="l02115"></a>02115 <span class="preprocessor"></span>  <span class="keyword">struct </span>st_mysql  *mysql;
<a name="l02116"></a>02116   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  client_stmt_id;
<a name="l02117"></a>02117   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>  client_param_count;
<a name="l02118"></a>02118   <span class="keyword">struct </span>st_mysql_bind *client_params;
<a name="l02119"></a>02119   <span class="keywordtype">char</span> *extra_data;
<a name="l02120"></a>02120   ulong extra_length;
<a name="l02121"></a>02121   <span class="keyword">struct </span>st_mysql_data *cur_data;
<a name="l02122"></a>02122   <span class="keyword">struct </span>st_mysql_data *first_data;
<a name="l02123"></a>02123   <span class="keyword">struct </span>st_mysql_data **data_tail;
<a name="l02124"></a>02124   <span class="keywordtype">void</span> clear_data_list();
<a name="l02125"></a>02125   <span class="keyword">struct </span>st_mysql_data *alloc_new_dataset();
<a name="l02126"></a>02126   <span class="comment">/*</span>
<a name="l02127"></a>02127 <span class="comment">    In embedded server it points to the statement that is processed</span>
<a name="l02128"></a>02128 <span class="comment">    in the current query. We store some results directly in statement</span>
<a name="l02129"></a>02129 <span class="comment">    fields then.</span>
<a name="l02130"></a>02130 <span class="comment">  */</span>
<a name="l02131"></a>02131   <span class="keyword">struct </span>st_mysql_stmt *current_stmt;
<a name="l02132"></a>02132 <span class="preprocessor">#endif</span>
<a name="l02133"></a>02133 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_QUERY_CACHE</span>
<a name="l02134"></a>02134 <span class="preprocessor"></span>  <a class="code" href="structQuery__cache__tls.html">Query_cache_tls</a> query_cache_tls;
<a name="l02135"></a>02135 <span class="preprocessor">#endif</span>
<a name="l02136"></a>02136 <span class="preprocessor"></span>  NET     net;                          <span class="comment">// client connection descriptor</span>
<a name="l02138"></a>02138 <span class="comment"></span>  NET_SERVER m_net_server_extension;
<a name="l02139"></a>02139   <a class="code" href="classProtocol.html">Protocol</a> *protocol;                   <span class="comment">// Current protocol</span>
<a name="l02140"></a>02140   <a class="code" href="classProtocol__text.html">Protocol_text</a>   protocol_text;        <span class="comment">// Normal protocol</span>
<a name="l02141"></a>02141   <a class="code" href="classProtocol__binary.html">Protocol_binary</a> protocol_binary;      <span class="comment">// Binary protocol</span>
<a name="l02142"></a>02142   HASH    user_vars;                    <span class="comment">// hash for user variables</span>
<a name="l02143"></a>02143   <a class="code" href="classString.html">String</a>  packet;                       <span class="comment">// dynamic buffer for network I/O</span>
<a name="l02144"></a>02144   <a class="code" href="classString.html">String</a>  convert_buffer;               <span class="comment">// buffer for charset conversions</span>
<a name="l02145"></a>02145   <span class="keyword">struct  </span>rand_struct rand;             <span class="comment">// used for authentication</span>
<a name="l02146"></a>02146   <span class="keyword">struct  </span><a class="code" href="structsystem__variables.html">system_variables</a> variables;   <span class="comment">// Changeable local variables</span>
<a name="l02147"></a>02147   <span class="keyword">struct  </span><a class="code" href="structsystem__status__var.html">system_status_var</a> status_var; <span class="comment">// Per thread statistic vars</span>
<a name="l02148"></a>02148   <span class="keyword">struct  </span><a class="code" href="structsystem__status__var.html">system_status_var</a> *initial_status_var; <span class="comment">/* used by show status */</span>
<a name="l02149"></a>02149   THR_LOCK_INFO lock_info;              <span class="comment">// Locking info of this thread</span>
<a name="l02157"></a>02157 <span class="comment"></span>  mysql_mutex_t LOCK_thd_data;
<a name="l02158"></a>02158 
<a name="l02159"></a>02159   <span class="comment">/* all prepared statements and cursors of this connection */</span>
<a name="l02160"></a>02160   Statement_map stmt_map;
<a name="l02161"></a>02161   <span class="comment">/*</span>
<a name="l02162"></a>02162 <span class="comment">    A pointer to the stack frame of handle_one_connection(),</span>
<a name="l02163"></a>02163 <span class="comment">    which is called first in the thread for handling a client</span>
<a name="l02164"></a>02164 <span class="comment">  */</span>
<a name="l02165"></a>02165   <span class="keywordtype">char</span>    *thread_stack;
<a name="l02166"></a>02166 
<a name="l02170"></a>02170   <span class="keywordtype">char</span> *catalog;
<a name="l02171"></a>02171 
<a name="l02185"></a>02185   Security_context main_security_ctx;
<a name="l02186"></a>02186   Security_context *security_ctx;
<a name="l02187"></a>02187 
<a name="l02188"></a>02188   <span class="comment">/*</span>
<a name="l02189"></a>02189 <span class="comment">    Points to info-string that we show in SHOW PROCESSLIST</span>
<a name="l02190"></a>02190 <span class="comment">    You are supposed to update thd-&gt;proc_info only if you have coded</span>
<a name="l02191"></a>02191 <span class="comment">    a time-consuming piece that MySQL can get stuck in for a long time.</span>
<a name="l02192"></a>02192 <span class="comment"></span>
<a name="l02193"></a>02193 <span class="comment">    Set it using the  thd_proc_info(THD *thread, const char *message)</span>
<a name="l02194"></a>02194 <span class="comment">    macro/function.</span>
<a name="l02195"></a>02195 <span class="comment"></span>
<a name="l02196"></a>02196 <span class="comment">    This member is accessed and assigned without any synchronization.</span>
<a name="l02197"></a>02197 <span class="comment">    Therefore, it may point only to constant (statically</span>
<a name="l02198"></a>02198 <span class="comment">    allocated) strings, which memory won&#39;t go away over time.</span>
<a name="l02199"></a>02199 <span class="comment">  */</span>
<a name="l02200"></a>02200   <span class="keyword">const</span> <span class="keywordtype">char</span> *proc_info;
<a name="l02201"></a>02201 
<a name="l02202"></a>02202 <span class="keyword">private</span>:
<a name="l02203"></a>02203   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m_current_stage_key;
<a name="l02204"></a>02204 
<a name="l02205"></a>02205 <span class="keyword">public</span>:
<a name="l02206"></a>02206   <span class="keywordtype">void</span> enter_stage(<span class="keyword">const</span> PSI_stage_info *stage,
<a name="l02207"></a>02207                    PSI_stage_info *old_stage,
<a name="l02208"></a>02208                    <span class="keyword">const</span> <span class="keywordtype">char</span> *calling_func,
<a name="l02209"></a>02209                    <span class="keyword">const</span> <span class="keywordtype">char</span> *calling_file,
<a name="l02210"></a>02210                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> calling_line);
<a name="l02211"></a>02211 
<a name="l02212"></a>02212   <span class="keyword">const</span> <span class="keywordtype">char</span> *get_proc_info()<span class="keyword"> const</span>
<a name="l02213"></a>02213 <span class="keyword">  </span>{ <span class="keywordflow">return</span> proc_info; }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215   <span class="comment">/*</span>
<a name="l02216"></a>02216 <span class="comment">    Used in error messages to tell user in what part of MySQL we found an</span>
<a name="l02217"></a>02217 <span class="comment">    error. E. g. when where= &quot;having clause&quot;, if fix_fields() fails, user</span>
<a name="l02218"></a>02218 <span class="comment">    will know that the error was in having clause.</span>
<a name="l02219"></a>02219 <span class="comment">  */</span>
<a name="l02220"></a>02220   <span class="keyword">const</span> <span class="keywordtype">char</span> *where;
<a name="l02221"></a>02221 
<a name="l02222"></a>02222   ulong client_capabilities;            <span class="comment">/* What the client supports */</span>
<a name="l02223"></a>02223   ulong max_client_packet_length;
<a name="l02224"></a>02224 
<a name="l02225"></a>02225   HASH          handler_tables_hash;
<a name="l02226"></a>02226   <span class="comment">/*</span>
<a name="l02227"></a>02227 <span class="comment">    One thread can hold up to one named user-level lock. This variable</span>
<a name="l02228"></a>02228 <span class="comment">    points to a lock object if the lock is present. See item_func.cc and</span>
<a name="l02229"></a>02229 <span class="comment">    chapter &#39;Miscellaneous functions&#39;, for functions GET_LOCK, RELEASE_LOCK. </span>
<a name="l02230"></a>02230 <span class="comment">  */</span>
<a name="l02231"></a>02231   <a class="code" href="classUser__level__lock.html">User_level_lock</a> *ull;
<a name="l02232"></a>02232 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02233"></a>02233 <span class="preprocessor"></span>  uint dbug_sentry; <span class="comment">// watch out for memory corruption</span>
<a name="l02234"></a>02234 <span class="preprocessor">#endif</span>
<a name="l02235"></a>02235 <span class="preprocessor"></span>  <span class="keyword">struct </span>st_my_thread_var *mysys_var;
<a name="l02236"></a>02236 
<a name="l02237"></a>02237 <span class="keyword">private</span>:
<a name="l02242"></a>02242   <span class="keyword">enum</span> enum_server_command m_command;
<a name="l02243"></a>02243 
<a name="l02244"></a>02244 <span class="keyword">public</span>:
<a name="l02245"></a>02245   uint32     unmasked_server_id;
<a name="l02246"></a>02246   uint32     server_id;
<a name="l02247"></a>02247   uint32     file_id;                   <span class="comment">// for LOAD DATA INFILE</span>
<a name="l02248"></a>02248   <span class="comment">/* remote (peer) port */</span>
<a name="l02249"></a>02249   uint16 peer_port;
<a name="l02250"></a>02250   <span class="keyword">struct </span>timeval start_time;
<a name="l02251"></a>02251   <span class="keyword">struct </span>timeval user_time;
<a name="l02252"></a>02252   <span class="comment">// track down slow pthread_create</span>
<a name="l02253"></a>02253   ulonglong  prior_thr_create_utime, thr_create_utime;
<a name="l02254"></a>02254   ulonglong  start_utime, utime_after_lock;
<a name="l02255"></a>02255 
<a name="l02256"></a>02256   thr_lock_type update_lock_default;
<a name="l02257"></a>02257   <a class="code" href="classDelayed__insert.html">Delayed_insert</a> *di;
<a name="l02258"></a>02258 
<a name="l02259"></a>02259   <span class="comment">/* &lt;&gt; 0 if we are inside of trigger or stored function. */</span>
<a name="l02260"></a>02260   uint in_sub_stmt;
<a name="l02261"></a>02261 
<a name="l02270"></a>02270   uint fill_status_recursion_level;
<a name="l02271"></a>02271   uint fill_variables_recursion_level;
<a name="l02272"></a>02272 
<a name="l02273"></a>02273   <span class="comment">/* container for handler&#39;s private per-connection data */</span>
<a name="l02274"></a>02274   Ha_data ha_data[MAX_HA];
<a name="l02275"></a>02275 
<a name="l02276"></a>02276   <span class="comment">/*</span>
<a name="l02277"></a>02277 <span class="comment">    Position of first event in Binlog</span>
<a name="l02278"></a>02278 <span class="comment">    *after* last event written by this</span>
<a name="l02279"></a>02279 <span class="comment">    thread.</span>
<a name="l02280"></a>02280 <span class="comment">  */</span>
<a name="l02281"></a>02281   <a class="code" href="structevent__coordinates.html">event_coordinates</a> binlog_next_event_pos;
<a name="l02282"></a>02282   <span class="keywordtype">void</span> set_next_event_pos(<span class="keyword">const</span> <span class="keywordtype">char</span>* _filename, ulonglong _pos);
<a name="l02283"></a>02283   <span class="keywordtype">void</span> clear_next_event_pos();
<a name="l02284"></a>02284 
<a name="l02285"></a>02285   <span class="comment">/*</span>
<a name="l02286"></a>02286 <span class="comment">     Ptr to row event extra data to be written to Binlog /</span>
<a name="l02287"></a>02287 <span class="comment">     received from Binlog.</span>
<a name="l02288"></a>02288 <span class="comment"></span>
<a name="l02289"></a>02289 <span class="comment">   */</span>
<a name="l02290"></a>02290   uchar* binlog_row_event_extra_data;
<a name="l02291"></a>02291   <span class="keyword">static</span> <span class="keywordtype">bool</span> binlog_row_event_extra_data_eq(<span class="keyword">const</span> uchar* a,
<a name="l02292"></a>02292                                              <span class="keyword">const</span> uchar* b);
<a name="l02293"></a>02293 
<a name="l02294"></a>02294 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l02295"></a>02295 <span class="preprocessor"></span>  <span class="keywordtype">int</span> binlog_setup_trx_data();
<a name="l02296"></a>02296 
<a name="l02297"></a>02297   <span class="comment">/*</span>
<a name="l02298"></a>02298 <span class="comment">    Public interface to write RBR events to the binlog</span>
<a name="l02299"></a>02299 <span class="comment">  */</span>
<a name="l02300"></a>02300   <span class="keywordtype">int</span> binlog_write_table_map(<a class="code" href="structTABLE.html">TABLE</a> *table, <span class="keywordtype">bool</span> is_transactional,
<a name="l02301"></a>02301                              <span class="keywordtype">bool</span> binlog_rows_query);
<a name="l02302"></a>02302   <span class="keywordtype">int</span> binlog_write_row(<a class="code" href="structTABLE.html">TABLE</a>* table, <span class="keywordtype">bool</span> is_transactional,
<a name="l02303"></a>02303                        <span class="keyword">const</span> uchar *new_data,
<a name="l02304"></a>02304                        <span class="keyword">const</span> uchar* extra_row_info);
<a name="l02305"></a>02305   <span class="keywordtype">int</span> binlog_delete_row(<a class="code" href="structTABLE.html">TABLE</a>* table, <span class="keywordtype">bool</span> is_transactional,
<a name="l02306"></a>02306                         <span class="keyword">const</span> uchar *old_data,
<a name="l02307"></a>02307                         <span class="keyword">const</span> uchar* extra_row_info);
<a name="l02308"></a>02308   <span class="keywordtype">int</span> binlog_update_row(<a class="code" href="structTABLE.html">TABLE</a>* table, <span class="keywordtype">bool</span> is_transactional,
<a name="l02309"></a>02309                         <span class="keyword">const</span> uchar *old_data, <span class="keyword">const</span> uchar *new_data,
<a name="l02310"></a>02310                         <span class="keyword">const</span> uchar* extra_row_info);
<a name="l02311"></a>02311   <span class="keywordtype">void</span> binlog_prepare_row_images(<a class="code" href="structTABLE.html">TABLE</a>* table);
<a name="l02312"></a>02312 
<a name="l02313"></a>02313   <span class="keywordtype">void</span> set_server_id(uint32 sid) { server_id = sid; }
<a name="l02314"></a>02314 
<a name="l02315"></a>02315   <span class="comment">/*</span>
<a name="l02316"></a>02316 <span class="comment">    Member functions to handle pending event for row-level logging.</span>
<a name="l02317"></a>02317 <span class="comment">  */</span>
<a name="l02318"></a>02318   <span class="keyword">template</span> &lt;<span class="keyword">class</span> RowsEventT&gt; <a class="code" href="classRows__log__event.html">Rows_log_event</a>*
<a name="l02319"></a>02319     binlog_prepare_pending_rows_event(<a class="code" href="structTABLE.html">TABLE</a>* table, uint32 serv_id,
<a name="l02320"></a>02320                                       <span class="keywordtype">size_t</span> needed,
<a name="l02321"></a>02321                                       <span class="keywordtype">bool</span> is_transactional,
<a name="l02322"></a>02322                                       RowsEventT* hint,
<a name="l02323"></a>02323                                       <span class="keyword">const</span> uchar* extra_row_info);
<a name="l02324"></a>02324   <a class="code" href="classRows__log__event.html">Rows_log_event</a>* binlog_get_pending_rows_event(<span class="keywordtype">bool</span> is_transactional) <span class="keyword">const</span>;
<a name="l02325"></a>02325   <span class="keyword">inline</span> <span class="keywordtype">int</span> binlog_flush_pending_rows_event(<span class="keywordtype">bool</span> stmt_end)
<a name="l02326"></a>02326   {
<a name="l02327"></a>02327     <span class="keywordflow">return</span> (binlog_flush_pending_rows_event(stmt_end, FALSE) || 
<a name="l02328"></a>02328             binlog_flush_pending_rows_event(stmt_end, TRUE));
<a name="l02329"></a>02329   }
<a name="l02330"></a>02330   <span class="keywordtype">int</span> binlog_flush_pending_rows_event(<span class="keywordtype">bool</span> stmt_end, <span class="keywordtype">bool</span> is_transactional);
<a name="l02331"></a>02331 
<a name="l02340"></a>02340   <span class="keywordtype">int</span> is_current_stmt_binlog_format_row()<span class="keyword"> const </span>{
<a name="l02341"></a>02341     DBUG_ASSERT(current_stmt_binlog_format == BINLOG_FORMAT_STMT ||
<a name="l02342"></a>02342                 current_stmt_binlog_format == BINLOG_FORMAT_ROW);
<a name="l02343"></a>02343     <span class="keywordflow">return</span> current_stmt_binlog_format == BINLOG_FORMAT_ROW;
<a name="l02344"></a>02344   }
<a name="l02346"></a>02346   <span class="keyword">inline</span> <span class="keywordtype">bool</span> optimizer_switch_flag(ulonglong flag)<span class="keyword"> const</span>
<a name="l02347"></a>02347 <span class="keyword">  </span>{
<a name="l02348"></a>02348     <span class="keywordflow">return</span> (variables.optimizer_switch &amp; flag);
<a name="l02349"></a>02349   }
<a name="l02350"></a>02350 
<a name="l02351"></a>02351   <span class="keyword">enum</span> binlog_filter_state
<a name="l02352"></a>02352   {
<a name="l02353"></a>02353     BINLOG_FILTER_UNKNOWN,
<a name="l02354"></a>02354     BINLOG_FILTER_CLEAR,
<a name="l02355"></a>02355     BINLOG_FILTER_SET
<a name="l02356"></a>02356   };
<a name="l02357"></a>02357 
<a name="l02358"></a>02358   <span class="keyword">inline</span> <span class="keywordtype">void</span> reset_binlog_local_stmt_filter()
<a name="l02359"></a>02359   {
<a name="l02360"></a>02360     m_binlog_filter_state= BINLOG_FILTER_UNKNOWN;
<a name="l02361"></a>02361   }
<a name="l02362"></a>02362 
<a name="l02363"></a>02363   <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_binlog_local_stmt_filter()
<a name="l02364"></a>02364   {
<a name="l02365"></a>02365     DBUG_ASSERT(m_binlog_filter_state == BINLOG_FILTER_UNKNOWN);
<a name="l02366"></a>02366     m_binlog_filter_state= BINLOG_FILTER_CLEAR;
<a name="l02367"></a>02367   }
<a name="l02368"></a>02368 
<a name="l02369"></a>02369   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_binlog_local_stmt_filter()
<a name="l02370"></a>02370   {
<a name="l02371"></a>02371     DBUG_ASSERT(m_binlog_filter_state == BINLOG_FILTER_UNKNOWN);
<a name="l02372"></a>02372     m_binlog_filter_state= BINLOG_FILTER_SET;
<a name="l02373"></a>02373   }
<a name="l02374"></a>02374 
<a name="l02375"></a>02375   <span class="keyword">inline</span> binlog_filter_state get_binlog_local_stmt_filter()
<a name="l02376"></a>02376   {
<a name="l02377"></a>02377     <span class="keywordflow">return</span> m_binlog_filter_state;
<a name="l02378"></a>02378   }
<a name="l02379"></a>02379 
<a name="l02380"></a>02380 <span class="keyword">private</span>:
<a name="l02388"></a>02388   binlog_filter_state m_binlog_filter_state;
<a name="l02389"></a>02389 
<a name="l02394"></a>02394   enum_binlog_format current_stmt_binlog_format;
<a name="l02395"></a>02395 
<a name="l02408"></a>02408   uint32 binlog_unsafe_warning_flags;
<a name="l02409"></a>02409 
<a name="l02410"></a>02410   <span class="comment">/*</span>
<a name="l02411"></a>02411 <span class="comment">    Number of outstanding table maps, i.e., table maps in the</span>
<a name="l02412"></a>02412 <span class="comment">    transaction cache.</span>
<a name="l02413"></a>02413 <span class="comment">  */</span>
<a name="l02414"></a>02414   uint binlog_table_maps;
<a name="l02415"></a>02415   <span class="comment">/*</span>
<a name="l02416"></a>02416 <span class="comment">    MTS: db names listing to be updated by the query databases</span>
<a name="l02417"></a>02417 <span class="comment">  */</span>
<a name="l02418"></a>02418   <a class="code" href="classList.html">List&lt;char&gt;</a> *binlog_accessed_db_names;
<a name="l02419"></a>02419 
<a name="l02434"></a>02434   <span class="keyword">const</span> <span class="keywordtype">char</span> *m_trans_log_file;
<a name="l02435"></a>02435   <span class="keywordtype">char</span> *m_trans_fixed_log_file;
<a name="l02436"></a>02436   my_off_t m_trans_end_pos;
<a name="l02439"></a>02439 <span class="keyword">public</span>:
<a name="l02440"></a>02440   <span class="keywordtype">void</span> issue_unsafe_warnings();
<a name="l02441"></a>02441 
<a name="l02442"></a>02442   uint get_binlog_table_maps()<span class="keyword"> const </span>{
<a name="l02443"></a>02443     <span class="keywordflow">return</span> binlog_table_maps;
<a name="l02444"></a>02444   }
<a name="l02445"></a>02445   <span class="keywordtype">void</span> clear_binlog_table_maps() {
<a name="l02446"></a>02446     binlog_table_maps= 0;
<a name="l02447"></a>02447   }
<a name="l02448"></a>02448 
<a name="l02449"></a>02449   <span class="comment">/*</span>
<a name="l02450"></a>02450 <span class="comment">    MTS: accessor to binlog_accessed_db_names list</span>
<a name="l02451"></a>02451 <span class="comment">  */</span>
<a name="l02452"></a>02452   <a class="code" href="classList.html">List&lt;char&gt;</a> * get_binlog_accessed_db_names()
<a name="l02453"></a>02453   {
<a name="l02454"></a>02454     <span class="keywordflow">return</span> binlog_accessed_db_names;
<a name="l02455"></a>02455   }
<a name="l02456"></a>02456 
<a name="l02457"></a>02457   <span class="comment">/*</span>
<a name="l02458"></a>02458 <span class="comment">     MTS: resetter of binlog_accessed_db_names list normally</span>
<a name="l02459"></a>02459 <span class="comment">     at the end of the query execution</span>
<a name="l02460"></a>02460 <span class="comment">  */</span>
<a name="l02461"></a>02461   <span class="keywordtype">void</span> clear_binlog_accessed_db_names() { binlog_accessed_db_names= NULL; }
<a name="l02462"></a>02462 
<a name="l02463"></a>02463   <span class="comment">/* MTS: method inserts a new unique name into binlog_updated_dbs */</span>
<a name="l02464"></a>02464   <span class="keywordtype">void</span> add_to_binlog_accessed_dbs(<span class="keyword">const</span> <span class="keywordtype">char</span> *db);
<a name="l02465"></a>02465 
<a name="l02466"></a>02466 <span class="preprocessor">#endif </span><span class="comment">/* MYSQL_CLIENT */</span>
<a name="l02467"></a>02467 
<a name="l02468"></a>02468 <span class="keyword">public</span>:
<a name="l02469"></a>02469 
<a name="l02470"></a>02470   <span class="keyword">struct </span>st_transactions {
<a name="l02471"></a>02471     SAVEPOINT *savepoints;
<a name="l02472"></a>02472     THD_TRANS all;                      <span class="comment">// Trans since BEGIN WORK</span>
<a name="l02473"></a>02473     THD_TRANS stmt;                     <span class="comment">// Trans for current statement</span>
<a name="l02474"></a>02474     XID_STATE xid_state;
<a name="l02475"></a>02475     <a class="code" href="classRows__log__event.html">Rows_log_event</a> *m_pending_rows_event;
<a name="l02476"></a>02476 
<a name="l02477"></a>02477     <span class="comment">/*</span>
<a name="l02478"></a>02478 <span class="comment">       Tables changed in transaction (that must be invalidated in query cache).</span>
<a name="l02479"></a>02479 <span class="comment">       List contain only transactional tables, that not invalidated in query</span>
<a name="l02480"></a>02480 <span class="comment">       cache (instead of full list of changed in transaction tables).</span>
<a name="l02481"></a>02481 <span class="comment">    */</span>
<a name="l02482"></a>02482     <a class="code" href="structst__changed__table__list.html">CHANGED_TABLE_LIST</a>* changed_tables;
<a name="l02483"></a>02483     MEM_ROOT mem_root; <span class="comment">// Transaction-life memory allocation pool</span>
<a name="l02484"></a>02484 
<a name="l02485"></a>02485     <span class="comment">/*</span>
<a name="l02486"></a>02486 <span class="comment">      (Mostly) binlog-specific fields use while flushing the caches</span>
<a name="l02487"></a>02487 <span class="comment">      and committing transactions.</span>
<a name="l02488"></a>02488 <span class="comment">      We don&#39;t use bitfield any more in the struct. Modification will</span>
<a name="l02489"></a>02489 <span class="comment">      be lost when concurrently updating multiple bit fields. It will</span>
<a name="l02490"></a>02490 <span class="comment">      cause a race condition in a multi-threaded application. And we</span>
<a name="l02491"></a>02491 <span class="comment">      already caught a race condition case between xid_written and</span>
<a name="l02492"></a>02492 <span class="comment">      ready_preempt in MYSQL_BIN_LOG::ordered_commit.</span>
<a name="l02493"></a>02493 <span class="comment">    */</span>
<a name="l02494"></a>02494     <span class="keyword">struct </span>{
<a name="l02495"></a>02495       <span class="keywordtype">bool</span> enabled;                   <span class="comment">// see ha_enable_transaction()</span>
<a name="l02496"></a>02496       <span class="keywordtype">bool</span> pending;                   <span class="comment">// Is the transaction commit pending?</span>
<a name="l02497"></a>02497       <span class="keywordtype">bool</span> xid_written;               <span class="comment">// The session wrote an XID</span>
<a name="l02498"></a>02498       <span class="keywordtype">bool</span> real_commit;               <span class="comment">// Is this a &quot;real&quot; commit?</span>
<a name="l02499"></a>02499       <span class="keywordtype">bool</span> commit_low;                <span class="comment">// see MYSQL_BIN_LOG::ordered_commit</span>
<a name="l02500"></a>02500       <span class="keywordtype">bool</span> run_hooks;                 <span class="comment">// Call the after_commit hook</span>
<a name="l02501"></a>02501 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02502"></a>02502 <span class="preprocessor"></span>      <span class="keywordtype">bool</span> ready_preempt;             <span class="comment">// internal in MYSQL_BIN_LOG::ordered_commit</span>
<a name="l02503"></a>02503 <span class="preprocessor">#endif</span>
<a name="l02504"></a>02504 <span class="preprocessor"></span>    } flags;
<a name="l02505"></a>02505 
<a name="l02506"></a>02506     <span class="keywordtype">void</span> cleanup()
<a name="l02507"></a>02507     {
<a name="l02508"></a>02508       DBUG_ENTER(<span class="stringliteral">&quot;THD::st_transaction::cleanup&quot;</span>);
<a name="l02509"></a>02509       changed_tables= 0;
<a name="l02510"></a>02510       savepoints= 0;
<a name="l02511"></a>02511 
<a name="l02512"></a>02512       <span class="comment">/*</span>
<a name="l02513"></a>02513 <span class="comment">        If rm_error is raised, it means that this piece of a distributed</span>
<a name="l02514"></a>02514 <span class="comment">        transaction has failed and must be rolled back. But the user must</span>
<a name="l02515"></a>02515 <span class="comment">        rollback it explicitly, so don&#39;t start a new distributed XA until</span>
<a name="l02516"></a>02516 <span class="comment">        then.</span>
<a name="l02517"></a>02517 <span class="comment">      */</span>
<a name="l02518"></a>02518       <span class="keywordflow">if</span> (!xid_state.rm_error)
<a name="l02519"></a>02519         xid_state.xid.null();
<a name="l02520"></a>02520       free_root(&amp;mem_root,MYF(MY_KEEP_PREALLOC));
<a name="l02521"></a>02521       DBUG_VOID_RETURN;
<a name="l02522"></a>02522     }
<a name="l02523"></a>02523     my_bool is_active()
<a name="l02524"></a>02524     {
<a name="l02525"></a>02525       <span class="keywordflow">return</span> (all.ha_list != NULL);
<a name="l02526"></a>02526     }
<a name="l02527"></a>02527     st_transactions()
<a name="l02528"></a>02528     {
<a name="l02529"></a>02529       memset(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(*<span class="keyword">this</span>));
<a name="l02530"></a>02530       xid_state.xid.null();
<a name="l02531"></a>02531       init_sql_alloc(&amp;mem_root, ALLOC_ROOT_MIN_BLOCK_SIZE, 0);
<a name="l02532"></a>02532     }
<a name="l02533"></a>02533     <span class="keywordtype">void</span> push_unsafe_rollback_warnings(THD *thd)
<a name="l02534"></a>02534     {
<a name="l02535"></a>02535       <span class="keywordflow">if</span> (all.has_modified_non_trans_table())
<a name="l02536"></a>02536         push_warning(thd, Sql_condition::WARN_LEVEL_WARN,
<a name="l02537"></a>02537                      ER_WARNING_NOT_COMPLETE_ROLLBACK,
<a name="l02538"></a>02538                      ER(ER_WARNING_NOT_COMPLETE_ROLLBACK));
<a name="l02539"></a>02539 
<a name="l02540"></a>02540       <span class="keywordflow">if</span> (all.has_created_temp_table())
<a name="l02541"></a>02541         push_warning(thd, Sql_condition::WARN_LEVEL_WARN,
<a name="l02542"></a>02542                      ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE,
<a name="l02543"></a>02543                      ER(ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE));
<a name="l02544"></a>02544 
<a name="l02545"></a>02545       <span class="keywordflow">if</span> (all.has_dropped_temp_table())
<a name="l02546"></a>02546         push_warning(thd, Sql_condition::WARN_LEVEL_WARN,
<a name="l02547"></a>02547                      ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE,
<a name="l02548"></a>02548                      ER(ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE));
<a name="l02549"></a>02549     }
<a name="l02550"></a>02550     <span class="keywordtype">void</span> merge_unsafe_rollback_flags()
<a name="l02551"></a>02551     {
<a name="l02552"></a>02552       <span class="comment">/*</span>
<a name="l02553"></a>02553 <span class="comment">        Merge stmt.unsafe_rollback_flags to all.unsafe_rollback_flags. If</span>
<a name="l02554"></a>02554 <span class="comment">        the statement cannot be rolled back safely, the transaction including</span>
<a name="l02555"></a>02555 <span class="comment">        this statement definitely cannot rolled back safely.</span>
<a name="l02556"></a>02556 <span class="comment">      */</span>
<a name="l02557"></a>02557       all.add_unsafe_rollback_flags(stmt.get_unsafe_rollback_flags());
<a name="l02558"></a>02558     }
<a name="l02559"></a>02559   } transaction;
<a name="l02560"></a>02560   Global_read_lock global_read_lock;
<a name="l02561"></a>02561   <a class="code" href="classField.html">Field</a>      *dup_field;
<a name="l02562"></a>02562 <span class="preprocessor">#ifndef __WIN__</span>
<a name="l02563"></a>02563 <span class="preprocessor"></span>  sigset_t signals;
<a name="l02564"></a>02564 <span class="preprocessor">#endif</span>
<a name="l02565"></a>02565 <span class="preprocessor"></span><span class="preprocessor">#ifdef SIGNAL_WITH_VIO_SHUTDOWN</span>
<a name="l02566"></a>02566 <span class="preprocessor"></span>  Vio* active_vio;
<a name="l02567"></a>02567 <span class="preprocessor">#endif</span>
<a name="l02568"></a>02568 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l02569"></a>02569 <span class="comment">    This is to track items changed during execution of a prepared</span>
<a name="l02570"></a>02570 <span class="comment">    statement/stored procedure. It&#39;s created by</span>
<a name="l02571"></a>02571 <span class="comment">    register_item_tree_change() in memory root of THD, and freed in</span>
<a name="l02572"></a>02572 <span class="comment">    rollback_item_tree_changes(). For conventional execution it&#39;s always</span>
<a name="l02573"></a>02573 <span class="comment">    empty.</span>
<a name="l02574"></a>02574 <span class="comment">  */</span>
<a name="l02575"></a>02575   Item_change_list change_list;
<a name="l02576"></a>02576 
<a name="l02577"></a>02577   <span class="comment">/*</span>
<a name="l02578"></a>02578 <span class="comment">    A permanent memory area of the statement. For conventional</span>
<a name="l02579"></a>02579 <span class="comment">    execution, the parsed tree and execution runtime reside in the same</span>
<a name="l02580"></a>02580 <span class="comment">    memory root. In this case stmt_arena points to THD. In case of</span>
<a name="l02581"></a>02581 <span class="comment">    a prepared statement or a stored procedure statement, thd-&gt;mem_root</span>
<a name="l02582"></a>02582 <span class="comment">    conventionally points to runtime memory, and thd-&gt;stmt_arena</span>
<a name="l02583"></a>02583 <span class="comment">    points to the memory of the PS/SP, where the parsed tree of the</span>
<a name="l02584"></a>02584 <span class="comment">    statement resides. Whenever you need to perform a permanent</span>
<a name="l02585"></a>02585 <span class="comment">    transformation of a parsed tree, you should allocate new memory in</span>
<a name="l02586"></a>02586 <span class="comment">    stmt_arena, to allow correct re-execution of PS/SP.</span>
<a name="l02587"></a>02587 <span class="comment">    Note: in the parser, stmt_arena == thd, even for PS/SP.</span>
<a name="l02588"></a>02588 <span class="comment">  */</span>
<a name="l02589"></a>02589   Query_arena *stmt_arena;
<a name="l02590"></a>02590 
<a name="l02591"></a>02591   <span class="comment">/*</span>
<a name="l02592"></a>02592 <span class="comment">    map for tables that will be updated for a multi-table update query</span>
<a name="l02593"></a>02593 <span class="comment">    statement, for other query statements, this will be zero.</span>
<a name="l02594"></a>02594 <span class="comment">  */</span>
<a name="l02595"></a>02595   table_map table_map_for_update;
<a name="l02596"></a>02596 
<a name="l02597"></a>02597   <span class="comment">/* Tells if LAST_INSERT_ID(#) was called for the current statement */</span>
<a name="l02598"></a>02598   <span class="keywordtype">bool</span> arg_of_last_insert_id_function;
<a name="l02599"></a>02599   <span class="comment">/*</span>
<a name="l02600"></a>02600 <span class="comment">    ALL OVER THIS FILE, &quot;insert_id&quot; means &quot;*automatically generated* value for</span>
<a name="l02601"></a>02601 <span class="comment">    insertion into an auto_increment column&quot;.</span>
<a name="l02602"></a>02602 <span class="comment">  */</span>
<a name="l02603"></a>02603   <span class="comment">/*</span>
<a name="l02604"></a>02604 <span class="comment">    This is the first autogenerated insert id which was *successfully*</span>
<a name="l02605"></a>02605 <span class="comment">    inserted by the previous statement (exactly, if the previous statement</span>
<a name="l02606"></a>02606 <span class="comment">    didn&#39;t successfully insert an autogenerated insert id, then it&#39;s the one</span>
<a name="l02607"></a>02607 <span class="comment">    of the statement before, etc).</span>
<a name="l02608"></a>02608 <span class="comment">    It can also be set by SET LAST_INSERT_ID=# or SELECT LAST_INSERT_ID(#).</span>
<a name="l02609"></a>02609 <span class="comment">    It is returned by LAST_INSERT_ID().</span>
<a name="l02610"></a>02610 <span class="comment">  */</span>
<a name="l02611"></a>02611   ulonglong  first_successful_insert_id_in_prev_stmt;
<a name="l02612"></a>02612   <span class="comment">/*</span>
<a name="l02613"></a>02613 <span class="comment">    Variant of the above, used for storing in statement-based binlog. The</span>
<a name="l02614"></a>02614 <span class="comment">    difference is that the one above can change as the execution of a stored</span>
<a name="l02615"></a>02615 <span class="comment">    function progresses, while the one below is set once and then does not</span>
<a name="l02616"></a>02616 <span class="comment">    change (which is the value which statement-based binlog needs).</span>
<a name="l02617"></a>02617 <span class="comment">  */</span>
<a name="l02618"></a>02618   ulonglong  first_successful_insert_id_in_prev_stmt_for_binlog;
<a name="l02619"></a>02619   <span class="comment">/*</span>
<a name="l02620"></a>02620 <span class="comment">    This is the first autogenerated insert id which was *successfully*</span>
<a name="l02621"></a>02621 <span class="comment">    inserted by the current statement. It is maintained only to set</span>
<a name="l02622"></a>02622 <span class="comment">    first_successful_insert_id_in_prev_stmt when statement ends.</span>
<a name="l02623"></a>02623 <span class="comment">  */</span>
<a name="l02624"></a>02624   ulonglong  first_successful_insert_id_in_cur_stmt;
<a name="l02625"></a>02625   <span class="comment">/*</span>
<a name="l02626"></a>02626 <span class="comment">    We follow this logic:</span>
<a name="l02627"></a>02627 <span class="comment">    - when stmt starts, first_successful_insert_id_in_prev_stmt contains the</span>
<a name="l02628"></a>02628 <span class="comment">    first insert id successfully inserted by the previous stmt.</span>
<a name="l02629"></a>02629 <span class="comment">    - as stmt makes progress, handler::insert_id_for_cur_row changes;</span>
<a name="l02630"></a>02630 <span class="comment">    every time get_auto_increment() is called,</span>
<a name="l02631"></a>02631 <span class="comment">    auto_inc_intervals_in_cur_stmt_for_binlog is augmented with the</span>
<a name="l02632"></a>02632 <span class="comment">    reserved interval (if statement-based binlogging).</span>
<a name="l02633"></a>02633 <span class="comment">    - at first successful insertion of an autogenerated value,</span>
<a name="l02634"></a>02634 <span class="comment">    first_successful_insert_id_in_cur_stmt is set to</span>
<a name="l02635"></a>02635 <span class="comment">    handler::insert_id_for_cur_row.</span>
<a name="l02636"></a>02636 <span class="comment">    - when stmt goes to binlog,</span>
<a name="l02637"></a>02637 <span class="comment">    auto_inc_intervals_in_cur_stmt_for_binlog is binlogged if</span>
<a name="l02638"></a>02638 <span class="comment">    non-empty.</span>
<a name="l02639"></a>02639 <span class="comment">    - when stmt ends, first_successful_insert_id_in_prev_stmt is set to</span>
<a name="l02640"></a>02640 <span class="comment">    first_successful_insert_id_in_cur_stmt.</span>
<a name="l02641"></a>02641 <span class="comment">  */</span>
<a name="l02642"></a>02642   <span class="comment">/*</span>
<a name="l02643"></a>02643 <span class="comment">    stmt_depends_on_first_successful_insert_id_in_prev_stmt is set when</span>
<a name="l02644"></a>02644 <span class="comment">    LAST_INSERT_ID() is used by a statement.</span>
<a name="l02645"></a>02645 <span class="comment">    If it is set, first_successful_insert_id_in_prev_stmt_for_binlog will be</span>
<a name="l02646"></a>02646 <span class="comment">    stored in the statement-based binlog.</span>
<a name="l02647"></a>02647 <span class="comment">    This variable is CUMULATIVE along the execution of a stored function or</span>
<a name="l02648"></a>02648 <span class="comment">    trigger: if one substatement sets it to 1 it will stay 1 until the</span>
<a name="l02649"></a>02649 <span class="comment">    function/trigger ends, thus making sure that</span>
<a name="l02650"></a>02650 <span class="comment">    first_successful_insert_id_in_prev_stmt_for_binlog does not change anymore</span>
<a name="l02651"></a>02651 <span class="comment">    and is propagated to the caller for binlogging.</span>
<a name="l02652"></a>02652 <span class="comment">  */</span>
<a name="l02653"></a>02653   <span class="keywordtype">bool</span>       stmt_depends_on_first_successful_insert_id_in_prev_stmt;
<a name="l02654"></a>02654   <span class="comment">/*</span>
<a name="l02655"></a>02655 <span class="comment">    List of auto_increment intervals reserved by the thread so far, for</span>
<a name="l02656"></a>02656 <span class="comment">    storage in the statement-based binlog.</span>
<a name="l02657"></a>02657 <span class="comment">    Note that its minimum is not first_successful_insert_id_in_cur_stmt:</span>
<a name="l02658"></a>02658 <span class="comment">    assuming a table with an autoinc column, and this happens:</span>
<a name="l02659"></a>02659 <span class="comment">    INSERT INTO ... VALUES(3);</span>
<a name="l02660"></a>02660 <span class="comment">    SET INSERT_ID=3; INSERT IGNORE ... VALUES (NULL);</span>
<a name="l02661"></a>02661 <span class="comment">    then the latter INSERT will insert no rows</span>
<a name="l02662"></a>02662 <span class="comment">    (first_successful_insert_id_in_cur_stmt == 0), but storing &quot;INSERT_ID=3&quot;</span>
<a name="l02663"></a>02663 <span class="comment">    in the binlog is still needed; the list&#39;s minimum will contain 3.</span>
<a name="l02664"></a>02664 <span class="comment">    This variable is cumulative: if several statements are written to binlog</span>
<a name="l02665"></a>02665 <span class="comment">    as one (stored functions or triggers are used) this list is the</span>
<a name="l02666"></a>02666 <span class="comment">    concatenation of all intervals reserved by all statements.</span>
<a name="l02667"></a>02667 <span class="comment">  */</span>
<a name="l02668"></a>02668   <a class="code" href="classDiscrete__intervals__list.html" title="List of Discrete_interval objects.">Discrete_intervals_list</a> auto_inc_intervals_in_cur_stmt_for_binlog;
<a name="l02669"></a>02669   <span class="comment">/* Used by replication and SET INSERT_ID */</span>
<a name="l02670"></a>02670   <a class="code" href="classDiscrete__intervals__list.html" title="List of Discrete_interval objects.">Discrete_intervals_list</a> auto_inc_intervals_forced;
<a name="l02671"></a>02671   <span class="comment">/*</span>
<a name="l02672"></a>02672 <span class="comment">    There is BUG#19630 where statement-based replication of stored</span>
<a name="l02673"></a>02673 <span class="comment">    functions/triggers with two auto_increment columns breaks.</span>
<a name="l02674"></a>02674 <span class="comment">    We however ensure that it works when there is 0 or 1 auto_increment</span>
<a name="l02675"></a>02675 <span class="comment">    column; our rules are</span>
<a name="l02676"></a>02676 <span class="comment">    a) on master, while executing a top statement involving substatements,</span>
<a name="l02677"></a>02677 <span class="comment">    first top- or sub- statement to generate auto_increment values wins the</span>
<a name="l02678"></a>02678 <span class="comment">    exclusive right to see its values be written to binlog (the write</span>
<a name="l02679"></a>02679 <span class="comment">    will be done by the statement or its caller), and the losers won&#39;t see</span>
<a name="l02680"></a>02680 <span class="comment">    their values be written to binlog.</span>
<a name="l02681"></a>02681 <span class="comment">    b) on slave, while replicating a top statement involving substatements,</span>
<a name="l02682"></a>02682 <span class="comment">    first top- or sub- statement to need to read auto_increment values from</span>
<a name="l02683"></a>02683 <span class="comment">    the master&#39;s binlog wins the exclusive right to read them (so the losers</span>
<a name="l02684"></a>02684 <span class="comment">    won&#39;t read their values from binlog but instead generate on their own).</span>
<a name="l02685"></a>02685 <span class="comment">    a) implies that we mustn&#39;t backup/restore</span>
<a name="l02686"></a>02686 <span class="comment">    auto_inc_intervals_in_cur_stmt_for_binlog.</span>
<a name="l02687"></a>02687 <span class="comment">    b) implies that we mustn&#39;t backup/restore auto_inc_intervals_forced.</span>
<a name="l02688"></a>02688 <span class="comment"></span>
<a name="l02689"></a>02689 <span class="comment">    If there are more than 1 auto_increment columns, then intervals for</span>
<a name="l02690"></a>02690 <span class="comment">    different columns may mix into the</span>
<a name="l02691"></a>02691 <span class="comment">    auto_inc_intervals_in_cur_stmt_for_binlog list, which is logically wrong,</span>
<a name="l02692"></a>02692 <span class="comment">    but there is no point in preventing this mixing by preventing intervals</span>
<a name="l02693"></a>02693 <span class="comment">    from the secondly inserted column to come into the list, as such</span>
<a name="l02694"></a>02694 <span class="comment">    prevention would be wrong too.</span>
<a name="l02695"></a>02695 <span class="comment">    What will happen in the case of</span>
<a name="l02696"></a>02696 <span class="comment">    INSERT INTO t1 (auto_inc) VALUES(NULL);</span>
<a name="l02697"></a>02697 <span class="comment">    where t1 has a trigger which inserts into an auto_inc column of t2, is</span>
<a name="l02698"></a>02698 <span class="comment">    that in binlog we&#39;ll store the interval of t1 and the interval of t2 (when</span>
<a name="l02699"></a>02699 <span class="comment">    we store intervals, soon), then in slave, t1 will use both intervals, t2</span>
<a name="l02700"></a>02700 <span class="comment">    will use none; if t1 inserts the same number of rows as on master,</span>
<a name="l02701"></a>02701 <span class="comment">    normally the 2nd interval will not be used by t1, which is fine. t2&#39;s</span>
<a name="l02702"></a>02702 <span class="comment">    values will be wrong if t2&#39;s internal auto_increment counter is different</span>
<a name="l02703"></a>02703 <span class="comment">    from what it was on master (which is likely). In 5.1, in mixed binlogging</span>
<a name="l02704"></a>02704 <span class="comment">    mode, row-based binlogging is used for such cases where two</span>
<a name="l02705"></a>02705 <span class="comment">    auto_increment columns are inserted.</span>
<a name="l02706"></a>02706 <span class="comment">  */</span>
<a name="l02707"></a>02707   <span class="keyword">inline</span> <span class="keywordtype">void</span> record_first_successful_insert_id_in_cur_stmt(ulonglong id_arg)
<a name="l02708"></a>02708   {
<a name="l02709"></a>02709     <span class="keywordflow">if</span> (first_successful_insert_id_in_cur_stmt == 0)
<a name="l02710"></a>02710       first_successful_insert_id_in_cur_stmt= id_arg;
<a name="l02711"></a>02711   }
<a name="l02712"></a>02712   <span class="keyword">inline</span> ulonglong read_first_successful_insert_id_in_prev_stmt(<span class="keywordtype">void</span>)
<a name="l02713"></a>02713   {
<a name="l02714"></a>02714     <span class="keywordflow">if</span> (!stmt_depends_on_first_successful_insert_id_in_prev_stmt)
<a name="l02715"></a>02715     {
<a name="l02716"></a>02716       <span class="comment">/* It&#39;s the first time we read it */</span>
<a name="l02717"></a>02717       first_successful_insert_id_in_prev_stmt_for_binlog=
<a name="l02718"></a>02718         first_successful_insert_id_in_prev_stmt;
<a name="l02719"></a>02719       stmt_depends_on_first_successful_insert_id_in_prev_stmt= 1;
<a name="l02720"></a>02720     }
<a name="l02721"></a>02721     <span class="keywordflow">return</span> first_successful_insert_id_in_prev_stmt;
<a name="l02722"></a>02722   }
<a name="l02723"></a>02723   <span class="comment">/*</span>
<a name="l02724"></a>02724 <span class="comment">    Used by Intvar_log_event::do_apply_event() and by &quot;SET INSERT_ID=#&quot;</span>
<a name="l02725"></a>02725 <span class="comment">    (mysqlbinlog). We&#39;ll soon add a variant which can take many intervals in</span>
<a name="l02726"></a>02726 <span class="comment">    argument.</span>
<a name="l02727"></a>02727 <span class="comment">  */</span>
<a name="l02728"></a>02728   <span class="keyword">inline</span> <span class="keywordtype">void</span> force_one_auto_inc_interval(ulonglong next_id)
<a name="l02729"></a>02729   {
<a name="l02730"></a>02730     auto_inc_intervals_forced.empty(); <span class="comment">// in case of multiple SET INSERT_ID</span>
<a name="l02731"></a>02731     auto_inc_intervals_forced.append(next_id, ULONGLONG_MAX, 0);
<a name="l02732"></a>02732   }
<a name="l02733"></a>02733 
<a name="l02734"></a>02734   ulonglong  limit_found_rows;
<a name="l02735"></a>02735 
<a name="l02736"></a>02736 <span class="keyword">private</span>:
<a name="l02766"></a>02766   longlong m_row_count_func;    <span class="comment">/* For the ROW_COUNT() function */</span>
<a name="l02767"></a>02767 
<a name="l02768"></a>02768 <span class="keyword">public</span>:
<a name="l02769"></a>02769   <span class="keyword">inline</span> longlong get_row_count_func()<span class="keyword"> const</span>
<a name="l02770"></a>02770 <span class="keyword">  </span>{
<a name="l02771"></a>02771     <span class="keywordflow">return</span> m_row_count_func;
<a name="l02772"></a>02772   }
<a name="l02773"></a>02773 
<a name="l02774"></a>02774   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_row_count_func(longlong row_count_func)
<a name="l02775"></a>02775   {
<a name="l02776"></a>02776     m_row_count_func= row_count_func;
<a name="l02777"></a>02777   }
<a name="l02778"></a>02778 
<a name="l02779"></a>02779   ha_rows    cuted_fields;
<a name="l02780"></a>02780 
<a name="l02781"></a>02781 <span class="keyword">private</span>:
<a name="l02786"></a>02786   ha_rows m_sent_row_count;
<a name="l02787"></a>02787 
<a name="l02798"></a>02798   ha_rows m_examined_row_count;
<a name="l02799"></a>02799 
<a name="l02800"></a>02800 <span class="keyword">private</span>:
<a name="l02801"></a>02801   <a class="code" href="structuser__conn.html">USER_CONN</a> *m_user_connect;
<a name="l02802"></a>02802 
<a name="l02803"></a>02803 <span class="keyword">public</span>:
<a name="l02804"></a>02804   <span class="keywordtype">void</span> set_user_connect(<a class="code" href="structuser__conn.html">USER_CONN</a> *uc);
<a name="l02805"></a>02805   <span class="keyword">const</span> <a class="code" href="structuser__conn.html">USER_CONN</a>* get_user_connect()
<a name="l02806"></a>02806   { <span class="keywordflow">return</span> m_user_connect; }
<a name="l02807"></a>02807 
<a name="l02808"></a>02808   <span class="keywordtype">void</span> increment_user_connections_counter();
<a name="l02809"></a>02809   <span class="keywordtype">void</span> decrement_user_connections_counter();
<a name="l02810"></a>02810 
<a name="l02811"></a>02811   <span class="keywordtype">void</span> increment_con_per_hour_counter();
<a name="l02812"></a>02812 
<a name="l02813"></a>02813   <span class="keywordtype">void</span> increment_updates_counter();
<a name="l02814"></a>02814 
<a name="l02815"></a>02815   <span class="keywordtype">void</span> increment_questions_counter();
<a name="l02816"></a>02816 
<a name="l02817"></a>02817   <span class="keywordtype">void</span> time_out_user_resource_limits();
<a name="l02818"></a>02818 
<a name="l02819"></a>02819 <span class="keyword">public</span>:
<a name="l02820"></a>02820   ha_rows get_sent_row_count()<span class="keyword"> const</span>
<a name="l02821"></a>02821 <span class="keyword">  </span>{ <span class="keywordflow">return</span> m_sent_row_count; }
<a name="l02822"></a>02822 
<a name="l02823"></a>02823   ha_rows get_examined_row_count()<span class="keyword"> const</span>
<a name="l02824"></a>02824 <span class="keyword">  </span>{ <span class="keywordflow">return</span> m_examined_row_count; }
<a name="l02825"></a>02825 
<a name="l02826"></a>02826   <span class="keywordtype">void</span> set_sent_row_count(ha_rows count);
<a name="l02827"></a>02827   <span class="keywordtype">void</span> set_examined_row_count(ha_rows count);
<a name="l02828"></a>02828 
<a name="l02829"></a>02829   <span class="keywordtype">void</span> inc_sent_row_count(ha_rows count);
<a name="l02830"></a>02830   <span class="keywordtype">void</span> inc_examined_row_count(ha_rows count);
<a name="l02831"></a>02831 
<a name="l02832"></a>02832   <span class="keywordtype">void</span> inc_status_created_tmp_disk_tables();
<a name="l02833"></a>02833   <span class="keywordtype">void</span> inc_status_created_tmp_files();
<a name="l02834"></a>02834   <span class="keywordtype">void</span> inc_status_created_tmp_tables();
<a name="l02835"></a>02835   <span class="keywordtype">void</span> inc_status_select_full_join();
<a name="l02836"></a>02836   <span class="keywordtype">void</span> inc_status_select_full_range_join();
<a name="l02837"></a>02837   <span class="keywordtype">void</span> inc_status_select_range();
<a name="l02838"></a>02838   <span class="keywordtype">void</span> inc_status_select_range_check();
<a name="l02839"></a>02839   <span class="keywordtype">void</span> inc_status_select_scan();
<a name="l02840"></a>02840   <span class="keywordtype">void</span> inc_status_sort_merge_passes();
<a name="l02841"></a>02841   <span class="keywordtype">void</span> inc_status_sort_range();
<a name="l02842"></a>02842   <span class="keywordtype">void</span> inc_status_sort_rows(ha_rows count);
<a name="l02843"></a>02843   <span class="keywordtype">void</span> inc_status_sort_scan();
<a name="l02844"></a>02844   <span class="keywordtype">void</span> set_status_no_index_used();
<a name="l02845"></a>02845   <span class="keywordtype">void</span> set_status_no_good_index_used();
<a name="l02846"></a>02846 
<a name="l02847"></a>02847   <span class="keyword">const</span> CHARSET_INFO *db_charset;
<a name="l02848"></a>02848 <span class="preprocessor">#if defined(ENABLED_PROFILING)</span>
<a name="l02849"></a>02849 <span class="preprocessor"></span>  PROFILING  profiling;
<a name="l02850"></a>02850 <span class="preprocessor">#endif</span>
<a name="l02851"></a>02851 <span class="preprocessor"></span>
<a name="l02853"></a>02853   <a class="code" href="structsql__digest__state.html">sql_digest_state</a> *m_digest;
<a name="l02855"></a>02855   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *m_token_array;
<a name="l02857"></a>02857   <a class="code" href="structsql__digest__state.html">sql_digest_state</a> m_digest_state;
<a name="l02858"></a>02858 
<a name="l02860"></a>02860   PSI_statement_locker *m_statement_psi;
<a name="l02861"></a>02861 <span class="preprocessor">#ifdef HAVE_PSI_STATEMENT_INTERFACE</span>
<a name="l02862"></a>02862 <span class="preprocessor"></span>
<a name="l02863"></a>02863   PSI_statement_locker_state m_statement_state;
<a name="l02864"></a>02864 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PSI_STATEMENT_INTERFACE */</span>
<a name="l02865"></a>02865 
<a name="l02866"></a>02866   PSI_idle_locker *m_idle_psi;
<a name="l02867"></a>02867 <span class="preprocessor">#ifdef HAVE_PSI_IDLE_INTERFACE</span>
<a name="l02868"></a>02868 <span class="preprocessor"></span>
<a name="l02869"></a>02869   PSI_idle_locker_state m_idle_state;
<a name="l02870"></a>02870 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_PSI_IDLE_INTERFACE */</span>
<a name="l02871"></a>02871 
<a name="l02872"></a>02872   <span class="keywordtype">bool</span> m_server_idle;
<a name="l02873"></a>02873 
<a name="l02874"></a>02874   <span class="comment">/*</span>
<a name="l02875"></a>02875 <span class="comment">    Id of current query. Statement can be reused to execute several queries</span>
<a name="l02876"></a>02876 <span class="comment">    query_id is global in context of the whole MySQL server.</span>
<a name="l02877"></a>02877 <span class="comment">    ID is automatically generated from mutex-protected counter.</span>
<a name="l02878"></a>02878 <span class="comment">    It&#39;s used in handler code for various purposes: to check which columns</span>
<a name="l02879"></a>02879 <span class="comment">    from table are necessary for this select, to check if it&#39;s necessary to</span>
<a name="l02880"></a>02880 <span class="comment">    update auto-updatable fields (like auto_increment and timestamp).</span>
<a name="l02881"></a>02881 <span class="comment">  */</span>
<a name="l02882"></a>02882   query_id_t query_id;
<a name="l02883"></a>02883   ulong      col_access;
<a name="l02884"></a>02884 
<a name="l02885"></a>02885   <span class="comment">/* Statement id is thread-wide. This counter is used to generate ids */</span>
<a name="l02886"></a>02886   ulong      statement_id_counter;
<a name="l02887"></a>02887   ulong      rand_saved_seed1, rand_saved_seed2;
<a name="l02888"></a>02888   pthread_t  real_id;                           <span class="comment">/* For debugging */</span>
<a name="l02889"></a>02889   my_thread_id  thread_id;
<a name="l02890"></a>02890   uint       tmp_table;
<a name="l02891"></a>02891   uint       server_status,open_options;
<a name="l02892"></a>02892   <span class="keyword">enum</span> enum_thread_type system_thread;
<a name="l02893"></a>02893   uint       select_number;             <span class="comment">//number of select (used for EXPLAIN)</span>
<a name="l02894"></a>02894   <span class="comment">/*</span>
<a name="l02895"></a>02895 <span class="comment">    Current or next transaction isolation level.</span>
<a name="l02896"></a>02896 <span class="comment">    When a connection is established, the value is taken from</span>
<a name="l02897"></a>02897 <span class="comment">    @@session.tx_isolation (default transaction isolation for</span>
<a name="l02898"></a>02898 <span class="comment">    the session), which is in turn taken from @@global.tx_isolation</span>
<a name="l02899"></a>02899 <span class="comment">    (the global value).</span>
<a name="l02900"></a>02900 <span class="comment">    If there is no transaction started, this variable</span>
<a name="l02901"></a>02901 <span class="comment">    holds the value of the next transaction&#39;s isolation level.</span>
<a name="l02902"></a>02902 <span class="comment">    When a transaction starts, the value stored in this variable</span>
<a name="l02903"></a>02903 <span class="comment">    becomes &quot;actual&quot;.</span>
<a name="l02904"></a>02904 <span class="comment">    At transaction commit or rollback, we assign this variable</span>
<a name="l02905"></a>02905 <span class="comment">    again from @@session.tx_isolation.</span>
<a name="l02906"></a>02906 <span class="comment">    The only statement that can otherwise change the value</span>
<a name="l02907"></a>02907 <span class="comment">    of this variable is SET TRANSACTION ISOLATION LEVEL.</span>
<a name="l02908"></a>02908 <span class="comment">    Its purpose is to effect the isolation level of the next</span>
<a name="l02909"></a>02909 <span class="comment">    transaction in this session. When this statement is executed,</span>
<a name="l02910"></a>02910 <span class="comment">    the value in this variable is changed. However, since</span>
<a name="l02911"></a>02911 <span class="comment">    this statement is only allowed when there is no active</span>
<a name="l02912"></a>02912 <span class="comment">    transaction, this assignment (naturally) only affects the</span>
<a name="l02913"></a>02913 <span class="comment">    upcoming transaction.</span>
<a name="l02914"></a>02914 <span class="comment">    At the end of the current active transaction the value is</span>
<a name="l02915"></a>02915 <span class="comment">    be reset again from @@session.tx_isolation, as described</span>
<a name="l02916"></a>02916 <span class="comment">    above.</span>
<a name="l02917"></a>02917 <span class="comment">  */</span>
<a name="l02918"></a>02918   enum_tx_isolation tx_isolation;
<a name="l02919"></a>02919   <span class="comment">/*</span>
<a name="l02920"></a>02920 <span class="comment">    Current or next transaction access mode.</span>
<a name="l02921"></a>02921 <span class="comment">    See comment above regarding tx_isolation.</span>
<a name="l02922"></a>02922 <span class="comment">  */</span>
<a name="l02923"></a>02923   <span class="keywordtype">bool</span>              tx_read_only;
<a name="l02924"></a>02924   enum_check_fields count_cuted_fields;
<a name="l02925"></a>02925 
<a name="l02926"></a>02926   DYNAMIC_ARRAY user_var_events;        <span class="comment">/* For user variables replication */</span>
<a name="l02927"></a>02927   MEM_ROOT      *user_var_events_alloc; <span class="comment">/* Allocate above array elements here */</span>
<a name="l02928"></a>02928 
<a name="l02933"></a>02933   THD *next_to_commit;
<a name="l02934"></a>02934 
<a name="l02942"></a>02942   <span class="keywordtype">void</span> set_trans_pos(<span class="keyword">const</span> <span class="keywordtype">char</span> *file, my_off_t pos)
<a name="l02943"></a>02943   {
<a name="l02944"></a>02944     DBUG_ENTER(<span class="stringliteral">&quot;THD::set_trans_pos&quot;</span>);
<a name="l02945"></a>02945     DBUG_ASSERT(((file == 0) &amp;&amp; (pos == 0)) || ((file != 0) &amp;&amp; (pos != 0)));
<a name="l02946"></a>02946     <span class="keywordflow">if</span> (file)
<a name="l02947"></a>02947     {
<a name="l02948"></a>02948       DBUG_PRINT(<span class="stringliteral">&quot;enter&quot;</span>, (<span class="stringliteral">&quot;file: %s, pos: %llu&quot;</span>, file, pos));
<a name="l02949"></a>02949       <span class="comment">// Only the file name should be used, not the full path</span>
<a name="l02950"></a>02950       m_trans_log_file= file + dirname_length(file);
<a name="l02951"></a>02951       <span class="keywordflow">if</span> (!m_trans_fixed_log_file)
<a name="l02952"></a>02952         m_trans_fixed_log_file= (<span class="keywordtype">char</span>*) alloc_root(&amp;main_mem_root, FN_REFLEN+1);
<a name="l02953"></a>02953       DBUG_ASSERT(strlen(m_trans_log_file) &lt;= FN_REFLEN);
<a name="l02954"></a>02954       strcpy(m_trans_fixed_log_file, m_trans_log_file);
<a name="l02955"></a>02955     }
<a name="l02956"></a>02956     <span class="keywordflow">else</span>
<a name="l02957"></a>02957     {
<a name="l02958"></a>02958       m_trans_log_file= NULL;
<a name="l02959"></a>02959       m_trans_fixed_log_file= NULL;
<a name="l02960"></a>02960     }
<a name="l02961"></a>02961 
<a name="l02962"></a>02962     m_trans_end_pos= pos;
<a name="l02963"></a>02963     DBUG_PRINT(<span class="stringliteral">&quot;return&quot;</span>, (<span class="stringliteral">&quot;m_trans_log_file: %s, m_trans_fixed_log_file: %s, &quot;</span>
<a name="l02964"></a>02964                           <span class="stringliteral">&quot;m_trans_end_pos: %llu&quot;</span>, m_trans_log_file,
<a name="l02965"></a>02965                           m_trans_fixed_log_file, m_trans_end_pos));
<a name="l02966"></a>02966     DBUG_VOID_RETURN;
<a name="l02967"></a>02967   }
<a name="l02968"></a>02968 
<a name="l02969"></a>02969   <span class="keywordtype">void</span> get_trans_pos(<span class="keyword">const</span> <span class="keywordtype">char</span> **file_var, my_off_t *pos_var)<span class="keyword"> const</span>
<a name="l02970"></a>02970 <span class="keyword">  </span>{
<a name="l02971"></a>02971     DBUG_ENTER(<span class="stringliteral">&quot;THD::get_trans_pos&quot;</span>);
<a name="l02972"></a>02972     <span class="keywordflow">if</span> (file_var)
<a name="l02973"></a>02973       *file_var = m_trans_log_file;
<a name="l02974"></a>02974     <span class="keywordflow">if</span> (pos_var)
<a name="l02975"></a>02975       *pos_var= m_trans_end_pos;
<a name="l02976"></a>02976     DBUG_PRINT(<span class="stringliteral">&quot;return&quot;</span>, (<span class="stringliteral">&quot;file: %s, pos: %llu&quot;</span>,
<a name="l02977"></a>02977                           file_var ? *file_var : <span class="stringliteral">&quot;&lt;none&gt;&quot;</span>,
<a name="l02978"></a>02978                           pos_var ? *pos_var : 0));
<a name="l02979"></a>02979     DBUG_VOID_RETURN;
<a name="l02980"></a>02980   }
<a name="l02981"></a>02981 
<a name="l02982"></a>02982   <span class="keywordtype">void</span> get_trans_fixed_pos(<span class="keyword">const</span> <span class="keywordtype">char</span> **file_var, my_off_t *pos_var)<span class="keyword"> const</span>
<a name="l02983"></a>02983 <span class="keyword">  </span>{
<a name="l02984"></a>02984     DBUG_ENTER(<span class="stringliteral">&quot;THD::get_trans_fixed_pos&quot;</span>);
<a name="l02985"></a>02985     <span class="keywordflow">if</span> (file_var)
<a name="l02986"></a>02986       *file_var = m_trans_fixed_log_file;
<a name="l02987"></a>02987     <span class="keywordflow">if</span> (pos_var)
<a name="l02988"></a>02988       *pos_var= m_trans_end_pos;
<a name="l02989"></a>02989     DBUG_PRINT(<span class="stringliteral">&quot;return&quot;</span>, (<span class="stringliteral">&quot;file: %s, pos: %llu&quot;</span>,
<a name="l02990"></a>02990                           file_var ? *file_var : <span class="stringliteral">&quot;&lt;none&gt;&quot;</span>,
<a name="l02991"></a>02991                           pos_var ? *pos_var : 0));
<a name="l02992"></a>02992     DBUG_VOID_RETURN;
<a name="l02993"></a>02993   }
<a name="l02997"></a>02997   <span class="comment">/*</span>
<a name="l02998"></a>02998 <span class="comment">    Error code from committing or rolling back the transaction.</span>
<a name="l02999"></a>02999 <span class="comment">  */</span>
<a name="l03000"></a>03000   <span class="keyword">enum</span> Commit_error
<a name="l03001"></a>03001   {
<a name="l03002"></a>03002     CE_NONE= 0,
<a name="l03003"></a>03003     CE_FLUSH_ERROR,
<a name="l03004"></a>03004     CE_COMMIT_ERROR,
<a name="l03005"></a>03005     CE_ERROR_COUNT
<a name="l03006"></a>03006   } commit_error;
<a name="l03007"></a>03007 
<a name="l03008"></a>03008   <span class="comment">/*</span>
<a name="l03009"></a>03009 <span class="comment">    Define durability properties that engines may check to</span>
<a name="l03010"></a>03010 <span class="comment">    improve performance.</span>
<a name="l03011"></a>03011 <span class="comment">  */</span>
<a name="l03012"></a>03012   <span class="keyword">enum</span> durability_properties durability_property;
<a name="l03013"></a>03013 
<a name="l03014"></a>03014   <span class="comment">/*</span>
<a name="l03015"></a>03015 <span class="comment">    If checking this in conjunction with a wait condition, please</span>
<a name="l03016"></a>03016 <span class="comment">    include a check after enter_cond() if you want to avoid a race</span>
<a name="l03017"></a>03017 <span class="comment">    condition. For details see the implementation of awake(),</span>
<a name="l03018"></a>03018 <span class="comment">    especially the &quot;broadcast&quot; part.</span>
<a name="l03019"></a>03019 <span class="comment">  */</span>
<a name="l03020"></a>03020   <span class="keyword">enum</span> killed_state
<a name="l03021"></a>03021   {
<a name="l03022"></a>03022     NOT_KILLED=0,
<a name="l03023"></a>03023     KILL_BAD_DATA=1,
<a name="l03024"></a>03024     KILL_CONNECTION=ER_SERVER_SHUTDOWN,
<a name="l03025"></a>03025     KILL_QUERY=ER_QUERY_INTERRUPTED,
<a name="l03026"></a>03026     KILLED_NO_VALUE      <span class="comment">/* means neither of the states */</span>
<a name="l03027"></a>03027   };
<a name="l03028"></a>03028   killed_state <span class="keyword">volatile</span> killed;
<a name="l03029"></a>03029 
<a name="l03030"></a>03030   <span class="comment">/* scramble - random string sent to client on handshake */</span>
<a name="l03031"></a>03031   <span class="keywordtype">char</span>       scramble[SCRAMBLE_LENGTH+1];
<a name="l03032"></a>03032 
<a name="l03034"></a>03034   <span class="keywordtype">bool</span>       slave_thread, one_shot_set;
<a name="l03035"></a>03035   <span class="keywordtype">bool</span>       no_errors;
<a name="l03036"></a>03036   uchar      password;
<a name="l03044"></a>03044   <span class="keywordtype">bool</span> is_fatal_error;
<a name="l03050"></a>03050   <span class="keywordtype">bool</span>       transaction_rollback_request;
<a name="l03062"></a>03062   <span class="keywordtype">bool</span>       is_fatal_sub_stmt_error;
<a name="l03063"></a>03063   <span class="keywordtype">bool</span>       query_start_used, query_start_usec_used;
<a name="l03064"></a>03064   <span class="keywordtype">bool</span>       rand_used, time_zone_used;
<a name="l03065"></a>03065   <span class="comment">/* for IS NULL =&gt; = last_insert_id() fix in remove_eq_conds() */</span>
<a name="l03066"></a>03066   <span class="keywordtype">bool</span>       substitute_null_with_insert_id;
<a name="l03067"></a>03067   <span class="keywordtype">bool</span>       in_lock_tables;
<a name="l03074"></a>03074   <span class="keywordtype">bool</span>       is_slave_error;
<a name="l03075"></a>03075   <span class="keywordtype">bool</span>       bootstrap;
<a name="l03076"></a>03076 
<a name="l03078"></a>03078   <span class="keywordtype">bool</span>       thread_specific_used;
<a name="l03083"></a>03083   <span class="keywordtype">bool</span>       charset_is_system_charset, charset_is_collation_connection;
<a name="l03084"></a>03084   <span class="keywordtype">bool</span>       charset_is_character_set_filesystem;
<a name="l03085"></a>03085   <span class="keywordtype">bool</span>       enable_slow_log;   <span class="comment">/* enable slow log for current statement */</span>
<a name="l03086"></a>03086   <span class="keywordtype">bool</span>       abort_on_warning;
<a name="l03087"></a>03087   <span class="keywordtype">bool</span>       got_warning;       <span class="comment">/* Set on call to push_warning() */</span>
<a name="l03088"></a>03088   <span class="comment">/* set during loop of derived table processing */</span>
<a name="l03089"></a>03089   <span class="keywordtype">bool</span>       derived_tables_processing;
<a name="l03090"></a>03090   my_bool    tablespace_op;     <span class="comment">/* This is TRUE in DISCARD/IMPORT TABLESPACE */</span>
<a name="l03091"></a>03091 
<a name="l03093"></a>03093   <a class="code" href="classsp__rcontext.html">sp_rcontext</a> *sp_runtime_ctx;
<a name="l03094"></a>03094   <a class="code" href="classsp__cache.html">sp_cache</a>   *sp_proc_cache;
<a name="l03095"></a>03095   <a class="code" href="classsp__cache.html">sp_cache</a>   *sp_func_cache;
<a name="l03096"></a>03096 
<a name="l03098"></a>03098   uint       query_name_consts;
<a name="l03099"></a>03099 
<a name="l03100"></a>03100   <span class="comment">/*</span>
<a name="l03101"></a>03101 <span class="comment">    If we do a purge of binary logs, log index info of the threads</span>
<a name="l03102"></a>03102 <span class="comment">    that are currently reading it needs to be adjusted. To do that</span>
<a name="l03103"></a>03103 <span class="comment">    each thread that is using LOG_INFO needs to adjust the pointer to it</span>
<a name="l03104"></a>03104 <span class="comment">  */</span>
<a name="l03105"></a>03105   <a class="code" href="structst__log__info.html">LOG_INFO</a>*  current_linfo;
<a name="l03106"></a>03106   NET*       slave_net;                 <span class="comment">// network connection from slave -&gt; m.</span>
<a name="l03107"></a>03107   <span class="comment">/* Used by the sys_var class to store temporary values */</span>
<a name="l03108"></a>03108   <span class="keyword">union</span>
<a name="l03109"></a>03109   {
<a name="l03110"></a>03110     my_bool   my_bool_value;
<a name="l03111"></a>03111     <span class="keywordtype">long</span>      long_value;
<a name="l03112"></a>03112     ulong     ulong_value;
<a name="l03113"></a>03113     ulonglong ulonglong_value;
<a name="l03114"></a>03114     <span class="keywordtype">double</span>    double_value;
<a name="l03115"></a>03115   } sys_var_tmp;
<a name="l03116"></a>03116   
<a name="l03117"></a>03117   <span class="keyword">struct </span>{
<a name="l03118"></a>03118     <span class="comment">/* </span>
<a name="l03119"></a>03119 <span class="comment">      If true, mysql_bin_log::write(Log_event) call will not write events to </span>
<a name="l03120"></a>03120 <span class="comment">      binlog, and maintain 2 below variables instead (use</span>
<a name="l03121"></a>03121 <span class="comment">      mysql_bin_log.start_union_events to turn this on)</span>
<a name="l03122"></a>03122 <span class="comment">    */</span>
<a name="l03123"></a>03123     <span class="keywordtype">bool</span> do_union;
<a name="l03124"></a>03124     <span class="comment">/*</span>
<a name="l03125"></a>03125 <span class="comment">      If TRUE, at least one mysql_bin_log::write(Log_event) call has been</span>
<a name="l03126"></a>03126 <span class="comment">      made after last mysql_bin_log.start_union_events() call.</span>
<a name="l03127"></a>03127 <span class="comment">    */</span>
<a name="l03128"></a>03128     <span class="keywordtype">bool</span> unioned_events;
<a name="l03129"></a>03129     <span class="comment">/*</span>
<a name="l03130"></a>03130 <span class="comment">      If TRUE, at least one mysql_bin_log::write(Log_event e), where </span>
<a name="l03131"></a>03131 <span class="comment">      e.cache_stmt == TRUE call has been made after last </span>
<a name="l03132"></a>03132 <span class="comment">      mysql_bin_log.start_union_events() call.</span>
<a name="l03133"></a>03133 <span class="comment">    */</span>
<a name="l03134"></a>03134     <span class="keywordtype">bool</span> unioned_events_trans;
<a name="l03135"></a>03135     
<a name="l03136"></a>03136     <span class="comment">/* </span>
<a name="l03137"></a>03137 <span class="comment">      &#39;queries&#39; (actually SP statements) that run under inside this binlog</span>
<a name="l03138"></a>03138 <span class="comment">      union have thd-&gt;query_id &gt;= first_query_id.</span>
<a name="l03139"></a>03139 <span class="comment">    */</span>
<a name="l03140"></a>03140     query_id_t first_query_id;
<a name="l03141"></a>03141   } binlog_evt_union;
<a name="l03142"></a>03142 
<a name="l03148"></a>03148   Parser_state *m_parser_state;
<a name="l03149"></a>03149 
<a name="l03150"></a>03150   Locked_tables_list locked_tables_list;
<a name="l03151"></a>03151 
<a name="l03152"></a>03152 <span class="preprocessor">#ifdef WITH_PARTITION_STORAGE_ENGINE</span>
<a name="l03153"></a>03153 <span class="preprocessor"></span>  <a class="code" href="classpartition__info.html">partition_info</a> *work_part_info;
<a name="l03154"></a>03154 <span class="preprocessor">#endif</span>
<a name="l03155"></a>03155 <span class="preprocessor"></span>
<a name="l03156"></a>03156 <span class="preprocessor">#ifndef EMBEDDED_LIBRARY</span>
<a name="l03157"></a>03157 <span class="preprocessor"></span>
<a name="l03162"></a>03162   DYNAMIC_ARRAY audit_class_plugins;
<a name="l03167"></a>03167   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> audit_class_mask[MYSQL_AUDIT_CLASS_MASK_SIZE];
<a name="l03168"></a>03168 <span class="preprocessor">#endif</span>
<a name="l03169"></a>03169 <span class="preprocessor"></span>
<a name="l03170"></a>03170 <span class="preprocessor">#if defined(ENABLED_DEBUG_SYNC)</span>
<a name="l03171"></a>03171 <span class="preprocessor"></span>  <span class="comment">/* Debug Sync facility. See debug_sync.cc. */</span>
<a name="l03172"></a>03172   <span class="keyword">struct </span>st_debug_sync_control *debug_sync_control;
<a name="l03173"></a>03173 <span class="preprocessor">#endif </span><span class="comment">/* defined(ENABLED_DEBUG_SYNC) */</span>
<a name="l03174"></a>03174 
<a name="l03175"></a>03175   <span class="comment">// We don&#39;t want to load/unload plugins for unit tests.</span>
<a name="l03176"></a>03176   <span class="keywordtype">bool</span> m_enable_plugins;
<a name="l03177"></a>03177 
<a name="l03178"></a>03178   THD(<span class="keywordtype">bool</span> enable_plugins= <span class="keyword">true</span>);
<a name="l03179"></a>03179 
<a name="l03180"></a>03180   <span class="comment">/*</span>
<a name="l03181"></a>03181 <span class="comment">    The THD dtor is effectively split in two:</span>
<a name="l03182"></a>03182 <span class="comment">      THD::release_resources() and ~THD().</span>
<a name="l03183"></a>03183 <span class="comment"></span>
<a name="l03184"></a>03184 <span class="comment">    We want to minimize the time we hold LOCK_thread_count,</span>
<a name="l03185"></a>03185 <span class="comment">    so when destroying a global thread, do:</span>
<a name="l03186"></a>03186 <span class="comment"></span>
<a name="l03187"></a>03187 <span class="comment">    thd-&gt;release_resources()</span>
<a name="l03188"></a>03188 <span class="comment">    remove_global_thread(thd);</span>
<a name="l03189"></a>03189 <span class="comment">    delete thd;</span>
<a name="l03190"></a>03190 <span class="comment">   */</span>
<a name="l03191"></a>03191   ~THD();
<a name="l03192"></a>03192 
<a name="l03193"></a>03193   <span class="keywordtype">void</span> release_resources();
<a name="l03194"></a>03194   <span class="keywordtype">bool</span> release_resources_done()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_release_resources_done; }
<a name="l03195"></a>03195 
<a name="l03196"></a>03196 <span class="keyword">private</span>:
<a name="l03197"></a>03197   <span class="keywordtype">bool</span> m_release_resources_done;
<a name="l03198"></a>03198   <span class="keywordtype">bool</span> cleanup_done;
<a name="l03199"></a>03199   <span class="keywordtype">void</span> cleanup(<span class="keywordtype">void</span>);
<a name="l03200"></a>03200 
<a name="l03201"></a>03201 <span class="keyword">public</span>:
<a name="l03202"></a>03202   <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>);
<a name="l03203"></a>03203   <span class="comment">/*</span>
<a name="l03204"></a>03204 <span class="comment">    Initialize memory roots necessary for query processing and (!)</span>
<a name="l03205"></a>03205 <span class="comment">    pre-allocate memory for it. We can&#39;t do that in THD constructor because</span>
<a name="l03206"></a>03206 <span class="comment">    there are use cases (acl_init, delayed inserts, watcher threads,</span>
<a name="l03207"></a>03207 <span class="comment">    killing mysqld) where it&#39;s vital to not allocate excessive and not used</span>
<a name="l03208"></a>03208 <span class="comment">    memory. Note, that we still don&#39;t return error from init_for_queries():</span>
<a name="l03209"></a>03209 <span class="comment">    if preallocation fails, we should notice that at the first call to</span>
<a name="l03210"></a>03210 <span class="comment">    alloc_root. </span>
<a name="l03211"></a>03211 <span class="comment">  */</span>
<a name="l03212"></a>03212   <span class="keywordtype">void</span> init_for_queries(<a class="code" href="classRelay__log__info.html">Relay_log_info</a> *rli= NULL);
<a name="l03213"></a>03213   <span class="keywordtype">void</span> change_user(<span class="keywordtype">void</span>);
<a name="l03214"></a>03214   <span class="keywordtype">void</span> cleanup_after_query();
<a name="l03215"></a>03215   <span class="keywordtype">bool</span> store_globals();
<a name="l03216"></a>03216   <span class="keywordtype">bool</span> restore_globals();
<a name="l03217"></a>03217 <span class="preprocessor">#ifdef SIGNAL_WITH_VIO_SHUTDOWN</span>
<a name="l03218"></a>03218 <span class="preprocessor"></span>  <span class="keyword">inline</span> <span class="keywordtype">void</span> set_active_vio(Vio* vio)
<a name="l03219"></a>03219   {
<a name="l03220"></a>03220     mysql_mutex_lock(&amp;LOCK_thd_data);
<a name="l03221"></a>03221     active_vio = vio;
<a name="l03222"></a>03222     mysql_mutex_unlock(&amp;LOCK_thd_data);
<a name="l03223"></a>03223   }
<a name="l03224"></a>03224   <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_active_vio()
<a name="l03225"></a>03225   {
<a name="l03226"></a>03226     mysql_mutex_lock(&amp;LOCK_thd_data);
<a name="l03227"></a>03227     active_vio = 0;
<a name="l03228"></a>03228     mysql_mutex_unlock(&amp;LOCK_thd_data);
<a name="l03229"></a>03229   }
<a name="l03230"></a>03230   <span class="keywordtype">void</span> shutdown_active_vio();
<a name="l03231"></a>03231 <span class="preprocessor">#endif</span>
<a name="l03232"></a>03232 <span class="preprocessor"></span>  <span class="keywordtype">void</span> awake(THD::killed_state state_to_set);
<a name="l03233"></a>03233 
<a name="l03235"></a>03235   <span class="keywordtype">void</span> disconnect();
<a name="l03236"></a>03236 
<a name="l03237"></a>03237 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l03238"></a>03238 <span class="preprocessor"></span>  <span class="keyword">enum</span> enum_binlog_query_type {
<a name="l03239"></a>03239     <span class="comment">/* The query can be logged in row format or in statement format. */</span>
<a name="l03240"></a>03240     ROW_QUERY_TYPE,
<a name="l03241"></a>03241     
<a name="l03242"></a>03242     <span class="comment">/* The query has to be logged in statement format. */</span>
<a name="l03243"></a>03243     STMT_QUERY_TYPE,
<a name="l03244"></a>03244     
<a name="l03245"></a>03245     QUERY_TYPE_COUNT
<a name="l03246"></a>03246   };
<a name="l03247"></a>03247   
<a name="l03248"></a>03248   <span class="keywordtype">int</span> binlog_query(enum_binlog_query_type qtype,
<a name="l03249"></a>03249                    <span class="keywordtype">char</span> <span class="keyword">const</span> *query, ulong query_len, <span class="keywordtype">bool</span> is_trans,
<a name="l03250"></a>03250                    <span class="keywordtype">bool</span> direct, <span class="keywordtype">bool</span> suppress_use,
<a name="l03251"></a>03251                    <span class="keywordtype">int</span> errcode);
<a name="l03252"></a>03252 <span class="preprocessor">#endif</span>
<a name="l03253"></a>03253 <span class="preprocessor"></span>
<a name="l03254"></a>03254   <span class="comment">// Begin implementation of MDL_context_owner interface.</span>
<a name="l03255"></a>03255 
<a name="l03256"></a>03256   <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l03257"></a>03257   enter_cond(mysql_cond_t *cond, mysql_mutex_t* mutex,
<a name="l03258"></a>03258              <span class="keyword">const</span> PSI_stage_info *stage, PSI_stage_info *old_stage,
<a name="l03259"></a>03259              <span class="keyword">const</span> <span class="keywordtype">char</span> *src_function, <span class="keyword">const</span> <span class="keywordtype">char</span> *src_file,
<a name="l03260"></a>03260              <span class="keywordtype">int</span> src_line)
<a name="l03261"></a>03261   {
<a name="l03262"></a>03262     DBUG_ENTER(<span class="stringliteral">&quot;THD::enter_cond&quot;</span>);
<a name="l03263"></a>03263     mysql_mutex_assert_owner(mutex);
<a name="l03264"></a>03264     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;thd: 0x%llx, mysys_var: 0x%llx, current_mutex: 0x%llx -&gt; 0x%llx&quot;</span>,
<a name="l03265"></a>03265                          (ulonglong) <span class="keyword">this</span>,
<a name="l03266"></a>03266                          (ulonglong) mysys_var,
<a name="l03267"></a>03267                          (ulonglong) mysys_var-&gt;current_mutex,
<a name="l03268"></a>03268                          (ulonglong) mutex));
<a name="l03269"></a>03269     mysys_var-&gt;current_mutex = mutex;
<a name="l03270"></a>03270     mysys_var-&gt;current_cond = cond;
<a name="l03271"></a>03271     enter_stage(stage, old_stage, src_function, src_file, src_line);
<a name="l03272"></a>03272     DBUG_VOID_RETURN;
<a name="l03273"></a>03273   }
<a name="l03274"></a>03274   <span class="keyword">inline</span> <span class="keywordtype">void</span> exit_cond(<span class="keyword">const</span> PSI_stage_info *stage,
<a name="l03275"></a>03275                         <span class="keyword">const</span> <span class="keywordtype">char</span> *src_function, <span class="keyword">const</span> <span class="keywordtype">char</span> *src_file,
<a name="l03276"></a>03276                         <span class="keywordtype">int</span> src_line)
<a name="l03277"></a>03277   {
<a name="l03278"></a>03278     DBUG_ENTER(<span class="stringliteral">&quot;THD::exit_cond&quot;</span>);
<a name="l03279"></a>03279     <span class="comment">/*</span>
<a name="l03280"></a>03280 <span class="comment">      Putting the mutex unlock in thd-&gt;exit_cond() ensures that</span>
<a name="l03281"></a>03281 <span class="comment">      mysys_var-&gt;current_mutex is always unlocked _before_ mysys_var-&gt;mutex is</span>
<a name="l03282"></a>03282 <span class="comment">      locked (if that would not be the case, you&#39;ll get a deadlock if someone</span>
<a name="l03283"></a>03283 <span class="comment">      does a THD::awake() on you).</span>
<a name="l03284"></a>03284 <span class="comment">    */</span>
<a name="l03285"></a>03285     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>, (<span class="stringliteral">&quot;thd: 0x%llx, mysys_var: 0x%llx, current_mutex: 0x%llx -&gt; 0x%llx&quot;</span>,
<a name="l03286"></a>03286                          (ulonglong) <span class="keyword">this</span>,
<a name="l03287"></a>03287                          (ulonglong) mysys_var,
<a name="l03288"></a>03288                          (ulonglong) mysys_var-&gt;current_mutex,
<a name="l03289"></a>03289                          0ULL));
<a name="l03290"></a>03290     mysql_mutex_unlock(mysys_var-&gt;current_mutex);
<a name="l03291"></a>03291     mysql_mutex_lock(&amp;mysys_var-&gt;mutex);
<a name="l03292"></a>03292     mysys_var-&gt;current_mutex = 0;
<a name="l03293"></a>03293     mysys_var-&gt;current_cond = 0;
<a name="l03294"></a>03294     enter_stage(stage, NULL, src_function, src_file, src_line);
<a name="l03295"></a>03295     mysql_mutex_unlock(&amp;mysys_var-&gt;mutex);
<a name="l03296"></a>03296     DBUG_VOID_RETURN;
<a name="l03297"></a>03297   }
<a name="l03298"></a>03298 
<a name="l03299"></a>03299   <span class="keyword">virtual</span> <span class="keywordtype">int</span> is_killed() { <span class="keywordflow">return</span> killed; }
<a name="l03300"></a>03300   <span class="keyword">virtual</span> THD* get_thd() { <span class="keywordflow">return</span> <span class="keyword">this</span>; }
<a name="l03301"></a>03301 
<a name="l03325"></a>03325   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> notify_shared_lock(<a class="code" href="classMDL__context__owner.html">MDL_context_owner</a> *ctx_in_use,
<a name="l03326"></a>03326                                   <span class="keywordtype">bool</span> needs_thr_lock_abort);
<a name="l03327"></a>03327 
<a name="l03328"></a>03328   <span class="comment">// End implementation of MDL_context_owner interface.</span>
<a name="l03329"></a>03329 
<a name="l03330"></a>03330   <span class="keyword">inline</span> sql_mode_t datetime_flags()<span class="keyword"> const</span>
<a name="l03331"></a>03331 <span class="keyword">  </span>{
<a name="l03332"></a>03332     <span class="keywordflow">return</span> variables.sql_mode &amp;
<a name="l03333"></a>03333       (MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE | MODE_INVALID_DATES);
<a name="l03334"></a>03334   }
<a name="l03335"></a>03335   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_strict_mode()<span class="keyword"> const</span>
<a name="l03336"></a>03336 <span class="keyword">  </span>{
<a name="l03337"></a>03337     <span class="keywordflow">return</span> MY_TEST(variables.sql_mode &amp; (MODE_STRICT_TRANS_TABLES |
<a name="l03338"></a>03338                                          MODE_STRICT_ALL_TABLES));
<a name="l03339"></a>03339   }
<a name="l03340"></a>03340   <span class="keyword">inline</span> <a class="code" href="classTime__zone.html">Time_zone</a> *time_zone()
<a name="l03341"></a>03341   {
<a name="l03342"></a>03342     time_zone_used= 1;
<a name="l03343"></a>03343     <span class="keywordflow">return</span> variables.time_zone;
<a name="l03344"></a>03344   }
<a name="l03345"></a>03345   <span class="keyword">inline</span> time_t query_start()
<a name="l03346"></a>03346   {
<a name="l03347"></a>03347     query_start_used= 1;
<a name="l03348"></a>03348     <span class="keywordflow">return</span> start_time.tv_sec;
<a name="l03349"></a>03349   }
<a name="l03350"></a>03350   <span class="keyword">inline</span> <span class="keywordtype">long</span> query_start_usec()
<a name="l03351"></a>03351   {
<a name="l03352"></a>03352     query_start_usec_used= 1;
<a name="l03353"></a>03353     <span class="keywordflow">return</span> start_time.tv_usec;
<a name="l03354"></a>03354   }
<a name="l03355"></a>03355   <span class="keyword">inline</span> timeval query_start_timeval()
<a name="l03356"></a>03356   {
<a name="l03357"></a>03357     query_start_used= query_start_usec_used= <span class="keyword">true</span>;
<a name="l03358"></a>03358     <span class="keywordflow">return</span> start_time;
<a name="l03359"></a>03359   }
<a name="l03360"></a>03360   timeval query_start_timeval_trunc(uint decimals);
<a name="l03361"></a>03361   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_time()
<a name="l03362"></a>03362   {
<a name="l03363"></a>03363     start_utime= utime_after_lock= my_micro_time();
<a name="l03364"></a>03364     <span class="keywordflow">if</span> (user_time.tv_sec || user_time.tv_usec)
<a name="l03365"></a>03365     {
<a name="l03366"></a>03366       start_time= user_time;
<a name="l03367"></a>03367     }
<a name="l03368"></a>03368     <span class="keywordflow">else</span>
<a name="l03369"></a>03369       my_micro_time_to_timeval(start_utime, &amp;start_time);
<a name="l03370"></a>03370 
<a name="l03371"></a>03371 <span class="preprocessor">#ifdef HAVE_PSI_THREAD_INTERFACE</span>
<a name="l03372"></a>03372 <span class="preprocessor"></span>    PSI_THREAD_CALL(set_thread_start_time)(start_time.tv_sec);
<a name="l03373"></a>03373 <span class="preprocessor">#endif</span>
<a name="l03374"></a>03374 <span class="preprocessor"></span>  }
<a name="l03375"></a>03375   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_current_time()
<a name="l03376"></a>03376   {
<a name="l03377"></a>03377     my_micro_time_to_timeval(my_micro_time(), &amp;start_time);
<a name="l03378"></a>03378 <span class="preprocessor">#ifdef HAVE_PSI_THREAD_INTERFACE</span>
<a name="l03379"></a>03379 <span class="preprocessor"></span>    PSI_THREAD_CALL(set_thread_start_time)(start_time.tv_sec);
<a name="l03380"></a>03380 <span class="preprocessor">#endif</span>
<a name="l03381"></a>03381 <span class="preprocessor"></span>  }
<a name="l03382"></a>03382   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_time(<span class="keyword">const</span> <span class="keyword">struct</span> timeval *t)
<a name="l03383"></a>03383   {
<a name="l03384"></a>03384     start_time= user_time= *t;
<a name="l03385"></a>03385     start_utime= utime_after_lock= my_micro_time();
<a name="l03386"></a>03386 <span class="preprocessor">#ifdef HAVE_PSI_THREAD_INTERFACE</span>
<a name="l03387"></a>03387 <span class="preprocessor"></span>    PSI_THREAD_CALL(set_thread_start_time)(start_time.tv_sec);
<a name="l03388"></a>03388 <span class="preprocessor">#endif</span>
<a name="l03389"></a>03389 <span class="preprocessor"></span>  }
<a name="l03390"></a>03390   <span class="comment">/*TODO: this will be obsolete when we have support for 64 bit my_time_t */</span>
<a name="l03391"></a>03391   <span class="keyword">inline</span> <span class="keywordtype">bool</span>   is_valid_time() 
<a name="l03392"></a>03392   { 
<a name="l03393"></a>03393     <span class="keywordflow">return</span> (IS_TIME_T_VALID_FOR_TIMESTAMP(start_time.tv_sec));
<a name="l03394"></a>03394   }
<a name="l03395"></a>03395   <span class="keywordtype">void</span> set_time_after_lock()
<a name="l03396"></a>03396   {
<a name="l03397"></a>03397     utime_after_lock= my_micro_time();
<a name="l03398"></a>03398     MYSQL_SET_STATEMENT_LOCK_TIME(m_statement_psi, (utime_after_lock - start_utime));
<a name="l03399"></a>03399   }
<a name="l03400"></a>03400   ulonglong current_utime()  { <span class="keywordflow">return</span> my_micro_time(); }
<a name="l03409"></a>03409   <span class="keywordtype">void</span> update_server_status()
<a name="l03410"></a>03410   {
<a name="l03411"></a>03411     ulonglong end_utime_of_query= current_utime();
<a name="l03412"></a>03412     <span class="keywordflow">if</span> (end_utime_of_query &gt; utime_after_lock + variables.long_query_time)
<a name="l03413"></a>03413       server_status|= SERVER_QUERY_WAS_SLOW;
<a name="l03414"></a>03414   }
<a name="l03415"></a>03415   <span class="keyword">inline</span> ulonglong found_rows(<span class="keywordtype">void</span>)
<a name="l03416"></a>03416   {
<a name="l03417"></a>03417     <span class="keywordflow">return</span> limit_found_rows;
<a name="l03418"></a>03418   }
<a name="l03442"></a>03442   <span class="keyword">inline</span> <span class="keywordtype">bool</span> in_multi_stmt_transaction_mode()<span class="keyword"> const</span>
<a name="l03443"></a>03443 <span class="keyword">  </span>{
<a name="l03444"></a>03444     <span class="keywordflow">return</span> variables.option_bits &amp; (OPTION_NOT_AUTOCOMMIT | OPTION_BEGIN);
<a name="l03445"></a>03445   }
<a name="l03479"></a>03479   <span class="keyword">inline</span> <span class="keywordtype">bool</span> in_active_multi_stmt_transaction()<span class="keyword"> const</span>
<a name="l03480"></a>03480 <span class="keyword">  </span>{
<a name="l03481"></a>03481     <span class="keywordflow">return</span> server_status &amp; SERVER_STATUS_IN_TRANS;
<a name="l03482"></a>03482   }
<a name="l03483"></a>03483   <span class="keyword">inline</span> <span class="keywordtype">bool</span> fill_derived_tables()
<a name="l03484"></a>03484   {
<a name="l03485"></a>03485     <span class="keywordflow">return</span> !stmt_arena-&gt;is_stmt_prepare() &amp;&amp; !lex-&gt;only_view_structure();
<a name="l03486"></a>03486   }
<a name="l03487"></a>03487   <span class="keyword">inline</span> <span class="keywordtype">bool</span> fill_information_schema_tables()
<a name="l03488"></a>03488   {
<a name="l03489"></a>03489     <span class="keywordflow">return</span> !stmt_arena-&gt;is_stmt_prepare();
<a name="l03490"></a>03490   }
<a name="l03491"></a>03491   <span class="keyword">inline</span> <span class="keywordtype">void</span>* trans_alloc(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size)
<a name="l03492"></a>03492   {
<a name="l03493"></a>03493     <span class="keywordflow">return</span> alloc_root(&amp;transaction.mem_root,size);
<a name="l03494"></a>03494   }
<a name="l03495"></a>03495 
<a name="l03496"></a>03496   LEX_STRING *make_lex_string(LEX_STRING *lex_str,
<a name="l03497"></a>03497                               <span class="keyword">const</span> <span class="keywordtype">char</span>* str, uint length,
<a name="l03498"></a>03498                               <span class="keywordtype">bool</span> allocate_lex_string);
<a name="l03499"></a>03499 
<a name="l03500"></a>03500   <span class="keywordtype">bool</span> convert_string(LEX_STRING *to, <span class="keyword">const</span> CHARSET_INFO *to_cs,
<a name="l03501"></a>03501                       <span class="keyword">const</span> <span class="keywordtype">char</span> *from, uint from_length,
<a name="l03502"></a>03502                       <span class="keyword">const</span> CHARSET_INFO *from_cs);
<a name="l03503"></a>03503 
<a name="l03504"></a>03504   <span class="keywordtype">bool</span> convert_string(<a class="code" href="classString.html">String</a> *s, <span class="keyword">const</span> CHARSET_INFO *from_cs,
<a name="l03505"></a>03505                       <span class="keyword">const</span> CHARSET_INFO *to_cs);
<a name="l03506"></a>03506 
<a name="l03507"></a>03507   <span class="keywordtype">void</span> add_changed_table(<a class="code" href="structTABLE.html">TABLE</a> *table);
<a name="l03508"></a>03508   <span class="keywordtype">void</span> add_changed_table(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">long</span> key_length);
<a name="l03509"></a>03509   <a class="code" href="structst__changed__table__list.html">CHANGED_TABLE_LIST</a> * changed_table_dup(<span class="keyword">const</span> <span class="keywordtype">char</span> *key, <span class="keywordtype">long</span> key_length);
<a name="l03510"></a>03510   <span class="keywordtype">int</span> send_explain_fields(select_result *result);
<a name="l03511"></a>03511 
<a name="l03519"></a>03519   <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_error()
<a name="l03520"></a>03520   {
<a name="l03521"></a>03521     DBUG_ENTER(<span class="stringliteral">&quot;clear_error&quot;</span>);
<a name="l03522"></a>03522     <span class="keywordflow">if</span> (get_stmt_da()-&gt;is_error())
<a name="l03523"></a>03523       get_stmt_da()-&gt;reset_diagnostics_area();
<a name="l03524"></a>03524     is_slave_error= 0;
<a name="l03525"></a>03525     DBUG_VOID_RETURN;
<a name="l03526"></a>03526   }
<a name="l03527"></a>03527 <span class="preprocessor">#ifndef EMBEDDED_LIBRARY</span>
<a name="l03528"></a>03528 <span class="preprocessor"></span>  <span class="keyword">inline</span> <span class="keywordtype">bool</span> vio_ok()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> net.vio != 0; }
<a name="l03530"></a>03530   <span class="keywordtype">bool</span> is_connected()
<a name="l03531"></a>03531   {
<a name="l03532"></a>03532     <span class="comment">/*</span>
<a name="l03533"></a>03533 <span class="comment">      All system threads (e.g., the slave IO thread) are connected but</span>
<a name="l03534"></a>03534 <span class="comment">      not using vio. So this function always returns true for all</span>
<a name="l03535"></a>03535 <span class="comment">      system threads.</span>
<a name="l03536"></a>03536 <span class="comment">    */</span>
<a name="l03537"></a>03537     <span class="keywordflow">return</span> system_thread || (vio_ok() ? vio_is_connected(net.vio) : FALSE);
<a name="l03538"></a>03538   }
<a name="l03539"></a>03539 <span class="preprocessor">#else</span>
<a name="l03540"></a>03540 <span class="preprocessor"></span>  <span class="keyword">inline</span> <span class="keywordtype">bool</span> vio_ok()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> TRUE; }
<a name="l03541"></a>03541   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_connected() { <span class="keywordflow">return</span> TRUE; }
<a name="l03542"></a>03542 <span class="preprocessor">#endif</span>
<a name="l03543"></a>03543 <span class="preprocessor"></span>
<a name="l03548"></a>03548   <span class="keyword">inline</span> <span class="keywordtype">void</span> fatal_error()
<a name="l03549"></a>03549   {
<a name="l03550"></a>03550     DBUG_ASSERT(get_stmt_da()-&gt;is_error() || killed);
<a name="l03551"></a>03551     is_fatal_error= 1;
<a name="l03552"></a>03552     DBUG_PRINT(<span class="stringliteral">&quot;error&quot;</span>,(<span class="stringliteral">&quot;Fatal error set&quot;</span>));
<a name="l03553"></a>03553   }
<a name="l03567"></a>03567   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_error()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> get_stmt_da()-&gt;is_error(); }
<a name="l03568"></a>03568 
<a name="l03570"></a>03570   <a class="code" href="classDiagnostics__area.html">Diagnostics_area</a> *get_stmt_da()
<a name="l03571"></a>03571   { <span class="keywordflow">return</span> m_stmt_da; }
<a name="l03572"></a>03572 
<a name="l03574"></a>03574   <span class="keyword">const</span> <a class="code" href="classDiagnostics__area.html">Diagnostics_area</a> *get_stmt_da()<span class="keyword"> const</span>
<a name="l03575"></a>03575 <span class="keyword">  </span>{ <span class="keywordflow">return</span> m_stmt_da; }
<a name="l03576"></a>03576 
<a name="l03578"></a>03578   <span class="keywordtype">void</span> set_stmt_da(<a class="code" href="classDiagnostics__area.html">Diagnostics_area</a> *da)
<a name="l03579"></a>03579   { m_stmt_da= da; }
<a name="l03580"></a>03580 
<a name="l03581"></a>03581 <span class="keyword">public</span>:
<a name="l03582"></a>03582   <span class="keyword">inline</span> <span class="keyword">const</span> CHARSET_INFO *charset()
<a name="l03583"></a>03583   { <span class="keywordflow">return</span> variables.character_set_client; }
<a name="l03584"></a>03584   <span class="keywordtype">void</span> update_charset();
<a name="l03585"></a>03585 
<a name="l03586"></a>03586   <span class="keywordtype">void</span> change_item_tree(<a class="code" href="classItem.html">Item</a> **place, <a class="code" href="classItem.html">Item</a> *new_value)
<a name="l03587"></a>03587   {
<a name="l03588"></a>03588     <span class="comment">/* TODO: check for OOM condition here */</span>
<a name="l03589"></a>03589     <span class="keywordflow">if</span> (!stmt_arena-&gt;is_conventional())
<a name="l03590"></a>03590     {
<a name="l03591"></a>03591       DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>,
<a name="l03592"></a>03592                  (<span class="stringliteral">&quot;change_item_tree place %p old_value %p new_value %p&quot;</span>,
<a name="l03593"></a>03593                   place, *place, new_value));
<a name="l03594"></a>03594       <span class="keywordflow">if</span> (new_value)
<a name="l03595"></a>03595         new_value-&gt;set_runtime_created(); <span class="comment">/* Note the change of item tree */</span>
<a name="l03596"></a>03596       nocheck_register_item_tree_change(place, *place, mem_root);
<a name="l03597"></a>03597     }
<a name="l03598"></a>03598     *place= new_value;
<a name="l03599"></a>03599   }
<a name="l03600"></a>03600 
<a name="l03601"></a>03601 <span class="comment">/*</span>
<a name="l03602"></a>03602 <span class="comment">  Find and update change record of an underlying item.</span>
<a name="l03603"></a>03603 <span class="comment"></span>
<a name="l03604"></a>03604 <span class="comment">  @param old_ref The old place of moved expression.</span>
<a name="l03605"></a>03605 <span class="comment">  @param new_ref The new place of moved expression.</span>
<a name="l03606"></a>03606 <span class="comment">  @details</span>
<a name="l03607"></a>03607 <span class="comment">  During permanent transformations, e.g. join flattening in simplify_joins,</span>
<a name="l03608"></a>03608 <span class="comment">  a condition could be moved from one place to another, e.g. from on_expr</span>
<a name="l03609"></a>03609 <span class="comment">  to WHERE condition. If the moved condition has replaced some other with</span>
<a name="l03610"></a>03610 <span class="comment">  change_item_tree() function, the change record will restore old value</span>
<a name="l03611"></a>03611 <span class="comment">  to the wrong place during rollback_item_tree_changes. This function goes</span>
<a name="l03612"></a>03612 <span class="comment">  through the list of change records, and replaces Item_change_record::place.</span>
<a name="l03613"></a>03613 <span class="comment">*/</span>
<a name="l03614"></a>03614   <span class="keywordtype">void</span> change_item_tree_place(<a class="code" href="classItem.html">Item</a> **old_ref, <a class="code" href="classItem.html">Item</a> **new_ref);
<a name="l03615"></a>03615   <span class="keywordtype">void</span> nocheck_register_item_tree_change(<a class="code" href="classItem.html">Item</a> **place, <a class="code" href="classItem.html">Item</a> *old_value,
<a name="l03616"></a>03616                                          MEM_ROOT *runtime_memroot);
<a name="l03617"></a>03617   <span class="keywordtype">void</span> rollback_item_tree_changes();
<a name="l03618"></a>03618 
<a name="l03619"></a>03619   <span class="comment">/*</span>
<a name="l03620"></a>03620 <span class="comment">    Cleanup statement parse state (parse tree, lex) and execution</span>
<a name="l03621"></a>03621 <span class="comment">    state after execution of a non-prepared SQL statement.</span>
<a name="l03622"></a>03622 <span class="comment">  */</span>
<a name="l03623"></a>03623   <span class="keywordtype">void</span> end_statement();
<a name="l03624"></a>03624   <span class="keyword">inline</span> <span class="keywordtype">int</span> killed_errno()<span class="keyword"> const</span>
<a name="l03625"></a>03625 <span class="keyword">  </span>{
<a name="l03626"></a>03626     killed_state killed_val; <span class="comment">/* to cache the volatile &#39;killed&#39; */</span>
<a name="l03627"></a>03627     <span class="keywordflow">return</span> (killed_val= killed) != KILL_BAD_DATA ? killed_val : 0;
<a name="l03628"></a>03628   }
<a name="l03629"></a>03629   <span class="keyword">inline</span> <span class="keywordtype">void</span> send_kill_message()<span class="keyword"> const</span>
<a name="l03630"></a>03630 <span class="keyword">  </span>{
<a name="l03631"></a>03631     <span class="keywordtype">int</span> err= killed_errno();
<a name="l03632"></a>03632     <span class="keywordflow">if</span> (err &amp;&amp; !get_stmt_da()-&gt;is_set())
<a name="l03633"></a>03633     {
<a name="l03634"></a>03634       <span class="keywordflow">if</span> ((err == KILL_CONNECTION) &amp;&amp; !shutdown_in_progress)
<a name="l03635"></a>03635         err = KILL_QUERY;
<a name="l03636"></a>03636       <span class="comment">/*</span>
<a name="l03637"></a>03637 <span class="comment">        KILL is fatal because:</span>
<a name="l03638"></a>03638 <span class="comment">        - if a condition handler was allowed to trap and ignore a KILL, one</span>
<a name="l03639"></a>03639 <span class="comment">        could create routines which the DBA could not kill</span>
<a name="l03640"></a>03640 <span class="comment">        - INSERT/UPDATE IGNORE should fail: if KILL arrives during</span>
<a name="l03641"></a>03641 <span class="comment">        JOIN::optimize(), statement cannot possibly run as its caller expected</span>
<a name="l03642"></a>03642 <span class="comment">        =&gt; &quot;OK&quot; would be misleading the caller.</span>
<a name="l03643"></a>03643 <span class="comment">      */</span>
<a name="l03644"></a>03644       my_message(err, ER(err), MYF(ME_FATALERROR));
<a name="l03645"></a>03645     }
<a name="l03646"></a>03646   }
<a name="l03647"></a>03647   <span class="comment">/* return TRUE if we will abort query if we make a warning now */</span>
<a name="l03648"></a>03648   <span class="keyword">inline</span> <span class="keywordtype">bool</span> really_abort_on_warning()
<a name="l03649"></a>03649   {
<a name="l03650"></a>03650     <span class="keywordflow">return</span> (abort_on_warning &amp;&amp;
<a name="l03651"></a>03651             (!transaction.stmt.cannot_safely_rollback() ||
<a name="l03652"></a>03652              (variables.sql_mode &amp; MODE_STRICT_ALL_TABLES)));
<a name="l03653"></a>03653   }
<a name="l03654"></a>03654   <span class="keywordtype">void</span> set_status_var_init();
<a name="l03655"></a>03655   <span class="keywordtype">void</span> reset_n_backup_open_tables_state(Open_tables_backup *backup);
<a name="l03656"></a>03656   <span class="keywordtype">void</span> restore_backup_open_tables_state(Open_tables_backup *backup);
<a name="l03657"></a>03657   <span class="keywordtype">void</span> reset_sub_statement_state(Sub_statement_state *backup, uint new_state);
<a name="l03658"></a>03658   <span class="keywordtype">void</span> restore_sub_statement_state(Sub_statement_state *backup);
<a name="l03659"></a>03659   <span class="keywordtype">void</span> set_n_backup_active_arena(Query_arena *<span class="keyword">set</span>, Query_arena *backup);
<a name="l03660"></a>03660   <span class="keywordtype">void</span> restore_active_arena(Query_arena *<span class="keyword">set</span>, Query_arena *backup);
<a name="l03661"></a>03661 
<a name="l03662"></a>03662   <span class="comment">/*</span>
<a name="l03663"></a>03663 <span class="comment">    @todo Make these methods private or remove them completely.  Only</span>
<a name="l03664"></a>03664 <span class="comment">    decide_logging_format should call them. /Sven</span>
<a name="l03665"></a>03665 <span class="comment">  */</span>
<a name="l03666"></a>03666   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_current_stmt_binlog_format_row_if_mixed()
<a name="l03667"></a>03667   {
<a name="l03668"></a>03668     DBUG_ENTER(<span class="stringliteral">&quot;set_current_stmt_binlog_format_row_if_mixed&quot;</span>);
<a name="l03669"></a>03669     <span class="comment">/*</span>
<a name="l03670"></a>03670 <span class="comment">      This should only be called from decide_logging_format.</span>
<a name="l03671"></a>03671 <span class="comment"></span>
<a name="l03672"></a>03672 <span class="comment">      @todo Once we have ensured this, uncomment the following</span>
<a name="l03673"></a>03673 <span class="comment">      statement, remove the big comment below that, and remove the</span>
<a name="l03674"></a>03674 <span class="comment">      in_sub_stmt==0 condition from the following &#39;if&#39;.</span>
<a name="l03675"></a>03675 <span class="comment">    */</span>
<a name="l03676"></a>03676     <span class="comment">/* DBUG_ASSERT(in_sub_stmt == 0); */</span>
<a name="l03677"></a>03677     <span class="comment">/*</span>
<a name="l03678"></a>03678 <span class="comment">      If in a stored/function trigger, the caller should already have done the</span>
<a name="l03679"></a>03679 <span class="comment">      change. We test in_sub_stmt to prevent introducing bugs where people</span>
<a name="l03680"></a>03680 <span class="comment">      wouldn&#39;t ensure that, and would switch to row-based mode in the middle</span>
<a name="l03681"></a>03681 <span class="comment">      of executing a stored function/trigger (which is too late, see also</span>
<a name="l03682"></a>03682 <span class="comment">      reset_current_stmt_binlog_format_row()); this condition will make their</span>
<a name="l03683"></a>03683 <span class="comment">      tests fail and so force them to propagate the</span>
<a name="l03684"></a>03684 <span class="comment">      lex-&gt;binlog_row_based_if_mixed upwards to the caller.</span>
<a name="l03685"></a>03685 <span class="comment">    */</span>
<a name="l03686"></a>03686     <span class="keywordflow">if</span> ((variables.binlog_format == BINLOG_FORMAT_MIXED) &amp;&amp;
<a name="l03687"></a>03687         (in_sub_stmt == 0))
<a name="l03688"></a>03688       set_current_stmt_binlog_format_row();
<a name="l03689"></a>03689 
<a name="l03690"></a>03690     DBUG_VOID_RETURN;
<a name="l03691"></a>03691   }
<a name="l03692"></a>03692   <span class="keyword">inline</span> <span class="keywordtype">void</span> set_current_stmt_binlog_format_row()
<a name="l03693"></a>03693   {
<a name="l03694"></a>03694     DBUG_ENTER(<span class="stringliteral">&quot;set_current_stmt_binlog_format_row&quot;</span>);
<a name="l03695"></a>03695     current_stmt_binlog_format= BINLOG_FORMAT_ROW;
<a name="l03696"></a>03696     DBUG_VOID_RETURN;
<a name="l03697"></a>03697   }
<a name="l03698"></a>03698   <span class="keyword">inline</span> <span class="keywordtype">void</span> clear_current_stmt_binlog_format_row()
<a name="l03699"></a>03699   {
<a name="l03700"></a>03700     DBUG_ENTER(<span class="stringliteral">&quot;clear_current_stmt_binlog_format_row&quot;</span>);
<a name="l03701"></a>03701     current_stmt_binlog_format= BINLOG_FORMAT_STMT;
<a name="l03702"></a>03702     DBUG_VOID_RETURN;
<a name="l03703"></a>03703   }
<a name="l03704"></a>03704   <span class="keyword">inline</span> <span class="keywordtype">void</span> reset_current_stmt_binlog_format_row()
<a name="l03705"></a>03705   {
<a name="l03706"></a>03706     DBUG_ENTER(<span class="stringliteral">&quot;reset_current_stmt_binlog_format_row&quot;</span>);
<a name="l03707"></a>03707     <span class="comment">/*</span>
<a name="l03708"></a>03708 <span class="comment">      If there are temporary tables, don&#39;t reset back to</span>
<a name="l03709"></a>03709 <span class="comment">      statement-based. Indeed it could be that:</span>
<a name="l03710"></a>03710 <span class="comment">      CREATE TEMPORARY TABLE t SELECT UUID(); # row-based</span>
<a name="l03711"></a>03711 <span class="comment">      # and row-based does not store updates to temp tables</span>
<a name="l03712"></a>03712 <span class="comment">      # in the binlog.</span>
<a name="l03713"></a>03713 <span class="comment">      INSERT INTO u SELECT * FROM t; # stmt-based</span>
<a name="l03714"></a>03714 <span class="comment">      and then the INSERT will fail as data inserted into t was not logged.</span>
<a name="l03715"></a>03715 <span class="comment">      So we continue with row-based until the temp table is dropped.</span>
<a name="l03716"></a>03716 <span class="comment">      If we are in a stored function or trigger, we mustn&#39;t reset in the</span>
<a name="l03717"></a>03717 <span class="comment">      middle of its execution (as the binary logging way of a stored function</span>
<a name="l03718"></a>03718 <span class="comment">      or trigger is decided when it starts executing, depending for example on</span>
<a name="l03719"></a>03719 <span class="comment">      the caller (for a stored function: if caller is SELECT or</span>
<a name="l03720"></a>03720 <span class="comment">      INSERT/UPDATE/DELETE...).</span>
<a name="l03721"></a>03721 <span class="comment">    */</span>
<a name="l03722"></a>03722     DBUG_PRINT(<span class="stringliteral">&quot;debug&quot;</span>,
<a name="l03723"></a>03723                (<span class="stringliteral">&quot;temporary_tables: %s, in_sub_stmt: %s, system_thread: %s&quot;</span>,
<a name="l03724"></a>03724                 YESNO(temporary_tables), YESNO(in_sub_stmt),
<a name="l03725"></a>03725                 show_system_thread(system_thread)));
<a name="l03726"></a>03726     <span class="keywordflow">if</span> (in_sub_stmt == 0)
<a name="l03727"></a>03727     {
<a name="l03728"></a>03728       <span class="keywordflow">if</span> (variables.binlog_format == BINLOG_FORMAT_ROW)
<a name="l03729"></a>03729         set_current_stmt_binlog_format_row();
<a name="l03730"></a>03730       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (temporary_tables == NULL)
<a name="l03731"></a>03731         clear_current_stmt_binlog_format_row();
<a name="l03732"></a>03732     }
<a name="l03733"></a>03733     DBUG_VOID_RETURN;
<a name="l03734"></a>03734   }
<a name="l03735"></a>03735 
<a name="l03737"></a>03737   <a class="code" href="classGtid__set.html">Gtid_set</a> *get_gtid_next_list()
<a name="l03738"></a>03738   {
<a name="l03739"></a>03739     <span class="keywordflow">return</span> variables.gtid_next_list.is_non_null ?
<a name="l03740"></a>03740       variables.gtid_next_list.gtid_set : NULL;
<a name="l03741"></a>03741   }
<a name="l03742"></a>03742 
<a name="l03744"></a>03744   <span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *get_gtid_next_list_const()<span class="keyword"> const</span>
<a name="l03745"></a>03745 <span class="keyword">  </span>{
<a name="l03746"></a>03746     <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>THD *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;get_gtid_next_list();
<a name="l03747"></a>03747   }
<a name="l03748"></a>03748 
<a name="l03754"></a>03754   <a class="code" href="classGroup__cache.html">Group_cache</a> *get_group_cache(<span class="keywordtype">bool</span> is_transactional);
<a name="l03755"></a>03755 
<a name="l03762"></a>03762   <a class="code" href="structGtid.html">Gtid</a> owned_gtid;
<a name="l03768"></a>03768   <a class="code" href="classGtid__set.html">Gtid_set</a> owned_gtid_set;
<a name="l03769"></a>03769 
<a name="l03770"></a>03770   <span class="keywordtype">void</span> clear_owned_gtids()
<a name="l03771"></a>03771   {
<a name="l03772"></a>03772     <span class="keywordflow">if</span> (owned_gtid.sidno == -1)
<a name="l03773"></a>03773     {
<a name="l03774"></a>03774 <span class="preprocessor">#ifdef HAVE_GTID_NEXT_LIST</span>
<a name="l03775"></a>03775 <span class="preprocessor"></span>      owned_gtid_set.<a class="code" href="classGtid__set.html#a8d8130a7559cfd7b940f42e66c9b171a">clear</a>();
<a name="l03776"></a>03776 <span class="preprocessor">#else</span>
<a name="l03777"></a>03777 <span class="preprocessor"></span>      DBUG_ASSERT(0);
<a name="l03778"></a>03778 <span class="preprocessor">#endif</span>
<a name="l03779"></a>03779 <span class="preprocessor"></span>    }
<a name="l03780"></a>03780     owned_gtid.sidno= 0;
<a name="l03781"></a>03781   }
<a name="l03782"></a>03782 
<a name="l03783"></a>03783   <span class="comment">/*</span>
<a name="l03784"></a>03784 <span class="comment">    There are some statements (like OPTIMIZE TABLE, ANALYZE TABLE and</span>
<a name="l03785"></a>03785 <span class="comment">    REPAIR TABLE) that might call trans_rollback_stmt() and also will be</span>
<a name="l03786"></a>03786 <span class="comment">    sucessfully executed and will have to go to the binary log.</span>
<a name="l03787"></a>03787 <span class="comment">    For these statements, the skip_gtid_rollback flag must be set to avoid</span>
<a name="l03788"></a>03788 <span class="comment">    problems when the statement is executed with a GTID_NEXT set to GTID_GROUP</span>
<a name="l03789"></a>03789 <span class="comment">    (like the SQL thread do when applying events from other server).</span>
<a name="l03790"></a>03790 <span class="comment">    When this flag is set, a call to gtid_rollback() will do nothing.</span>
<a name="l03791"></a>03791 <span class="comment">  */</span>
<a name="l03792"></a>03792   <span class="keywordtype">bool</span> skip_gtid_rollback;
<a name="l03793"></a>03793 
<a name="l03815"></a>03815   <span class="keywordtype">bool</span> set_db(<span class="keyword">const</span> <span class="keywordtype">char</span> *new_db, <span class="keywordtype">size_t</span> new_db_len)
<a name="l03816"></a>03816   {
<a name="l03817"></a>03817     <span class="keywordtype">bool</span> result;
<a name="l03818"></a>03818     <span class="comment">/*</span>
<a name="l03819"></a>03819 <span class="comment">      Acquiring mutex LOCK_thd_data as we either free the memory allocated</span>
<a name="l03820"></a>03820 <span class="comment">      for the database and reallocating the memory for the new db or memcpy</span>
<a name="l03821"></a>03821 <span class="comment">      the new_db to the db.</span>
<a name="l03822"></a>03822 <span class="comment">    */</span>
<a name="l03823"></a>03823     mysql_mutex_lock(&amp;LOCK_thd_data);
<a name="l03824"></a>03824     <span class="comment">/* Do not reallocate memory if current chunk is big enough. */</span>
<a name="l03825"></a>03825     <span class="keywordflow">if</span> (db &amp;&amp; new_db &amp;&amp; db_length &gt;= new_db_len)
<a name="l03826"></a>03826       memcpy(db, new_db, new_db_len+1);
<a name="l03827"></a>03827     <span class="keywordflow">else</span>
<a name="l03828"></a>03828     {
<a name="l03829"></a>03829       my_free(db);
<a name="l03830"></a>03830       <span class="keywordflow">if</span> (new_db)
<a name="l03831"></a>03831         db= my_strndup(new_db, new_db_len, MYF(MY_WME | ME_FATALERROR));
<a name="l03832"></a>03832       <span class="keywordflow">else</span>
<a name="l03833"></a>03833         db= NULL;
<a name="l03834"></a>03834     }
<a name="l03835"></a>03835     db_length= db ? new_db_len : 0;
<a name="l03836"></a>03836     mysql_mutex_unlock(&amp;LOCK_thd_data);
<a name="l03837"></a>03837     result= new_db &amp;&amp; !db;
<a name="l03838"></a>03838 <span class="preprocessor">#ifdef HAVE_PSI_THREAD_INTERFACE</span>
<a name="l03839"></a>03839 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (result)
<a name="l03840"></a>03840       PSI_THREAD_CALL(set_thread_db)(new_db, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(new_db_len));
<a name="l03841"></a>03841 <span class="preprocessor">#endif</span>
<a name="l03842"></a>03842 <span class="preprocessor"></span>    <span class="keywordflow">return</span> result;
<a name="l03843"></a>03843   }
<a name="l03844"></a>03844 
<a name="l03856"></a>03856   <span class="keywordtype">void</span> reset_db(<span class="keywordtype">char</span> *new_db, <span class="keywordtype">size_t</span> new_db_len)
<a name="l03857"></a>03857   {
<a name="l03858"></a>03858     db= new_db;
<a name="l03859"></a>03859     db_length= new_db_len;
<a name="l03860"></a>03860 <span class="preprocessor">#ifdef HAVE_PSI_THREAD_INTERFACE</span>
<a name="l03861"></a>03861 <span class="preprocessor"></span>    PSI_THREAD_CALL(set_thread_db)(new_db, <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(new_db_len));
<a name="l03862"></a>03862 <span class="preprocessor">#endif</span>
<a name="l03863"></a>03863 <span class="preprocessor"></span>  }
<a name="l03864"></a>03864   <span class="comment">/*</span>
<a name="l03865"></a>03865 <span class="comment">    Copy the current database to the argument. Use the current arena to</span>
<a name="l03866"></a>03866 <span class="comment">    allocate memory for a deep copy: current database may be freed after</span>
<a name="l03867"></a>03867 <span class="comment">    a statement is parsed but before it&#39;s executed.</span>
<a name="l03868"></a>03868 <span class="comment">  */</span>
<a name="l03869"></a>03869   <span class="keywordtype">bool</span> copy_db_to(<span class="keywordtype">char</span> **p_db, <span class="keywordtype">size_t</span> *p_db_length)
<a name="l03870"></a>03870   {
<a name="l03871"></a>03871     <span class="keywordflow">if</span> (db == NULL)
<a name="l03872"></a>03872     {
<a name="l03873"></a>03873       my_message(ER_NO_DB_ERROR, ER(ER_NO_DB_ERROR), MYF(0));
<a name="l03874"></a>03874       <span class="keywordflow">return</span> TRUE;
<a name="l03875"></a>03875     }
<a name="l03876"></a>03876     *p_db= strmake(db, db_length);
<a name="l03877"></a>03877     *p_db_length= db_length;
<a name="l03878"></a>03878     <span class="keywordflow">return</span> FALSE;
<a name="l03879"></a>03879   }
<a name="l03880"></a>03880   <a class="code" href="classthd__scheduler.html">thd_scheduler</a> scheduler;
<a name="l03881"></a>03881 
<a name="l03882"></a>03882 <span class="keyword">public</span>:
<a name="l03883"></a>03883   <span class="keyword">inline</span> Internal_error_handler *get_internal_handler()
<a name="l03884"></a>03884   { <span class="keywordflow">return</span> m_internal_handler; }
<a name="l03885"></a>03885 
<a name="l03890"></a>03890   <span class="keywordtype">void</span> push_internal_handler(Internal_error_handler *<a class="code" href="classhandler.html">handler</a>);
<a name="l03891"></a>03891 
<a name="l03892"></a>03892 <span class="keyword">private</span>:
<a name="l03902"></a>03902   <span class="keywordtype">bool</span> handle_condition(uint sql_errno,
<a name="l03903"></a>03903                         <span class="keyword">const</span> <span class="keywordtype">char</span>* sqlstate,
<a name="l03904"></a>03904                         Sql_condition::enum_warning_level level,
<a name="l03905"></a>03905                         <span class="keyword">const</span> <span class="keywordtype">char</span>* msg,
<a name="l03906"></a>03906                         <a class="code" href="classSql__condition.html">Sql_condition</a> ** cond_hdl);
<a name="l03907"></a>03907 
<a name="l03908"></a>03908 <span class="keyword">public</span>:
<a name="l03912"></a>03912   Internal_error_handler *pop_internal_handler();
<a name="l03913"></a>03913 
<a name="l03914"></a>03914   <a class="code" href="classOpt__trace__context.html">Opt_trace_context</a> opt_trace; 
<a name="l03915"></a>03915 
<a name="l03919"></a>03919   <span class="keywordtype">void</span> raise_error(uint code);
<a name="l03920"></a>03920 
<a name="l03925"></a>03925   <span class="keywordtype">void</span> raise_error_printf(uint code, ...);
<a name="l03926"></a>03926 
<a name="l03931"></a>03931   <span class="keywordtype">void</span> raise_warning(uint code);
<a name="l03932"></a>03932 
<a name="l03937"></a>03937   <span class="keywordtype">void</span> raise_warning_printf(uint code, ...);
<a name="l03938"></a>03938 
<a name="l03943"></a>03943   <span class="keywordtype">void</span> raise_note(uint code);
<a name="l03944"></a>03944 
<a name="l03949"></a>03949   <span class="keywordtype">void</span> raise_note_printf(uint code, ...);
<a name="l03950"></a>03950 
<a name="l03951"></a>03951 <span class="keyword">private</span>:
<a name="l03952"></a>03952   <span class="comment">/*</span>
<a name="l03953"></a>03953 <span class="comment">    Only the implementation of the SIGNAL and RESIGNAL statements</span>
<a name="l03954"></a>03954 <span class="comment">    is permitted to raise SQL conditions in a generic way,</span>
<a name="l03955"></a>03955 <span class="comment">    or to raise them by bypassing handlers (RESIGNAL).</span>
<a name="l03956"></a>03956 <span class="comment">    To raise a SQL condition, the code should use the public</span>
<a name="l03957"></a>03957 <span class="comment">    raise_error() or raise_warning() methods provided by class THD.</span>
<a name="l03958"></a>03958 <span class="comment">  */</span>
<a name="l03959"></a>03959   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSql__cmd__common__signal.html">Sql_cmd_common_signal</a>;
<a name="l03960"></a>03960   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSql__cmd__signal.html">Sql_cmd_signal</a>;
<a name="l03961"></a>03961   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classSql__cmd__resignal.html">Sql_cmd_resignal</a>;
<a name="l03962"></a>03962   <span class="keyword">friend</span> <span class="keywordtype">void</span> push_warning(THD*, Sql_condition::enum_warning_level, uint, <span class="keyword">const</span> <span class="keywordtype">char</span>*);
<a name="l03963"></a>03963   <span class="keyword">friend</span> <span class="keywordtype">void</span> my_message_sql(uint, <span class="keyword">const</span> <span class="keywordtype">char</span> *, myf);
<a name="l03964"></a>03964 
<a name="l03973"></a>03973   <a class="code" href="classSql__condition.html">Sql_condition</a>*
<a name="l03974"></a>03974   <a class="code" href="classSql__cmd__common__signal.html#a47b307e7e605d4a0939c997662a65c01">raise_condition</a>(uint sql_errno,
<a name="l03975"></a>03975                   <span class="keyword">const</span> <span class="keywordtype">char</span>* sqlstate,
<a name="l03976"></a>03976                   Sql_condition::enum_warning_level level,
<a name="l03977"></a>03977                   <span class="keyword">const</span> <span class="keywordtype">char</span>* msg);
<a name="l03978"></a>03978 
<a name="l03979"></a>03979 <span class="keyword">public</span>:
<a name="l03981"></a>03981   <span class="keyword">virtual</span> <span class="keywordtype">void</span> set_statement(Statement *stmt);
<a name="l03982"></a>03982 
<a name="l03983"></a>03983   <span class="keywordtype">void</span> set_command(<span class="keyword">enum</span> enum_server_command command);
<a name="l03984"></a>03984 
<a name="l03985"></a>03985   <span class="keyword">inline</span> <span class="keyword">enum</span> enum_server_command get_command()<span class="keyword"> const</span>
<a name="l03986"></a>03986 <span class="keyword">  </span>{ <span class="keywordflow">return</span> m_command; }
<a name="l03987"></a>03987 
<a name="l03992"></a>03992   <span class="keywordtype">void</span> set_query(<span class="keywordtype">char</span> *query_arg, uint32 query_length_arg,
<a name="l03993"></a>03993                  <span class="keyword">const</span> CHARSET_INFO *cs_arg)
<a name="l03994"></a>03994   {
<a name="l03995"></a>03995     set_query(<a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a>(query_arg, query_length_arg, cs_arg));
<a name="l03996"></a>03996   }
<a name="l03997"></a>03997   <span class="keywordtype">void</span> set_query(<span class="keywordtype">char</span> *query_arg, uint32 query_length_arg) <span class="comment">/*Mutex protected*/</span>
<a name="l03998"></a>03998   {
<a name="l03999"></a>03999     set_query(<a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a>(query_arg, query_length_arg, charset()));
<a name="l04000"></a>04000   }
<a name="l04001"></a>04001   <span class="keywordtype">void</span> set_query(<span class="keyword">const</span> <a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a> &amp;str); <span class="comment">/* Mutex protected */</span>
<a name="l04002"></a>04002   <span class="keywordtype">void</span> reset_query()               <span class="comment">/* Mutex protected */</span>
<a name="l04003"></a>04003   { set_query(<a class="code" href="classCSET__STRING.html" title="Character set armed LEX_STRING.">CSET_STRING</a>()); }
<a name="l04004"></a>04004   <span class="keywordtype">void</span> set_query_and_id(<span class="keywordtype">char</span> *query_arg, uint32 query_length_arg,
<a name="l04005"></a>04005                         <span class="keyword">const</span> CHARSET_INFO *cs, query_id_t new_query_id);
<a name="l04006"></a>04006   <span class="keywordtype">void</span> set_query_id(query_id_t new_query_id);
<a name="l04007"></a>04007   <span class="keywordtype">void</span> set_open_tables(<a class="code" href="structTABLE.html">TABLE</a> *open_tables_arg)
<a name="l04008"></a>04008   {
<a name="l04009"></a>04009     mysql_mutex_lock(&amp;LOCK_thd_data);
<a name="l04010"></a>04010     <a class="code" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables</a>= open_tables_arg;
<a name="l04011"></a>04011     mysql_mutex_unlock(&amp;LOCK_thd_data);
<a name="l04012"></a>04012   }
<a name="l04013"></a>04013   <span class="keywordtype">void</span> set_mysys_var(<span class="keyword">struct</span> st_my_thread_var *new_mysys_var);
<a name="l04014"></a>04014   <span class="keywordtype">void</span> enter_locked_tables_mode(enum_locked_tables_mode mode_arg)
<a name="l04015"></a>04015   {
<a name="l04016"></a>04016     DBUG_ASSERT(locked_tables_mode == LTM_NONE);
<a name="l04017"></a>04017 
<a name="l04018"></a>04018     <span class="keywordflow">if</span> (mode_arg == LTM_LOCK_TABLES)
<a name="l04019"></a>04019     {
<a name="l04020"></a>04020       <span class="comment">/*</span>
<a name="l04021"></a>04021 <span class="comment">        When entering LOCK TABLES mode we should set explicit duration</span>
<a name="l04022"></a>04022 <span class="comment">        for all metadata locks acquired so far in order to avoid releasing</span>
<a name="l04023"></a>04023 <span class="comment">        them till UNLOCK TABLES statement.</span>
<a name="l04024"></a>04024 <span class="comment">        We don&#39;t do this when entering prelocked mode since sub-statements</span>
<a name="l04025"></a>04025 <span class="comment">        don&#39;t release metadata locks and restoring status-quo after leaving</span>
<a name="l04026"></a>04026 <span class="comment">        prelocking mode gets complicated.</span>
<a name="l04027"></a>04027 <span class="comment">      */</span>
<a name="l04028"></a>04028       mdl_context.set_explicit_duration_for_all_locks();
<a name="l04029"></a>04029     }
<a name="l04030"></a>04030 
<a name="l04031"></a>04031     locked_tables_mode= mode_arg;
<a name="l04032"></a>04032   }
<a name="l04033"></a>04033   <span class="keywordtype">void</span> leave_locked_tables_mode();
<a name="l04034"></a>04034   <span class="keywordtype">int</span> decide_logging_format(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *tables);
<a name="l04075"></a>04075   <span class="keywordtype">bool</span>
<a name="l04076"></a>04076   is_dml_gtid_compatible(<span class="keywordtype">bool</span> transactional_table,
<a name="l04077"></a>04077                          <span class="keywordtype">bool</span> non_transactional_table,
<a name="l04078"></a>04078                          <span class="keywordtype">bool</span> non_transactional_tmp_tables) <span class="keyword">const</span>;
<a name="l04079"></a>04079   <span class="keywordtype">bool</span> is_ddl_gtid_compatible() <span class="keyword">const</span>;
<a name="l04080"></a>04080   <span class="keywordtype">void</span> binlog_invoker() { m_binlog_invoker= TRUE; }
<a name="l04081"></a>04081   <span class="keywordtype">bool</span> need_binlog_invoker() { <span class="keywordflow">return</span> m_binlog_invoker; }
<a name="l04082"></a>04082   <span class="keywordtype">void</span> get_definer(<a class="code" href="structst__lex__user.html">LEX_USER</a> *definer);
<a name="l04083"></a>04083   <span class="keywordtype">void</span> set_invoker(<span class="keyword">const</span> LEX_STRING *user, <span class="keyword">const</span> LEX_STRING *host)
<a name="l04084"></a>04084   {
<a name="l04085"></a>04085     invoker_user= *user;
<a name="l04086"></a>04086     invoker_host= *host;
<a name="l04087"></a>04087   }
<a name="l04088"></a>04088   LEX_STRING get_invoker_user() { <span class="keywordflow">return</span> invoker_user; }
<a name="l04089"></a>04089   LEX_STRING get_invoker_host() { <span class="keywordflow">return</span> invoker_host; }
<a name="l04090"></a>04090   <span class="keywordtype">bool</span> has_invoker() { <span class="keywordflow">return</span> invoker_user.str != NULL; }
<a name="l04091"></a>04091 
<a name="l04092"></a>04092   <span class="keywordtype">void</span> mark_transaction_to_rollback(<span class="keywordtype">bool</span> all);
<a name="l04093"></a>04093 
<a name="l04094"></a>04094 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l04095"></a>04095 <span class="preprocessor"></span><span class="keyword">private</span>:
<a name="l04096"></a>04096   <span class="keywordtype">int</span> gis_debug; <span class="comment">// Storage for &quot;SELECT ST_GIS_DEBUG(param);&quot;</span>
<a name="l04097"></a>04097 <span class="keyword">public</span>:
<a name="l04098"></a>04098   <span class="keywordtype">int</span> get_gis_debug() { <span class="keywordflow">return</span> gis_debug; }
<a name="l04099"></a>04099   <span class="keywordtype">void</span> set_gis_debug(<span class="keywordtype">int</span> arg) { gis_debug= arg; }
<a name="l04100"></a>04100 <span class="preprocessor">#endif</span>
<a name="l04101"></a>04101 <span class="preprocessor"></span>
<a name="l04102"></a>04102 <span class="keyword">private</span>:
<a name="l04103"></a>04103 
<a name="l04105"></a>04105   Internal_error_handler *m_internal_handler;
<a name="l04106"></a>04106 
<a name="l04113"></a>04113   LEX main_lex;
<a name="l04122"></a>04122   MEM_ROOT main_mem_root;
<a name="l04123"></a>04123   <a class="code" href="classDiagnostics__area.html">Diagnostics_area</a> main_da;
<a name="l04124"></a>04124   <a class="code" href="classDiagnostics__area.html">Diagnostics_area</a> *m_stmt_da;
<a name="l04125"></a>04125 
<a name="l04134"></a>04134   <span class="keywordtype">bool</span> m_binlog_invoker;
<a name="l04135"></a>04135 
<a name="l04142"></a>04142   LEX_STRING invoker_user;
<a name="l04143"></a>04143   LEX_STRING invoker_host;
<a name="l04144"></a>04144 <span class="keyword">public</span>:
<a name="l04151"></a>04151   <span class="keywordtype">bool</span> duplicate_slave_uuid;
<a name="l04152"></a>04152 };
<a name="l04153"></a>04153 
<a name="l04154"></a>04154 
<a name="l04159"></a>04159 <span class="keyword">class </span>Prepared_stmt_arena_holder
<a name="l04160"></a>04160 {
<a name="l04161"></a>04161 <span class="keyword">public</span>:
<a name="l04170"></a>04170   Prepared_stmt_arena_holder(THD *thd, <span class="keywordtype">bool</span> activate_now_if_needed= <span class="keyword">true</span>)
<a name="l04171"></a>04171    :m_thd(thd),
<a name="l04172"></a>04172     m_arena(NULL)
<a name="l04173"></a>04173   {
<a name="l04174"></a>04174     <span class="keywordflow">if</span> (activate_now_if_needed &amp;&amp;
<a name="l04175"></a>04175         !m_thd-&gt;stmt_arena-&gt;is_conventional() &amp;&amp;
<a name="l04176"></a>04176         m_thd-&gt;mem_root != m_thd-&gt;stmt_arena-&gt;mem_root)
<a name="l04177"></a>04177     {
<a name="l04178"></a>04178       m_thd-&gt;set_n_backup_active_arena(m_thd-&gt;stmt_arena, &amp;m_backup);
<a name="l04179"></a>04179       m_arena= m_thd-&gt;stmt_arena;
<a name="l04180"></a>04180     }
<a name="l04181"></a>04181   }
<a name="l04182"></a>04182 
<a name="l04187"></a>04187   ~Prepared_stmt_arena_holder()
<a name="l04188"></a>04188   {
<a name="l04189"></a>04189     <span class="keywordflow">if</span> (is_activated())
<a name="l04190"></a>04190       m_thd-&gt;restore_active_arena(m_arena, &amp;m_backup);
<a name="l04191"></a>04191   }
<a name="l04192"></a>04192 
<a name="l04193"></a>04193   <span class="keywordtype">bool</span> is_activated()<span class="keyword"> const</span>
<a name="l04194"></a>04194 <span class="keyword">  </span>{ <span class="keywordflow">return</span> m_arena != NULL; }
<a name="l04195"></a>04195 
<a name="l04196"></a>04196 <span class="keyword">private</span>:
<a name="l04198"></a>04198   THD *<span class="keyword">const</span> m_thd;
<a name="l04199"></a>04199 
<a name="l04201"></a>04201   Query_arena *m_arena;
<a name="l04202"></a>04202 
<a name="l04204"></a>04204   Query_arena m_backup;
<a name="l04205"></a>04205 };
<a name="l04206"></a>04206 
<a name="l04207"></a>04207 
<a name="l04210"></a>04210 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04211"></a>04211 my_ok(THD *thd, ulonglong affected_rows= 0, ulonglong <span class="keywordtype">id</span>= 0,
<a name="l04212"></a>04212         <span class="keyword">const</span> <span class="keywordtype">char</span> *message= NULL)
<a name="l04213"></a>04213 {
<a name="l04214"></a>04214   thd-&gt;set_row_count_func(affected_rows);
<a name="l04215"></a>04215   thd-&gt;get_stmt_da()-&gt;set_ok_status(affected_rows, <span class="keywordtype">id</span>, message);
<a name="l04216"></a>04216 }
<a name="l04217"></a>04217 
<a name="l04218"></a>04218 
<a name="l04221"></a>04221 <span class="keyword">inline</span> <span class="keywordtype">void</span>
<a name="l04222"></a>04222 my_eof(THD *thd)
<a name="l04223"></a>04223 {
<a name="l04224"></a>04224   thd-&gt;set_row_count_func(-1);
<a name="l04225"></a>04225   thd-&gt;get_stmt_da()-&gt;set_eof_status(thd);
<a name="l04226"></a>04226 }
<a name="l04227"></a>04227 
<a name="l04228"></a>04228 <span class="preprocessor">#define tmp_disable_binlog(A)       \</span>
<a name="l04229"></a>04229 <span class="preprocessor">  {ulonglong tmp_disable_binlog__save_options= (A)-&gt;variables.option_bits; \</span>
<a name="l04230"></a>04230 <span class="preprocessor">  (A)-&gt;variables.option_bits&amp;= ~OPTION_BIN_LOG</span>
<a name="l04231"></a>04231 <span class="preprocessor"></span>
<a name="l04232"></a>04232 <span class="preprocessor">#define reenable_binlog(A)   (A)-&gt;variables.option_bits= tmp_disable_binlog__save_options;}</span>
<a name="l04233"></a>04233 <span class="preprocessor"></span>
<a name="l04234"></a>04234 
<a name="l04235"></a>04235 LEX_STRING *
<a name="l04236"></a>04236 make_lex_string_root(MEM_ROOT *mem_root,
<a name="l04237"></a>04237                      LEX_STRING *lex_str, <span class="keyword">const</span> <span class="keywordtype">char</span>* str, uint length,
<a name="l04238"></a>04238                      <span class="keywordtype">bool</span> allocate_lex_string);
<a name="l04239"></a>04239 
<a name="l04240"></a>04240 <span class="comment">/*</span>
<a name="l04241"></a>04241 <span class="comment">  Used to hold information about file and file structure in exchange</span>
<a name="l04242"></a>04242 <span class="comment">  via non-DB file (...INTO OUTFILE..., ...LOAD DATA...)</span>
<a name="l04243"></a>04243 <span class="comment">  XXX: We never call destructor for objects of this class.</span>
<a name="l04244"></a>04244 <span class="comment">*/</span>
<a name="l04245"></a>04245 
<a name="l04246"></a>04246 <span class="keyword">class </span>sql_exchange :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l04247"></a>04247 {
<a name="l04248"></a>04248 <span class="keyword">public</span>:
<a name="l04249"></a>04249   <span class="keyword">enum</span> enum_filetype filetype; <span class="comment">/* load XML, Added by Arnold &amp; Erik */</span>
<a name="l04250"></a>04250   <span class="keywordtype">char</span> *file_name;
<a name="l04251"></a>04251   <span class="keyword">const</span> <a class="code" href="classString.html">String</a> *field_term, *enclosed, *line_term, *line_start, *escaped;
<a name="l04252"></a>04252   <span class="keywordtype">bool</span> opt_enclosed;
<a name="l04253"></a>04253   <span class="keywordtype">bool</span> dumpfile;
<a name="l04254"></a>04254   ulong skip_lines;
<a name="l04255"></a>04255   <span class="keyword">const</span> CHARSET_INFO *cs;
<a name="l04256"></a>04256   sql_exchange(<span class="keywordtype">char</span> *name, <span class="keywordtype">bool</span> dumpfile_flag,
<a name="l04257"></a>04257                enum_filetype filetype_arg= FILETYPE_CSV);
<a name="l04258"></a>04258   <span class="keywordtype">bool</span> escaped_given(<span class="keywordtype">void</span>);
<a name="l04259"></a>04259 };
<a name="l04260"></a>04260 
<a name="l04261"></a>04261 <span class="comment">/*</span>
<a name="l04262"></a>04262 <span class="comment">  This is used to get result from a select</span>
<a name="l04263"></a>04263 <span class="comment">*/</span>
<a name="l04264"></a>04264 
<a name="l04265"></a>04265 <span class="keyword">class </span><a class="code" href="classJOIN.html">JOIN</a>;
<a name="l04266"></a>04266 
<a name="l04267"></a>04267 <span class="keyword">class </span>select_result :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a> {
<a name="l04268"></a>04268 <span class="keyword">protected</span>:
<a name="l04269"></a>04269   THD *thd;
<a name="l04270"></a>04270   SELECT_LEX_UNIT *unit;
<a name="l04271"></a>04271 <span class="keyword">public</span>:
<a name="l04276"></a>04276   ha_rows estimated_rowcount;
<a name="l04277"></a>04277   select_result();
<a name="l04278"></a>04278   <span class="keyword">virtual</span> ~select_result() {};
<a name="l04279"></a>04279   <span class="keyword">virtual</span> <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u)
<a name="l04280"></a>04280   {
<a name="l04281"></a>04281     unit= u;
<a name="l04282"></a>04282     <span class="keywordflow">return</span> 0;
<a name="l04283"></a>04283   }
<a name="l04284"></a>04284   <span class="keyword">virtual</span> <span class="keywordtype">int</span> prepare2(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> 0; }
<a name="l04285"></a>04285   <span class="comment">/*</span>
<a name="l04286"></a>04286 <span class="comment">    Because of peculiarities of prepared statements protocol</span>
<a name="l04287"></a>04287 <span class="comment">    we need to know number of columns in the result set (if</span>
<a name="l04288"></a>04288 <span class="comment">    there is a result set) apart from sending columns metadata.</span>
<a name="l04289"></a>04289 <span class="comment">  */</span>
<a name="l04290"></a>04290   <span class="keyword">virtual</span> uint field_count(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;fields)<span class="keyword"> const</span>
<a name="l04291"></a>04291 <span class="keyword">  </span>{ <span class="keywordflow">return</span> fields.elements; }
<a name="l04292"></a>04292   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> send_result_set_metadata(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, uint flags)=0;
<a name="l04293"></a>04293   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items)=0;
<a name="l04294"></a>04294   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> initialize_tables (<a class="code" href="classJOIN.html">JOIN</a> *join=0) { <span class="keywordflow">return</span> 0; }
<a name="l04295"></a>04295   <span class="keyword">virtual</span> <span class="keywordtype">void</span> send_error(uint errcode,<span class="keyword">const</span> <span class="keywordtype">char</span> *err);
<a name="l04296"></a>04296   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> send_eof()=0;
<a name="l04304"></a>04304   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="group__Runtime__Environment.html#ga9f257ba1c05a6af19ffbb21bb49d2005">check_simple_select</a>() <span class="keyword">const</span>;
<a name="l04305"></a>04305   <span class="keyword">virtual</span> <span class="keywordtype">void</span> abort_result_set() {}
<a name="l04306"></a>04306   <span class="comment">/*</span>
<a name="l04307"></a>04307 <span class="comment">    Cleanup instance of this class for next execution of a prepared</span>
<a name="l04308"></a>04308 <span class="comment">    statement/stored procedure.</span>
<a name="l04309"></a>04309 <span class="comment">  */</span>
<a name="l04310"></a>04310   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cleanup();
<a name="l04311"></a>04311   <span class="keywordtype">void</span> set_thd(THD *thd_arg) { thd= thd_arg; }
<a name="l04312"></a>04312 
<a name="l04318"></a>04318   <span class="keywordtype">void</span> reset_offset_limit_cnt() { unit-&gt;offset_limit_cnt= 0; }
<a name="l04319"></a>04319 
<a name="l04320"></a>04320 <span class="preprocessor">#ifdef EMBEDDED_LIBRARY</span>
<a name="l04321"></a>04321 <span class="preprocessor"></span>  <span class="keyword">virtual</span> <span class="keywordtype">void</span> begin_dataset() {}
<a name="l04322"></a>04322 <span class="preprocessor">#else</span>
<a name="l04323"></a>04323 <span class="preprocessor"></span>  <span class="keywordtype">void</span> begin_dataset() {}
<a name="l04324"></a>04324 <span class="preprocessor">#endif</span>
<a name="l04325"></a>04325 <span class="preprocessor"></span>};
<a name="l04326"></a>04326 
<a name="l04327"></a>04327 
<a name="l04328"></a>04328 <span class="comment">/*</span>
<a name="l04329"></a>04329 <span class="comment">  Base class for select_result descendands which intercept and</span>
<a name="l04330"></a>04330 <span class="comment">  transform result set rows. As the rows are not sent to the client,</span>
<a name="l04331"></a>04331 <span class="comment">  sending of result set metadata should be suppressed as well.</span>
<a name="l04332"></a>04332 <span class="comment">*/</span>
<a name="l04333"></a>04333 
<a name="l04334"></a>04334 <span class="keyword">class </span>select_result_interceptor: <span class="keyword">public</span> select_result
<a name="l04335"></a>04335 {
<a name="l04336"></a>04336 <span class="keyword">public</span>:
<a name="l04337"></a>04337   select_result_interceptor() {}              <span class="comment">/* Remove gcc warning */</span>
<a name="l04338"></a>04338   uint field_count(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;fields)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l04339"></a>04339   <span class="keywordtype">bool</span> send_result_set_metadata(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;fields, uint flag) { <span class="keywordflow">return</span> FALSE; }
<a name="l04340"></a>04340 };
<a name="l04341"></a>04341 
<a name="l04342"></a>04342 
<a name="l04343"></a>04343 <span class="keyword">class </span>select_send :<span class="keyword">public</span> select_result {
<a name="l04349"></a>04349   <span class="keywordtype">bool</span> is_result_set_started;
<a name="l04350"></a>04350 <span class="keyword">public</span>:
<a name="l04351"></a>04351   select_send() :is_result_set_started(FALSE) {}
<a name="l04352"></a>04352   <span class="keywordtype">bool</span> send_result_set_metadata(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, uint flags);
<a name="l04353"></a>04353   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l04354"></a>04354   <span class="keywordtype">bool</span> send_eof();
<a name="l04355"></a>04355   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="group__Runtime__Environment.html#ga9f257ba1c05a6af19ffbb21bb49d2005">check_simple_select</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> FALSE; }
<a name="l04356"></a>04356   <span class="keywordtype">void</span> abort_result_set();
<a name="l04357"></a>04357   <span class="keyword">virtual</span> <span class="keywordtype">void</span> cleanup();
<a name="l04358"></a>04358 };
<a name="l04359"></a>04359 
<a name="l04360"></a>04360 
<a name="l04361"></a>04361 <span class="keyword">class </span>select_to_file :<span class="keyword">public</span> select_result_interceptor {
<a name="l04362"></a>04362 <span class="keyword">protected</span>:
<a name="l04363"></a>04363   sql_exchange *exchange;
<a name="l04364"></a>04364   File file;
<a name="l04365"></a>04365   IO_CACHE cache;
<a name="l04366"></a>04366   ha_rows row_count;
<a name="l04367"></a>04367   <span class="keywordtype">char</span> path[FN_REFLEN];
<a name="l04368"></a>04368 
<a name="l04369"></a>04369 <span class="keyword">public</span>:
<a name="l04370"></a>04370   select_to_file(sql_exchange *ex) :exchange(ex), file(-1),row_count(0L)
<a name="l04371"></a>04371   { path[0]=0; }
<a name="l04372"></a>04372   ~select_to_file();
<a name="l04373"></a>04373   <span class="keywordtype">void</span> send_error(uint errcode,<span class="keyword">const</span> <span class="keywordtype">char</span> *err);
<a name="l04374"></a>04374   <span class="keywordtype">bool</span> send_eof();
<a name="l04375"></a>04375   <span class="keywordtype">void</span> cleanup();
<a name="l04376"></a>04376 };
<a name="l04377"></a>04377 
<a name="l04378"></a>04378 
<a name="l04379"></a>04379 <span class="preprocessor">#define ESCAPE_CHARS &quot;ntrb0ZN&quot; // keep synchronous with READ_INFO::unescape</span>
<a name="l04380"></a>04380 <span class="preprocessor"></span>
<a name="l04381"></a>04381 
<a name="l04382"></a>04382 <span class="comment">/*</span>
<a name="l04383"></a>04383 <span class="comment"> List of all possible characters of a numeric value text representation.</span>
<a name="l04384"></a>04384 <span class="comment">*/</span>
<a name="l04385"></a>04385 <span class="preprocessor">#define NUMERIC_CHARS &quot;.0123456789e+-&quot;</span>
<a name="l04386"></a>04386 <span class="preprocessor"></span>
<a name="l04387"></a>04387 
<a name="l04388"></a>04388 <span class="keyword">class </span>select_export :<span class="keyword">public</span> select_to_file {
<a name="l04389"></a>04389   uint field_term_length;
<a name="l04390"></a>04390   <span class="keywordtype">int</span> field_sep_char,escape_char,line_sep_char;
<a name="l04391"></a>04391   <span class="keywordtype">int</span> field_term_char; <span class="comment">// first char of FIELDS TERMINATED BY or MAX_INT</span>
<a name="l04392"></a>04392   <span class="comment">/*</span>
<a name="l04393"></a>04393 <span class="comment">    The is_ambiguous_field_sep field is true if a value of the field_sep_char</span>
<a name="l04394"></a>04394 <span class="comment">    field is one of the &#39;n&#39;, &#39;t&#39;, &#39;r&#39; etc characters</span>
<a name="l04395"></a>04395 <span class="comment">    (see the READ_INFO::unescape method and the ESCAPE_CHARS constant value).</span>
<a name="l04396"></a>04396 <span class="comment">  */</span>
<a name="l04397"></a>04397   <span class="keywordtype">bool</span> is_ambiguous_field_sep;
<a name="l04398"></a>04398   <span class="comment">/*</span>
<a name="l04399"></a>04399 <span class="comment">     The is_ambiguous_field_term is true if field_sep_char contains the first</span>
<a name="l04400"></a>04400 <span class="comment">     char of the FIELDS TERMINATED BY (ENCLOSED BY is empty), and items can</span>
<a name="l04401"></a>04401 <span class="comment">     contain this character.</span>
<a name="l04402"></a>04402 <span class="comment">  */</span>
<a name="l04403"></a>04403   <span class="keywordtype">bool</span> is_ambiguous_field_term;
<a name="l04404"></a>04404   <span class="comment">/*</span>
<a name="l04405"></a>04405 <span class="comment">    The is_unsafe_field_sep field is true if a value of the field_sep_char</span>
<a name="l04406"></a>04406 <span class="comment">    field is one of the &#39;0&#39;..&#39;9&#39;, &#39;+&#39;, &#39;-&#39;, &#39;.&#39; and &#39;e&#39; characters</span>
<a name="l04407"></a>04407 <span class="comment">    (see the NUMERIC_CHARS constant value).</span>
<a name="l04408"></a>04408 <span class="comment">  */</span>
<a name="l04409"></a>04409   <span class="keywordtype">bool</span> is_unsafe_field_sep;
<a name="l04410"></a>04410   <span class="keywordtype">bool</span> fixed_row_size;
<a name="l04411"></a>04411   <span class="keyword">const</span> CHARSET_INFO *write_cs; <span class="comment">// output charset</span>
<a name="l04412"></a>04412 <span class="keyword">public</span>:
<a name="l04413"></a>04413   select_export(sql_exchange *ex) :select_to_file(ex) {}
<a name="l04414"></a>04414   ~select_export();
<a name="l04415"></a>04415   <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u);
<a name="l04416"></a>04416   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l04417"></a>04417 };
<a name="l04418"></a>04418 
<a name="l04419"></a>04419 
<a name="l04420"></a>04420 <span class="keyword">class </span>select_dump :<span class="keyword">public</span> select_to_file {
<a name="l04421"></a>04421 <span class="keyword">public</span>:
<a name="l04422"></a>04422   select_dump(sql_exchange *ex) :select_to_file(ex) {}
<a name="l04423"></a>04423   <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u);
<a name="l04424"></a>04424   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l04425"></a>04425 };
<a name="l04426"></a>04426 
<a name="l04432"></a>04432 <span class="keyword">class </span>select_insert :<span class="keyword">public</span> select_result_interceptor {
<a name="l04433"></a>04433 <span class="keyword">public</span>:
<a name="l04434"></a>04434   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list;
<a name="l04435"></a>04435   <a class="code" href="structTABLE.html">TABLE</a> *table;
<a name="l04436"></a>04436 <span class="keyword">private</span>:
<a name="l04442"></a>04442   <a class="code" href="classList.html">List&lt;Item&gt;</a> *fields;
<a name="l04443"></a>04443 <span class="keyword">protected</span>:
<a name="l04445"></a>04445   <span class="keywordtype">bool</span> bulk_insert_started;
<a name="l04446"></a>04446 <span class="keyword">public</span>:
<a name="l04447"></a>04447   ulonglong autoinc_value_of_last_inserted_row; <span class="comment">// autogenerated or not</span>
<a name="l04448"></a>04448   <a class="code" href="classCOPY__INFO.html">COPY_INFO</a> info;
<a name="l04449"></a>04449   <a class="code" href="classCOPY__INFO.html">COPY_INFO</a> update; 
<a name="l04450"></a>04450   <span class="keywordtype">bool</span> insert_into_view;
<a name="l04451"></a>04451 
<a name="l04500"></a>04500   select_insert(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list_par,
<a name="l04501"></a>04501                 <a class="code" href="structTABLE.html">TABLE</a> *table_par,
<a name="l04502"></a>04502                 <a class="code" href="classList.html">List&lt;Item&gt;</a> *target_columns,
<a name="l04503"></a>04503                 <a class="code" href="classList.html">List&lt;Item&gt;</a> *target_or_source_columns,
<a name="l04504"></a>04504                 <a class="code" href="classList.html">List&lt;Item&gt;</a> *update_fields,
<a name="l04505"></a>04505                 <a class="code" href="classList.html">List&lt;Item&gt;</a> *update_values,
<a name="l04506"></a>04506                 enum_duplicates duplic,
<a name="l04507"></a>04507                 <span class="keywordtype">bool</span> ignore)
<a name="l04508"></a>04508     :table_list(table_list_par),
<a name="l04509"></a>04509      table(table_par),
<a name="l04510"></a>04510      fields(target_or_source_columns),
<a name="l04511"></a>04511      bulk_insert_started(false),
<a name="l04512"></a>04512      autoinc_value_of_last_inserted_row(0),
<a name="l04513"></a>04513      info(<a class="code" href="classCOPY__INFO.html">COPY_INFO</a>::INSERT_OPERATION,
<a name="l04514"></a>04514           target_columns,
<a name="l04515"></a>04515           <span class="comment">// manage_defaults</span>
<a name="l04516"></a>04516           (target_columns == NULL || target_columns-&gt;elements != 0),
<a name="l04517"></a>04517           duplic,
<a name="l04518"></a>04518           ignore),
<a name="l04519"></a>04519      update(<a class="code" href="classCOPY__INFO.html">COPY_INFO</a>::UPDATE_OPERATION,
<a name="l04520"></a>04520             update_fields,
<a name="l04521"></a>04521             update_values),
<a name="l04522"></a>04522      insert_into_view(table_list_par &amp;&amp; table_list_par-&gt;view != 0)
<a name="l04523"></a>04523   {
<a name="l04524"></a>04524     DBUG_ASSERT(target_or_source_columns != NULL);
<a name="l04525"></a>04525     DBUG_ASSERT(target_columns == target_or_source_columns ||
<a name="l04526"></a>04526                 target_columns == NULL);
<a name="l04527"></a>04527   }
<a name="l04528"></a>04528 
<a name="l04529"></a>04529 
<a name="l04530"></a>04530 <span class="keyword">public</span>:
<a name="l04531"></a>04531   ~select_insert();
<a name="l04532"></a>04532   <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u);
<a name="l04533"></a>04533   <span class="keyword">virtual</span> <span class="keywordtype">int</span> prepare2(<span class="keywordtype">void</span>);
<a name="l04534"></a>04534   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l04535"></a>04535   <span class="keyword">virtual</span> <span class="keywordtype">void</span> store_values(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;values);
<a name="l04536"></a>04536   <span class="keywordtype">void</span> send_error(uint errcode,<span class="keyword">const</span> <span class="keywordtype">char</span> *err);
<a name="l04537"></a>04537   <span class="keywordtype">bool</span> send_eof();
<a name="l04538"></a>04538   <span class="keyword">virtual</span> <span class="keywordtype">void</span> abort_result_set();
<a name="l04539"></a>04539   <span class="comment">/* not implemented: select_insert is never re-used in prepared statements */</span>
<a name="l04540"></a>04540   <span class="keywordtype">void</span> cleanup();
<a name="l04541"></a>04541 };
<a name="l04542"></a>04542 
<a name="l04543"></a>04543 
<a name="l04550"></a>04550 <span class="keyword">class </span>select_create: <span class="keyword">public</span> select_insert {
<a name="l04551"></a>04551   <a class="code" href="structst__order.html">ORDER</a> *group;
<a name="l04552"></a>04552   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *create_table;
<a name="l04553"></a>04553   <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info;
<a name="l04554"></a>04554   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *select_tables;
<a name="l04555"></a>04555   <a class="code" href="classAlter__info.html">Alter_info</a> *alter_info;
<a name="l04556"></a>04556   <a class="code" href="classField.html">Field</a> **field;
<a name="l04557"></a>04557   <span class="comment">/* lock data for tmp table */</span>
<a name="l04558"></a>04558   <a class="code" href="structst__mysql__lock.html">MYSQL_LOCK</a> *m_lock;
<a name="l04559"></a>04559   <span class="comment">/* m_lock or thd-&gt;extra_lock */</span>
<a name="l04560"></a>04560   <a class="code" href="structst__mysql__lock.html">MYSQL_LOCK</a> **m_plock;
<a name="l04561"></a>04561 <span class="keyword">public</span>:
<a name="l04562"></a>04562   select_create (<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_arg,
<a name="l04563"></a>04563                  <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info_par,
<a name="l04564"></a>04564                  <a class="code" href="classAlter__info.html">Alter_info</a> *alter_info_arg,
<a name="l04565"></a>04565                  <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;select_fields,enum_duplicates duplic, <span class="keywordtype">bool</span> ignore,
<a name="l04566"></a>04566                  <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *select_tables_arg)
<a name="l04567"></a>04567     :select_insert (NULL, <span class="comment">// table_list_par</span>
<a name="l04568"></a>04568                     NULL, <span class="comment">// table_par</span>
<a name="l04569"></a>04569                     NULL, <span class="comment">// target_columns</span>
<a name="l04570"></a>04570                     &amp;select_fields,
<a name="l04571"></a>04571                     NULL, <span class="comment">// update_fields</span>
<a name="l04572"></a>04572                     NULL, <span class="comment">// update_values</span>
<a name="l04573"></a>04573                     duplic,
<a name="l04574"></a>04574                     ignore),
<a name="l04575"></a>04575      create_table(table_arg),
<a name="l04576"></a>04576      create_info(create_info_par),
<a name="l04577"></a>04577      select_tables(select_tables_arg),
<a name="l04578"></a>04578      alter_info(alter_info_arg),
<a name="l04579"></a>04579      m_plock(NULL)
<a name="l04580"></a>04580   {}
<a name="l04581"></a>04581   <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u);
<a name="l04582"></a>04582 
<a name="l04583"></a>04583   <span class="keywordtype">int</span> binlog_show_create_table(<a class="code" href="structTABLE.html">TABLE</a> **tables, uint count);
<a name="l04584"></a>04584   <span class="keywordtype">void</span> store_values(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;values);
<a name="l04585"></a>04585   <span class="keywordtype">void</span> send_error(uint errcode,<span class="keyword">const</span> <span class="keywordtype">char</span> *err);
<a name="l04586"></a>04586   <span class="keywordtype">bool</span> send_eof();
<a name="l04587"></a>04587   <span class="keyword">virtual</span> <span class="keywordtype">void</span> abort_result_set();
<a name="l04588"></a>04588 
<a name="l04589"></a>04589   <span class="comment">// Needed for access from local class MY_HOOKS in prepare(), since thd is proteted.</span>
<a name="l04590"></a>04590   <span class="keyword">const</span> THD *get_thd(<span class="keywordtype">void</span>) { <span class="keywordflow">return</span> thd; }
<a name="l04591"></a>04591   <span class="keyword">const</span> <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *get_create_info() { <span class="keywordflow">return</span> create_info; };
<a name="l04592"></a>04592   <span class="keywordtype">int</span> prepare2(<span class="keywordtype">void</span>);
<a name="l04593"></a>04593 };
<a name="l04594"></a>04594 
<a name="l04595"></a>04595 <span class="preprocessor">#include &lt;myisam.h&gt;</span>
<a name="l04596"></a>04596 
<a name="l04597"></a>04597 <span class="comment">/* </span>
<a name="l04598"></a>04598 <span class="comment">  Param to create temporary tables when doing SELECT:s </span>
<a name="l04599"></a>04599 <span class="comment">  NOTE</span>
<a name="l04600"></a>04600 <span class="comment">    This structure is copied using memcpy as a part of JOIN.</span>
<a name="l04601"></a>04601 <span class="comment">*/</span>
<a name="l04602"></a>04602 
<a name="l04603"></a>04603 <span class="keyword">class </span>TMP_TABLE_PARAM :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l04604"></a>04604 {
<a name="l04605"></a>04605 <span class="keyword">public</span>:
<a name="l04606"></a>04606   <a class="code" href="classList.html">List&lt;Item&gt;</a> <a class="code" href="group__Query__Executor.html#ga83ce4c7b8a149e93d6112527d0416aa7">copy_funcs</a>;
<a name="l04607"></a>04607   <a class="code" href="classCopy__field.html">Copy_field</a> *copy_field, *copy_field_end;
<a name="l04608"></a>04608   uchar     *group_buff;
<a name="l04609"></a>04609   <a class="code" href="classItem.html">Item</a>      **items_to_copy;                    <span class="comment">/* Fields in tmp table */</span>
<a name="l04610"></a>04610   MI_COLUMNDEF *recinfo,*start_recinfo;
<a name="l04611"></a>04611   <a class="code" href="structst__key.html">KEY</a> *keyinfo;
<a name="l04612"></a>04612   ha_rows end_write_records;
<a name="l04620"></a>04620   uint  field_count; 
<a name="l04629"></a>04629   uint  func_count;  
<a name="l04638"></a>04638   uint  sum_func_count;   
<a name="l04639"></a>04639   uint  hidden_field_count;
<a name="l04640"></a>04640   uint  group_parts,group_length,group_null_parts;
<a name="l04641"></a>04641   uint  quick_group;
<a name="l04648"></a>04648   uint  outer_sum_func_count;
<a name="l04655"></a>04655   <span class="keywordtype">bool</span>  using_outer_summary_function;
<a name="l04656"></a>04656   CHARSET_INFO *table_charset; 
<a name="l04657"></a>04657   <span class="keywordtype">bool</span> schema_table;
<a name="l04658"></a>04658   <span class="comment">/*</span>
<a name="l04659"></a>04659 <span class="comment">    True if GROUP BY and its aggregate functions are already computed</span>
<a name="l04660"></a>04660 <span class="comment">    by a table access method (e.g. by loose index scan). In this case</span>
<a name="l04661"></a>04661 <span class="comment">    query execution should not perform aggregation and should treat</span>
<a name="l04662"></a>04662 <span class="comment">    aggregate functions as normal functions.</span>
<a name="l04663"></a>04663 <span class="comment">  */</span>
<a name="l04664"></a>04664   <span class="keywordtype">bool</span> precomputed_group_by;
<a name="l04665"></a>04665   <span class="keywordtype">bool</span> force_copy_fields;
<a name="l04672"></a>04672   <span class="keywordtype">bool</span> skip_create_table;
<a name="l04673"></a>04673   <span class="comment">/*</span>
<a name="l04674"></a>04674 <span class="comment">    If TRUE, create_tmp_field called from create_tmp_table will convert</span>
<a name="l04675"></a>04675 <span class="comment">    all BIT fields to 64-bit longs. This is a workaround the limitation</span>
<a name="l04676"></a>04676 <span class="comment">    that MEMORY tables cannot index BIT columns.</span>
<a name="l04677"></a>04677 <span class="comment">  */</span>
<a name="l04678"></a>04678   <span class="keywordtype">bool</span> bit_fields_as_long;
<a name="l04679"></a>04679 
<a name="l04680"></a>04680   TMP_TABLE_PARAM()
<a name="l04681"></a>04681     :copy_field(0), copy_field_end(0), group_parts(0),
<a name="l04682"></a>04682      group_length(0), group_null_parts(0), outer_sum_func_count(0),
<a name="l04683"></a>04683      using_outer_summary_function(0),
<a name="l04684"></a>04684      schema_table(0), precomputed_group_by(0), force_copy_fields(0),
<a name="l04685"></a>04685      skip_create_table(FALSE), bit_fields_as_long(0)
<a name="l04686"></a>04686   {}
<a name="l04687"></a>04687   ~TMP_TABLE_PARAM()
<a name="l04688"></a>04688   {
<a name="l04689"></a>04689     cleanup();
<a name="l04690"></a>04690   }
<a name="l04691"></a>04691   <span class="keywordtype">void</span> init(<span class="keywordtype">void</span>);
<a name="l04692"></a>04692   <span class="keyword">inline</span> <span class="keywordtype">void</span> cleanup(<span class="keywordtype">void</span>)
<a name="l04693"></a>04693   {
<a name="l04694"></a>04694     <span class="keywordflow">if</span> (copy_field)                             <span class="comment">/* Fix for Intel compiler */</span>
<a name="l04695"></a>04695     {
<a name="l04696"></a>04696       <span class="keyword">delete</span> [] copy_field;
<a name="l04697"></a>04697       copy_field= NULL;
<a name="l04698"></a>04698       copy_field_end= NULL;
<a name="l04699"></a>04699     }
<a name="l04700"></a>04700   }
<a name="l04701"></a>04701 };
<a name="l04702"></a>04702 
<a name="l04703"></a>04703 <span class="keyword">class </span>select_union :<span class="keyword">public</span> select_result_interceptor
<a name="l04704"></a>04704 {
<a name="l04705"></a>04705   TMP_TABLE_PARAM tmp_table_param;
<a name="l04706"></a>04706 <span class="keyword">public</span>:
<a name="l04707"></a>04707   <a class="code" href="structTABLE.html">TABLE</a> *table;
<a name="l04708"></a>04708 
<a name="l04709"></a>04709   select_union() :table(0) {}
<a name="l04710"></a>04710   <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u);
<a name="l04711"></a>04711   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l04712"></a>04712   <span class="keywordtype">bool</span> send_eof();
<a name="l04713"></a>04713   <span class="keywordtype">bool</span> flush();
<a name="l04714"></a>04714   <span class="keywordtype">void</span> cleanup();
<a name="l04715"></a>04715   <span class="keywordtype">bool</span> create_result_table(THD *thd, <a class="code" href="classList.html">List&lt;Item&gt;</a> *column_types,
<a name="l04716"></a>04716                            <span class="keywordtype">bool</span> is_distinct, ulonglong options,
<a name="l04717"></a>04717                            <span class="keyword">const</span> <span class="keywordtype">char</span> *alias, <span class="keywordtype">bool</span> bit_fields_as_long,
<a name="l04718"></a>04718                            <span class="keywordtype">bool</span> create_table);
<a name="l04719"></a>04719   <span class="keyword">friend</span> <span class="keywordtype">bool</span> mysql_derived_create(THD *thd, LEX *lex, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *derived);
<a name="l04720"></a>04720 };
<a name="l04721"></a>04721 
<a name="l04722"></a>04722 <span class="comment">/* Base subselect interface class */</span>
<a name="l04723"></a>04723 <span class="keyword">class </span>select_subselect :<span class="keyword">public</span> select_result_interceptor
<a name="l04724"></a>04724 {
<a name="l04725"></a>04725 <span class="keyword">protected</span>:
<a name="l04726"></a>04726   <a class="code" href="classItem__subselect.html">Item_subselect</a> *item;
<a name="l04727"></a>04727 <span class="keyword">public</span>:
<a name="l04728"></a>04728   select_subselect(<a class="code" href="classItem__subselect.html">Item_subselect</a> *item);
<a name="l04729"></a>04729   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items)=0;
<a name="l04730"></a>04730   <span class="keywordtype">bool</span> send_eof() { <span class="keywordflow">return</span> 0; };
<a name="l04731"></a>04731 };
<a name="l04732"></a>04732 
<a name="l04733"></a>04733 <span class="comment">/* Single value subselect interface class */</span>
<a name="l04734"></a>04734 <span class="keyword">class </span>select_singlerow_subselect :<span class="keyword">public</span> select_subselect
<a name="l04735"></a>04735 {
<a name="l04736"></a>04736 <span class="keyword">public</span>:
<a name="l04737"></a>04737   select_singlerow_subselect(<a class="code" href="classItem__subselect.html">Item_subselect</a> *item_arg)
<a name="l04738"></a>04738     :select_subselect(item_arg)
<a name="l04739"></a>04739   {}
<a name="l04740"></a>04740   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l04741"></a>04741 };
<a name="l04742"></a>04742 
<a name="l04743"></a>04743 <span class="comment">/* used in independent ALL/ANY optimisation */</span>
<a name="l04744"></a>04744 <span class="keyword">class </span>select_max_min_finder_subselect :<span class="keyword">public</span> select_subselect
<a name="l04745"></a>04745 {
<a name="l04746"></a>04746   <a class="code" href="classItem__cache.html">Item_cache</a> *cache;
<a name="l04747"></a>04747   bool (select_max_min_finder_subselect::*op)();
<a name="l04748"></a>04748   <span class="keywordtype">bool</span> fmax;
<a name="l04754"></a>04754   <span class="keywordtype">bool</span> ignore_nulls;
<a name="l04755"></a>04755 <span class="keyword">public</span>:
<a name="l04756"></a>04756   select_max_min_finder_subselect(<a class="code" href="classItem__subselect.html">Item_subselect</a> *item_arg, <span class="keywordtype">bool</span> mx,
<a name="l04757"></a>04757                                   <span class="keywordtype">bool</span> ignore_nulls)
<a name="l04758"></a>04758     :select_subselect(item_arg), cache(0), fmax(mx), ignore_nulls(ignore_nulls)
<a name="l04759"></a>04759   {}
<a name="l04760"></a>04760   <span class="keywordtype">void</span> cleanup();
<a name="l04761"></a>04761   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l04762"></a>04762 <span class="keyword">private</span>:
<a name="l04763"></a>04763   <span class="keywordtype">bool</span> cmp_real();
<a name="l04764"></a>04764   <span class="keywordtype">bool</span> cmp_int();
<a name="l04765"></a>04765   <span class="keywordtype">bool</span> cmp_decimal();
<a name="l04766"></a>04766   <span class="keywordtype">bool</span> cmp_str();
<a name="l04767"></a>04767 };
<a name="l04768"></a>04768 
<a name="l04769"></a>04769 <span class="comment">/* EXISTS subselect interface class */</span>
<a name="l04770"></a>04770 <span class="keyword">class </span>select_exists_subselect :<span class="keyword">public</span> select_subselect
<a name="l04771"></a>04771 {
<a name="l04772"></a>04772 <span class="keyword">public</span>:
<a name="l04773"></a>04773   select_exists_subselect(<a class="code" href="classItem__subselect.html">Item_subselect</a> *item_arg)
<a name="l04774"></a>04774     :select_subselect(item_arg){}
<a name="l04775"></a>04775   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l04776"></a>04776 };
<a name="l04777"></a>04777 
<a name="l04778"></a>04778 
<a name="l04779"></a>04779 <span class="comment">/* Structs used when sorting */</span>
<a name="l04780"></a>04780 
<a name="l04781"></a>04781 <span class="keyword">typedef</span> <span class="keyword">struct </span>st_sort_field {
<a name="l04782"></a>04782   <a class="code" href="classField.html">Field</a> *field;                         <span class="comment">/* Field to sort */</span>
<a name="l04783"></a>04783   <a class="code" href="classItem.html">Item</a>  *item;                          <span class="comment">/* Item if not sorting fields */</span>
<a name="l04784"></a>04784   uint   length;                        <span class="comment">/* Length of sort field */</span>
<a name="l04785"></a>04785   uint   suffix_length;                 <span class="comment">/* Length suffix (0-4) */</span>
<a name="l04786"></a>04786   Item_result result_type;              <span class="comment">/* Type of item */</span>
<a name="l04787"></a>04787   <span class="keywordtype">bool</span> reverse;                         <span class="comment">/* if descending sort */</span>
<a name="l04788"></a>04788   <span class="keywordtype">bool</span> need_strxnfrm;                   <span class="comment">/* If we have to use strxnfrm() */</span>
<a name="l04789"></a>04789 } SORT_FIELD;
<a name="l04790"></a>04790 
<a name="l04791"></a>04791 
<a name="l04792"></a>04792 <span class="keyword">typedef</span> <span class="keyword">struct </span>st_sort_buffer {
<a name="l04793"></a>04793   uint index;                                   <span class="comment">/* 0 or 1 */</span>
<a name="l04794"></a>04794   uint sort_orders;
<a name="l04795"></a>04795   uint change_pos;                              <span class="comment">/* If sort-fields changed */</span>
<a name="l04796"></a>04796   <span class="keywordtype">char</span> **buff;
<a name="l04797"></a>04797   SORT_FIELD *sortorder;
<a name="l04798"></a>04798 } SORT_BUFFER;
<a name="l04799"></a>04799 
<a name="l04800"></a>04800 <span class="comment">/* Structure for db &amp; table in sql_yacc */</span>
<a name="l04801"></a>04801 
<a name="l04802"></a>04802 <span class="keyword">class </span>Table_ident :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l04803"></a>04803 {
<a name="l04804"></a>04804 <span class="keyword">public</span>:
<a name="l04805"></a>04805   LEX_STRING db;
<a name="l04806"></a>04806   LEX_STRING table;
<a name="l04807"></a>04807   SELECT_LEX_UNIT *sel;
<a name="l04808"></a>04808   <span class="keyword">inline</span> Table_ident(THD *thd, LEX_STRING db_arg, LEX_STRING table_arg,
<a name="l04809"></a>04809                      <span class="keywordtype">bool</span> force)
<a name="l04810"></a>04810     :table(table_arg), sel((SELECT_LEX_UNIT *)0)
<a name="l04811"></a>04811   {
<a name="l04812"></a>04812     <span class="keywordflow">if</span> (!force &amp;&amp; (thd-&gt;client_capabilities &amp; CLIENT_NO_SCHEMA))
<a name="l04813"></a>04813       db.str=0;
<a name="l04814"></a>04814     <span class="keywordflow">else</span>
<a name="l04815"></a>04815       db= db_arg;
<a name="l04816"></a>04816   }
<a name="l04817"></a>04817   <span class="keyword">inline</span> Table_ident(LEX_STRING table_arg) 
<a name="l04818"></a>04818     :table(table_arg), sel((SELECT_LEX_UNIT *)0)
<a name="l04819"></a>04819   {
<a name="l04820"></a>04820     db.str=0;
<a name="l04821"></a>04821   }
<a name="l04822"></a>04822   <span class="comment">/*</span>
<a name="l04823"></a>04823 <span class="comment">    This constructor is used only for the case when we create a derived</span>
<a name="l04824"></a>04824 <span class="comment">    table. A derived table has no name and doesn&#39;t belong to any database.</span>
<a name="l04825"></a>04825 <span class="comment">    Later, if there was an alias specified for the table, it will be set</span>
<a name="l04826"></a>04826 <span class="comment">    by add_table_to_list.</span>
<a name="l04827"></a>04827 <span class="comment">  */</span>
<a name="l04828"></a>04828   <span class="keyword">inline</span> Table_ident(SELECT_LEX_UNIT *s) : sel(s)
<a name="l04829"></a>04829   {
<a name="l04830"></a>04830     <span class="comment">/* We must have a table name here as this is used with add_table_to_list */</span>
<a name="l04831"></a>04831     db.str= empty_c_string;                    <span class="comment">/* a subject to casedn_str */</span>
<a name="l04832"></a>04832     db.length= 0;
<a name="l04833"></a>04833     table.str= internal_table_name;
<a name="l04834"></a>04834     table.length=1;
<a name="l04835"></a>04835   }
<a name="l04836"></a>04836   <span class="keywordtype">bool</span> is_derived_table()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MY_TEST(sel); }
<a name="l04837"></a>04837   <span class="keyword">inline</span> <span class="keywordtype">void</span> change_db(<span class="keywordtype">char</span> *db_name)
<a name="l04838"></a>04838   {
<a name="l04839"></a>04839     db.str= db_name; db.length= (uint) strlen(db_name);
<a name="l04840"></a>04840   }
<a name="l04841"></a>04841 };
<a name="l04842"></a>04842 
<a name="l04843"></a>04843 <span class="comment">// this is needed for user_vars hash</span>
<a name="l04844"></a>04844 <span class="keyword">class </span>user_var_entry
<a name="l04845"></a>04845 {
<a name="l04846"></a>04846   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> extra_size= <span class="keyword">sizeof</span>(double);
<a name="l04847"></a>04847   <span class="keywordtype">char</span> *m_ptr;          <span class="comment">// Value</span>
<a name="l04848"></a>04848   ulong m_length;       <span class="comment">// Value length</span>
<a name="l04849"></a>04849   Item_result m_type;   <span class="comment">// Value type</span>
<a name="l04850"></a>04850 
<a name="l04851"></a>04851   <span class="keywordtype">void</span> reset_value()
<a name="l04852"></a>04852   { m_ptr= NULL; m_length= 0; }
<a name="l04853"></a>04853   <span class="keywordtype">void</span> set_value(<span class="keywordtype">char</span> *value, ulong length)
<a name="l04854"></a>04854   { m_ptr= value; m_length= length; }
<a name="l04855"></a>04855 
<a name="l04863"></a>04863   <span class="keywordtype">char</span> *internal_buffer_ptr()<span class="keyword"> const</span>
<a name="l04864"></a>04864 <span class="keyword">  </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *) <span class="keyword">this</span> + ALIGN_SIZE(<span class="keyword">sizeof</span>(user_var_entry)); }
<a name="l04865"></a>04865 
<a name="l04870"></a>04870   <span class="keywordtype">char</span> *name_ptr()<span class="keyword"> const</span>
<a name="l04871"></a>04871 <span class="keyword">  </span>{ <span class="keywordflow">return</span> internal_buffer_ptr() + extra_size; }
<a name="l04872"></a>04872 
<a name="l04878"></a>04878   <span class="keywordtype">bool</span> realloc(uint length);
<a name="l04879"></a>04879 
<a name="l04885"></a>04885   <span class="keywordtype">bool</span> alloced()
<a name="l04886"></a>04886   { <span class="keywordflow">return</span> m_ptr &amp;&amp; m_ptr != internal_buffer_ptr(); }
<a name="l04887"></a>04887 
<a name="l04891"></a>04891   <span class="keywordtype">void</span> free_value()
<a name="l04892"></a>04892   {
<a name="l04893"></a>04893     <span class="keywordflow">if</span> (alloced())
<a name="l04894"></a>04894       my_free(m_ptr);
<a name="l04895"></a>04895   }
<a name="l04896"></a>04896 
<a name="l04901"></a>04901   <span class="keywordtype">void</span> copy_name(<span class="keyword">const</span> <a class="code" href="classSimple__cstring.html">Simple_cstring</a> &amp;name)
<a name="l04902"></a>04902   {
<a name="l04903"></a>04903     name.<a class="code" href="classSimple__cstring.html#a3154f129a1edc4e0b297e03e38b3323f">strcpy</a>(name_ptr());
<a name="l04904"></a>04904     entry_name= <a class="code" href="className__string.html">Name_string</a>(name_ptr(), name.<a class="code" href="classSimple__cstring.html#a595baefd444a2584baf95758d1deacbf">length</a>());
<a name="l04905"></a>04905   }
<a name="l04906"></a>04906 
<a name="l04911"></a>04911   <span class="keywordtype">void</span> init(<span class="keyword">const</span> <a class="code" href="classSimple__cstring.html">Simple_cstring</a> &amp;name)
<a name="l04912"></a>04912   {
<a name="l04913"></a>04913     copy_name(name);
<a name="l04914"></a>04914     reset_value();
<a name="l04915"></a>04915     update_query_id= 0;
<a name="l04916"></a>04916     collation.set(NULL, DERIVATION_IMPLICIT, 0);
<a name="l04917"></a>04917     unsigned_flag= 0;
<a name="l04918"></a>04918     <span class="comment">/*</span>
<a name="l04919"></a>04919 <span class="comment">      If we are here, we were called from a SET or a query which sets a</span>
<a name="l04920"></a>04920 <span class="comment">      variable. Imagine it is this:</span>
<a name="l04921"></a>04921 <span class="comment">      INSERT INTO t SELECT @a:=10, @a:=@a+1.</span>
<a name="l04922"></a>04922 <span class="comment">      Then when we have a Item_func_get_user_var (because of the @a+1) so we</span>
<a name="l04923"></a>04923 <span class="comment">      think we have to write the value of @a to the binlog. But before that,</span>
<a name="l04924"></a>04924 <span class="comment">      we have a Item_func_set_user_var to create @a (@a:=10), in this we mark</span>
<a name="l04925"></a>04925 <span class="comment">      the variable as &quot;already logged&quot; (line below) so that it won&#39;t be logged</span>
<a name="l04926"></a>04926 <span class="comment">      by Item_func_get_user_var (because that&#39;s not necessary).</span>
<a name="l04927"></a>04927 <span class="comment">    */</span>
<a name="l04928"></a>04928     used_query_id= current_thd-&gt;query_id;
<a name="l04929"></a>04929     set_type(STRING_RESULT);
<a name="l04930"></a>04930   }
<a name="l04931"></a>04931 
<a name="l04941"></a>04941   <span class="keywordtype">bool</span> store(<span class="keywordtype">void</span> *from, uint length, Item_result type);
<a name="l04942"></a>04942 
<a name="l04943"></a>04943 <span class="keyword">public</span>:
<a name="l04944"></a>04944   user_var_entry() {}                         <span class="comment">/* Remove gcc warning */</span>
<a name="l04945"></a>04945 
<a name="l04946"></a>04946   <a class="code" href="classSimple__cstring.html">Simple_cstring</a> entry_name;  <span class="comment">// Variable name</span>
<a name="l04947"></a>04947   <a class="code" href="classDTCollation.html">DTCollation</a> collation;      <span class="comment">// Collation with attributes</span>
<a name="l04948"></a>04948   query_id_t update_query_id, used_query_id;
<a name="l04949"></a>04949   <span class="keywordtype">bool</span> unsigned_flag;         <span class="comment">// true if unsigned, false if signed</span>
<a name="l04950"></a>04950 
<a name="l04964"></a>04964   <span class="keywordtype">bool</span> store(<span class="keywordtype">void</span> *from, uint length, Item_result type,
<a name="l04965"></a>04965              <span class="keyword">const</span> CHARSET_INFO *cs, Derivation dv, <span class="keywordtype">bool</span> unsigned_arg);
<a name="l04970"></a>04970   <span class="keywordtype">void</span> set_type(Item_result type) { m_type= type; }
<a name="l04976"></a>04976   <span class="keywordtype">void</span> set_null_value(Item_result type)
<a name="l04977"></a>04977   {
<a name="l04978"></a>04978     free_value();
<a name="l04979"></a>04979     reset_value();
<a name="l04980"></a>04980     set_type(type);
<a name="l04981"></a>04981   }
<a name="l04982"></a>04982 
<a name="l04990"></a>04990   <span class="keyword">static</span> user_var_entry *create(<span class="keyword">const</span> <a class="code" href="className__string.html">Name_string</a> &amp;name)
<a name="l04991"></a>04991   {
<a name="l04992"></a>04992     user_var_entry *entry;
<a name="l04993"></a>04993     <span class="keywordtype">size_t</span> size= ALIGN_SIZE(<span class="keyword">sizeof</span>(user_var_entry)) +
<a name="l04994"></a>04994                (name.<a class="code" href="classSimple__cstring.html#a595baefd444a2584baf95758d1deacbf">length</a>() + 1) + extra_size;
<a name="l04995"></a>04995     <span class="keywordflow">if</span> (!(entry= (user_var_entry*) my_malloc(size, MYF(MY_WME |
<a name="l04996"></a>04996                                                        ME_FATALERROR))))
<a name="l04997"></a>04997       <span class="keywordflow">return</span> NULL;
<a name="l04998"></a>04998     entry-&gt;init(name);
<a name="l04999"></a>04999     <span class="keywordflow">return</span> entry;
<a name="l05000"></a>05000   }
<a name="l05001"></a>05001 
<a name="l05006"></a>05006   <span class="keywordtype">void</span> destroy()
<a name="l05007"></a>05007   {
<a name="l05008"></a>05008     free_value();  <span class="comment">// Free the external value buffer</span>
<a name="l05009"></a>05009     my_free(<span class="keyword">this</span>); <span class="comment">// Free the instance itself</span>
<a name="l05010"></a>05010   }
<a name="l05011"></a>05011 
<a name="l05012"></a>05012   <span class="comment">/* Routines to access the value and its type */</span>
<a name="l05013"></a>05013   <span class="keyword">const</span> <span class="keywordtype">char</span> *ptr()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_ptr; }
<a name="l05014"></a>05014   ulong length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_length; }
<a name="l05015"></a>05015   Item_result type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_type; }
<a name="l05016"></a>05016   <span class="comment">/* Item-alike routines to access the value */</span>
<a name="l05017"></a>05017   <span class="keywordtype">double</span> val_real(my_bool *null_value);
<a name="l05018"></a>05018   longlong val_int(my_bool *null_value) <span class="keyword">const</span>;
<a name="l05019"></a>05019   <a class="code" href="classString.html">String</a> *val_str(my_bool *null_value, <a class="code" href="classString.html">String</a> *str, uint decimals);
<a name="l05020"></a>05020   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(my_bool *null_value, <a class="code" href="classmy__decimal.html">my_decimal</a> *result);
<a name="l05021"></a>05021 };
<a name="l05022"></a>05022 
<a name="l05023"></a>05023 <span class="comment">/*</span>
<a name="l05024"></a>05024 <span class="comment">   Unique -- class for unique (removing of duplicates). </span>
<a name="l05025"></a>05025 <span class="comment">   Puts all values to the TREE. If the tree becomes too big,</span>
<a name="l05026"></a>05026 <span class="comment">   it&#39;s dumped to the file. User can request sorted values, or</span>
<a name="l05027"></a>05027 <span class="comment">   just iterate through them. In the last case tree merging is performed in</span>
<a name="l05028"></a>05028 <span class="comment">   memory simultaneously with iteration, so it should be ~2-3x faster.</span>
<a name="l05029"></a>05029 <span class="comment"> */</span>
<a name="l05030"></a>05030 
<a name="l05031"></a>05031 <span class="keyword">class </span>Unique :<span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l05032"></a>05032 {
<a name="l05033"></a>05033   DYNAMIC_ARRAY file_ptrs;
<a name="l05034"></a>05034   ulong max_elements;
<a name="l05035"></a>05035   ulonglong max_in_memory_size;
<a name="l05036"></a>05036   IO_CACHE file;
<a name="l05037"></a>05037   TREE tree;
<a name="l05038"></a>05038   uchar *record_pointers;
<a name="l05039"></a>05039   <span class="keywordtype">bool</span> flush();
<a name="l05040"></a>05040   uint size;
<a name="l05041"></a>05041 
<a name="l05042"></a>05042 <span class="keyword">public</span>:
<a name="l05043"></a>05043   ulong elements;
<a name="l05044"></a>05044   Unique(qsort_cmp2 comp_func, <span class="keywordtype">void</span> *comp_func_fixed_arg,
<a name="l05045"></a>05045          uint size_arg, ulonglong max_in_memory_size_arg);
<a name="l05046"></a>05046   ~Unique();
<a name="l05047"></a>05047   ulong elements_in_tree() { <span class="keywordflow">return</span> tree.elements_in_tree; }
<a name="l05048"></a>05048   <span class="keyword">inline</span> <span class="keywordtype">bool</span> unique_add(<span class="keywordtype">void</span> *ptr)
<a name="l05049"></a>05049   {
<a name="l05050"></a>05050     DBUG_ENTER(<span class="stringliteral">&quot;unique_add&quot;</span>);
<a name="l05051"></a>05051     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>, (<span class="stringliteral">&quot;tree %u - %lu&quot;</span>, tree.elements_in_tree, max_elements));
<a name="l05052"></a>05052     <span class="keywordflow">if</span> (tree.elements_in_tree &gt; max_elements &amp;&amp; flush())
<a name="l05053"></a>05053       DBUG_RETURN(1);
<a name="l05054"></a>05054     DBUG_RETURN(!tree_insert(&amp;tree, ptr, 0, tree.custom_arg));
<a name="l05055"></a>05055   }
<a name="l05056"></a>05056 
<a name="l05057"></a>05057   <span class="keywordtype">bool</span> <span class="keyword">get</span>(<a class="code" href="structTABLE.html">TABLE</a> *table);
<a name="l05058"></a>05058   <span class="keyword">static</span> <span class="keywordtype">double</span> get_use_cost(uint *buffer, uint nkeys, uint key_size, 
<a name="l05059"></a>05059                              ulonglong max_in_memory_size);
<a name="l05060"></a>05060 
<a name="l05061"></a>05061   <span class="comment">// Returns the number of bytes needed in imerge_cost_buf.</span>
<a name="l05062"></a>05062   <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> get_cost_calc_buff_size(ulong nkeys, uint key_size, 
<a name="l05063"></a>05063                                             ulonglong max_in_memory_size)
<a name="l05064"></a>05064   {
<a name="l05065"></a>05065     <span class="keyword">register</span> ulonglong max_elems_in_tree=
<a name="l05066"></a>05066       (max_in_memory_size / ALIGN_SIZE(<span class="keyword">sizeof</span>(TREE_ELEMENT)+key_size));
<a name="l05067"></a>05067     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>) (<span class="keyword">sizeof</span>(uint)*(1 + nkeys/max_elems_in_tree));
<a name="l05068"></a>05068   }
<a name="l05069"></a>05069 
<a name="l05070"></a>05070   <span class="keywordtype">void</span> reset();
<a name="l05071"></a>05071   <span class="keywordtype">bool</span> walk(tree_walk_action action, <span class="keywordtype">void</span> *walk_action_arg);
<a name="l05072"></a>05072 
<a name="l05073"></a>05073   uint get_size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size; }
<a name="l05074"></a>05074   ulonglong get_max_in_memory_size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> max_in_memory_size; }
<a name="l05075"></a>05075 
<a name="l05076"></a>05076   <span class="keyword">friend</span> <span class="keywordtype">int</span> unique_write_to_file(uchar* key, element_count count, Unique *unique);
<a name="l05077"></a>05077   <span class="keyword">friend</span> <span class="keywordtype">int</span> unique_write_to_ptrs(uchar* key, element_count count, Unique *unique);
<a name="l05078"></a>05078 };
<a name="l05079"></a>05079 
<a name="l05080"></a>05080 
<a name="l05081"></a>05081 <span class="keyword">class </span>multi_delete :<span class="keyword">public</span> select_result_interceptor
<a name="l05082"></a>05082 {
<a name="l05083"></a>05083   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *delete_tables, *table_being_deleted;
<a name="l05084"></a>05084   Unique **tempfiles;
<a name="l05085"></a>05085   ha_rows deleted, found;
<a name="l05086"></a>05086   uint num_of_tables;
<a name="l05087"></a>05087   <span class="keywordtype">int</span> error;
<a name="l05088"></a>05088   <span class="keywordtype">bool</span> do_delete;
<a name="l05089"></a>05089   <span class="comment">/* True if at least one table we delete from is transactional */</span>
<a name="l05090"></a>05090   <span class="keywordtype">bool</span> transactional_tables;
<a name="l05091"></a>05091   <span class="comment">/* True if at least one table we delete from is not transactional */</span>
<a name="l05092"></a>05092   <span class="keywordtype">bool</span> normal_tables;
<a name="l05093"></a>05093   <span class="keywordtype">bool</span> delete_while_scanning;
<a name="l05094"></a>05094   <span class="comment">/*</span>
<a name="l05095"></a>05095 <span class="comment">     error handling (rollback and binlogging) can happen in send_eof()</span>
<a name="l05096"></a>05096 <span class="comment">     so that afterward send_error() needs to find out that.</span>
<a name="l05097"></a>05097 <span class="comment">  */</span>
<a name="l05098"></a>05098   <span class="keywordtype">bool</span> error_handled;
<a name="l05099"></a>05099 
<a name="l05100"></a>05100 <span class="keyword">public</span>:
<a name="l05101"></a>05101   multi_delete(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *dt, uint num_of_tables);
<a name="l05102"></a>05102   ~multi_delete();
<a name="l05103"></a>05103   <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u);
<a name="l05104"></a>05104   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l05105"></a>05105   <span class="keywordtype">bool</span> initialize_tables (<a class="code" href="classJOIN.html">JOIN</a> *join);
<a name="l05106"></a>05106   <span class="keywordtype">void</span> send_error(uint errcode,<span class="keyword">const</span> <span class="keywordtype">char</span> *err);
<a name="l05107"></a>05107   <span class="keywordtype">int</span> do_deletes();
<a name="l05108"></a>05108   <span class="keywordtype">int</span> do_table_deletes(<a class="code" href="structTABLE.html">TABLE</a> *table, <span class="keywordtype">bool</span> ignore);
<a name="l05109"></a>05109   <span class="keywordtype">bool</span> send_eof();
<a name="l05110"></a>05110   <span class="keyword">inline</span> ha_rows num_deleted()
<a name="l05111"></a>05111   {
<a name="l05112"></a>05112     <span class="keywordflow">return</span> deleted;
<a name="l05113"></a>05113   }
<a name="l05114"></a>05114   <span class="keyword">virtual</span> <span class="keywordtype">void</span> abort_result_set();
<a name="l05115"></a>05115 };
<a name="l05116"></a>05116 
<a name="l05117"></a>05117 
<a name="l05122"></a>05122 <span class="keyword">class </span>multi_update :<span class="keyword">public</span> select_result_interceptor
<a name="l05123"></a>05123 {
<a name="l05124"></a>05124   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *all_tables; <span class="comment">/* query/update command tables */</span>
<a name="l05125"></a>05125   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *leaves;     <span class="comment">/* list of leves of join table tree */</span>
<a name="l05126"></a>05126   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *update_tables, *table_being_updated;
<a name="l05127"></a>05127   <a class="code" href="structTABLE.html">TABLE</a> **tmp_tables, *main_table, *table_to_update;
<a name="l05128"></a>05128   TMP_TABLE_PARAM *tmp_table_param;
<a name="l05129"></a>05129   ha_rows updated, found;
<a name="l05130"></a>05130   <a class="code" href="classList.html">List &lt;Item&gt;</a> *fields, *values;
<a name="l05131"></a>05131   <a class="code" href="classList.html">List &lt;Item&gt;</a> **fields_for_table, **values_for_table;
<a name="l05132"></a>05132   uint table_count;
<a name="l05133"></a>05133   <span class="comment">/*</span>
<a name="l05134"></a>05134 <span class="comment">   List of tables referenced in the CHECK OPTION condition of</span>
<a name="l05135"></a>05135 <span class="comment">   the updated view excluding the updated table. </span>
<a name="l05136"></a>05136 <span class="comment">  */</span>
<a name="l05137"></a>05137   <a class="code" href="classList.html">List &lt;TABLE&gt;</a> unupdated_check_opt_tables;
<a name="l05138"></a>05138   <a class="code" href="classCopy__field.html">Copy_field</a> *copy_field;
<a name="l05139"></a>05139   <span class="keyword">enum</span> enum_duplicates handle_duplicates;
<a name="l05140"></a>05140   <span class="keywordtype">bool</span> do_update, trans_safe;
<a name="l05141"></a>05141   <span class="comment">/* True if the update operation has made a change in a transactional table */</span>
<a name="l05142"></a>05142   <span class="keywordtype">bool</span> transactional_tables;
<a name="l05143"></a>05143   <span class="keywordtype">bool</span> ignore;
<a name="l05144"></a>05144   <span class="comment">/* </span>
<a name="l05145"></a>05145 <span class="comment">     error handling (rollback and binlogging) can happen in send_eof()</span>
<a name="l05146"></a>05146 <span class="comment">     so that afterward send_error() needs to find out that.</span>
<a name="l05147"></a>05147 <span class="comment">  */</span>
<a name="l05148"></a>05148   <span class="keywordtype">bool</span> error_handled;
<a name="l05149"></a>05149 
<a name="l05164"></a>05164   <a class="code" href="classCOPY__INFO.html">COPY_INFO</a> **update_operations;
<a name="l05165"></a>05165 
<a name="l05166"></a>05166 <span class="keyword">public</span>:
<a name="l05167"></a>05167   multi_update(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *ut, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *leaves_list,
<a name="l05168"></a>05168                <a class="code" href="classList.html">List&lt;Item&gt;</a> *fields, <a class="code" href="classList.html">List&lt;Item&gt;</a> *values,
<a name="l05169"></a>05169                enum_duplicates handle_duplicates, <span class="keywordtype">bool</span> ignore);
<a name="l05170"></a>05170   ~multi_update();
<a name="l05171"></a>05171   <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u);
<a name="l05172"></a>05172   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l05173"></a>05173   <span class="keywordtype">bool</span> initialize_tables (<a class="code" href="classJOIN.html">JOIN</a> *join);
<a name="l05174"></a>05174   <span class="keywordtype">void</span> send_error(uint errcode,<span class="keyword">const</span> <span class="keywordtype">char</span> *err);
<a name="l05175"></a>05175   <span class="keywordtype">int</span>  do_updates();
<a name="l05176"></a>05176   <span class="keywordtype">bool</span> send_eof();
<a name="l05177"></a>05177   <span class="keyword">inline</span> ha_rows num_found()
<a name="l05178"></a>05178   {
<a name="l05179"></a>05179     <span class="keywordflow">return</span> found;
<a name="l05180"></a>05180   }
<a name="l05181"></a>05181   <span class="keyword">inline</span> ha_rows num_updated()
<a name="l05182"></a>05182   {
<a name="l05183"></a>05183     <span class="keywordflow">return</span> updated;
<a name="l05184"></a>05184   }
<a name="l05185"></a>05185   <span class="keyword">virtual</span> <span class="keywordtype">void</span> abort_result_set();
<a name="l05186"></a>05186 };
<a name="l05187"></a>05187 
<a name="l05188"></a>05188 <span class="keyword">class </span>my_var : <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>  {
<a name="l05189"></a>05189 <span class="keyword">public</span>:
<a name="l05190"></a>05190   LEX_STRING s;
<a name="l05191"></a>05191 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l05192"></a>05192 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l05193"></a>05193 <span class="comment">    Routine to which this Item_splocal belongs. Used for checking if correct</span>
<a name="l05194"></a>05194 <span class="comment">    runtime context is used for variable handling.</span>
<a name="l05195"></a>05195 <span class="comment">  */</span>
<a name="l05196"></a>05196   <a class="code" href="classsp__head.html">sp_head</a> *sp;
<a name="l05197"></a>05197 <span class="preprocessor">#endif</span>
<a name="l05198"></a>05198 <span class="preprocessor"></span>  <span class="keywordtype">bool</span> local;
<a name="l05199"></a>05199   uint offset;
<a name="l05200"></a>05200   enum_field_types type;
<a name="l05201"></a>05201   my_var (LEX_STRING&amp; j, <span class="keywordtype">bool</span> i, uint o, enum_field_types t)
<a name="l05202"></a>05202     :s(j), local(i), offset(o), type(t)
<a name="l05203"></a>05203   {}
<a name="l05204"></a>05204   ~my_var() {}
<a name="l05205"></a>05205 };
<a name="l05206"></a>05206 
<a name="l05207"></a>05207 <span class="keyword">class </span>select_dumpvar :<span class="keyword">public</span> select_result_interceptor {
<a name="l05208"></a>05208   ha_rows row_count;
<a name="l05209"></a>05209 <span class="keyword">public</span>:
<a name="l05210"></a>05210   <a class="code" href="classList.html">List&lt;my_var&gt;</a> var_list;
<a name="l05211"></a>05211   select_dumpvar()  { var_list.empty(); row_count= 0;}
<a name="l05212"></a>05212   ~select_dumpvar() {}
<a name="l05213"></a>05213   <span class="keywordtype">int</span> prepare(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list, SELECT_LEX_UNIT *u);
<a name="l05214"></a>05214   <span class="keywordtype">bool</span> send_data(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;items);
<a name="l05215"></a>05215   <span class="keywordtype">bool</span> send_eof();
<a name="l05216"></a>05216   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="group__Runtime__Environment.html#ga9f257ba1c05a6af19ffbb21bb49d2005">check_simple_select</a>() <span class="keyword">const</span>;
<a name="l05217"></a>05217   <span class="keywordtype">void</span> cleanup();
<a name="l05218"></a>05218 };
<a name="l05219"></a>05219 
<a name="l05220"></a>05220 <span class="comment">/* Bits in sql_command_flags */</span>
<a name="l05221"></a>05221 
<a name="l05222"></a>05222 <span class="preprocessor">#define CF_CHANGES_DATA           (1U &lt;&lt; 0)</span>
<a name="l05223"></a>05223 <span class="preprocessor"></span><span class="comment">/* The 2nd bit is unused -- it used to be CF_HAS_ROW_COUNT. */</span>
<a name="l05224"></a>05224 <span class="preprocessor">#define CF_STATUS_COMMAND         (1U &lt;&lt; 2)</span>
<a name="l05225"></a>05225 <span class="preprocessor"></span><span class="preprocessor">#define CF_SHOW_TABLE_COMMAND     (1U &lt;&lt; 3)</span>
<a name="l05226"></a>05226 <span class="preprocessor"></span><span class="preprocessor">#define CF_WRITE_LOGS_COMMAND     (1U &lt;&lt; 4)</span>
<a name="l05227"></a>05227 <span class="preprocessor"></span>
<a name="l05240"></a>05240 <span class="preprocessor">#define CF_REEXECUTION_FRAGILE    (1U &lt;&lt; 5)</span>
<a name="l05241"></a>05241 <span class="preprocessor"></span>
<a name="l05252"></a>05252 <span class="preprocessor">#define CF_IMPLICIT_COMMIT_BEGIN  (1U &lt;&lt; 6)</span>
<a name="l05253"></a>05253 <span class="preprocessor"></span>
<a name="l05263"></a>05263 <span class="preprocessor">#define CF_IMPLICIT_COMMIT_END    (1U &lt;&lt; 7)</span>
<a name="l05264"></a>05264 <span class="preprocessor"></span>
<a name="l05270"></a>05270 <span class="preprocessor">#define CF_AUTO_COMMIT_TRANS  (CF_IMPLICIT_COMMIT_BEGIN | CF_IMPLICIT_COMMIT_END)</span>
<a name="l05271"></a>05271 <span class="preprocessor"></span>
<a name="l05280"></a>05280 <span class="preprocessor">#define CF_DIAGNOSTIC_STMT        (1U &lt;&lt; 8)</span>
<a name="l05281"></a>05281 <span class="preprocessor"></span>
<a name="l05286"></a>05286 <span class="preprocessor">#define CF_CAN_GENERATE_ROW_EVENTS (1U &lt;&lt; 9)</span>
<a name="l05287"></a>05287 <span class="preprocessor"></span>
<a name="l05292"></a>05292 <span class="preprocessor">#define CF_PREOPEN_TMP_TABLES   (1U &lt;&lt; 10)</span>
<a name="l05293"></a>05293 <span class="preprocessor"></span>
<a name="l05298"></a>05298 <span class="preprocessor">#define CF_HA_CLOSE             (1U &lt;&lt; 11)</span>
<a name="l05299"></a>05299 <span class="preprocessor"></span>
<a name="l05303"></a>05303 <span class="preprocessor">#define CF_CAN_BE_EXPLAINED       (1U &lt;&lt; 12)</span>
<a name="l05304"></a>05304 <span class="preprocessor"></span>
<a name="l05306"></a>05306 <span class="preprocessor">#define CF_OPTIMIZER_TRACE        (1U &lt;&lt; 14)</span>
<a name="l05307"></a>05307 <span class="preprocessor"></span>
<a name="l05312"></a>05312 <span class="preprocessor">#define CF_DISALLOW_IN_RO_TRANS   (1U &lt;&lt; 15)</span>
<a name="l05313"></a>05313 <span class="preprocessor"></span>
<a name="l05314"></a>05314 <span class="comment">/* Bits in server_command_flags */</span>
<a name="l05315"></a>05315 
<a name="l05323"></a>05323 <span class="preprocessor">#define CF_SKIP_QUERY_ID        (1U &lt;&lt; 0)</span>
<a name="l05324"></a>05324 <span class="preprocessor"></span>
<a name="l05331"></a>05331 <span class="preprocessor">#define CF_SKIP_QUESTIONS       (1U &lt;&lt; 1)</span>
<a name="l05332"></a>05332 <span class="preprocessor"></span>
<a name="l05333"></a>05333 <span class="keywordtype">void</span> add_to_status(<a class="code" href="structsystem__status__var.html">STATUS_VAR</a> *to_var, <a class="code" href="structsystem__status__var.html">STATUS_VAR</a> *from_var);
<a name="l05334"></a>05334 
<a name="l05335"></a>05335 <span class="keywordtype">void</span> add_diff_to_status(<a class="code" href="structsystem__status__var.html">STATUS_VAR</a> *to_var, <a class="code" href="structsystem__status__var.html">STATUS_VAR</a> *from_var,
<a name="l05336"></a>05336                         <a class="code" href="structsystem__status__var.html">STATUS_VAR</a> *dec_var);
<a name="l05337"></a>05337 
<a name="l05338"></a>05338 <span class="comment">/* Inline functions */</span>
<a name="l05339"></a>05339 
<a name="l05340"></a>05340 <span class="keyword">inline</span> <span class="keywordtype">bool</span> add_item_to_list(THD *thd, <a class="code" href="classItem.html">Item</a> *item)
<a name="l05341"></a>05341 {
<a name="l05342"></a>05342   <span class="keywordflow">return</span> thd-&gt;lex-&gt;current_select-&gt;add_item_to_list(thd, item);
<a name="l05343"></a>05343 }
<a name="l05344"></a>05344 
<a name="l05345"></a>05345 <span class="keyword">inline</span> <span class="keywordtype">bool</span> add_value_to_list(THD *thd, <a class="code" href="classItem.html">Item</a> *value)
<a name="l05346"></a>05346 {
<a name="l05347"></a>05347   <span class="keywordflow">return</span> thd-&gt;lex-&gt;value_list.push_back(value);
<a name="l05348"></a>05348 }
<a name="l05349"></a>05349 
<a name="l05350"></a>05350 <span class="keyword">inline</span> <span class="keywordtype">bool</span> add_order_to_list(THD *thd, <a class="code" href="classItem.html">Item</a> *item, <span class="keywordtype">bool</span> asc)
<a name="l05351"></a>05351 {
<a name="l05352"></a>05352   <span class="keywordflow">return</span> thd-&gt;lex-&gt;current_select-&gt;add_order_to_list(thd, item, asc);
<a name="l05353"></a>05353 }
<a name="l05354"></a>05354 
<a name="l05355"></a>05355 <span class="keyword">inline</span> <span class="keywordtype">bool</span> add_gorder_to_list(THD *thd, <a class="code" href="classItem.html">Item</a> *item, <span class="keywordtype">bool</span> asc)
<a name="l05356"></a>05356 {
<a name="l05357"></a>05357   <span class="keywordflow">return</span> thd-&gt;lex-&gt;current_select-&gt;add_gorder_to_list(thd, item, asc);
<a name="l05358"></a>05358 }
<a name="l05359"></a>05359 
<a name="l05360"></a>05360 <span class="keyword">inline</span> <span class="keywordtype">bool</span> add_group_to_list(THD *thd, <a class="code" href="classItem.html">Item</a> *item, <span class="keywordtype">bool</span> asc)
<a name="l05361"></a>05361 {
<a name="l05362"></a>05362   <span class="keywordflow">return</span> thd-&gt;lex-&gt;current_select-&gt;add_group_to_list(thd, item, asc);
<a name="l05363"></a>05363 }
<a name="l05364"></a>05364 
<a name="l05365"></a>05365 <span class="preprocessor">#endif </span><span class="comment">/* MYSQL_SERVER */</span>
<a name="l05366"></a>05366 
<a name="l05367"></a>05367 <span class="preprocessor">#endif </span><span class="comment">/* SQL_CLASS_INCLUDED */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:46 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
