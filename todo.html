<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: Todo List</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Todo <a class="el" href="classList.html">List</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="classAlter__inplace__info.html#a1774915f106804ab1aeb6629d58bcae4">Alter_inplace_info::key_info_buffer</a>  </dt>
<dd>This is mainly due to the fact that we need to keep compatibility with removed handler::add_index() call. We plan to switch to TABLE::key_info numbering later. </dd>
<dt><a class="anchor" id="_todo000018"></a>Member <a class="el" href="handler_8cc.html#a24d44ee426ff4454b3e832c4470d6cc7">AUTO_INC_DEFAULT_NB_ROWS</a>  </dt>
<dd>Replace all references to "next number" or NEXT_NUMBER to "auto_increment", everywhere (see below: there is table-&gt;auto_increment_field_not_null, and there also exists table-&gt;next_number_field, it's not consistent). </dd>
<dt><a class="anchor" id="_todo000001"></a>Class <a class="el" href="classbinlog__cache__data.html">binlog_cache_data</a>  </dt>
<dd>All the access functions for the flags suggest that the encapsuling is not done correctly, so try to move any logic that requires access to the flags into the cache.  </dd>
<dt><a class="anchor" id="_todo000102"></a>Member <a class="el" href="group__Query__Optimizer.html#gab0ca922593fe6b15db19791f8133f407">calc_used_field_length</a>  (THD *thd, JOIN_TAB *join_tab)</dt>
<dd>why don't we count the rowids that we might need to store when using DuplicateElimination?  </dd>
<dt><a class="anchor" id="_todo000072"></a>Class <a class="el" href="classCOPY__INFO.html">COPY_INFO</a>  </dt>
<dd>Rename this class. </dd>
<dt><a class="anchor" id="_todo000051"></a>Member <a class="el" href="my__decimal_8h.html#a2f8281ea4229757f5d01f04c292d32d5">decimal_operation_results</a>  (int result)</dt>
<dd>Fix error messages </dd>
<dt><a class="anchor" id="_todo000082"></a>Member <a class="el" href="group__Runtime__Environment.html#ga3ee16ca35fd31e7babfd4afbe8a5914f">dispatch_command</a>  (enum enum_server_command command, THD *thd, char *packet, uint packet_length)</dt>
<dd><p class="startdd">set thd-&gt;lex-&gt;sql_command to SQLCOM_END here. </p>
<p class="enddd">The following has to be changed to an 8 byte integer </p>
</dd>
<dt><a class="anchor" id="_todo000093"></a>Member <a class="el" href="classEd__connection.html#ad80317ac21aa245c7a0d1162ac98b264">Ed_connection::store_result_set</a>  ()</dt>
<dd>Use double-linked list, when this is really used. </dd>
<dt><a class="anchor" id="_todo000095"></a>Class <a class="el" href="classEd__result__set.html">Ed_result_set</a>  </dt>
<dd>Implement support for result set metadata and automatic type conversion.  </dd>
<dt><a class="anchor" id="_todo000012"></a>Class <a class="el" href="classField__bit__as__char.html">Field_bit_as_char</a>  </dt>
<dd>The inheritance relationship is backwards since <a class="el" href="classField__bit.html">Field_bit</a> is an extended version of <a class="el" href="classField__bit__as__char.html">Field_bit_as_char</a> and not the other way around. Hence, we should refactor it to fix the hierarchy order.  </dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="classField__new__decimal.html#a05d9f15a2a8a5148871c947dfe7a9dbe">Field_new_decimal::store</a>  (double nr)</dt>
<dd>Fix following when double2my_decimal when double2decimal will return E_DEC_TRUNCATED always correctly  </dd>
<dt><a class="anchor" id="_todo000009"></a>Member <a class="el" href="classField__num.html#a4aba1e99e15d07a40cb6ae9fbff720b7">Field_num::check_int</a>  (const CHARSET_INFO *cs, const char *str, int length, const char *int_end, int error)</dt>
<dd>Make this multi-byte-character safe </dd>
<dt><a class="anchor" id="_todo000010"></a>Member <a class="el" href="classField__str.html#ae0a260a3e657aa6778dcf651ff3e9b95">Field_str::store_decimal</a>  (const <a class="el" href="classmy__decimal.html">my_decimal</a> *)</dt>
<dd>use decimal2string? </dd>
<dt><a class="anchor" id="_todo000013"></a>Member <a class="el" href="classField__temporal__with__date__and__time.html#ac497834ddc1ef395a387790d97cfb63d">Field_temporal_with_date_and_time::init_timestamp_flags</a>  ()</dt>
<dd>get rid of TIMESTAMP_FLAG and ON_UPDATE_NOW_FLAG.  </dd>
<dt><a class="anchor" id="_todo000014"></a>Member <a class="el" href="classField__time__common.html#ab30cf710ffb3f033da46e5e43430490d">Field_time_common::convert_number_to_TIME</a>  (longlong nr, bool unsigned_val, int nanoseconds, MYSQL_TIME *ltime, int *warning)</dt>
<dd>: convert_number_to_TIME returns conversion status through two different interfaces: return value and warning. It should be refactored to only use return value.  </dd>
<dt><a class="anchor" id="_todo000114"></a>Member <a class="el" href="sys__vars_8cc.html#a995ff555f60375cf17a4408c516c43a2">fix_delay_key_write</a>  (<a class="el" href="classsys__var.html">sys_var</a> *self, THD *thd, enum_var_type type)</dt>
<dd>When updating myisam_delay_key_write, we should do a 'flush tables' of all MyISAM tables to ensure that they are reopen with the new attribute.  </dd>
<dt><a class="anchor" id="_todo000015"></a>File <a class="el" href="gen__lex__hash_8cc.html">gen_lex_hash.cc</a>  </dt>
<dd><p class="startdd">use instead to_upper_lex, special array (substitute chars) without skip codes.. </p>
<p class="enddd">try use reverse order of comparing.. </p>
</dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="handler_8cc.html#ad012444cc24f2178ff92e9e7ecbfbc85">get_canonical_filename</a>  (handler *file, const char *path, char *tmp_path)</dt>
<dd>This may be done more efficiently when table path gets built. Convert this function to something like ASSERT_CANONICAL_FILENAME.  </dd>
<dt><a class="anchor" id="_todo000056"></a>Member <a class="el" href="classGtid__set.html#a9a384be7c735d018d5fc0c8c0c64344e">Gtid_set::intersection</a>  (const <a class="el" href="classGtid__set.html">Gtid_set</a> *other, <a class="el" href="classGtid__set.html">Gtid_set</a> *result)</dt>
<dd>: This algorithm is simple, a little bit slower than necessary. It would be more efficient to iterate over intervals of 'this' and 'other' similar to add_gno_interval(). At the moment the performance of this is not super-important. /Sven  </dd>
<dt><a class="anchor" id="_todo000019"></a>Member <a class="el" href="handler_8cc.html#a4b52399a74d9db4f3421851b46ff6dc9">ha_check_if_supported_system_table</a>  (handlerton *hton, const char *db, const char *table_name)</dt>
<dd>There is another function called is_system_table_name() used by get_table_category(), which is used to set <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> table_category. It checks only a subset of table name like proc, event and time*. We cannot use below function in get_table_category(), as that affects locking mechanism. If we need to unify these functions, we need to fix locking issues generated. </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="handler_8cc.html#a9a81ce45b63a150449fb897a34572bb1">ha_commit_trans</a>  (THD *thd, bool all, bool ignore_global_read_lock)</dt>
<dd>Since we don't support nested statement transactions in 5.0, we can't commit or rollback stmt transactions while we are inside stored functions or triggers. So we simply do nothing now. TODO: This should be fixed in later ( &gt;= 5.1) releases.  </dd>
<dt><a class="anchor" id="_todo000020"></a>Member <a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">handler::index_only_read_time</a>  (uint keynr, double records)</dt>
<dd>Consider joining this function and <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler::read_time()</a> into one handler::read_time(keynr, records, ranges, bool index_only) function. </dd>
<dt><a class="anchor" id="_todo000023"></a>Member <a class="el" href="structHybrid__type__traits__decimal.html#a5a73eab2d3ce41745f63446e64d81974">Hybrid_type_traits_decimal::div</a>  (<a class="el" href="structHybrid__type.html">Hybrid_type</a> *val, ulonglong u) const </dt>
<dd>what is '4' for scale?  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="classItem.html#a7cf3cc4b8db99b2fa1bbc00a6c0c86f7">Item::copy_andor_structure</a>  (THD *thd, bool real_items=false)</dt>
<dd>this argument should be always false and removed in WL#7082.  </dd>
<dt><a class="anchor" id="_todo000024"></a>Member <a class="el" href="classItem.html#a875594d2b9d99ccff3863bfd435828f0">Item::val_bool</a>  ()</dt>
<dd>Make this functions class dependent  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="classItem__func__case.html#a72dc07ea4fc65211872b8b7e0c53813a">Item_func_case::print</a>  (<a class="el" href="classString.html">String</a> *str, enum_query_type query_type)</dt>
<dd>Fix this so that it prints the whole CASE expression  </dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="classItem__func__format.html#a9f01cf724eacb711a5874955671fdc67">Item_func_format::val_str_ascii</a>  (<a class="el" href="classString.html">String</a> *)</dt>
<dd>This needs to be fixed for multi-byte character set where numbers are stored in more than one byte  </dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classItem__func__replace.html#a339fa98601454ef99451c1c2daf5d1a4">Item_func_replace::val_str</a>  (<a class="el" href="classString.html">String</a> *)</dt>
<dd>Fix that this works with binary strings when using USE_MB  </dd>
<dt><a class="anchor" id="_todo000030"></a>Member <a class="el" href="classItem__func__xor.html#abf20b3f1b71cb4c4b588c5a04d77ba05">Item_func_xor::val_int</a>  ()</dt>
<dd>(low priority) Change this to be optimized as: <br/>
 A XOR B -&gt; (A) == 1 AND (B) &lt;&gt; 1) OR (A &lt;&gt; 1 AND (B) == 1) <br/>
 To be able to do this, we would however first have to extend the MySQL range optimizer to handle OR better. </dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="classItem__in__subselect.html#a5b227952590f09ea10b9a2c95d33551b">Item_in_subselect::row_value_in_to_exists_transformer</a>  (<a class="el" href="classJOIN.html">JOIN</a> *join)</dt>
<dd>The IF-ELSE below can be refactored so that there is no duplication of the statements that create the new conditions. For this we have to invert the IF and the FOR statements as this: for (each left operand) create the equi-join condition if (is_having_used || !abort_on_null) create the "is null" and is_not_null_test items if (is_having_used) add the equi-join and the null tests to HAVING else add the equi-join and the "is null" to WHERE add the is_not_null_test to HAVING  </dd>
<dt><a class="anchor" id="_todo000026"></a>Member <a class="el" href="classItem__param.html#a9df220068abddaa7965488ae0ed17224">Item_param::query_val_str</a>  (THD *thd, <a class="el" href="classString.html">String</a> *str) const </dt>
<dd><ul>
<li>Change interface and implementation to fill log data in place and avoid one more memcpy/alloc between str and log string.</li>
<li>In case of error we need to notify replication that binary log contains wrong statement  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="classItem__ref.html#a6a78e05b0db89e799f61808c621b808f">Item_ref::fix_fields</a>  (THD *, <a class="el" href="classItem.html">Item</a> **)</dt>
<dd>Here we could first find the field anyway, and then test this condition, so that we can give a better error message - ER_WRONG_FIELD_WITH_GROUP, instead of the less informative ER_BAD_FIELD_ERROR which we produce now. </dd>
<dt><a class="anchor" id="_todo000032"></a>Member <a class="el" href="classItem__row.html#aeddb642ba1780904980f6b4e2d29dffb">Item_row::Item_row</a>  (<a class="el" href="classList.html">List&lt; Item &gt;</a> &amp;)</dt>
<dd>think placing 2-3 component items in item (as it done for function  </dd>
<dt><a class="anchor" id="_todo000036"></a>Member <a class="el" href="classItem__singlerow__subselect.html#a61aa448d7333365d599e518eefdeb468">Item_singlerow_subselect::select_transformer</a>  (<a class="el" href="classJOIN.html">JOIN</a> *join)</dt>
<dd><ul>
<li>We cant change name of <a class="el" href="classItem__field.html">Item_field</a> or <a class="el" href="classItem__ref.html">Item_ref</a>, because it will prevent it's correct resolving, but we should save name of removed item =&gt; we do not make optimization if top item of list is field or reference.</li>
<li>switch off this optimization for prepare statement, because we do not rollback this changes. Make rollback for it, or special name resolving mode in 5.0.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000025"></a>Member <a class="el" href="classItem__string.html#a4226f4dfd6a0c9eb1b97c33da0b3db78">Item_string::val_int</a>  ()</dt>
<dd>Give error if we wanted a signed integer and we got an unsigned one  </dd>
<dt><a class="anchor" id="_todo000035"></a>File <a class="el" href="item__subselect_8cc.html">item_subselect.cc</a>  </dt>
<dd><ul>
<li>add function from mysql_select that use JOIN* as parameter to <a class="el" href="classJOIN.html">JOIN</a> methods (<a class="el" href="sql__select_8h.html" title="classes to use when handling where clause">sql_select.h</a>/sql_select.cc)  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="classItem__sum__hybrid.html#ad7d563ebdca9c58beec529763623c3fb">Item_sum_hybrid::min_max_update_decimal_field</a>  ()</dt>
<dd>optimize: do not get result_field in case of args[0] is NULL  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="classItem__sum__sum.html#af259b3fb68c269dba5d29d7f1e2323eb">Item_sum_sum::Item_sum_sum</a>  (THD *thd, <a class="el" href="classItem__sum__sum.html">Item_sum_sum</a> *item)</dt>
<dd>check if the following assignments are really needed  </dd>
<dt><a class="anchor" id="_todo000041"></a>File <a class="el" href="item__timefunc_8cc.html">item_timefunc.cc</a>  </dt>
<dd>Move month and days to language files  </dd>
<dt><a class="anchor" id="_todo000075"></a>Member <a class="el" href="group__Query__Executor.html#ga31581f58624b85919d7c6cd632157929">JOIN::exec</a>  ()</dt>
<dd>When can we have here thd-&gt;net.report_error not zero?  </dd>
<dt><a class="anchor" id="_todo000105"></a>Member <a class="el" href="group__Query__Optimizer.html#gaa62d47da29f3853e87b1069ee5c1ff21">JOIN::join_free</a>  ()</dt>
<dd>Unlock tables even if the join isn't top level select in the tree  </dd>
<dt><a class="anchor" id="_todo000079"></a>Member <a class="el" href="group__Query__Optimizer.html#ga7f722315c64ce97cff639d705107c660">JOIN::optimize</a>  ()</dt>
<dd>Above we passed unique=false. But for this query: (oe1, oe2) IN (SELECT primary_key, non_key_maybe_null_field FROM tbl) we could use "unique=true" for the first index component and let Item_is_not_null_test(non_key_maybe_null_field) handle the second.  </dd>
<dt><a class="anchor" id="_todo000097"></a>Member <a class="el" href="group__Query__Resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a>  (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, uint wind_num, <a class="el" href="classItem.html">Item</a> *conds, uint og_num, ORDER *order, ORDER *group, <a class="el" href="classItem.html">Item</a> *having, SELECT_LEX *select, SELECT_LEX_UNIT *unit)</dt>
<dd>Add check of calculation of GROUP functions and fields: SELECT COUNT(*)+table.col1 from table1; </dd>
<dt><a class="anchor" id="_todo000021"></a>Member <a class="el" href="handler_8cc.html#a136dfdf479102e63c8ddf02af552c445">key_uses_partial_cols</a>  (<a class="el" href="structTABLE.html">TABLE</a> *table, uint keyno)</dt>
<dd>Allow use of DS-MRR in cases where the index has partially-covered components but they are not used for scanning. </dd>
<dt><a class="anchor" id="_todo000042"></a>File <a class="el" href="lock_8cc.html">lock.cc</a>  </dt>
<dd>Change to use my_malloc() ONLY when using LOCK TABLES command or when we are forced to use mysql_lock_merge.  </dd>
<dt><a class="anchor" id="_todo000043"></a>File <a class="el" href="log_8cc.html">log.cc</a>  </dt>
<dd>Abort logging when we get an error in reading or writing log files  </dd>
<dt><a class="anchor" id="_todo000044"></a>Member <a class="el" href="classLog__to__csv__event__handler.html#a5174e86bbcc9f91b3e8a7683f8a1e785">Log_to_csv_event_handler::log_general</a>  (THD *thd, time_t event_time, const char *user_host, uint user_host_len, my_thread_id thread_id, const char *command_type, uint command_type_len, const char *sql_text, uint sql_text_len, const CHARSET_INFO *client_cs)</dt>
<dd>: how?). If a write to the table has failed, the function attempts to write to a short error message to the file. The failure is also indicated in the return value.  </dd>
<dt><a class="anchor" id="_todo000006"></a>Member <a class="el" href="group__Binary__Log.html#ga1eb09393ab56b2ba8a7620cbd4cb34b9">MYSQL_BIN_LOG::open_binlog</a>  (const char *log_name, const char *new_name, enum cache_type io_cache_type_arg, ulong max_size, bool null_created, bool need_lock_index, bool need_sid_lock, <a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> *extra_description_event)</dt>
<dd>: although this was introduced to appease valgrind when injecting emulated faults using fault_injection_registering_index it may be good to consider what actually happens when open_purge_index_file succeeds but register or sync fails. </dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="group__Binary__Log.html#ga44de4e3109fc4d50d4968191ab0f3544">MYSQL_BIN_LOG::open_binlog</a>  (const char *opt_name)</dt>
<dd>keep in-memory list of prepared transactions (add to list in log(), remove on unlog()) and copy it to the new binlog if rotated but let's check the behaviour of tc_log_page_waits first!  </dd>
<dt><a class="anchor" id="_todo000083"></a>Member <a class="el" href="group__Runtime__Environment.html#ga6a69efbbf47bbcab9d2e517e285679d9">mysql_execute_command</a>  (THD *thd)</dt>
<dd><ul>
<li>Invalidate the table in the query cache if something changed after unlocking when changes become visible. </li>
</ul>
<p class="enddd">: this is workaround. right way will be move invalidating in the unlock procedure.</p>
<ul>
<li>TODO: use check_change_password() </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="classMYSQL__LOG.html#a5bbba2bb951d6ff27d3676b0d6a15057">MYSQL_LOG::generate_name</a>  (const char *log_name, const char *suffix, bool strip_ext, char *buff)</dt>
<dd>The following should be using fn_format(); We just need to first change fn_format() to cut the file name if it's too long.  </dd>
<dt><a class="anchor" id="_todo000084"></a>Member <a class="el" href="group__Runtime__Environment.html#gab37db6950d3b6bc16bbbb2ae0484ae55">mysql_reset_thd_for_next_command</a>  (THD *thd)</dt>
<dd><p class="startdd">Remove mysql_reset_thd_for_next_command and only use the member function.</p>
<p class="enddd">Call it after we use THD for queries, not before.  </p>
</dd>
<dt><a class="anchor" id="_todo000054"></a>Member <a class="el" href="classProtocol__text.html#a66166244c73b0d710d2896c411514890">Protocol_text::store</a>  (MYSQL_TIME *time, uint precision)</dt>
<dd>Second_part format ("%06") needs to change when we support 0-6 decimals for time.  </dd>
<dt><a class="anchor" id="_todo000047"></a>Member <a class="el" href="classQuery__log__event.html#a8eeda6f83d6ed20343be666af286032b">Query_log_event::Query_log_event</a>  (const char *buf, uint event_len, const <a class="el" href="classFormat__description__log__event.html">Format_description_log_event</a> *description_event, Log_event_type event_type)</dt>
<dd>we should clean up and do only copy_str_and_move; it works for both cases. Then we can remove the catalog_nz flag. /sven  </dd>
<dt><a class="anchor" id="_todo000091"></a>Member <a class="el" href="sql__prepare_8cc.html#ac923efcc818c95eeb45ebc9ac085f081">reinit_stmt_before_use</a>  (THD *thd, LEX *lex)</dt>
<dd>When the new table structure is ready, then have a status bit to indicate the table is altered, and re-do the setup_* and open the tables back.  </dd>
<dt><a class="anchor" id="_todo000059"></a>Member <a class="el" href="classRelay__log__info.html#ab4299015e0504c30685b2e3b3e093d27">Relay_log_info::flush_info</a>  (bool force=FALSE)</dt>
<dd>Change the log file information to a binary format to avoid calling longlong2str. </dd>
<dt><a class="anchor" id="_todo000058"></a>Member <a class="el" href="classRelay__log__info.html#a7bfd2c28d4caabdc57c35793bde91d18">Relay_log_info::init_relay_log_pos</a>  (const char *log, ulonglong pos, bool need_data_lock, const char **errmsg, bool look_for_description_event)</dt>
<dd>check proper initialization of group_master_log_name/group_master_log_pos. /alfranio </dd>
<dt><a class="anchor" id="_todo000076"></a>Member <a class="el" href="group__Query__Executor.html#gabf6f9870d5d7d18698a9fed0295393f4">setup_copy_fields</a>  (THD *thd, TMP_TABLE_PARAM *param, Ref_ptr_array ref_pointer_array, <a class="el" href="classList.html">List&lt; Item &gt;</a> &amp;res_selected_fields, <a class="el" href="classList.html">List&lt; Item &gt;</a> &amp;res_all_fields, uint elements, <a class="el" href="classList.html">List&lt; Item &gt;</a> &amp;all_fields)</dt>
<dd>In most cases this result will be sent to the user. This should be changed to use copy_int or copy_real depending on how the value is to be used: In some cases this may be an argument in a group function, like: IF(ISNULL(col),0,COUNT(*)) </dd>
<dt><a class="anchor" id="_todo000064"></a>Member <a class="el" href="classsp__head.html#a1c125eeeef415da5d45fdf16de43ecb7">sp_head::execute_function</a>  (THD *thd, <a class="el" href="classItem.html">Item</a> **args, uint argcount, <a class="el" href="classField.html">Field</a> *return_fld)</dt>
<dd><p class="startdd">We should create <a class="el" href="classsp__rcontext.html">sp_rcontext</a> once per command and reuse it on subsequent executions of a function/trigger.</p>
<p class="enddd">In future we should associate call arena/mem_root with <a class="el" href="classsp__rcontext.html">sp_rcontext</a> and allocate all these objects (and <a class="el" href="classsp__rcontext.html">sp_rcontext</a> itself) on it directly rather than juggle with arenas. </p>
</dd>
<dt><a class="anchor" id="_todo000063"></a>Member <a class="el" href="classsp__head.html#ac113041f45cd9bef83a5c53431e2b860">sp_head::execute_trigger</a>  (THD *thd, const LEX_STRING *db_name, const LEX_STRING *table_name, GRANT_INFO *grant_info)</dt>
<dd><ul>
<li>TODO: we should create <a class="el" href="classsp__rcontext.html">sp_rcontext</a> once per command and reuse it on subsequent executions of a trigger. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000066"></a>Member <a class="el" href="classsp__head.html#afe7c4aad6b9627d1f38b569b39f66419">sp_head::set_security_ctx</a>  (THD *thd, Security_context **save_ctx)</dt>
<dd>Cache if the definer has the rights to use the object on the first usage and reset the cache only if someone does a GRANT statement that 'may' affect this. </dd>
<dt><a class="anchor" id="_todo000068"></a>Class <a class="el" href="classsp__instr__jump.html">sp_instr_jump</a>  </dt>
<dd>later we will consider introducing a new class, which will be the base for <a class="el" href="classsp__instr__jump.html">sp_instr_jump</a>, <a class="el" href="classsp__instr__set__case__expr.html">sp_instr_set_case_expr</a> and <a class="el" href="classsp__instr__jump__case__when.html">sp_instr_jump_case_when</a>. Something like sp_regular_branch_instr (similar to <a class="el" href="classsp__lex__branch__instr.html">sp_lex_branch_instr</a>).  </dd>
<dt><a class="anchor" id="_todo000062"></a>Member <a class="el" href="classsp__parser__data.html#af658fd5aa0ce26b21268b34be0fd2c29">sp_parser_data::new_cont_backpatch</a>  ()</dt>
<dd>These functions should probably be declared in a separate interface class, but currently we try to minimize the <a class="el" href="classsp__instr.html">sp_instr</a> hierarchy. </dd>
<dt><a class="anchor" id="_todo000070"></a>Class <a class="el" href="classSql__cmd__alter__table.html">Sql_cmd_alter_table</a>  </dt>
<dd>move <a class="el" href="classAlter__info.html">Alter_info</a> and other ALTER specific structures from Lex here.  </dd>
<dt><a class="anchor" id="_todo000069"></a>Class <a class="el" href="classSql__cmd__common__alter__table.html">Sql_cmd_common_alter_table</a>  </dt>
<dd>move <a class="el" href="classAlter__info.html">Alter_info</a> and other ALTER generic structures from Lex here.  </dd>
<dt><a class="anchor" id="_todo000048"></a>Member <a class="el" href="structsql__ex__info.html#a90e3b19d97cb512779dd0bf6112d4fd0">sql_ex_info::write_data</a>  (IO_CACHE *file)</dt>
<dd>This is sensitive to field padding. We should write a char[7], not an <a class="el" href="structold__sql__ex.html">old_sql_ex</a>. /sven  </dd>
<dt><a class="anchor" id="_todo000107"></a>Member <a class="el" href="structst__join__table.html#a29fd946570ed7369a98edd0e5747c710">st_join_table::st_join_table</a>  ()</dt>
<dd>Add constructor to <a class="el" href="structREAD__RECORD.html">READ_RECORD</a>. All users do init_read_record(), which does memset(), rather than invoking a constructor.  </dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="classsubselect__single__select__engine.html#abea1c2122554f643c8b82b648f63ba39">subselect_single_select_engine::prepare</a>  ()</dt>
<dd>Re-check what properties of 'join' are needed during prepare, and see if we can avoid creating a <a class="el" href="classJOIN.html">JOIN</a> during <a class="el" href="group__Query__Resolver.html#gad5eeef6eb5eed0d15c62f22b467f0c96">JOIN::prepare</a> of the outer join. </dd>
<dt><a class="anchor" id="_todo000119"></a>Member <a class="el" href="classSys__var__keycache.html#a7775f6e9ee55bb58461d6556f053075f">Sys_var_keycache::global_update</a>  (THD *thd, <a class="el" href="classset__var.html">set_var</a> *var)</dt>
<dd>This should be changed so that we wait until the previous assignment is done and then do the new assign  </dd>
<dt><a class="anchor" id="_todo000121"></a>Member <a class="el" href="structTABLE.html#aa76fd5e13a8b5101a247413701978730">TABLE::mem_root</a>  </dt>
<dd>This member should not be declared in-line. That makes it impossible for any function that does memory allocation to take a const reference to a <a class="el" href="structTABLE.html">TABLE</a> object.  </dd>
<dt><a class="anchor" id="_todo000122"></a>Member <a class="el" href="structTABLE__LIST.html#ad2814dff1dc9df41c607fdb66e2abbc1">TABLE_LIST::context_of_embedding</a>  </dt>
<dd>When name resolution contexts are created after parsing, we should be able to store this in the embedding join nest instead.  </dd>
<dt><a class="anchor" id="_todo000120"></a>Member <a class="el" href="structTABLE__SHARE.html#ac58358f786a71e0ede5213ee8ea571fd">TABLE_SHARE::get_table_ref_type</a>  () const </dt>
<dd>perhaps we need to have a member instead of a function.  </dd>
<dt><a class="anchor" id="_todo000111"></a>Member <a class="el" href="classTable__triggers__list.html#ac2d1d5b25d9bb266b0ee2c060561caf4">Table_triggers_list::check_n_load</a>  (THD *thd, const char *db, const char *table_name, <a class="el" href="structTABLE.html">TABLE</a> *table, bool names_only)</dt>
<dd><p class="startdd">A lot of things to do here e.g. how about other funcs and being more paranoical ?</p>
<p class="enddd">This could be avoided if there is no triggers for UPDATE and DELETE. </p>
</dd>
<dt><a class="anchor" id="_todo000110"></a>Member <a class="el" href="classTable__triggers__list.html#a5dd5facac52475db6b2e850519377271">Table_triggers_list::drop_trigger</a>  (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="classString.html">String</a> *stmt_query)</dt>
<dd>Probably instead of removing .TRG file we should move to archive directory but this should be done as part of <a class="el" href="parse__file_8cc.html" title="Text .frm files management routines.">parse_file.cc</a> functionality (because we will need it elsewhere). </dd>
<dt><a class="anchor" id="_todo000071"></a>Member <a class="el" href="group__Data__Dictionary.html#ga97a6db70d8b4bedd682115942e96b09e">tdc_open_view</a>  (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *alias, const char *cache_key, uint cache_key_length, uint flags)</dt>
<dd>This function is needed for special handling of views under LOCK TABLES. We probably should get rid of it in long term. </dd>
<dt><a class="anchor" id="_todo000106"></a>Member <a class="el" href="group__Query__Optimizer.html#ga14a304484212b5489e8e995539493dd0">test_if_skip_sort_order</a>  (JOIN_TAB *tab, ORDER *order, ha_rows select_limit, const bool no_changes, const key_map *map, const char *clause_type)</dt>
<dd><ul>
<li>sergeyp: Results of all index merge selects actually are ordered by clustered PK values.</li>
</ul>
</dd>
</dl>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:47 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
