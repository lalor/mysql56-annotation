<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: Runtime Environment</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Runtime Environment</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Event__Scheduler.html">Event Scheduler</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Stored__Routines.html">Stored Routines</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa5a49afc8485933a534390973f37fcfe"></a><!-- doxytag: member="Runtime_Environment::SP_TYPE_STRING" ref="gaa5a49afc8485933a534390973f37fcfe" args="(LP)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SP_TYPE_STRING</b>(LP)&#160;&#160;&#160;((LP)-&gt;sphead-&gt;m_type == SP_TYPE_FUNCTION ? &quot;FUNCTION&quot; : &quot;PROCEDURE&quot;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>SP_COM_STRING</b>(LP)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab5a8b65ae940ccbcd0665dae441270e7"></a><!-- doxytag: member="Runtime_Environment::used_stack" ref="gab5a8b65ae940ccbcd0665dae441270e7" args="(A, B)" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>used_stack</b>(A, B)&#160;&#160;&#160;(long) (B - A)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08d1ba6753fe093a35ab0c87ab118b8a"></a><!-- doxytag: member="Runtime_Environment::MY_YACC_INIT" ref="ga08d1ba6753fe093a35ab0c87ab118b8a" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MY_YACC_INIT</b>&#160;&#160;&#160;1000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga42ed848262f0f56a57d1e07c0d4878c3"></a><!-- doxytag: member="Runtime_Environment::MY_YACC_MAX" ref="ga42ed848262f0f56a57d1e07c0d4878c3" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MY_YACC_MAX</b>&#160;&#160;&#160;32000</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3eb15b6124092efd1a4ff88f91c1b4e4"></a><!-- doxytag: member="Runtime_Environment::opt_log_throttle_queries_not_using_indexes" ref="ga3eb15b6124092efd1a4ff88f91c1b4e4" args="(s) suppressed.&quot;" -->
Slow_log_throttle <br class="typebreak"/>
log_throttle_qni &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>opt_log_throttle_queries_not_using_indexes</b> (s) suppressed.&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4c2f693556d7e6b0d1cf38ad801ae51c"></a><!-- doxytag: member="Runtime_Environment::stmt_causes_implicit_commit" ref="ga4c2f693556d7e6b0d1cf38ad801ae51c" args="(const THD *thd, uint mask)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>stmt_causes_implicit_commit</b> (const THD *thd, uint mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga50e3f222a46f347db65d19bd17941286"></a><!-- doxytag: member="Runtime_Environment::init_update_queries" ref="ga50e3f222a46f347db65d19bd17941286" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_update_queries</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b2464ebc1bdb059269bcb997d5329b2"></a><!-- doxytag: member="Runtime_Environment::sqlcom_can_generate_row_events" ref="ga5b2464ebc1bdb059269bcb997d5329b2" args="(const THD *thd)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sqlcom_can_generate_row_events</b> (const THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacd6cd553a8c7199f9ab84c0f72871177"></a><!-- doxytag: member="Runtime_Environment::is_update_query" ref="gacd6cd553a8c7199f9ab84c0f72871177" args="(enum enum_sql_command command)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_update_query</b> (enum enum_sql_command command)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4b1b314a012674325f76ce371614df4d"></a><!-- doxytag: member="Runtime_Environment::is_explainable_query" ref="ga4b1b314a012674325f76ce371614df4d" args="(enum enum_sql_command command)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_explainable_query</b> (enum enum_sql_command command)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga1eaa146f67e2bd9604ec2ec0645ba81c">is_log_table_write_query</a> (enum enum_sql_command command)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10e39fc20b643c491433d588e0cc1c0e"></a><!-- doxytag: member="Runtime_Environment::execute_init_command" ref="ga10e39fc20b643c491433d588e0cc1c0e" args="(THD *thd, LEX_STRING *init_command, mysql_rwlock_t *var_lock)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>execute_init_command</b> (THD *thd, LEX_STRING *init_command, mysql_rwlock_t *var_lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pthread_handler_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gacf9312b6cc71d1357eeb61197a877ce1">handle_bootstrap</a> (void *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7dec92b6bab8d3703abfe029427ab761"></a><!-- doxytag: member="Runtime_Environment::do_handle_bootstrap" ref="ga7dec92b6bab8d3703abfe029427ab761" args="(THD *thd)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>do_handle_bootstrap</b> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3ca455b4e3e525a662ef572d60f9290"></a><!-- doxytag: member="Runtime_Environment::free_items" ref="gaf3ca455b4e3e525a662ef572d60f9290" args="(Item *item)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_items</b> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaf7bccb54271a0546d92f2bc732abf3d1">cleanup_items</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga331df424a7892fbbad536f0f3a7b18f6">do_command</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga3ee16ca35fd31e7babfd4afbe8a5914f">dispatch_command</a> (enum enum_server_command command, THD *thd, char *packet, uint packet_length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga93624d7ffd4d872d5e820e5b8ce8432b">log_slow_applicable</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga129f4305c71867fb0acceb629a5e87ec">log_slow_do</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga61772c99fe344b2afa6d92281d114027">log_slow_statement</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaa5de0e97014b9b2e757a145f30eb7efb">prepare_schema_table</a> (THD *thd, LEX *lex, Table_ident *table_ident, enum enum_schema_tables schema_table_idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaeb7f1383eddc970705bb31930071f1cb">alloc_query</a> (THD *thd, const char *packet, uint packet_length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga6a69efbbf47bbcab9d2e517e285679d9">mysql_execute_command</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga52a0044f9c2a876b8a5bb7129d291fca">check_single_table_access</a> (THD *thd, ulong privilege, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *all_tables, bool no_errors)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga396029d3520763afb454cf9606dad876">check_one_table_access</a> (THD *thd, ulong privilege, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *all_tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga18661c7627d8c846bc52e2c002d8cf42">check_access</a> (THD *thd, ulong want_access, const char *db, ulong *save_priv, <a class="el" href="structst__grant__internal__info.html">GRANT_INTERNAL_INFO</a> *grant_internal_info, bool dont_check_global_grants, bool no_errors)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare requested privileges with the privileges acquired from the User- and Db-tables.  <a href="#ga18661c7627d8c846bc52e2c002d8cf42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga8167bfd04a47fe411b1d11a31975f464">check_table_access</a> (THD *thd, ulong requirements, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, bool any_combination_of_privileges_will_do, uint number, bool no_errors)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the requested privileges exists in either User-, Host- or Db-tables.  <a href="#ga8167bfd04a47fe411b1d11a31975f464"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4a8dd79c3b480a79867da26a57e60e9"></a><!-- doxytag: member="Runtime_Environment::check_routine_access" ref="gac4a8dd79c3b480a79867da26a57e60e9" args="(THD *thd, ulong want_access, char *db, char *name, bool is_proc, bool no_errors)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_routine_access</b> (THD *thd, ulong want_access, char *db, char *name, bool is_proc, bool no_errors)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga224ee9386fac8102ef57d7bb42c05b73">check_some_routine_access</a> (THD *thd, const char *db, const char *name, bool is_proc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaf63a766beac9fd20ebd87dff2c452815">check_some_access</a> (THD *thd, ulong want_access, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga61bd73a368e2b52ae29bdb51e5925367">check_global_access</a> (THD *thd, ulong want_access)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga0420d0e1c0ed7ed64194df863018fcce">check_fk_parent_table_access</a> (THD *thd, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, <a class="el" href="classAlter__info.html">Alter_info</a> *alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga32001160626cc47bd92f7276940814e9">check_stack_overrun</a> (THD *thd, long margin, uchar *buf __attribute__((unused)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga653474cbdeba6ede5508acff79e9d0cd"></a><!-- doxytag: member="Runtime_Environment::my_yyoverflow" ref="ga653474cbdeba6ede5508acff79e9d0cd" args="(short **yyss, YYSTYPE **yyvs, ulong *yystacksize)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>my_yyoverflow</b> (short **yyss, <a class="el" href="unionYYSTYPE.html">YYSTYPE</a> **yyvs, ulong *yystacksize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gab37db6950d3b6bc16bbbb2ae0484ae55">mysql_reset_thd_for_next_command</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga6cd8728922a6dd573cdbaf1598dcb31b">mysql_init_select</a> (LEX *lex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gab1a7eb9da0d5fa32819d62445cf42eae">mysql_new_select</a> (LEX *lex, bool move_down)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga71013eb132159ad97802e07aca344069">create_select_for_variable</a> (const char *var_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga891266e258a6034e8f09a410bb4abe62"></a><!-- doxytag: member="Runtime_Environment::mysql_init_multi_delete" ref="ga891266e258a6034e8f09a410bb4abe62" args="(LEX *lex)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>mysql_init_multi_delete</b> (LEX *lex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga762af5af3ecea78352d38be4b36e5ec9">mysql_parse</a> (THD *thd, char *rawbuf, uint length, Parser_state *parser_state)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga30265d99843b10e6cd08197ed3b2eb5f">add_field_to_list</a> (THD *thd, LEX_STRING *field_name, enum_field_types type, char *length, char *decimals, uint type_modifier, <a class="el" href="classItem.html">Item</a> *default_value, <a class="el" href="classItem.html">Item</a> *on_update_value, LEX_STRING *comment, char *change, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *interval_list, const CHARSET_INFO *cs, uint uint_geom_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga22aec956c23a6f1e16aef7d9db67bc79">store_position_for_column</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaeabebe6eeb7f6d049f3d88dab61d376c">add_to_list</a> (THD *thd, <a class="el" href="classSQL__I__List.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; &amp;list, <a class="el" href="classItem.html">Item</a> *item, bool asc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaa70b34c69515f56b1d43caa55824d5d5">add_join_natural</a> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *a, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *b, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *using_fields, SELECT_LEX *lex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gae3955e7882768e3eda3467b835ec72e8">kill_one_thread</a> (THD *thd, ulong id, bool only_kill_query)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga09d8997f1551aefa58a28606ff68c6f5">append_file_to_dir</a> (THD *thd, const char **filename_ptr, const char *table_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga9f257ba1c05a6af19ffbb21bb49d2005">check_simple_select</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf4fc9496f4801d17398eed353847b8b9"></a><!-- doxytag: member="Runtime_Environment::comp_eq_creator" ref="gaf4fc9496f4801d17398eed353847b8b9" args="(bool invert)" -->
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_eq_creator</b> (bool invert)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga20931601222cda32e69fd3945f6626cc"></a><!-- doxytag: member="Runtime_Environment::comp_ge_creator" ref="ga20931601222cda32e69fd3945f6626cc" args="(bool invert)" -->
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_ge_creator</b> (bool invert)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39f9fb67350b86979e8075ebf10ec3b2"></a><!-- doxytag: member="Runtime_Environment::comp_gt_creator" ref="ga39f9fb67350b86979e8075ebf10ec3b2" args="(bool invert)" -->
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_gt_creator</b> (bool invert)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad219be929fb149f9ffa69224e8214834"></a><!-- doxytag: member="Runtime_Environment::comp_le_creator" ref="gad219be929fb149f9ffa69224e8214834" args="(bool invert)" -->
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_le_creator</b> (bool invert)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5581721018ae2b9b655cefa8bacfb255"></a><!-- doxytag: member="Runtime_Environment::comp_lt_creator" ref="ga5581721018ae2b9b655cefa8bacfb255" args="(bool invert)" -->
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_lt_creator</b> (bool invert)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83bec074d98c59c94c8b0f8631df6e5b"></a><!-- doxytag: member="Runtime_Environment::comp_ne_creator" ref="ga83bec074d98c59c94c8b0f8631df6e5b" args="(bool invert)" -->
<a class="el" href="classComp__creator.html">Comp_creator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>comp_ne_creator</b> (bool invert)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gac994ea735fa021334a4e3c9370af1bd3">all_any_subquery_creator</a> (<a class="el" href="classItem.html">Item</a> *left_expr, chooser_compare_func_creator cmp, bool all, SELECT_LEX *select_lex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaa96b4fbd4c778890b5b178fe5e0a04d0">select_precheck</a> (THD *thd, LEX *lex, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *first_table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga2e0076228a3d2a567cc028eec8851e83">multi_update_precheck</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaef000acb1e6d369acaa40cff099e9ba6">multi_delete_precheck</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga955450e862907b5b8f1499eb71a1f408">multi_delete_set_locks_and_link_aux_tables</a> (LEX *lex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaca439f317910c5ced0d4ee122ab3da72">update_precheck</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gada452077027d855d873579905fde4637">delete_precheck</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gaa78ba920e5b2a02cb98d66c3a6695eb2">insert_precheck</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga95cca4e86f6c748bc34a5879ae0d36f4">create_table_set_open_action_and_adjust_tables</a> (LEX *lex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga7e2798fca7aff6362bf68f6486df25d1">create_table_precheck</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *create_table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gac17cae6ccff0ac32823df32447cfeb83">negate_expression</a> (THD *thd, <a class="el" href="classItem.html">Item</a> *expr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gae6109e9d93731678e792405018a30a24">get_default_definer</a> (THD *thd, <a class="el" href="structst__lex__user.html">LEX_USER</a> *definer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga8ba3e531f8d364506ca098138bd4b459">create_default_definer</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga78e5c88a118719a346a7444ebaaf7828">create_definer</a> (THD *thd, LEX_STRING *user_name, LEX_STRING *host_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga3317cfcf3ee5abca5accb1e77461ca56">get_current_user</a> (THD *thd, <a class="el" href="structst__lex__user.html">LEX_USER</a> *user)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga986b5b8439d700715fe09b309e576e1f">check_string_byte_length</a> (LEX_STRING *str, const char *err_msg, uint max_byte_length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf2673802faf8f4061b81d58aebad499f"></a><!-- doxytag: member="Runtime_Environment::check_string_char_length" ref="gaf2673802faf8f4061b81d58aebad499f" args="(LEX_STRING *str, const char *err_msg, uint max_char_length, const CHARSET_INFO *cs, bool no_error)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_string_char_length</b> (LEX_STRING *str, const char *err_msg, uint max_char_length, const CHARSET_INFO *cs, bool no_error)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35590aeb74bdebbccac86b889a2cb7d1"></a><!-- doxytag: member="Runtime_Environment::test_if_data_home_dir" ref="ga35590aeb74bdebbccac86b889a2cb7d1" args="(const char *dir)" -->
C_MODE_START int&#160;</td><td class="memItemRight" valign="bottom"><b>test_if_data_home_dir</b> (const char *dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">C_MODE_END bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga0aa02c355e70cce63a2412e8a4bccb1b">check_host_name</a> (LEX_STRING *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga064577e9942acfdd4ec6383b30792475"></a><!-- doxytag: member="Runtime_Environment::MYSQLparse" ref="ga064577e9942acfdd4ec6383b30792475" args="(class THD *thd)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>MYSQLparse</b> (class THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#gabb1400ab6d81b2c3eb496d66df4d7674">parse_sql</a> (THD *thd, Parser_state *parser_state, <a class="el" href="classObject__creation__ctx.html">Object_creation_ctx</a> *creation_ctx)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga516dc5f43d189929fe49c1b22aad8b74"></a><!-- doxytag: member="Runtime_Environment::any_db" ref="ga516dc5f43d189929fe49c1b22aad8b74" args="" -->
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>any_db</b> = &quot;*any*&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0fff36dbb3be1083486e5226dbe8267e"></a><!-- doxytag: member="Runtime_Environment::command_name" ref="ga0fff36dbb3be1083486e5226dbe8267e" args="[]" -->
const LEX_STRING&#160;</td><td class="memItemRight" valign="bottom"><b>command_name</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>xa_state_names</b> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Runtime__Environment.html#ga2b520658dfe2259770e9037c640d5399">sql_command_flags</a> [SQLCOM_END+1]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5f7d9336c6c3648f41f0f8603b5a081"></a><!-- doxytag: member="Runtime_Environment::server_command_flags" ref="gae5f7d9336c6c3648f41f0f8603b5a081" args="[COM_END+1]" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>server_command_flags</b> [COM_END+1]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga909f1c5c4bc6d72a01f18503b25d2e07"></a><!-- doxytag: member="Runtime_Environment::max_stack_used" ref="ga909f1c5c4bc6d72a01f18503b25d2e07" args="" -->
long&#160;</td><td class="memItemRight" valign="bottom"><b>max_stack_used</b></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="gaad46f86d310fd4da9b8b2fa93068c4a0"></a><!-- doxytag: member="sql_parse.cc::SP_COM_STRING" ref="gaad46f86d310fd4da9b8b2fa93068c4a0" args="(LP)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SP_COM_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LP</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((LP)-&gt;sql_command == SQLCOM_CREATE_SPFUNCTION || \
   (LP)-&gt;sql_command == SQLCOM_ALTER_FUNCTION || \
   (LP)-&gt;sql_command == SQLCOM_SHOW_CREATE_FUNC || \
   (LP)-&gt;sql_command == SQLCOM_DROP_FUNCTION ? \
   <span class="stringliteral">&quot;FUNCTION&quot;</span> : <span class="stringliteral">&quot;PROCEDURE&quot;</span>)
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga30265d99843b10e6cd08197ed3b2eb5f"></a><!-- doxytag: member="sql_parse.cc::add_field_to_list" ref="ga30265d99843b10e6cd08197ed3b2eb5f" args="(THD *thd, LEX_STRING *field_name, enum_field_types type, char *length, char *decimals, uint type_modifier, Item *default_value, Item *on_update_value, LEX_STRING *comment, char *change, List&lt; String &gt; *interval_list, const CHARSET_INFO *cs, uint uint_geom_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga30265d99843b10e6cd08197ed3b2eb5f">add_field_to_list</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>field_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_field_types&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>decimals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>type_modifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>on_update_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>comment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>change</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *&#160;</td>
          <td class="paramname"><em>interval_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CHARSET_INFO *&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>uint_geom_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Store field definition for create.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Return 0 if ok </dd></dl>

</div>
</div>
<a class="anchor" id="gaa70b34c69515f56b1d43caa55824d5d5"></a><!-- doxytag: member="sql_parse.cc::add_join_natural" ref="gaa70b34c69515f56b1d43caa55824d5d5" args="(TABLE_LIST *a, TABLE_LIST *b, List&lt; String &gt; *using_fields, SELECT_LEX *lex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#gaa70b34c69515f56b1d43caa55824d5d5">add_join_natural</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classString.html">String</a> &gt; *&#160;</td>
          <td class="paramname"><em>using_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a fake SELECT_LEX for a unit.</p>
<p>The method create a fake SELECT_LEX object for a unit. This object is created for any union construct containing a union operation and also for any single select union construct of the form </p>
<div class="fragment"><pre class="fragment">
    (SELECT ... ORDER BY order_list [LIMIT n]) ORDER BY ... 
    @endvarbatim
    or of the form
    @varbatim
    (SELECT ... ORDER BY LIMIT n) ORDER BY ...
    @endvarbatim
  
  @param thd_arg		   thread handle

  @note
    The object is used to retrieve rows from the temporary table
    where the result on the union is obtained.

  @retval
    1     on failure to create the object
  @retval
    0     on success
*/

bool st_select_lex_unit::add_fake_select_lex(THD *thd_arg)
{
  SELECT_LEX *first_sl= first_select();
  DBUG_ENTER("add_fake_select_lex");
  DBUG_ASSERT(!fake_select_lex);

  if (!(fake_select_lex= new (thd_arg-&gt;mem_root) SELECT_LEX()))
      DBUG_RETURN(1);
  fake_select_lex-&gt;include_standalone(this, 
                                      (SELECT_LEX_NODE**)&amp;fake_select_lex);
  fake_select_lex-&gt;select_number= INT_MAX;
  fake_select_lex-&gt;parent_lex= thd_arg-&gt;lex; /* Used in init_query. */
  fake_select_lex-&gt;make_empty_select();
  fake_select_lex-&gt;linkage= GLOBAL_OPTIONS_TYPE;
  fake_select_lex-&gt;select_limit= 0;

  fake_select_lex-&gt;context.outer_context=first_sl-&gt;context.outer_context;
  /* allow item list resolving in fake select for ORDER BY */
  fake_select_lex-&gt;context.resolve_in_select_list= TRUE;
  fake_select_lex-&gt;context.select_lex= fake_select_lex;

  if (!is_union())
  {
    /* 
      This works only for 
      (SELECT ... ORDER BY list [LIMIT n]) ORDER BY order_list [LIMIT m],
      (SELECT ... LIMIT n) ORDER BY order_list [LIMIT m]
      just before the parser starts processing order_list
    */ 
    global_parameters= fake_select_lex;
    fake_select_lex-&gt;no_table_names_allowed= 1;
    thd_arg-&gt;lex-&gt;current_select= fake_select_lex;
  }
  thd_arg-&gt;lex-&gt;pop_context();
  DBUG_RETURN(0);
}


/**
  Push a new name resolution context for a JOIN ... ON clause to the
  context stack of a query block.

    Create a new name resolution context for a JOIN ... ON clause,
    set the first and last leaves of the list of table references
    to be used for name resolution, and push the newly created
    context to the stack of contexts of the query.

  @param thd       pointer to current thread
  @param left_op   left  operand of the JOIN
  @param right_op  rigth operand of the JOIN

  @todo Research if we should set the "outer_context" member of the new ON
  context.

  @retval
    FALSE  if all is OK
  @retval
    TRUE   if a memory allocation error occured
*/

bool
push_new_name_resolution_context(THD *thd,
                                 TABLE_LIST *left_op, TABLE_LIST *right_op)
{
  Name_resolution_context *on_context;
  if (!(on_context= new (thd-&gt;mem_root) Name_resolution_context))
    return TRUE;
  on_context-&gt;init();
  on_context-&gt;first_name_resolution_table=
    left_op-&gt;first_leaf_for_name_resolution();
  on_context-&gt;last_name_resolution_table=
    right_op-&gt;last_leaf_for_name_resolution();
  on_context-&gt;select_lex= thd-&gt;lex-&gt;current_select;
  // Save join nest's context in right_op, to find it later in view merging.
  DBUG_ASSERT(right_op-&gt;context_of_embedding == NULL);
  right_op-&gt;context_of_embedding= on_context;
  return thd-&gt;lex-&gt;push_context(on_context);
}


/**
  Add an ON condition to the second operand of a JOIN ... ON.

    Add an ON condition to the right operand of a JOIN ... ON clause.

  @param b     the second operand of a JOIN ... ON
  @param expr  the condition to be added to the ON clause
*/

void add_join_on(TABLE_LIST *b, Item *expr)
{
  if (expr)
  {
    if (!b-&gt;join_cond())
      b-&gt;set_join_cond(expr);
    else
    {
      /*
        If called from the parser, this happens if you have both a
        right and left join. If called later, it happens if we add more
        than one condition to the ON clause.
      */
      b-&gt;set_join_cond(new Item_cond_and(b-&gt;join_cond(), expr));
    }
    b-&gt;join_cond()-&gt;top_level_item();
  }
}


/**
  Mark that there is a NATURAL JOIN or JOIN ... USING between two
  tables.

    This function marks that table b should be joined with a either via
    a NATURAL JOIN or via JOIN ... USING. Both join types are special
    cases of each other, so we treat them together. The function
    setup_conds() creates a list of equal condition between all fields
    of the same name for NATURAL JOIN or the fields in 'using_fields'
    for JOIN ... USING. The list of equality conditions is stored
    either in b-&gt;join_cond(), or in JOIN::conds, depending on whether there
    was an outer join.

  EXAMPLE
  @verbatim
    SELECT * FROM t1 NATURAL LEFT JOIN t2
     &lt;=&gt;
    SELECT * FROM t1 LEFT JOIN t2 ON (t1.i=t2.i and t1.j=t2.j ... )

    SELECT * FROM t1 NATURAL JOIN t2 WHERE &lt;some_cond&gt;
     &lt;=&gt;
    SELECT * FROM t1, t2 WHERE (t1.i=t2.i and t1.j=t2.j and &lt;some_cond&gt;)

    SELECT * FROM t1 JOIN t2 USING(j) WHERE &lt;some_cond&gt;
     &lt;=&gt;
    SELECT * FROM t1, t2 WHERE (t1.j=t2.j and &lt;some_cond&gt;)
   </pre></div><dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Left join argument </td></tr>
    <tr><td class="paramname">b</td><td>Right join argument </td></tr>
    <tr><td class="paramname">using_fields</td><td><a class="el" href="classField.html">Field</a> names from USING clause </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeabebe6eeb7f6d049f3d88dab61d376c"></a><!-- doxytag: member="sql_parse.cc::add_to_list" ref="gaeabebe6eeb7f6d049f3d88dab61d376c" args="(THD *thd, SQL_I_List&lt; ORDER &gt; &amp;list, Item *item, bool asc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gaeabebe6eeb7f6d049f3d88dab61d376c">add_to_list</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSQL__I__List.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>save order by and tables in own lists. </p>

</div>
</div>
<a class="anchor" id="gac994ea735fa021334a4e3c9370af1bd3"></a><!-- doxytag: member="sql_parse.cc::all_any_subquery_creator" ref="gac994ea735fa021334a4e3c9370af1bd3" args="(Item *left_expr, chooser_compare_func_creator cmp, bool all, SELECT_LEX *select_lex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* <a class="el" href="group__Runtime__Environment.html#gac994ea735fa021334a4e3c9370af1bd3">all_any_subquery_creator</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>left_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">chooser_compare_func_creator&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct ALL/ANY/SOME subquery <a class="el" href="classItem.html">Item</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">left_expr</td><td>pointer to left expression </td></tr>
    <tr><td class="paramname">cmp</td><td>compare function creator </td></tr>
    <tr><td class="paramname">all</td><td>true if we create ALL subquery </td></tr>
    <tr><td class="paramname">select_lex</td><td>pointer on parsed subquery structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>constructed <a class="el" href="classItem.html">Item</a> (or 0 if out of memory) </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb7f1383eddc970705bb31930071f1cb"></a><!-- doxytag: member="sql_parse.cc::alloc_query" ref="gaeb7f1383eddc970705bb31930071f1cb" args="(THD *thd, const char *packet, uint packet_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gaeb7f1383eddc970705bb31930071f1cb">alloc_query</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>packet_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read query from packet and store in thd-&gt;query. Used in COM_QUERY and COM_STMT_PREPARE.</p>
<p>Sets the following THD variables:</p>
<ul>
<li>query</li>
<li>query_length</li>
</ul>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>ok </td></tr>
    <tr><td class="paramname">TRUE</td><td>error; In this case thd-&gt;fatal_error is set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga09d8997f1551aefa58a28606ff68c6f5"></a><!-- doxytag: member="sql_parse.cc::append_file_to_dir" ref="ga09d8997f1551aefa58a28606ff68c6f5" args="(THD *thd, const char **filename_ptr, const char *table_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga09d8997f1551aefa58a28606ff68c6f5">append_file_to_dir</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>filename_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If pointer is not a null pointer, append filename to it. </p>

</div>
</div>
<a class="anchor" id="ga18661c7627d8c846bc52e2c002d8cf42"></a><!-- doxytag: member="sql_parse.cc::check_access" ref="ga18661c7627d8c846bc52e2c002d8cf42" args="(THD *thd, ulong want_access, const char *db, ulong *save_priv, GRANT_INTERNAL_INFO *grant_internal_info, bool dont_check_global_grants, bool no_errors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga18661c7627d8c846bc52e2c002d8cf42">check_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>want_access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong *&#160;</td>
          <td class="paramname"><em>save_priv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__grant__internal__info.html">GRANT_INTERNAL_INFO</a> *&#160;</td>
          <td class="paramname"><em>grant_internal_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dont_check_global_grants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare requested privileges with the privileges acquired from the User- and Db-tables. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">want_access</td><td>The requested access privileges. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">db</td><td>A pointer to the Db name. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">save_priv</td><td>A pointer to the granted privileges will be stored. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">grant_internal_info</td><td>A pointer to the internal grant cache. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dont_check_global_grants</td><td>True if no global grants are checked. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">no_error</td><td>True if no errors should be sent to the client.</td></tr>
  </table>
  </dd>
</dl>
<p>'save_priv' is used to save the User-table (global) and Db-table grants for the supplied db name. Note that we don't store db level grants if the global grants is enough to satisfy the request AND the global grants contains a SELECT grant.</p>
<p>For internal databases (INFORMATION_SCHEMA, PERFORMANCE_SCHEMA), additional rules apply, see <a class="el" href="classACL__internal__schema__access.html">ACL_internal_schema_access</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>check_grant</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Status of denial of access by exclusive ACLs. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Access can't exclusively be denied by Db- and User-table access unless Column- and Table-grants are checked too. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Access denied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0420d0e1c0ed7ed64194df863018fcce"></a><!-- doxytag: member="sql_parse.cc::check_fk_parent_table_access" ref="ga0420d0e1c0ed7ed64194df863018fcce" args="(THD *thd, HA_CREATE_INFO *create_info, Alter_info *alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga0420d0e1c0ed7ed64194df863018fcce">check_fk_parent_table_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__info.html">Alter_info</a> *&#160;</td>
          <td class="paramname"><em>alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks foreign key's parent table access.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>[in] Thread handler </td></tr>
    <tr><td class="paramname">create_info</td><td>[in] Create information (like MAX_ROWS, ENGINE or temporary table flag) </td></tr>
    <tr><td class="paramname">alter_info</td><td>[in] Initial list of columns and indexes for the table to be created</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>ok. </td></tr>
    <tr><td class="paramname">true</td><td>error or access denied. Error is sent to client in this case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61bd73a368e2b52ae29bdb51e5925367"></a><!-- doxytag: member="sql_parse.cc::check_global_access" ref="ga61bd73a368e2b52ae29bdb51e5925367" args="(THD *thd, ulong want_access)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga61bd73a368e2b52ae29bdb51e5925367">check_global_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>want_access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>check for global access and give descriptive error message if it fails.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">want_access</td><td>Use should have any of these global rights</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>One gets access right if one has ANY of the rights in want_access. This is useful as one in most cases only need one global right, but in some case we want to check if the user has SUPER or REPL_CLIENT_ACL rights.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Access denied. In this case an error is sent to the client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0aa02c355e70cce63a2412e8a4bccb1b"></a><!-- doxytag: member="sql_parse.cc::check_host_name" ref="ga0aa02c355e70cce63a2412e8a4bccb1b" args="(LEX_STRING *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">C_MODE_END bool <a class="el" href="group__Runtime__Environment.html#ga0aa02c355e70cce63a2412e8a4bccb1b">check_host_name</a> </td>
          <td>(</td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check that host name string is valid.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>string to be checked</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>host name is ok </td></tr>
    <tr><td class="paramname">TRUE</td><td>host name string is longer than max_length or has invalid symbols </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga396029d3520763afb454cf9606dad876"></a><!-- doxytag: member="sql_parse.cc::check_one_table_access" ref="ga396029d3520763afb454cf9606dad876" args="(THD *thd, ulong privilege, TABLE_LIST *all_tables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga396029d3520763afb454cf9606dad876">check_one_table_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>privilege</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>all_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check grants for commands which work only with one table and all other tables belonging to subselects or implicitly opened tables.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">privilege</td><td>requested privilege </td></tr>
    <tr><td class="paramname">all_tables</td><td>global table list of query</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>access denied, error is sent to client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9f257ba1c05a6af19ffbb21bb49d2005"></a><!-- doxytag: member="sql_parse.cc::check_simple_select" ref="ga9f257ba1c05a6af19ffbb21bb49d2005" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga9f257ba1c05a6af19ffbb21bb49d2005">select_dumpvar::check_simple_select</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the select is a simple select (not an union).</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error ; In this case the error messege is sent to the client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52a0044f9c2a876b8a5bb7129d291fca"></a><!-- doxytag: member="sql_parse.cc::check_single_table_access" ref="ga52a0044f9c2a876b8a5bb7129d291fca" args="(THD *thd, ulong privilege, TABLE_LIST *all_tables, bool no_errors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga52a0044f9c2a876b8a5bb7129d291fca">check_single_table_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>privilege</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>all_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check grants for commands which work only with one table.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">privilege</td><td>requested privilege </td></tr>
    <tr><td class="paramname">all_tables</td><td>global table list of query </td></tr>
    <tr><td class="paramname">no_errors</td><td>FALSE/TRUE - report/don't report error to the client (using my_error() call).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>access denied, error is sent to client </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf63a766beac9fd20ebd87dff2c452815"></a><!-- doxytag: member="sql_parse.cc::check_some_access" ref="gaf63a766beac9fd20ebd87dff2c452815" args="(THD *thd, ulong want_access, TABLE_LIST *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gaf63a766beac9fd20ebd87dff2c452815">check_some_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>want_access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the given table has any of the asked privileges</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">want_access</td><td><a class="el" href="classBitmap.html">Bitmap</a> of possible privileges to check for</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga224ee9386fac8102ef57d7bb42c05b73"></a><!-- doxytag: member="sql_parse.cc::check_some_routine_access" ref="ga224ee9386fac8102ef57d7bb42c05b73" args="(THD *thd, const char *db, const char *name, bool is_proc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga224ee9386fac8102ef57d7bb42c05b73">check_some_routine_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_proc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the routine has any of the routine privileges.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">db</td><td>Database name </td></tr>
    <tr><td class="paramname">name</td><td>Routine name</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga32001160626cc47bd92f7276940814e9"></a><!-- doxytag: member="sql_parse.cc::check_stack_overrun" ref="ga32001160626cc47bd92f7276940814e9" args="(THD *thd, long margin, uchar *buf __attribute__((unused)))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga32001160626cc47bd92f7276940814e9">check_stack_overrun</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>margin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *buf &#160;</td>
          <td class="paramname"><em>__attribute__</em>(unused)&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="note"><dt><b>Note:</b></dt><dd>Note: The 'buf' parameter is necessary, even if it is unused here.<ul>
<li>fix_fields functions has a "dummy" buffer large enough for the corresponding exec. (Thus we only have to check in fix_fields.)</li>
<li>Passing to <a class="el" href="group__Runtime__Environment.html#ga32001160626cc47bd92f7276940814e9">check_stack_overrun()</a> prevents the compiler from removing it. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga986b5b8439d700715fe09b309e576e1f"></a><!-- doxytag: member="sql_parse.cc::check_string_byte_length" ref="ga986b5b8439d700715fe09b309e576e1f" args="(LEX_STRING *str, const char *err_msg, uint max_byte_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga986b5b8439d700715fe09b309e576e1f">check_string_byte_length</a> </td>
          <td>(</td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>err_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max_byte_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check that byte length of a string does not exceed some limit.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to be checked </td></tr>
    <tr><td class="paramname">err_msg</td><td>error message to be displayed if the string is too long </td></tr>
    <tr><td class="paramname">max_length</td><td>max length</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>the passed string is not longer than max_length </td></tr>
    <tr><td class="paramname">TRUE</td><td>the passed string is longer than max_length</td></tr>
  </table>
  </dd>
</dl>
<p>NOTE The function is not used in existing code but can be useful later? </p>

</div>
</div>
<a class="anchor" id="ga8167bfd04a47fe411b1d11a31975f464"></a><!-- doxytag: member="sql_parse.cc::check_table_access" ref="ga8167bfd04a47fe411b1d11a31975f464" args="(THD *thd, ulong requirements, TABLE_LIST *tables, bool any_combination_of_privileges_will_do, uint number, bool no_errors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga8167bfd04a47fe411b1d11a31975f464">check_table_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>requirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>any_combination_of_privileges_will_do</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the requested privileges exists in either User-, Host- or Db-tables. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">want_access</td><td>Privileges requested </td></tr>
    <tr><td class="paramname">tables</td><td><a class="el" href="classList.html">List</a> of tables to be compared against </td></tr>
    <tr><td class="paramname">no_errors</td><td>Don't report error to the client (using my_error() call). </td></tr>
    <tr><td class="paramname">any_combination_of_privileges_will_do</td><td>TRUE if any privileges on any column combination is enough. </td></tr>
    <tr><td class="paramname">number</td><td>Only the first 'number' tables in the linked list are relevant.</td></tr>
  </table>
  </dd>
</dl>
<p>The suppled table list contains cached privileges. This functions calls the help functions check_access and check_grant to verify the first three steps in the privileges check queue: 1. Global privileges 2. OR (db privileges AND host privileges) 3. OR table privileges 4. OR column privileges (not checked by this function!) 5. OR routine privileges (not checked by this function!)</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Runtime__Environment.html#ga18661c7627d8c846bc52e2c002d8cf42" title="Compare requested privileges with the privileges acquired from the User- and Db-tables.">check_access</a> </dd>
<dd>
check_grant</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This functions assumes that table list used and thd-&gt;lex-&gt;query_tables_own_last value correspond to each other (the latter should be either 0 or point to next_global member of one of elements of this table list).</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>Access denied; But column or routine privileges might need to be checked also. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf7bccb54271a0546d92f2bc732abf3d1"></a><!-- doxytag: member="sql_parse.cc::cleanup_items" ref="gaf7bccb54271a0546d92f2bc732abf3d1" args="(Item *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#gaf7bccb54271a0546d92f2bc732abf3d1">cleanup_items</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This works because items are allocated with sql_alloc(). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The function also handles null pointers (empty list). </dd></dl>

</div>
</div>
<a class="anchor" id="ga8ba3e531f8d364506ca098138bd4b459"></a><!-- doxytag: member="sql_parse.cc::create_default_definer" ref="ga8ba3e531f8d364506ca098138bd4b459" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__lex__user.html">LEX_USER</a>* <a class="el" href="group__Runtime__Environment.html#ga8ba3e531f8d364506ca098138bd4b459">create_default_definer</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create default definer for the specified THD.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>On success, return a valid pointer to the created and initialized LEX_USER, which contains definer information.</li>
<li>On error, return 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga78e5c88a118719a346a7444ebaaf7828"></a><!-- doxytag: member="sql_parse.cc::create_definer" ref="ga78e5c88a118719a346a7444ebaaf7828" args="(THD *thd, LEX_STRING *user_name, LEX_STRING *host_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__lex__user.html">LEX_USER</a>* <a class="el" href="group__Runtime__Environment.html#ga78e5c88a118719a346a7444ebaaf7828">create_definer</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>user_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>host_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create definer with the given user and host names.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_name</td><td>user name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">host_name</td><td>host name</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>On success, return a valid pointer to the created and initialized LEX_USER, which contains definer information.</li>
<li>On error, return 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga71013eb132159ad97802e07aca344069"></a><!-- doxytag: member="sql_parse.cc::create_select_for_variable" ref="ga71013eb132159ad97802e07aca344069" args="(const char *var_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#ga71013eb132159ad97802e07aca344069">create_select_for_variable</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>var_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a select to return the same output as 'SELECT @var_name'.</p>
<p>Used for SHOW COUNT(*) [ WARNINGS | ERROR].</p>
<p>This will crash with a core dump if the variable doesn't exists.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">var_name</td><td>Variable name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e2798fca7aff6362bf68f6486df25d1"></a><!-- doxytag: member="sql_parse.cc::create_table_precheck" ref="ga7e2798fca7aff6362bf68f6486df25d1" args="(THD *thd, TABLE_LIST *tables, TABLE_LIST *create_table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga7e2798fca7aff6362bf68f6486df25d1">create_table_precheck</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>create_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>CREATE <a class="el" href="structTABLE.html">TABLE</a> query pre-check.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Global table list </td></tr>
    <tr><td class="paramname">create_table</td><td>Table which will be created</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga95cca4e86f6c748bc34a5879ae0d36f4"></a><!-- doxytag: member="sql_parse.cc::create_table_set_open_action_and_adjust_tables" ref="ga95cca4e86f6c748bc34a5879ae0d36f4" args="(LEX *lex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#ga95cca4e86f6c748bc34a5879ae0d36f4">create_table_set_open_action_and_adjust_tables</a> </td>
          <td>(</td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set proper open mode and table type for element representing target table of CREATE <a class="el" href="structTABLE.html">TABLE</a> statement, also adjust statement table list if necessary. </p>

</div>
</div>
<a class="anchor" id="gada452077027d855d873579905fde4637"></a><!-- doxytag: member="sql_parse.cc::delete_precheck" ref="gada452077027d855d873579905fde4637" args="(THD *thd, TABLE_LIST *tables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gada452077027d855d873579905fde4637">delete_precheck</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>simple DELETE query pre-check.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Global table list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3ee16ca35fd31e7babfd4afbe8a5914f"></a><!-- doxytag: member="sql_parse.cc::dispatch_command" ref="ga3ee16ca35fd31e7babfd4afbe8a5914f" args="(enum enum_server_command command, THD *thd, char *packet, uint packet_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga3ee16ca35fd31e7babfd4afbe8a5914f">dispatch_command</a> </td>
          <td>(</td>
          <td class="paramtype">enum enum_server_command&#160;</td>
          <td class="paramname"><em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>packet_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform one connection-level (COM_XXXX) command.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>type of command to perform </td></tr>
    <tr><td class="paramname">thd</td><td>connection handle </td></tr>
    <tr><td class="paramname">packet</td><td>data for the command, packet is always null-terminated </td></tr>
    <tr><td class="paramname">packet_length</td><td>length of packet + 1 (to show that data is null-terminated) except for COM_SLEEP, where it can be zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000082">Todo:</a></b></dt><dd><p class="startdd">set thd-&gt;lex-&gt;sql_command to SQLCOM_END here. </p>
<p class="enddd">The following has to be changed to an 8 byte integer</p>
</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>request of thread shutdown, i. e. if command is COM_QUIT/COM_SHUTDOWN </td></tr>
  </table>
  </dd>
</dl>
<p>Clear the set of flags that are expected to be cleared at the beginning of each command.</p>
<p>Enforce password expiration for all RPC commands, except the following:</p>
<p>COM_QUERY does a more fine-grained check later. COM_STMT_CLOSE and COM_STMT_SEND_LONG_DATA don't return anything. COM_PING only discloses information that the server is running, and that's available through other means. COM_QUIT should work even for expired statements.</p>

</div>
</div>
<a class="anchor" id="ga331df424a7892fbbad536f0f3a7b18f6"></a><!-- doxytag: member="sql_parse.cc::do_command" ref="ga331df424a7892fbbad536f0f3a7b18f6" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga331df424a7892fbbad536f0f3a7b18f6">do_command</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read one command from connection and execute it (query or simple command). This function is called in loop from thread function.</p>
<p>For profiling to work, it must never be called recursively.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>request of thread shutdown (see <a class="el" href="group__Runtime__Environment.html#ga3ee16ca35fd31e7babfd4afbe8a5914f">dispatch_command()</a> description) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3317cfcf3ee5abca5accb1e77461ca56"></a><!-- doxytag: member="sql_parse.cc::get_current_user" ref="ga3317cfcf3ee5abca5accb1e77461ca56" args="(THD *thd, LEX_USER *user)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__lex__user.html">LEX_USER</a>* <a class="el" href="group__Runtime__Environment.html#ga3317cfcf3ee5abca5accb1e77461ca56">get_current_user</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td>
          <td class="paramname"><em>user</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retuns information about user or current user.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user</td><td>user</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>On success, return a valid pointer to initialized LEX_USER, which contains user information.</li>
<li>On error, return 0. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae6109e9d93731678e792405018a30a24"></a><!-- doxytag: member="sql_parse.cc::get_default_definer" ref="gae6109e9d93731678e792405018a30a24" args="(THD *thd, LEX_USER *definer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#gae6109e9d93731678e792405018a30a24">get_default_definer</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__lex__user.html">LEX_USER</a> *&#160;</td>
          <td class="paramname"><em>definer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified definer to the default value, which is the current user in the thread.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">definer</td><td>definer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacf9312b6cc71d1357eeb61197a877ce1"></a><!-- doxytag: member="sql_parse.cc::handle_bootstrap" ref="gacf9312b6cc71d1357eeb61197a877ce1" args="(void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_handler_t <a class="el" href="group__Runtime__Environment.html#gacf9312b6cc71d1357eeb61197a877ce1">handle_bootstrap</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Execute commands from bootstrap_file.</p>
<p>Used when creating the initial grant tables. </p>

</div>
</div>
<a class="anchor" id="gaa78ba920e5b2a02cb98d66c3a6695eb2"></a><!-- doxytag: member="sql_parse.cc::insert_precheck" ref="gaa78ba920e5b2a02cb98d66c3a6695eb2" args="(THD *thd, TABLE_LIST *tables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gaa78ba920e5b2a02cb98d66c3a6695eb2">insert_precheck</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>simple INSERT query pre-check.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Global table list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1eaa146f67e2bd9604ec2ec0645ba81c"></a><!-- doxytag: member="sql_parse.cc::is_log_table_write_query" ref="ga1eaa146f67e2bd9604ec2ec0645ba81c" args="(enum enum_sql_command command)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga1eaa146f67e2bd9604ec2ec0645ba81c">is_log_table_write_query</a> </td>
          <td>(</td>
          <td class="paramtype">enum enum_sql_command&#160;</td>
          <td class="paramname"><em>command</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if a sql command is allowed to write to log tables. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The SQL command </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if writing is allowed </dd></dl>

</div>
</div>
<a class="anchor" id="gae3955e7882768e3eda3467b835ec72e8"></a><!-- doxytag: member="sql_parse.cc::kill_one_thread" ref="gae3955e7882768e3eda3467b835ec72e8" args="(THD *thd, ulong id, bool only_kill_query)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Runtime__Environment.html#gae3955e7882768e3eda3467b835ec72e8">kill_one_thread</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_kill_query</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>kill on thread.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread class </td></tr>
    <tr><td class="paramname">id</td><td>Thread id </td></tr>
    <tr><td class="paramname">only_kill_query</td><td>Should it kill the query or the connection</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This is written such that we have a short lock on LOCK_thread_count </dd></dl>

</div>
</div>
<a class="anchor" id="ga93624d7ffd4d872d5e820e5b8ce8432b"></a><!-- doxytag: member="sql_parse.cc::log_slow_applicable" ref="ga93624d7ffd4d872d5e820e5b8ce8432b" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga93624d7ffd4d872d5e820e5b8ce8432b">log_slow_applicable</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check whether we need to write the current statement (or its rewritten version if it exists) to the slow query log. As a side-effect, a digest of suppressed statements may be written.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>statement needs to be logged </td></tr>
    <tr><td class="paramname">false</td><td>statement does not need to be logged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga129f4305c71867fb0acceb629a5e87ec"></a><!-- doxytag: member="sql_parse.cc::log_slow_do" ref="ga129f4305c71867fb0acceb629a5e87ec" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#ga129f4305c71867fb0acceb629a5e87ec">log_slow_do</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unconditionally the current statement (or its rewritten version if it exists) to the slow query log.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga61772c99fe344b2afa6d92281d114027"></a><!-- doxytag: member="sql_parse.cc::log_slow_statement" ref="ga61772c99fe344b2afa6d92281d114027" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#ga61772c99fe344b2afa6d92281d114027">log_slow_statement</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check whether we need to write the current statement to the slow query log. If so, do so. This is a wrapper for the two functions above; most callers should use this wrapper. Only use the above functions directly if you have expensive rewriting that you only need to do if the query actually needs to be logged (e.g. SP variables / NAME_CONST substitution when executing a PROCEDURE). A digest of suppressed statements may be logged instead of the current statement.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef000acb1e6d369acaa40cff099e9ba6"></a><!-- doxytag: member="sql_parse.cc::multi_delete_precheck" ref="gaef000acb1e6d369acaa40cff099e9ba6" args="(THD *thd, TABLE_LIST *tables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gaef000acb1e6d369acaa40cff099e9ba6">multi_delete_precheck</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multi delete query pre-check.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Global/local table list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga955450e862907b5b8f1499eb71a1f408"></a><!-- doxytag: member="sql_parse.cc::multi_delete_set_locks_and_link_aux_tables" ref="ga955450e862907b5b8f1499eb71a1f408" args="(LEX *lex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga955450e862907b5b8f1499eb71a1f408">multi_delete_set_locks_and_link_aux_tables</a> </td>
          <td>(</td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Link tables in auxilary table list of multi-delete with corresponding elements in main table list, and set proper locks for them.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lex</td><td>pointer to LEX representing multi-delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>success </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2e0076228a3d2a567cc028eec8851e83"></a><!-- doxytag: member="sql_parse.cc::multi_update_precheck" ref="ga2e0076228a3d2a567cc028eec8851e83" args="(THD *thd, TABLE_LIST *tables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#ga2e0076228a3d2a567cc028eec8851e83">multi_update_precheck</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multi update query pre-check.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Global/local table list (have to be the same)</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a69efbbf47bbcab9d2e517e285679d9"></a><!-- doxytag: member="sql_parse.cc::mysql_execute_command" ref="ga6a69efbbf47bbcab9d2e517e285679d9" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Runtime__Environment.html#ga6a69efbbf47bbcab9d2e517e285679d9">mysql_execute_command</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Execute command saved in thd and lex-&gt;sql_command.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000083">Todo:</a></b></dt><dd><ul>
<li>Invalidate the table in the query cache if something changed after unlocking when changes become visible. </li>
</ul>
<p class="enddd">: this is workaround. right way will be move invalidating in the unlock procedure.</p>
<ul>
<li>TODO: use check_change_password()</li>
</ul>
</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error </td></tr>
  </table>
  </dd>
</dl>
<p>NO_EMBEDDED_ACCESS_CHECKS </p>

</div>
</div>
<a class="anchor" id="ga6cd8728922a6dd573cdbaf1598dcb31b"></a><!-- doxytag: member="sql_parse.cc::mysql_init_select" ref="ga6cd8728922a6dd573cdbaf1598dcb31b" args="(LEX *lex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#ga6cd8728922a6dd573cdbaf1598dcb31b">mysql_init_select</a> </td>
          <td>(</td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the lex-&gt;current_select object. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is assumed that lex-&gt;current_select != NULL</dd></dl>
<p>This function is a wrapper around select_lex-&gt;init_select() with an added check for the special situation when using INTO OUTFILE and LOAD DATA. </p>

</div>
</div>
<a class="anchor" id="gab1a7eb9da0d5fa32819d62445cf42eae"></a><!-- doxytag: member="sql_parse.cc::mysql_new_select" ref="gab1a7eb9da0d5fa32819d62445cf42eae" args="(LEX *lex, bool move_down)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gab1a7eb9da0d5fa32819d62445cf42eae">mysql_new_select</a> </td>
          <td>(</td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>move_down</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to allocate a new SELECT_LEX object on the current thd mem_root and link it into the relevant lists.</p>
<p>This function is always followed by mysql_init_select.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Runtime__Environment.html#ga6cd8728922a6dd573cdbaf1598dcb31b">mysql_init_select</a></dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>An error occurred </td></tr>
    <tr><td class="paramname">FALSE</td><td>The new SELECT_LEX was successfully allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga762af5af3ecea78352d38be4b36e5ec9"></a><!-- doxytag: member="sql_parse.cc::mysql_parse" ref="ga762af5af3ecea78352d38be4b36e5ec9" args="(THD *thd, char *rawbuf, uint length, Parser_state *parser_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#ga762af5af3ecea78352d38be4b36e5ec9">mysql_parse</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>rawbuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parser_state *&#160;</td>
          <td class="paramname"><em>parser_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Parse a query.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Current thread </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rawbuf</td><td>Begining of the query text </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">length</td><td>Length of the query text </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found_semicolon</td><td>For multi queries, position of the character of the next query in the query text. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab37db6950d3b6bc16bbbb2ae0484ae55"></a><!-- doxytag: member="sql_parse.cc::mysql_reset_thd_for_next_command" ref="gab37db6950d3b6bc16bbbb2ae0484ae55" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#gab37db6950d3b6bc16bbbb2ae0484ae55">mysql_reset_thd_for_next_command</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the part of THD responsible for the state of command processing.</p>
<p>This needs to be called before execution of every statement (prepared or conventional). It is not called by substatements of routines.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000084">Todo:</a></b></dt><dd>Remove mysql_reset_thd_for_next_command and only use the member function.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000085">Todo:</a></b></dt><dd>Call it after we use THD for queries, not before. </dd></dl>

</div>
</div>
<a class="anchor" id="gac17cae6ccff0ac32823df32447cfeb83"></a><!-- doxytag: member="sql_parse.cc::negate_expression" ref="gac17cae6ccff0ac32823df32447cfeb83" args="(THD *thd, Item *expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* <a class="el" href="group__Runtime__Environment.html#gac17cae6ccff0ac32823df32447cfeb83">negate_expression</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>negate given expression.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">expr</td><td>expression for negation</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>negated expression </dd></dl>

</div>
</div>
<a class="anchor" id="gabb1400ab6d81b2c3eb496d66df4d7674"></a><!-- doxytag: member="sql_parse.cc::parse_sql" ref="gabb1400ab6d81b2c3eb496d66df4d7674" args="(THD *thd, Parser_state *parser_state, Object_creation_ctx *creation_ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gabb1400ab6d81b2c3eb496d66df4d7674">parse_sql</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Parser_state *&#160;</td>
          <td class="paramname"><em>parser_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classObject__creation__ctx.html">Object_creation_ctx</a> *&#160;</td>
          <td class="paramname"><em>creation_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is a wrapper of MYSQLparse(). All the code should call <a class="el" href="group__Runtime__Environment.html#gabb1400ab6d81b2c3eb496d66df4d7674">parse_sql()</a> instead of MYSQLparse().</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">parser_state</td><td>Parser state. </td></tr>
    <tr><td class="paramname">creation_ctx</td><td>Object creation context.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>on success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>on parsing error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa5de0e97014b9b2e757a145f30eb7efb"></a><!-- doxytag: member="sql_parse.cc::prepare_schema_table" ref="gaa5de0e97014b9b2e757a145f30eb7efb" args="(THD *thd, LEX *lex, Table_ident *table_ident, enum enum_schema_tables schema_table_idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Runtime__Environment.html#gaa5de0e97014b9b2e757a145f30eb7efb">prepare_schema_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Table_ident *&#160;</td>
          <td class="paramname"><em>table_ident</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum enum_schema_tables&#160;</td>
          <td class="paramname"><em>schema_table_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> object for an INFORMATION_SCHEMA table.</p>
<p>This function is used in the parser to convert a SHOW or DESCRIBE table_name command to a SELECT from INFORMATION_SCHEMA. It prepares a SELECT_LEX and a <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> object to represent the given command as a SELECT parse tree.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramname">lex</td><td>current lex </td></tr>
    <tr><td class="paramname">table_ident</td><td>table alias if it's used </td></tr>
    <tr><td class="paramname">schema_table_idx</td><td>the type of the INFORMATION_SCHEMA table to be created</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Due to the way this function works with memory and LEX it cannot be used outside the parser (parse tree transformations outside the parser break PS and SP).</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>out of memory or SHOW commands are not allowed in this version of the server. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa96b4fbd4c778890b5b178fe5e0a04d0"></a><!-- doxytag: member="sql_parse.cc::select_precheck" ref="gaa96b4fbd4c778890b5b178fe5e0a04d0" args="(THD *thd, LEX *lex, TABLE_LIST *tables, TABLE_LIST *first_table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gaa96b4fbd4c778890b5b178fe5e0a04d0">select_precheck</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX *&#160;</td>
          <td class="paramname"><em>lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>first_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform first stage of privilege checking for SELECT statement.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">lex</td><td>LEX for SELECT statement. </td></tr>
    <tr><td class="paramname">tables</td><td><a class="el" href="classList.html">List</a> of tables used by statement. </td></tr>
    <tr><td class="paramname">first_table</td><td>First table in the main SELECT of the SELECT statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>- Success (column-level privilege checks might be required). </td></tr>
    <tr><td class="paramname">TRUE</td><td>- Failure, privileges are insufficient. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga22aec956c23a6f1e16aef7d9db67bc79"></a><!-- doxytag: member="sql_parse.cc::store_position_for_column" ref="ga22aec956c23a6f1e16aef7d9db67bc79" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Runtime__Environment.html#ga22aec956c23a6f1e16aef7d9db67bc79">store_position_for_column</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Store position for column in ALTER <a class="el" href="structTABLE.html">TABLE</a> .. ADD column. </p>

</div>
</div>
<a class="anchor" id="gaca439f317910c5ced0d4ee122ab3da72"></a><!-- doxytag: member="sql_parse.cc::update_precheck" ref="gaca439f317910c5ced0d4ee122ab3da72" args="(THD *thd, TABLE_LIST *tables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Runtime__Environment.html#gaca439f317910c5ced0d4ee122ab3da72">update_precheck</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>simple UPDATE query pre-check.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Global table list</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga2b520658dfe2259770e9037c640d5399"></a><!-- doxytag: member="sql_parse.cc::sql_command_flags" ref="ga2b520658dfe2259770e9037c640d5399" args="[SQLCOM_END+1]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Runtime__Environment.html#ga2b520658dfe2259770e9037c640d5399">sql_command_flags</a>[SQLCOM_END+1]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mark all commands that somehow changes a table.</p>
<p>This is used to check number of updates / hour.</p>
<p>sql_command is actually set to SQLCOM_END sometimes so we need the +1 to include it in the array.</p>
<p>See COMMAND_FLAG_xxx for different type of commands 2 - query that returns meaningful ROW_COUNT() - a number of modified rows </p>

</div>
</div>
<a class="anchor" id="ga8ae23d04bda74624f8e6bffd2aea6eff"></a><!-- doxytag: member="sql_parse.cc::xa_state_names" ref="ga8ae23d04bda74624f8e6bffd2aea6eff" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* xa_state_names[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment">{
  <span class="stringliteral">&quot;NON-EXISTING&quot;</span>, <span class="stringliteral">&quot;ACTIVE&quot;</span>, <span class="stringliteral">&quot;IDLE&quot;</span>, <span class="stringliteral">&quot;PREPARED&quot;</span>, <span class="stringliteral">&quot;ROLLBACK ONLY&quot;</span>
}
</pre></div>
</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:47 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
