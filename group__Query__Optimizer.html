<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: Query Optimizer</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Query Optimizer</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCOND__CMP.html">COND_CMP</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structKey__field.html">Key_field</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used when finding key fields.  <a href="structKey__field.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPlan__change__watchdog.html">Plan_change_watchdog</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58297bde0da4187801e718c29d5d6b5e"></a><!-- doxytag: member="Query_Optimizer::KEY_OPTIMIZE_EXISTS" ref="ga58297bde0da4187801e718c29d5d6b5e" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KEY_OPTIMIZE_EXISTS</b>&#160;&#160;&#160;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0658a5d9673135da1c2f6463f0537405"></a><!-- doxytag: member="Query_Optimizer::KEY_OPTIMIZE_REF_OR_NULL" ref="ga0658a5d9673135da1c2f6463f0537405" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>KEY_OPTIMIZE_REF_OR_NULL</b>&#160;&#160;&#160;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8976c581bb885405f6b19a1753e6e6dd"></a><!-- doxytag: member="Query_Optimizer::ICP_COND_USES_INDEX_ONLY" ref="ga8976c581bb885405f6b19a1753e6e6dd" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ICP_COND_USES_INDEX_ONLY</b>&#160;&#160;&#160;10</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga54a15a3b027af8533c100d5c0fa218f5">reset_nj_counters</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *join_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__equal.html">Item_equal</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab9652206431848c00d81533336a424c6">find_item_equal</a> (<a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal, <a class="el" href="classField.html">Field</a> *field, bool *inherited_fl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga67d1175177356bf1c9b05e9104d28c5b">get_best_field</a> (<a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa6b7012eda6c33a9a9e734948853a334">build_equal_items</a> (THD *thd, <a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *inherited, bool do_inherit, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *join_list, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> **cond_equal_ref)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga253393c0747cf378b9cefa109662bd17">substitute_for_best_equal_field</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *cond_equal, void *table_join_idx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga81ebfe4ef44f9496582b436835f4680c">update_depend_map</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga652bf7109dfbe0fdd7deb75c05c0a7a3"></a><!-- doxytag: member="Query_Optimizer::uses_index_fields_only" ref="ga652bf7109dfbe0fdd7deb75c05c0a7a3" args="(Item *item, TABLE *tbl, uint keyno, bool other_tbls_ok)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>uses_index_fields_only</b> (<a class="el" href="classItem.html">Item</a> *item, <a class="el" href="structTABLE.html">TABLE</a> *tbl, uint keyno, bool other_tbls_ok)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa992e841315769954816105b951d3e17">is_indexed_agg_distinct</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__field.html">Item_field</a> &gt; *out_args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMem__root__array.html">Key_use_array</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7a5efe6ddb0de3a2b43f36c3330354e7">create_keyuse_for_table</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, uint keyparts, <a class="el" href="classItem__field.html">Item_field</a> **fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; outer_exprs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaedf2fb3248e5d013e6a74b29dd9e7429">make_cond_for_table</a> (<a class="el" href="classItem.html">Item</a> *cond, table_map tables, table_map used_table, bool exclude_expensive_cond)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5e8bc785b0cfb6f2269f566283e239f7">optimize_cond</a> (THD *thd, <a class="el" href="classItem.html">Item</a> *conds, <a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> **cond_equal, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *join_list, bool build_equalities, Item::cond_result *cond_value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaba67ab6a59be99d1ae4d29ff674feebc">remove_eq_conds</a> (THD *thd, <a class="el" href="classItem.html">Item</a> *cond, Item::cond_result *cond_value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0fc6278226cdb15849ecfd9c3af07b00"></a><!-- doxytag: member="Query_Optimizer::const_expression_in_where" ref="ga0fc6278226cdb15849ecfd9c3af07b00" args="(Item *conds, Item *item, Item **comp_item)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>const_expression_in_where</b> (<a class="el" href="classItem.html">Item</a> *conds, <a class="el" href="classItem.html">Item</a> *item, <a class="el" href="classItem.html">Item</a> **comp_item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafd0c3fdb07be77d705feaf3f8f51164f">find_shortest_key</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *usable_keys)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad9015b581d8214425649d273f3e12090">handle_select</a> (THD *thd, select_result *result, ulong setup_tables_done_option)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga410e1c85b186cd5520a7d21930ead6e5">types_allow_materialization</a> (<a class="el" href="classItem.html">Item</a> *outer, <a class="el" href="classItem.html">Item</a> *inner)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two items are compatible wrt. materialization.  <a href="#ga410e1c85b186cd5520a7d21930ead6e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gac201f6bcc85fbd7e04997dda1c83e5b1">mysql_select</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, uint wild_num, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="classItem.html">Item</a> *conds, <a class="el" href="classSQL__I__List.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; *order, <a class="el" href="classSQL__I__List.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; *group, <a class="el" href="classItem.html">Item</a> *having, ulonglong select_options, select_result *result, SELECT_LEX_UNIT *unit, SELECT_LEX *select_lex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab0ca922593fe6b15db19791f8133f407">calc_used_field_length</a> (THD *thd, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *join_tab)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga3b518fb7975676afc7395b412e803368">create_ref_for_key</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__join__table.html">JOIN_TAB</a> *j, <a class="el" href="classKey__use.html">Key_use</a> *org_keyuse, table_map used_tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad3c0a5624f789fb0bf0c5fc5ec057de9">and_conditions</a> (<a class="el" href="classItem.html">Item</a> **e1, <a class="el" href="classItem.html">Item</a> *e2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga77fc941f20e42c089b99ab1641646828">make_join_readinfo</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, ulonglong options, uint no_jbuf_after)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf1351457ee30a4e67786117e50413541">error_if_full_join</a> (<a class="el" href="classJOIN.html">JOIN</a> *join)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gadbc980a72c17c8442fab87af085697d4">simple_remove_const</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="classItem.html">Item</a> *where)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga8478e8df214dcc332c84d24ebe3f0785">const_expression_in_where</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> *comp_item, <a class="el" href="classField.html">Field</a> *comp_field, <a class="el" href="classItem.html">Item</a> **const_item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga96dc524565684a4e258c98f5b7fd1541">test_if_order_by_key</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="structTABLE.html">TABLE</a> *table, uint idx, uint *used_key_parts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4a8d854a364ab749539a9363619acf99">is_subkey</a> (<a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *key_part, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *ref_key_part, <a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *ref_key_part_end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5c7525857d6d4c3c486dd5985d81675f">is_ref_or_null_optimized</a> (const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, uint ref_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga14a304484212b5489e8e995539493dd0">test_if_skip_sort_order</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, <a class="el" href="structst__order.html">ORDER</a> *order, ha_rows select_limit, const bool no_changes, const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *map, const char *clause_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga61bf73cb2d42b343f9e6306b5d5e56ec">count_field_types</a> (SELECT_LEX *select_lex, TMP_TABLE_PARAM *param, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, bool reset_with_sum_func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4d5a2e1822e2131fcfbe6501a8a97525">test_if_subpart</a> (<a class="el" href="structst__order.html">ORDER</a> *a, <a class="el" href="structst__order.html">ORDER</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa978828bfe7be091fb76e1c5da80d644">calc_group_buffer</a> (<a class="el" href="classJOIN.html">JOIN</a> *join, <a class="el" href="structst__order.html">ORDER</a> *group)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga59080a3acd829efcf18fc56d51df215c">free_underlaid_joins</a> (THD *thd, SELECT_LEX *select)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5e83c73f6271bc56ebedaa2e8d3ec5ad">get_index_for_order</a> (<a class="el" href="structst__order.html">ORDER</a> *order, <a class="el" href="structTABLE.html">TABLE</a> *table, <a class="el" href="classSQL__SELECT.html">SQL_SELECT</a> *select, ha_rows limit, bool *need_sort, bool *reverse)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gadbf1b1ecda6374b7b3a32b5454d09876">actual_key_parts</a> (<a class="el" href="structst__key.html">KEY</a> *key_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga174d79a5aef2a8abd1caec143b42837e">actual_key_flags</a> (<a class="el" href="structst__key.html">KEY</a> *key_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa52eaf58ec1438c6d387b55e4035e504"></a><!-- doxytag: member="Query_Optimizer::calc_record_fields" ref="gaa52eaf58ec1438c6d387b55e4035e504" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::calc_record_fields</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa64e01213d7f5f755d1ff689d5e46fd8"></a><!-- doxytag: member="Query_Optimizer::alloc_fields" ref="gaa64e01213d7f5f755d1ff689d5e46fd8" args="(uint external_fields)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::alloc_fields</b> (uint external_fields)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga631f7419905d1b8199d14f5fd11926d4"></a><!-- doxytag: member="Query_Optimizer::create_flag_fields" ref="ga631f7419905d1b8199d14f5fd11926d4" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::create_flag_fields</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab3ab87ee19d6e92561f80933563bb147"></a><!-- doxytag: member="Query_Optimizer::create_remaining_fields" ref="gab3ab87ee19d6e92561f80933563bb147" args="(bool all_read_fields)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::create_remaining_fields</b> (bool all_read_fields)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga81e30ba1b4cfa2fd22aaf1c5bac90b7e"></a><!-- doxytag: member="Query_Optimizer::set_constants" ref="ga81e30ba1b4cfa2fd22aaf1c5bac90b7e" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::set_constants</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5932344e1185abf63788970856f45766">JOIN_CACHE::alloc_buffer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab3dbb0f8b69dc30985e0d9a0ff94121f">JOIN_CACHE_BNL::init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga327376f63198bf31a770fb89242d49aa">JOIN_CACHE_BKA::init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga700b94ef76d1152d7ea4816ec7b46299"></a><!-- doxytag: member="Query_Optimizer::check_emb_key_usage" ref="ga700b94ef76d1152d7ea4816ec7b46299" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::check_emb_key_usage</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga8661280e3da40b2c581ec758c50e1979">JOIN_CACHE_BKA::aux_buffer_incr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaae3c5d1c786e1a3520b7def5d1bbf49e">JOIN_CACHE_BKA::aux_buffer_min_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga552f68c5d61c00714ca823ff05cd7847"></a><!-- doxytag: member="Query_Optimizer::skip_index_tuple" ref="ga552f68c5d61c00714ca823ff05cd7847" args="(range_seq_t rseq, char *range_info)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::skip_index_tuple</b> (range_seq_t rseq, char *range_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga264fccad2a1ea9271e785cb8e38432ca"></a><!-- doxytag: member="Query_Optimizer::write_record_data" ref="ga264fccad2a1ea9271e785cb8e38432ca" args="(uchar *link, bool *is_full)" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::write_record_data</b> (uchar *link, bool *is_full)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8">JOIN_CACHE::reset_cache</a> (bool for_writing)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the join buffer for reading/writing: default implementation.  <a href="#gad54e309ac7f0fd377d7a422ea54f59f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6d55336d67514ad78878149c80528e33"></a><!-- doxytag: member="Query_Optimizer::put_record_in_cache" ref="ga6d55336d67514ad78878149c80528e33" args="()" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::put_record_in_cache</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f7ee01f20498b51114e1afb40806685"></a><!-- doxytag: member="Query_Optimizer::get_record" ref="ga6f7ee01f20498b51114e1afb40806685" args="()" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_record</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaccb8c25ca124e9aeaddf1442c6167e87"></a><!-- doxytag: member="Query_Optimizer::get_record_by_pos" ref="gaccb8c25ca124e9aeaddf1442c6167e87" args="(uchar *rec_ptr)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_record_by_pos</b> (uchar *rec_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab7955ae39f556d0141a6eb11e03a4b1e"></a><!-- doxytag: member="Query_Optimizer::get_match_flag_by_pos" ref="gab7955ae39f556d0141a6eb11e03a4b1e" args="(uchar *rec_ptr)" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::get_match_flag_by_pos</b> (uchar *rec_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga20c8bd509fba4099611e8a7b01c115d8">JOIN_CACHE::read_some_record_fields</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafa19cecc5eccee0ff1285c62769daf39">JOIN_CACHE::read_some_flag_fields</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6967798983487fe2f83ed405b5b2d1f4"></a><!-- doxytag: member="Query_Optimizer::read_record_field" ref="ga6967798983487fe2f83ed405b5b2d1f4" args="(CACHE_FIELD *copy, bool last_record)" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::read_record_field</b> (<a class="el" href="structst__cache__field.html">CACHE_FIELD</a> *copy, bool last_record)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66b36ae5a54a63d5fb2fe863a036aa08"></a><!-- doxytag: member="Query_Optimizer::read_referenced_field" ref="ga66b36ae5a54a63d5fb2fe863a036aa08" args="(CACHE_FIELD *copy, uchar *rec_ptr, uint *len)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::read_referenced_field</b> (<a class="el" href="structst__cache__field.html">CACHE_FIELD</a> *copy, uchar *rec_ptr, uint *len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafbb269cde39ce62236de5b481296de21"></a><!-- doxytag: member="Query_Optimizer::skip_record_if_match" ref="gafbb269cde39ce62236de5b481296de21" args="()" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::skip_record_if_match</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae3feda29f01cc03251f55a0b00511d7a"></a><!-- doxytag: member="Query_Optimizer::restore_last_record" ref="gae3feda29f01cc03251f55a0b00511d7a" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::restore_last_record</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga66879154541707521bc3d07829084c2e"></a><!-- doxytag: member="Query_Optimizer::join_records" ref="ga66879154541707521bc3d07829084c2e" args="(bool skip_last)" -->
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::join_records</b> (bool skip_last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga05271c0a916273b7f8b934fbaab623bd"></a><!-- doxytag: member="Query_Optimizer::join_matching_records" ref="ga05271c0a916273b7f8b934fbaab623bd" args="(bool skip_last)" -->
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BNL::join_matching_records</b> (bool skip_last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafac37078c046dbe5b782dec454fe2da4"></a><!-- doxytag: member="Query_Optimizer::set_match_flag_if_none" ref="gafac37078c046dbe5b782dec454fe2da4" args="(JOIN_TAB *first_inner, uchar *rec_ptr)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::set_match_flag_if_none</b> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *first_inner, uchar *rec_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga774240988bd63b547442150fd459e6d2"></a><!-- doxytag: member="Query_Optimizer::generate_full_extensions" ref="ga774240988bd63b547442150fd459e6d2" args="(uchar *rec_ptr)" -->
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::generate_full_extensions</b> (uchar *rec_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab160a0ff435a7a1da8bb065ba03f1573"></a><!-- doxytag: member="Query_Optimizer::check_match" ref="gab160a0ff435a7a1da8bb065ba03f1573" args="(uchar *rec_ptr)" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::check_match</b> (uchar *rec_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga08fb808afb3705abba0f0bfaf5798d05"></a><!-- doxytag: member="Query_Optimizer::join_null_complements" ref="ga08fb808afb3705abba0f0bfaf5798d05" args="(bool skip_last)" -->
virtual enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE::join_null_complements</b> (bool skip_last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5ae42b1e09c108b419fb9eefac1312ef"></a><!-- doxytag: member="Query_Optimizer::join_matching_records" ref="ga5ae42b1e09c108b419fb9eefac1312ef" args="(bool skip_last)" -->
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::join_matching_records</b> (bool skip_last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89ba1e9701fe4bab26bd70d79e91cd30"></a><!-- doxytag: member="Query_Optimizer::init_join_matching_records" ref="ga89ba1e9701fe4bab26bd70d79e91cd30" args="(RANGE_SEQ_IF *seq_funcs, uint ranges)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::init_join_matching_records</b> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq_funcs, uint ranges)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga812222f5f9eb4a9026c8ce89069ef8d7">JOIN_CACHE::read_all_flag_fields_by_pos</a> (uchar *rec_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga31d40beb0d805bd84dd9c1547450de48"></a><!-- doxytag: member="Query_Optimizer::get_next_key" ref="ga31d40beb0d805bd84dd9c1547450de48" args="(uchar **key)" -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA::get_next_key</b> (uchar **key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa7ca6a85294c32bac8c69bea0c4e5fe1">JOIN_CACHE_BKA_UNIQUE::init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7">JOIN_CACHE_BKA_UNIQUE::reset_cache</a> (bool for_writing)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the join buffer for reading/writing: default implementation.  <a href="#gafb1afc6322b69d01ea68b677b715ddc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga45dfdf58092c485f346a66afd4e124ad"></a><!-- doxytag: member="Query_Optimizer::put_record_in_cache" ref="ga45dfdf58092c485f346a66afd4e124ad" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::put_record_in_cache</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga15ffed7193009e4a49e1c66622217a0f"></a><!-- doxytag: member="Query_Optimizer::get_record" ref="ga15ffed7193009e4a49e1c66622217a0f" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::get_record</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2fc649f4ce5bb5be551fab670511e8b8"></a><!-- doxytag: member="Query_Optimizer::skip_record_if_match" ref="ga2fc649f4ce5bb5be551fab670511e8b8" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::skip_record_if_match</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac4c98e95bbd633f5bd7df7c8bbbe4ed1"></a><!-- doxytag: member="Query_Optimizer::key_search" ref="gac4c98e95bbd633f5bd7df7c8bbbe4ed1" args="(uchar *key, uint key_len, uchar **key_ref_ptr)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::key_search</b> (uchar *key, uint key_len, uchar **key_ref_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6afa1e2231c8090ecae73554fca37c41">JOIN_CACHE_BKA_UNIQUE::skip_index_tuple</a> (range_seq_t rseq, char *range_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1c2a23d19df8e983c61ed2c25214c86d"></a><!-- doxytag: member="Query_Optimizer::join_matching_records" ref="ga1c2a23d19df8e983c61ed2c25214c86d" args="(bool skip_last)" -->
enum_nested_loop_state&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::join_matching_records</b> (bool skip_last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga93a69af2bfc11dc07fce9cdb261cdcd3"></a><!-- doxytag: member="Query_Optimizer::check_all_match_flags_for_key" ref="ga93a69af2bfc11dc07fce9cdb261cdcd3" args="(uchar *key_chain_ptr)" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::check_all_match_flags_for_key</b> (uchar *key_chain_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2cacb8dfb5e5fad32b82fb0b8c572507"></a><!-- doxytag: member="Query_Optimizer::get_next_key" ref="ga2cacb8dfb5e5fad32b82fb0b8c572507" args="(uchar **key)" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN_CACHE_BKA_UNIQUE::get_next_key</b> (uchar **key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gafd031be055cee296d6629313a333b56f">JOIN_CACHE_BKA_UNIQUE::check_match</a> (uchar *rec_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7f722315c64ce97cff639d705107c660">JOIN::optimize</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaeaa6edcfa6c4d934dd42d505d9de2fef">JOIN::update_equalities_for_sjm</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga52d3829776ab95dee43086b5aa43b234">JOIN::set_semijoin_embedding</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb9dfedea0a797bc7aa7f2625ee768b1"></a><!-- doxytag: member="Query_Optimizer::flatten_subqueries" ref="gafb9dfedea0a797bc7aa7f2625ee768b1" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN::flatten_subqueries</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadcdbb72be9500a59e81e9e738607cb3a"></a><!-- doxytag: member="Query_Optimizer::remove_subq_pushed_predicates" ref="gadcdbb72be9500a59e81e9e738607cb3a" args="(Item **where)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>JOIN::remove_subq_pushed_predicates</b> (<a class="el" href="classItem.html">Item</a> **where)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga92bf64a03ec666f565627fbb48ba4677">JOIN::generate_derived_keys</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add keys to derived tables'/views' result tables in a list.  <a href="#ga92bf64a03ec666f565627fbb48ba4677"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga54392f4f40ec2c57b8263f22fa3d4296">JOIN::drop_unused_derived_keys</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop unused keys for each materialized derived table/view.  <a href="#ga54392f4f40ec2c57b8263f22fa3d4296"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga4408ac7e9a04a594110d2009cfcd54c9">JOIN::cache_const_exprs</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gab466b49a22220854ef8f11a2c4a2ae8a">JOIN::decide_subquery_strategy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaef4f64b9b280796d9abe945b2eda94ac">JOIN::refine_best_rowcount</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad4e09d71987062663db1836d651ec4d4">JOIN::reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6214b5001b6cf6a328981401c253f6bb">JOIN::prepare_result</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; **columns_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga6daf5ee65a55d8b5f6ef6c4c35f3a90a">JOIN::explain</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaf2d76654da99be4012095c016ea5d4d2">JOIN::destroy</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae9c1cf0874f4bda777557d012148e059">JOIN::get_best_combination</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae913870950feb0d927de9b53963f0a6a">st_join_table::cleanup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gad1d0a40533b54750b9335583b4c19dda">st_join_table::sjm_query_block_id</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga504ef4abccd4c3f837f2cef119eb5666">st_join_table::and_with_jt_and_sel_condition</a> (<a class="el" href="classItem.html">Item</a> *tmp_cond, uint line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga59504ff5091d87102a2f2a5d4649ec46">st_join_table::and_with_condition</a> (<a class="el" href="classItem.html">Item</a> *tmp_cond, uint line)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaeb2dfefe4d4f6a26323a70b37617b0eb">st_join_table::unified_condition</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gaa62d47da29f3853e87b1069ee5c1ff21">JOIN::join_free</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga52d407ea5f5966580f25da80dd4e9c35">JOIN::cleanup</a> (bool full)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga140c4ff912190f1c0f6279897103a720">JOIN::alloc_func_list</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#gae713fbd3faf5b5aefad41408fd11685a">JOIN::make_sum_func_list</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;all_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;send_fields, bool before_group_by, bool recompute=FALSE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga076b7e6736c0bf0a9e9bf7542e4746c8">JOIN::rollup_process_const_fields</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga7e92b14b52e210ce225ad4c0312f9bca">JOIN::rollup_make_fields</a> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;all_fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="classItem__sum.html">Item_sum</a> ***func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga91edca802204d71161d32b208ae3d969">JOIN::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga573c4df23fc730283f00f922bdf80cc3">JOIN::change_result</a> (select_result *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Query__Optimizer.html#ga5cb6b434229049cde9f65d25f59709f2">JOIN::add_sorting_to_table</a> (<a class="el" href="structst__join__table.html">JOIN_TAB</a> *tab, ORDER_with_src *order)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classFilesort.html">Filesort</a> object to the given table to sort if with filesort.  <a href="#ga5cb6b434229049cde9f65d25f59709f2"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga174d79a5aef2a8abd1caec143b42837e"></a><!-- doxytag: member="sql_select.cc::actual_key_flags" ref="ga174d79a5aef2a8abd1caec143b42837e" args="(KEY *key_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Query__Optimizer.html#ga174d79a5aef2a8abd1caec143b42837e">actual_key_flags</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__key.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns key flags depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key_info</td><td>pointer to KEY structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>key flags. </dd></dl>

</div>
</div>
<a class="anchor" id="gadbf1b1ecda6374b7b3a32b5454d09876"></a><!-- doxytag: member="sql_select.cc::actual_key_parts" ref="gadbf1b1ecda6374b7b3a32b5454d09876" args="(KEY *key_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Query__Optimizer.html#gadbf1b1ecda6374b7b3a32b5454d09876">actual_key_parts</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__key.html">KEY</a> *&#160;</td>
          <td class="paramname"><em>key_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns number of key parts depending on OPTIMIZER_SWITCH_USE_INDEX_EXTENSIONS flag.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key_info</td><td>pointer to KEY structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of key parts. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5cb6b434229049cde9f65d25f59709f2"></a><!-- doxytag: member="JOIN::add_sorting_to_table" ref="ga5cb6b434229049cde9f65d25f59709f2" args="(JOIN_TAB *tab, ORDER_with_src *order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga5cb6b434229049cde9f65d25f59709f2">JOIN::add_sorting_to_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN_1_1ORDER__with__src.html">ORDER_with_src</a> *&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add <a class="el" href="classFilesort.html">Filesort</a> object to the given table to sort if with filesort. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>the JOIN_TAB object to attach created <a class="el" href="classFilesort.html">Filesort</a> object to </td></tr>
    <tr><td class="paramname">order</td><td><a class="el" href="classList.html">List</a> of expressions to sort the table by</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function moves tab-&gt;select, if any, to filesort-&gt;select</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false on success, true on OOM </dd></dl>

</div>
</div>
<a class="anchor" id="ga5932344e1185abf63788970856f45766"></a><!-- doxytag: member="JOIN_CACHE::alloc_buffer" ref="ga5932344e1185abf63788970856f45766" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga5932344e1185abf63788970856f45766">JOIN_CACHE::alloc_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate memory for a join buffer.</p>
<p>The function allocates a lump of memory for the join buffer. The size of the allocated memory is 'buff_size' bytes.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if success, otherwise true. </dd></dl>

</div>
</div>
<a class="anchor" id="ga140c4ff912190f1c0f6279897103a720"></a><!-- doxytag: member="JOIN::alloc_func_list" ref="ga140c4ff912190f1c0f6279897103a720" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga140c4ff912190f1c0f6279897103a720">JOIN::alloc_func_list</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make an array of pointers to sum_functions to speed up sum_func calculation.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad3c0a5624f789fb0bf0c5fc5ec057de9"></a><!-- doxytag: member="sql_select.cc::and_conditions" ref="gad3c0a5624f789fb0bf0c5fc5ec057de9" args="(Item **e1, Item *e2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gad3c0a5624f789fb0bf0c5fc5ec057de9">and_conditions</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extend e1 by AND'ing e2 to the condition e1 points to. The resulting condition is fixed. Requirement: the input Items must already have been fixed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">e1</td><td>Pointer to condition that will be extended with e2 </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">e2</td><td>Condition that will extend e1</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error, in which case e1 remains unchanged </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59504ff5091d87102a2f2a5d4649ec46"></a><!-- doxytag: member="st_join_table::and_with_condition" ref="ga59504ff5091d87102a2f2a5d4649ec46" args="(Item *tmp_cond, uint line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga59504ff5091d87102a2f2a5d4649ec46">JOIN_TAB::and_with_condition</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>add_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extend join_tab-&gt;cond by AND'ing add_cond to it</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">add_cond</td><td>The condition to AND with the existing cond for this JOIN_TAB </td></tr>
    <tr><td class="paramname">line</td><td>Code line this method was called from</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga504ef4abccd4c3f837f2cef119eb5666"></a><!-- doxytag: member="st_join_table::and_with_jt_and_sel_condition" ref="ga504ef4abccd4c3f837f2cef119eb5666" args="(Item *tmp_cond, uint line)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga504ef4abccd4c3f837f2cef119eb5666">JOIN_TAB::and_with_jt_and_sel_condition</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>add_cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extend join_tab-&gt;m_condition and join_tab-&gt;select-&gt;cond by AND'ing add_cond to them</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">add_cond</td><td>The condition to AND with the existing conditions </td></tr>
    <tr><td class="paramname">line</td><td>Code line this method was called from</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if there was a memory allocation error </td></tr>
    <tr><td class="paramname">false</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8661280e3da40b2c581ec758c50e1979"></a><!-- doxytag: member="JOIN_CACHE_BKA::aux_buffer_incr" ref="ga8661280e3da40b2c581ec758c50e1979" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Query__Optimizer.html#ga8661280e3da40b2c581ec758c50e1979">JOIN_CACHE_BKA::aux_buffer_incr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the increment of the MRR buffer for a record write </p>

<p>Reimplemented from <a class="el" href="classJOIN__CACHE.html">JOIN_CACHE</a>.</p>

</div>
</div>
<a class="anchor" id="gaae3c5d1c786e1a3520b7def5d1bbf49e"></a><!-- doxytag: member="JOIN_CACHE_BKA::aux_buffer_min_size" ref="gaae3c5d1c786e1a3520b7def5d1bbf49e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Query__Optimizer.html#gaae3c5d1c786e1a3520b7def5d1bbf49e">JOIN_CACHE_BKA::aux_buffer_min_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the minimume size for the MRR buffer</p>
<p>Calculate the minimume size for the MRR buffer.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The minumum size that must be allocated for the MRR buffer </dd></dl>

<p>Reimplemented from <a class="el" href="classJOIN__CACHE.html#aca3470f400dda843dbc540839a0fad78">JOIN_CACHE</a>.</p>

</div>
</div>
<a class="anchor" id="gaa6b7012eda6c33a9a9e734948853a334"></a><!-- doxytag: member="sql_optimizer.cc::build_equal_items" ref="gaa6b7012eda6c33a9a9e734948853a334" args="(THD *thd, Item *cond, COND_EQUAL *inherited, bool do_inherit, List&lt; TABLE_LIST &gt; *join_list, COND_EQUAL **cond_equal_ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* <a class="el" href="group__Query__Optimizer.html#gaa6b7012eda6c33a9a9e734948853a334">build_equal_items</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>inherited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_inherit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> **&#160;</td>
          <td class="paramname"><em>cond_equal_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Build multiple equalities for a condition and all on expressions that inherit these multiple equalities.</p>
<p>The function first applies the build_equal_items_for_cond function to build all multiple equalities for condition cond utilizing equalities referred through the parameter inherited. The extended set of equalities is returned in the structure referred by the cond_equal_ref parameter. After this the function calls itself recursively for all on expressions whose direct references can be found in join_list and who inherit directly the multiple equalities just having built.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The on expression used in an outer join operation inherits all equalities from the on expression of the embedding join, if there is any, or otherwise - from the where condition. This fact is not obvious, but presumably can be proved. Consider the following query: <div class="fragment"><pre class="fragment">      SELECT * FROM (t1,t2) LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t2.a=t4.a
        WHERE t1.a=t2.a;
</pre></div> If the on expression in the query inherits =(t1.a,t2.a), then we can build the multiple equality =(t1.a,t2.a,t3.a,t4.a) that infers the equality t3.a=t4.a. Although the on expression t1.a=t3.a AND t2.a=t4.a AND t3.a=t4.a is not equivalent to the one in the query the latter can be replaced by the former: the new query will return the same result set as the original one.</dd></dl>
<p>Interesting that multiple equality =(t1.a,t2.a,t3.a,t4.a) allows us to use t1.a=t3.a AND t3.a=t4.a under the on condition: </p>
<div class="fragment"><pre class="fragment">      SELECT * FROM (t1,t2) LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t3.a=t4.a
        WHERE t1.a=t2.a
</pre></div><p> This query equivalent to: </p>
<div class="fragment"><pre class="fragment">      SELECT * FROM (t1 LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) ON t1.a=t3.a AND t3.a=t4.a),t2
        WHERE t1.a=t2.a
</pre></div><p> Similarly the original query can be rewritten to the query: </p>
<div class="fragment"><pre class="fragment">      SELECT * FROM (t1,t2) LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4) ON t2.a=t4.a AND t3.a=t4.a
        WHERE t1.a=t2.a
</pre></div><p> that is equivalent to: </p>
<div class="fragment"><pre class="fragment">      SELECT * FROM (t2 LEFT <a class="code" href="classJOIN.html">JOIN</a> (t3,t4)ON t2.a=t4.a AND t3.a=t4.a), t1
        WHERE t1.a=t2.a
</pre></div><p> Thus, applying equalities from the where condition we basically can get more freedom in performing join operations. Althogh we don't use this property now, it probably makes sense to use it in the future. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>condition to build the multiple equalities for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inherited</td><td>path to all inherited multiple equality items </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">do_inherit</td><td>whether or not to inherit equalities from other parts of the condition </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list of join tables to which the condition refers to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_equal_ref</td><td>pointer to the structure to place built equalities in</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the transformed condition containing multiple equalities </dd></dl>

</div>
</div>
<a class="anchor" id="ga4408ac7e9a04a594110d2009cfcd54c9"></a><!-- doxytag: member="JOIN::cache_const_exprs" ref="ga4408ac7e9a04a594110d2009cfcd54c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga4408ac7e9a04a594110d2009cfcd54c9">JOIN::cache_const_exprs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cache constant expressions in WHERE, HAVING, ON conditions.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if success, True if error</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is run after conditions have been pushed down to individual tables, so transformation is applied to JOIN_TAB::condition and not to the WHERE condition. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa978828bfe7be091fb76e1c5da80d644"></a><!-- doxytag: member="sql_select.cc::calc_group_buffer" ref="gaa978828bfe7be091fb76e1c5da80d644" args="(JOIN *join, ORDER *group)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gaa978828bfe7be091fb76e1c5da80d644">calc_group_buffer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>calc how big buffer we need for comparing group entries. </p>

</div>
</div>
<a class="anchor" id="gab0ca922593fe6b15db19791f8133f407"></a><!-- doxytag: member="sql_select.cc::calc_used_field_length" ref="gab0ca922593fe6b15db19791f8133f407" args="(THD *thd, JOIN_TAB *join_tab)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gab0ca922593fe6b15db19791f8133f407">calc_used_field_length</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>join_tab</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find how much space the prevous read not const tables takes in cache. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000102">Todo:</a></b></dt><dd>why don't we count the rowids that we might need to store when using DuplicateElimination? </dd></dl>

</div>
</div>
<a class="anchor" id="ga573c4df23fc730283f00f922bdf80cc3"></a><!-- doxytag: member="JOIN::change_result" ref="ga573c4df23fc730283f00f922bdf80cc3" args="(select_result *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga573c4df23fc730283f00f922bdf80cc3">JOIN::change_result</a> </td>
          <td>(</td>
          <td class="paramtype">select_result *&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>change select_result object of <a class="el" href="classJOIN.html">JOIN</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>new select_result object</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK </td></tr>
    <tr><td class="paramname">TRUE</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafd031be055cee296d6629313a333b56f"></a><!-- doxytag: member="JOIN_CACHE_BKA_UNIQUE::check_match" ref="gafd031be055cee296d6629313a333b56f" args="(uchar *rec_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gafd031be055cee296d6629313a333b56f">JOIN_CACHE_BKA_UNIQUE::check_match</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>rec_ptr</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check matching to a partial join record from the join buffer, an implementation specialized for <a class="el" href="classJOIN__CACHE__BKA__UNIQUE.html">JOIN_CACHE_BKA_UNIQUE</a>. Only <a class="el" href="classJOIN__CACHE__BKA__UNIQUE.html">JOIN_CACHE_BKA_UNIQUE</a> needs that, because it's the only cache using distinct keys. <a class="el" href="classJOIN__CACHE__BKA.html">JOIN_CACHE_BKA</a>, on the other hand, does one key lookup per cached record, so can take a per-record individualized decision for the pushed index condition as soon as it has the index tuple. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Query__Optimizer.html#ga6afa1e2231c8090ecae73554fca37c41">JOIN_CACHE_BKA_UNIQUE::skip_index_tuple</a> </dd>
<dd>
JOIN_CACHE::check_match </dd></dl>

<p>Reimplemented from <a class="el" href="classJOIN__CACHE.html">JOIN_CACHE</a>.</p>

</div>
</div>
<a class="anchor" id="ga52d407ea5f5966580f25da80dd4e9c35"></a><!-- doxytag: member="JOIN::cleanup" ref="ga52d407ea5f5966580f25da80dd4e9c35" args="(bool full)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga52d407ea5f5966580f25da80dd4e9c35">JOIN::cleanup</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>full</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cleanup this <a class="el" href="classJOIN.html">JOIN</a>, possibly for reuse</p>
<p>Free resources of given join.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fill</td><td>true if we should free all resources, call with full==1 should be last, before it this function can be called with full==0</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>With subquery this function definitely will be called several times, but even for simple query it can be called several times. </dd></dl>

</div>
</div>
<a class="anchor" id="gae913870950feb0d927de9b53963f0a6a"></a><!-- doxytag: member="st_join_table::cleanup" ref="gae913870950feb0d927de9b53963f0a6a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gae913870950feb0d927de9b53963f0a6a">JOIN_TAB::cleanup</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clean up associated table after query execution, including resources</p>
<p>Cleanup table of join operation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Notice that this is not a complete cleanup. In some situations, the object may be reused after a cleanup operation, hence we cannot set the table pointer to NULL in this function. </dd></dl>

</div>
</div>
<a class="anchor" id="ga91edca802204d71161d32b208ae3d969"></a><!-- doxytag: member="JOIN::clear" ref="ga91edca802204d71161d32b208ae3d969" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga91edca802204d71161d32b208ae3d969">JOIN::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>clear results if there are not rows found for group (end_send_group/end_write_group) </p>

</div>
</div>
<a class="anchor" id="ga8478e8df214dcc332c84d24ebe3f0785"></a><!-- doxytag: member="sql_select.cc::const_expression_in_where" ref="ga8478e8df214dcc332c84d24ebe3f0785" args="(Item *cond, Item *comp_item, Field *comp_field, Item **const_item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga8478e8df214dcc332c84d24ebe3f0785">const_expression_in_where</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>comp_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>comp_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>const_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test if a field or an item is equal to a constant value in WHERE</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond</td><td>WHERE clause expression </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_item</td><td><a class="el" href="classItem.html">Item</a> to find in WHERE expression (if comp_field != NULL) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comp_field</td><td><a class="el" href="classField.html">Field</a> to find in WHERE expression (if comp_item != NULL) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">const_item</td><td>intermediate arg, set to <a class="el" href="classItem.html">Item</a> pointer to NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the field is a constant value in WHERE</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>comp_item and comp_field parameters are mutually exclusive. </dd></dl>

</div>
</div>
<a class="anchor" id="ga61bf73cb2d42b343f9e6306b5d5e56ec"></a><!-- doxytag: member="sql_select.cc::count_field_types" ref="ga61bf73cb2d42b343f9e6306b5d5e56ec" args="(SELECT_LEX *select_lex, TMP_TABLE_PARAM *param, List&lt; Item &gt; &amp;fields, bool reset_with_sum_func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga61bf73cb2d42b343f9e6306b5d5e56ec">count_field_types</a> </td>
          <td>(</td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMP_TABLE_PARAM *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reset_with_sum_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update join with count of the different type of fields. </p>

</div>
</div>
<a class="anchor" id="ga7a5efe6ddb0de3a2b43f36c3330354e7"></a><!-- doxytag: member="sql_optimizer.cc::create_keyuse_for_table" ref="ga7a5efe6ddb0de3a2b43f36c3330354e7" args="(THD *thd, TABLE *table, uint keyparts, Item_field **fields, List&lt; Item &gt; outer_exprs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMem__root__array.html">Key_use_array</a>* <a class="el" href="group__Query__Optimizer.html#ga7a5efe6ddb0de3a2b43f36c3330354e7">create_keyuse_for_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyparts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> **&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt;&#160;</td>
          <td class="paramname"><em>outer_exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a keyuse array for a table with a primary key. To be used when creating a materialized temporary table.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer, for memory allocation </td></tr>
    <tr><td class="paramname">table</td><td>Table object representing table </td></tr>
    <tr><td class="paramname">keyparts</td><td>Number of key parts in the primary key </td></tr>
    <tr><td class="paramname">outer_exprs</td><td><a class="el" href="classList.html">List</a> of items used for key lookup</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to created keyuse array, or NULL if error </dd></dl>

</div>
</div>
<a class="anchor" id="ga3b518fb7975676afc7395b412e803368"></a><!-- doxytag: member="sql_select.cc::create_ref_for_key" ref="ga3b518fb7975676afc7395b412e803368" args="(JOIN *join, JOIN_TAB *j, Key_use *org_keyuse, table_map used_tables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga3b518fb7975676afc7395b412e803368">create_ref_for_key</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKey__use.html">Key_use</a> *&#160;</td>
          <td class="paramname"><em>org_keyuse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>used_tables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup a ref access for looking up rows via an index (a key).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>The join object being handled </td></tr>
    <tr><td class="paramname">j</td><td>The join_tab which will have the ref access populated </td></tr>
    <tr><td class="paramname">first_keyuse</td><td>First key part of (possibly multi-part) key </td></tr>
    <tr><td class="paramname">used_tables</td><td><a class="el" href="classBitmap.html">Bitmap</a> of available tables</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if success, True if error</dd></dl>
<p>This function will set up a ref access using the best key found during access path analysis and cost analysis.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>We cannot setup fields used for ref access before we have sorted the items within multiple equalities according to the final order of the tables involved in the join operation. Currently, this occurs in </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Query__Optimizer.html#ga253393c0747cf378b9cefa109662bd17">substitute_for_best_equal_field()</a>. The exception is ref access for const tables, which are fixed before the greedy search planner is invoked. </dd></dl>

</div>
</div>
<a class="anchor" id="gab466b49a22220854ef8f11a2c4a2ae8a"></a><!-- doxytag: member="JOIN::decide_subquery_strategy" ref="gab466b49a22220854ef8f11a2c4a2ae8a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gab466b49a22220854ef8f11a2c4a2ae8a">JOIN::decide_subquery_strategy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Decides between EXISTS and materialization; performs last steps to set up the chosen strategy. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>'false' if no error</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If UNION this is called on each contained <a class="el" href="classJOIN.html">JOIN</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf2d76654da99be4012095c016ea5d4d2"></a><!-- doxytag: member="JOIN::destroy" ref="gaf2d76654da99be4012095c016ea5d4d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gaf2d76654da99be4012095c016ea5d4d2">JOIN::destroy</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clean up and destroy join object.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if previous execution was successful, and true otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga54392f4f40ec2c57b8263f22fa3d4296"></a><!-- doxytag: member="JOIN::drop_unused_derived_keys" ref="ga54392f4f40ec2c57b8263f22fa3d4296" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga54392f4f40ec2c57b8263f22fa3d4296">JOIN::drop_unused_derived_keys</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Drop unused keys for each materialized derived table/view. </p>
<p>For each materialized derived table/view, call TABLE::use_index to save one index chosen by the optimizer and ignore others. If no key is chosen, then all keys will be ignored. </p>

</div>
</div>
<a class="anchor" id="gaf1351457ee30a4e67786117e50413541"></a><!-- doxytag: member="sql_select.cc::error_if_full_join" ref="gaf1351457ee30a4e67786117e50413541" args="(JOIN *join)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gaf1351457ee30a4e67786117e50413541">error_if_full_join</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Give error if we some tables are done with a full join.</p>
<p>This is used by multi_table_update and multi_table_delete when running in safe mode.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join condition</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>Error (full join used) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6daf5ee65a55d8b5f6ef6c4c35f3a90a"></a><!-- doxytag: member="JOIN::explain" ref="ga6daf5ee65a55d8b5f6ef6c4c35f3a90a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga6daf5ee65a55d8b5f6ef6c4c35f3a90a">JOIN::explain</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classExplain.html">Explain</a> join. </p>

</div>
</div>
<a class="anchor" id="gab9652206431848c00d81533336a424c6"></a><!-- doxytag: member="sql_optimizer.cc::find_item_equal" ref="gab9652206431848c00d81533336a424c6" args="(COND_EQUAL *cond_equal, Field *field, bool *inherited_fl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__equal.html">Item_equal</a>* <a class="el" href="group__Query__Optimizer.html#gab9652206431848c00d81533336a424c6">find_item_equal</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> *&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>inherited_fl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find the multiple equality predicate containing a field.</p>
<p>The function retrieves the multiple equalities accessed through the con_equal structure from current level and up looking for an equality containing field. It stops retrieval as soon as the equality is found and set up inherited_fl to TRUE if it's found on upper levels.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cond_equal</td><td>multiple equalities to search in </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">field</td><td>field to look for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inherited_fl</td><td>set up to TRUE if multiple equality is found on upper levels (not on current level of cond_equal)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><a class="el" href="classItem__equal.html">Item_equal</a> for the found multiple equality predicate if a success;</li>
<li>NULL otherwise. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gafd0c3fdb07be77d705feaf3f8f51164f"></a><!-- doxytag: member="sql_select.cc::find_shortest_key" ref="gafd0c3fdb07be77d705feaf3f8f51164f" args="(TABLE *table, const key_map *usable_keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Query__Optimizer.html#gafd0c3fdb07be77d705feaf3f8f51164f">find_shortest_key</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *&#160;</td>
          <td class="paramname"><em>usable_keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find shortest key suitable for full table scan.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Table to scan </td></tr>
    <tr><td class="paramname">usable_keys</td><td>Allowed keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>As far as 1) clustered primary key entry data set is a set of all record fields (key fields and not key fields) and 2) secondary index entry data is a union of its key fields and primary key fields (at least InnoDB and its derivatives don't duplicate primary key fields there, even if the primary and the secondary keys have a common subset of key fields), then secondary index entry data is always a subset of primary key entry. Unfortunately, key_info[nr].key_length doesn't show the length of key/pointer pair but a sum of key field lengths only, thus we can't estimate index IO volume comparing only this key_length value of secondary keys and clustered PK. So, try secondary keys first, and choose PK only if there are no usable secondary covering keys or found best secondary key include all table fields (i.e. same as PK):</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>MAX_KEY no suitable key found key index otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="ga59080a3acd829efcf18fc56d51df215c"></a><!-- doxytag: member="sql_select.cc::free_underlaid_joins" ref="ga59080a3acd829efcf18fc56d51df215c" args="(THD *thd, SELECT_LEX *select)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga59080a3acd829efcf18fc56d51df215c">free_underlaid_joins</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free joins of subselect of this select.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>THD pointer </td></tr>
    <tr><td class="paramname">select</td><td>pointer to st_select_lex which subselects joins we will free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga92bf64a03ec666f565627fbb48ba4677"></a><!-- doxytag: member="JOIN::generate_derived_keys" ref="ga92bf64a03ec666f565627fbb48ba4677" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga92bf64a03ec666f565627fbb48ba4677">JOIN::generate_derived_keys</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add keys to derived tables'/views' result tables in a list. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">select_lex</td><td>generate derived keys for select_lex's derived tables</td></tr>
  </table>
  </dd>
</dl>
<p>This function generates keys for all derived tables/views of the select_lex to which this join corresponds to with help of the <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>:generate_keys function.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE all keys were successfully added. </dd>
<dd>
TRUE OOM error </dd></dl>

</div>
</div>
<a class="anchor" id="gae9c1cf0874f4bda777557d012148e059"></a><!-- doxytag: member="JOIN::get_best_combination" ref="gae9c1cf0874f4bda777557d012148e059" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gae9c1cf0874f4bda777557d012148e059">JOIN::get_best_combination</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set up JOIN_TAB structs according to the picked join order in best_positions. This allocates execution structures so may be called only after we have the very final plan. It must be called after Optimize_table_order::fix_semijoin_strategies().</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if success, True if error</dd></dl>
<ul>
<li>create join-&gt;join_tab array and copy from existing JOIN_TABs in join order</li>
<li>create helper structs for materialized semi-join handling</li>
<li>finalize semi-join strategy choices</li>
<li>Number of intermediate tables "tmp_tables" is calculated.</li>
<li>"tables" and "primary_tables" are recalculated.</li>
</ul>
<p>Notice that intermediate tables will not have a POSITION reference; and they will not have a <a class="el" href="structTABLE.html">TABLE</a> reference before the final stages of code generation. </p>

</div>
</div>
<a class="anchor" id="ga67d1175177356bf1c9b05e9104d28c5b"></a><!-- doxytag: member="sql_optimizer.cc::get_best_field" ref="ga67d1175177356bf1c9b05e9104d28c5b" args="(Item_field *item_field, COND_EQUAL *cond_equal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__field.html">Item_field</a>* <a class="el" href="group__Query__Optimizer.html#ga67d1175177356bf1c9b05e9104d28c5b">get_best_field</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the best field substitution for a given field.</p>
<p>If the field is member of a multiple equality, look up that equality and return the most appropriate field. Usually this is the equivalenced field belonging to the outer-most table in the join order, but </p>
<dl class="see"><dt><b>See also:</b></dt><dd>Item_field::get_subst_item() for details. Otherwise, return the same field.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">item_field</td><td>The field that we are seeking a substitution for. </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities to search in</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The substituted field. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5e83c73f6271bc56ebedaa2e8d3ec5ad"></a><!-- doxytag: member="sql_select.cc::get_index_for_order" ref="ga5e83c73f6271bc56ebedaa2e8d3ec5ad" args="(ORDER *order, TABLE *table, SQL_SELECT *select, ha_rows limit, bool *need_sort, bool *reverse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Query__Optimizer.html#ga5e83c73f6271bc56ebedaa2e8d3ec5ad">get_index_for_order</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSQL__SELECT.html">SQL_SELECT</a> *&#160;</td>
          <td class="paramname"><em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a key to apply single table UPDATE/DELETE by a given ORDER</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table to find a key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">select</td><td>Pointer to access/update select-&gt;quick (if any) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">limit</td><td>LIMIT clause parameter </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_sort</td><td>TRUE if filesort needed </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reverse</td><td>TRUE if the key is reversed again given ORDER (undefined if key == MAX_KEY)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>MAX_KEY if no key found (need_sort == TRUE)</li>
<li>MAX_KEY if quick select result order is OK (need_sort == FALSE)</li>
<li>key number (either index scan or quick select) (need_sort == FALSE)</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Side effects:<ul>
<li>may deallocate or deallocate and replace select-&gt;quick;</li>
<li>may set table-&gt;quick_condition_rows and table-&gt;quick_rows[...] to table-&gt;file-&gt;stats.records. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gad9015b581d8214425649d273f3e12090"></a><!-- doxytag: member="sql_select.cc::handle_select" ref="gad9015b581d8214425649d273f3e12090" args="(THD *thd, select_result *result, ulong setup_tables_done_option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gad9015b581d8214425649d273f3e12090">handle_select</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">select_result *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>setup_tables_done_option</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This handles SELECT with and without UNION </p>

</div>
</div>
<a class="anchor" id="gab3dbb0f8b69dc30985e0d9a0ff94121f"></a><!-- doxytag: member="JOIN_CACHE_BNL::init" ref="gab3dbb0f8b69dc30985e0d9a0ff94121f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Optimizer.html#gab3dbb0f8b69dc30985e0d9a0ff94121f">JOIN_CACHE_BNL::init</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize operation's internal state. Called once per query execution. </p>

<p>Implements <a class="el" href="classJOIN__CACHE.html#a1dcdce348bba725c675b327eb90aa924">JOIN_CACHE</a>.</p>

</div>
</div>
<a class="anchor" id="ga327376f63198bf31a770fb89242d49aa"></a><!-- doxytag: member="JOIN_CACHE_BKA::init" ref="ga327376f63198bf31a770fb89242d49aa" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Optimizer.html#ga327376f63198bf31a770fb89242d49aa">JOIN_CACHE_BKA::init</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize operation's internal state. Called once per query execution. </p>

<p>Implements <a class="el" href="classJOIN__CACHE.html#a1dcdce348bba725c675b327eb90aa924">JOIN_CACHE</a>.</p>

<p>Reimplemented in <a class="el" href="group__Query__Optimizer.html#gaa7ca6a85294c32bac8c69bea0c4e5fe1">JOIN_CACHE_BKA_UNIQUE</a>.</p>

</div>
</div>
<a class="anchor" id="gaa7ca6a85294c32bac8c69bea0c4e5fe1"></a><!-- doxytag: member="JOIN_CACHE_BKA_UNIQUE::init" ref="gaa7ca6a85294c32bac8c69bea0c4e5fe1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Optimizer.html#gaa7ca6a85294c32bac8c69bea0c4e5fe1">JOIN_CACHE_BKA_UNIQUE::init</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize operation's internal state. Called once per query execution. </p>

<p>Reimplemented from <a class="el" href="group__Query__Optimizer.html#ga327376f63198bf31a770fb89242d49aa">JOIN_CACHE_BKA</a>.</p>

</div>
</div>
<a class="anchor" id="gaa992e841315769954816105b951d3e17"></a><!-- doxytag: member="sql_optimizer.cc::is_indexed_agg_distinct" ref="gaa992e841315769954816105b951d3e17" args="(JOIN *join, List&lt; Item_field &gt; *out_args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gaa992e841315769954816105b951d3e17">is_indexed_agg_distinct</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__field.html">Item_field</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check for the presence of AGGFN(DISTINCT a) queries that may be subject to loose index scan.</p>
<p>Check if the query is a subject to AGGFN(DISTINCT) using loose index scan (<a class="el" href="classQUICK__GROUP__MIN__MAX__SELECT.html">QUICK_GROUP_MIN_MAX_SELECT</a>). Optionally (if out_args is supplied) will push the arguments of AGGFN(DISTINCT) to the list</p>
<p>Check for every COUNT(DISTINCT), AVG(DISTINCT) or SUM(DISTINCT). These can be resolved by Loose Index Scan as long as all the aggregate distinct functions refer to the same fields. Thus:</p>
<p>SELECT AGGFN(DISTINCT a, b), AGGFN(DISTINCT b, a)... =&gt; can use LIS SELECT AGGFN(DISTINCT a), AGGFN(DISTINCT a) ... =&gt; can use LIS SELECT AGGFN(DISTINCT a, b), AGGFN(DISTINCT a) ... =&gt; cannot use LIS SELECT AGGFN(DISTINCT a), AGGFN(DISTINCT b) ... =&gt; cannot use LIS etc.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>the join to check </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_args</td><td>Collect the arguments of the aggregate functions to a list. We don't worry about duplicates as these will be sorted out later in get_best_group_min_max.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>does the query qualify for indexed AGGFN(DISTINCT) </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>it does </td></tr>
    <tr><td class="paramname">false</td><td>AGGFN(DISTINCT) must apply distinct in it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c7525857d6d4c3c486dd5985d81675f"></a><!-- doxytag: member="sql_select.cc::is_ref_or_null_optimized" ref="ga5c7525857d6d4c3c486dd5985d81675f" args="(const JOIN_TAB *tab, uint ref_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga5c7525857d6d4c3c486dd5985d81675f">is_ref_or_null_optimized</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ref_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test if REF_OR_NULL optimization will be used if the specified ref_key is used for REF-access to 'tab'</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>JT_REF_OR_NULL will be used </td></tr>
    <tr><td class="paramname">false</td><td>no JT_REF_OR_NULL access </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4a8d854a364ab749539a9363619acf99"></a><!-- doxytag: member="sql_select.cc::is_subkey" ref="ga4a8d854a364ab749539a9363619acf99" args="(KEY_PART_INFO *key_part, KEY_PART_INFO *ref_key_part, KEY_PART_INFO *ref_key_part_end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga4a8d854a364ab749539a9363619acf99">is_subkey</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>ref_key_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td>
          <td class="paramname"><em>ref_key_part_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test if a second key is the subkey of the first one.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">key_part</td><td>First key parts </td></tr>
    <tr><td class="paramname">ref_key_part</td><td>Second key parts </td></tr>
    <tr><td class="paramname">ref_key_part_end</td><td>Last+1 part of the second key</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Second key MUST be shorter than the first one.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>is a subkey </td></tr>
    <tr><td class="paramname">0</td><td>no sub key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa62d47da29f3853e87b1069ee5c1ff21"></a><!-- doxytag: member="JOIN::join_free" ref="gaa62d47da29f3853e87b1069ee5c1ff21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gaa62d47da29f3853e87b1069ee5c1ff21">JOIN::join_free</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release memory and, if possible, the open tables held by this execution plan (and nested plans). It's used to release some tables before the end of execution in order to increase concurrency and reduce memory consumption.</p>
<p>Partially cleanup <a class="el" href="classJOIN.html">JOIN</a> after it has executed: close index or rnd read (table cursors), free quick selects.</p>
<p>This function is called in the end of execution of a <a class="el" href="classJOIN.html">JOIN</a>, before the used tables are unlocked and closed.</p>
<p>For a join that is resolved using a temporary table, the first sweep is performed against actual tables and an intermediate result is inserted into the temprorary table. The last sweep is performed against the temporary table. Therefore, the base tables and associated buffers used to fill the temporary table are no longer needed, and this function is called to free them.</p>
<p>For a join that is performed without a temporary table, this function is called after all rows are sent, but before EOF packet is sent.</p>
<p>For a simple SELECT with no subqueries this function performs a full cleanup of the <a class="el" href="classJOIN.html">JOIN</a> and calls mysql_unlock_read_tables to free used base tables.</p>
<p>If a <a class="el" href="classJOIN.html">JOIN</a> is executed for a subquery or if it has a subquery, we can't do the full cleanup and need to do a partial cleanup only.</p>
<ul>
<li>If a <a class="el" href="classJOIN.html">JOIN</a> is not the top level join, we must not unlock the tables because the outer select may not have been evaluated yet, and we can't unlock only selected tables of a query.</li>
<li>Additionally, if this <a class="el" href="classJOIN.html">JOIN</a> corresponds to a correlated subquery, we should not free quick selects and join buffers because they will be needed for the next execution of the correlated subquery.</li>
<li>However, if this is a <a class="el" href="classJOIN.html">JOIN</a> for a [sub]select, which is not a correlated subquery itself, but has subqueries, we can free it fully and also free JOINs of all its subqueries. The exception is a subquery in SELECT list, e.g: <br/>
 SELECT a, (select max(b) from t1) group by c <br/>
 This subquery will not be evaluated at first sweep and its value will not be inserted into the temporary table. Instead, it's evaluated when selecting from the temporary table. Therefore, it can't be freed here even though it's not correlated.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000105">Todo:</a></b></dt><dd>Unlock tables even if the join isn't top level select in the tree </dd></dl>

</div>
</div>
<a class="anchor" id="gaedf2fb3248e5d013e6a74b29dd9e7429"></a><!-- doxytag: member="sql_optimizer.cc::make_cond_for_table" ref="gaedf2fb3248e5d013e6a74b29dd9e7429" args="(Item *cond, table_map tables, table_map used_table, bool exclude_expensive_cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* <a class="el" href="group__Query__Optimizer.html#gaedf2fb3248e5d013e6a74b29dd9e7429">make_cond_for_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">table_map&#160;</td>
          <td class="paramname"><em>used_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclude_expensive_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Extract a condition that can be checked after reading given table</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to analyze </td></tr>
    <tr><td class="paramname">tables</td><td>Tables for which "current field values" are available </td></tr>
    <tr><td class="paramname">used_table</td><td>Table(s) that we are extracting the condition for (may also include PSEUDO_TABLE_BITS, and may be zero) </td></tr>
    <tr><td class="paramname">exclude_expensive_cond</td><td>Do not push expensive conditions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">&lt;&gt;NULL</td><td>Generated condition </td></tr>
    <tr><td class="paramname">=</td><td>NULL Already checked, OR error</td></tr>
  </table>
  </dd>
</dl>
<p>Extract the condition that can be checked after reading the table(s) specified in <code>used_table</code>, given that current-field values for tables specified in <code>tables</code> bitmap are available. If <code>used_table</code> is 0, extract conditions for all tables in <code>tables</code>.</p>
<p>This function can be used to extract conditions relevant for a table in a join order. Together with its caller, it will ensure that all conditions are attached to the first table in the join order where all necessary fields are available, and it will also ensure that a given condition is attached to only one table. To accomplish this, first initialize <code>tables</code> to the empty set. Then, loop over all tables in the join order, set <code>used_table</code> to the bit representing the current table, accumulate <code>used_table</code> into the <code>tables</code> set, and call this function. To ensure correct handling of const expressions and outer references, add the const table map and OUTER_REF_TABLE_BIT to <code>used_table</code> for the first table. To ensure that random expressions are evaluated for the final table, add RAND_TABLE_BIT to <code>used_table</code> for the final table.</p>
<p>The function assumes that constant, inexpensive parts of the condition have already been checked. Constant, expensive parts will be attached to the first table in the join order, provided that the above call sequence is followed.</p>
<p>The call order will ensure that conditions covering tables in <code>tables</code> minus those in <code>used_table</code>, have already been checked.</p>
<p>The function takes into account that some parts of the condition are guaranteed to be true by employed 'ref' access methods (the code that does this is located at the end, search down for "EQ_FUNC").</p>
<dl class="note"><dt><b>Note:</b></dt><dd>make_cond_for_info_schema() uses an algorithm similar to <a class="el" href="group__Query__Optimizer.html#gaedf2fb3248e5d013e6a74b29dd9e7429">make_cond_for_table()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga77fc941f20e42c089b99ab1641646828"></a><!-- doxytag: member="sql_select.cc::make_join_readinfo" ref="ga77fc941f20e42c089b99ab1641646828" args="(JOIN *join, ulonglong options, uint no_jbuf_after)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga77fc941f20e42c089b99ab1641646828">make_join_readinfo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>no_jbuf_after</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Plan refinement stage: do various setup things for the executor</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">join</td><td>Join being processed </td></tr>
    <tr><td class="paramname">options</td><td>Join's options (checking for SELECT_DESCRIBE, SELECT_NO_JOIN_CACHE) </td></tr>
    <tr><td class="paramname">no_jbuf_after</td><td>Don't use join buffering after table with this number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if successful, true if error (Out of memory)</dd></dl>
<p>Plan refinement stage: do various set ups for the executioner</p>
<ul>
<li>setup join buffering use</li>
<li>push index conditions</li>
<li>increment relevant counters</li>
<li>etc </li>
</ul>

</div>
</div>
<a class="anchor" id="gae713fbd3faf5b5aefad41408fd11685a"></a><!-- doxytag: member="JOIN::make_sum_func_list" ref="gae713fbd3faf5b5aefad41408fd11685a" args="(List&lt; Item &gt; &amp;all_fields, List&lt; Item &gt; &amp;send_fields, bool before_group_by, bool recompute=FALSE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gae713fbd3faf5b5aefad41408fd11685a">JOIN::make_sum_func_list</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>field_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>send_result_set_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>before_group_by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>FALSE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize 'sum_funcs' array with all <a class="el" href="classItem__sum.html">Item_sum</a> objects.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">field_list</td><td>All items </td></tr>
    <tr><td class="paramname">send_result_set_metadata</td><td>Items in select list </td></tr>
    <tr><td class="paramname">before_group_by</td><td>Set to 1 if this is called before GROUP BY handling </td></tr>
    <tr><td class="paramname">recompute</td><td>Set to TRUE if sum_funcs must be recomputed</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>ok </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac201f6bcc85fbd7e04997dda1c83e5b1"></a><!-- doxytag: member="sql_select.cc::mysql_select" ref="gac201f6bcc85fbd7e04997dda1c83e5b1" args="(THD *thd, TABLE_LIST *tables, uint wild_num, List&lt; Item &gt; &amp;fields, Item *conds, SQL_I_List&lt; ORDER &gt; *order, SQL_I_List&lt; ORDER &gt; *group, Item *having, ulonglong select_options, select_result *result, SELECT_LEX_UNIT *unit, SELECT_LEX *select_lex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gac201f6bcc85fbd7e04997dda1c83e5b1">mysql_select</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>wild_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSQL__I__List.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSQL__I__List.html">SQL_I_List</a>&lt; <a class="el" href="structst__order.html">ORDER</a> &gt; *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>having</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>select_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">select_result *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX_UNIT *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SELECT_LEX *&#160;</td>
          <td class="paramname"><em>select_lex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An entry point to single-unit select (a select without UNION).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>list of all tables used in this query. The tables have been pre-opened. </td></tr>
    <tr><td class="paramname">wild_num</td><td>number of wildcards used in the top level select of this query. For example statement SELECT *, t1.*, catalog.t2.* FROM t0, t1, t2; has 3 wildcards. </td></tr>
    <tr><td class="paramname">fields</td><td>list of items in SELECT list of the top-level select e.g. SELECT a, b, c FROM t1 will have <a class="el" href="classItem__field.html">Item_field</a> for a, b and c in this list. </td></tr>
    <tr><td class="paramname">conds</td><td>top level item of an expression representing WHERE clause of the top level select </td></tr>
    <tr><td class="paramname">order</td><td>linked list of ORDER BY agruments </td></tr>
    <tr><td class="paramname">group</td><td>linked list of GROUP BY arguments </td></tr>
    <tr><td class="paramname">having</td><td>top level item of HAVING expression </td></tr>
    <tr><td class="paramname">select_options</td><td>select options (BIG_RESULT, etc) </td></tr>
    <tr><td class="paramname">result</td><td>an instance of result set handling class. This object is responsible for send result set rows to the client or inserting them into a table. </td></tr>
    <tr><td class="paramname">unit</td><td>top-level UNIT of this query UNIT is an artificial object created by the parser for every SELECT clause. e.g. SELECT * FROM t1 WHERE a1 IN (SELECT * FROM t2) has 2 unions. </td></tr>
    <tr><td class="paramname">select_lex</td><td>the only SELECT_LEX of this query</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>success </td></tr>
    <tr><td class="paramname">true</td><td>an error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7f722315c64ce97cff639d705107c660"></a><!-- doxytag: member="JOIN::optimize" ref="ga7f722315c64ce97cff639d705107c660" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Optimizer.html#ga7f722315c64ce97cff639d705107c660">JOIN::optimize</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>global select optimisation.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>error code saved in field 'error'</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>success </td></tr>
    <tr><td class="paramname">1</td><td>error </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000079">Todo:</a></b></dt><dd>Above we passed unique=false. But for this query: (oe1, oe2) IN (SELECT primary_key, non_key_maybe_null_field FROM tbl) we could use "unique=true" for the first index component and let Item_is_not_null_test(non_key_maybe_null_field) handle the second. </dd></dl>
<p>Push joins to handler(s) whenever possible. The handlers will inspect the QEP through the <a class="el" href="namespaceAQP.html">AQP</a> (Abstract Query Plan), and extract from it whatewer it might implement of pushed execution. It is the responsibility if the handler to store any information it need for later execution of pushed queries.</p>
<p>Currently pushed joins are only implemented by NDB. It only make sense to try pushing if &gt; 1 non-const tables.</p>
<p>Set up access functions for the tables as required by the selected access type.</p>

</div>
</div>
<a class="anchor" id="ga5e8bc785b0cfb6f2269f566283e239f7"></a><!-- doxytag: member="sql_optimizer.cc::optimize_cond" ref="ga5e8bc785b0cfb6f2269f566283e239f7" args="(THD *thd, Item *conds, COND_EQUAL **cond_equal, List&lt; TABLE_LIST &gt; *join_list, bool build_equalities, Item::cond_result *cond_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* <a class="el" href="group__Query__Optimizer.html#ga5e8bc785b0cfb6f2269f566283e239f7">optimize_cond</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> **&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>build_equalities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item::cond_result *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimize conditions by</p>
<p>a) applying transitivity to build multiple equality predicates (MEP): if x=y and y=z the MEP x=y=z is built. b) apply constants where possible. If the value of x is known to be 42, x is replaced with a constant of value 42. By transitivity, this also applies to MEPs, so the MEP in a) will become 42=x=y=z. c) remove conditions that are impossible or always true</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">join</td><td>pointer to the structure providing all context info for the query </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">conds</td><td>conditions to optimize </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">join_list</td><td>list of join tables to which the condition refers to </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cond_value</td><td>Not changed if conds was empty COND_TRUE if conds is always true COND_FALSE if conds is impossible COND_OK otherwise</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>optimized conditions </dd></dl>

</div>
</div>
<a class="anchor" id="ga6214b5001b6cf6a328981401c253f6bb"></a><!-- doxytag: member="JOIN::prepare_result" ref="ga6214b5001b6cf6a328981401c253f6bb" args="(List&lt; Item &gt; **columns_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga6214b5001b6cf6a328981401c253f6bb">JOIN::prepare_result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; **&#160;</td>
          <td class="paramname"><em>columns_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepare join result.</p>
<p>Prepare join result prior to join execution or describing. Instantiate derived tables and get schema tables result if necessary.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE An error during derived or schema tables instantiation. FALSE Ok </dd></dl>

</div>
</div>
<a class="anchor" id="ga812222f5f9eb4a9026c8ce89069ef8d7"></a><!-- doxytag: member="JOIN_CACHE::read_all_flag_fields_by_pos" ref="ga812222f5f9eb4a9026c8ce89069ef8d7" args="(uchar *rec_ptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga812222f5f9eb4a9026c8ce89069ef8d7">JOIN_CACHE::read_all_flag_fields_by_pos</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>rec_ptr</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads all flag fields of a positioned record from the join buffer. Including all flag fields (of this record) stored in the previous join buffers.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rec_ptr</td><td>position of the first field of the record in the join buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa19cecc5eccee0ff1285c62769daf39"></a><!-- doxytag: member="JOIN_CACHE::read_some_flag_fields" ref="gafa19cecc5eccee0ff1285c62769daf39" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gafa19cecc5eccee0ff1285c62769daf39">JOIN_CACHE::read_some_flag_fields</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read some flag fields of a record from the join buffer.</p>
<p>Reads all flag fields stored in this join buffer, for the current record (at 'pos'). If the buffer is incremental, flag fields of this record which are stored in previous join buffers are _not_ read so remain unknown: caller must then make sure to call this function on previous buffers too.</p>
<p>The flag fields are read starting from the position 'pos'. The function increments the value of 'pos' by the length of the read data.</p>
<p>Flag fields are copied back to their source. </p>

</div>
</div>
<a class="anchor" id="ga20c8bd509fba4099611e8a7b01c115d8"></a><!-- doxytag: member="JOIN_CACHE::read_some_record_fields" ref="ga20c8bd509fba4099611e8a7b01c115d8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Optimizer.html#ga20c8bd509fba4099611e8a7b01c115d8">JOIN_CACHE::read_some_record_fields</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read some flag and data fields of a record from the join buffer.</p>
<p>Reads all fields (flag and data fields) stored in this join buffer, for the current record (at 'pos'). If the buffer is incremental, fields of this record which are stored in previous join buffers are _not_ read so remain unknown: caller must then make sure to call this function on previous buffers too.</p>
<p>The fields are read starting from the position 'pos' which is supposed to point to the beginning of the first record field. The function increments the value of 'pos' by the length of the read data.</p>
<p>Flag fields are copied back to their source; data fields are copied to the record's buffer.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">(-1)</td><td>if there are no more records in the join buffer </td></tr>
    <tr><td class="paramname">&lt;&gt;(-1)</td><td>length of the data read from the join buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef4f64b9b280796d9abe945b2eda94ac"></a><!-- doxytag: member="JOIN::refine_best_rowcount" ref="gaef4f64b9b280796d9abe945b2eda94ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gaef4f64b9b280796d9abe945b2eda94ac">JOIN::refine_best_rowcount</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Refine the best_rowcount estimation based on what happens after tables have been joined: LIMIT and type of result sink. </p>

</div>
</div>
<a class="anchor" id="gaba67ab6a59be99d1ae4d29ff674feebc"></a><!-- doxytag: member="sql_optimizer.cc::remove_eq_conds" ref="gaba67ab6a59be99d1ae4d29ff674feebc" args="(THD *thd, Item *cond, Item::cond_result *cond_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* <a class="el" href="group__Query__Optimizer.html#gaba67ab6a59be99d1ae4d29ff674feebc">remove_eq_conds</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item::cond_result *&#160;</td>
          <td class="paramname"><em>cond_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove const and eq items. Return new item, or NULL if no condition cond_value is set to according: COND_OK query is possible (field = constant) COND_TRUE always true ( 1 = 1 ) COND_FALSE always false ( 1 = 2 )</p>
<p>SYNPOSIS <a class="el" href="group__Query__Optimizer.html#gaba67ab6a59be99d1ae4d29ff674feebc">remove_eq_conds()</a> thd THD environment cond the condition to handle cond_value the resulting value of the condition</p>
<p>NOTES calls the inner_remove_eq_conds to check all the tree reqursively</p>
<p>RETURN <a class="el" href="classItem.html">Item</a> with the simplified condition </p>

</div>
</div>
<a class="anchor" id="gad4e09d71987062663db1836d651ec4d4"></a><!-- doxytag: member="JOIN::reset" ref="gad4e09d71987062663db1836d651ec4d4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gad4e09d71987062663db1836d651ec4d4">JOIN::reset</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the state of this join object so that it is ready for a new execution. </p>

</div>
</div>
<a class="anchor" id="gad54e309ac7f0fd377d7a422ea54f59f8"></a><!-- doxytag: member="JOIN_CACHE::reset_cache" ref="gad54e309ac7f0fd377d7a422ea54f59f8" args="(bool for_writing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8">JOIN_CACHE::reset_cache</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_writing</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the join buffer for reading/writing: default implementation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">for_writing</td><td>if it's TRUE the function reset the buffer for writing</td></tr>
  </table>
  </dd>
</dl>
<p>This default implementation of the virtual function <a class="el" href="group__Query__Optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8" title="Reset the join buffer for reading/writing: default implementation.">reset_cache()</a> resets the join buffer for reading or writing. If the buffer is reset for reading only the 'pos' value is reset to point to the very beginning of the join buffer. If the buffer is reset for writing additionally:</p>
<ul>
<li>the counter of the records in the buffer is set to 0,</li>
<li>the the value of 'last_rec_pos' gets pointing at the position just before the buffer,</li>
<li>'end_pos' is set to point to the beginning of the join buffer,</li>
<li>the size of the auxiliary buffer is reset to 0,</li>
<li>the flag 'last_rec_blob_data_is_in_rec_buff' is set to 0. </li>
</ul>

<p>Reimplemented in <a class="el" href="group__Query__Optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7">JOIN_CACHE_BKA_UNIQUE</a>.</p>

</div>
</div>
<a class="anchor" id="gafb1afc6322b69d01ea68b677b715ddc7"></a><!-- doxytag: member="JOIN_CACHE_BKA_UNIQUE::reset_cache" ref="gafb1afc6322b69d01ea68b677b715ddc7" args="(bool for_writing)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7">JOIN_CACHE_BKA_UNIQUE::reset_cache</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>for_writing</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset the join buffer for reading/writing: default implementation. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">for_writing</td><td>if it's TRUE the function reset the buffer for writing</td></tr>
  </table>
  </dd>
</dl>
<p>This default implementation of the virtual function <a class="el" href="group__Query__Optimizer.html#gafb1afc6322b69d01ea68b677b715ddc7" title="Reset the join buffer for reading/writing: default implementation.">reset_cache()</a> resets the join buffer for reading or writing. If the buffer is reset for reading only the 'pos' value is reset to point to the very beginning of the join buffer. If the buffer is reset for writing additionally:</p>
<ul>
<li>the counter of the records in the buffer is set to 0,</li>
<li>the the value of 'last_rec_pos' gets pointing at the position just before the buffer,</li>
<li>'end_pos' is set to point to the beginning of the join buffer,</li>
<li>the size of the auxiliary buffer is reset to 0,</li>
<li>the flag 'last_rec_blob_data_is_in_rec_buff' is set to 0. </li>
</ul>

<p>Reimplemented from <a class="el" href="group__Query__Optimizer.html#gad54e309ac7f0fd377d7a422ea54f59f8">JOIN_CACHE</a>.</p>

</div>
</div>
<a class="anchor" id="ga54a15a3b027af8533c100d5c0fa218f5"></a><!-- doxytag: member="sql_optimizer.cc::reset_nj_counters" ref="ga54a15a3b027af8533c100d5c0fa218f5" args="(List&lt; TABLE_LIST &gt; *join_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga54a15a3b027af8533c100d5c0fa218f5">reset_nj_counters</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>join_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set NESTED_JOIN::counter=0 in all nested joins in passed list.</p>
<p>Recursively set NESTED_JOIN::counter=0 for all nested joins contained in the passed join_list.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">join_list</td><td><a class="el" href="classList.html">List</a> of nested joins to process. It may also contain base tables which will be ignored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7e92b14b52e210ce225ad4c0312f9bca"></a><!-- doxytag: member="JOIN::rollup_make_fields" ref="ga7e92b14b52e210ce225ad4c0312f9bca" args="(List&lt; Item &gt; &amp;all_fields, List&lt; Item &gt; &amp;fields, Item_sum ***func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga7e92b14b52e210ce225ad4c0312f9bca">JOIN::rollup_make_fields</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> ***&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill up rollup structures with pointers to fields to use.</p>
<p>Creates copies of item_sum items for each sum level.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">fields_arg</td><td><a class="el" href="classList.html">List</a> of all fields (hidden and real ones) </td></tr>
    <tr><td class="paramname">sel_fields</td><td>Pointer to selected fields </td></tr>
    <tr><td class="paramname">func</td><td>Store here a pointer to all fields</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ok; In this case func is pointing to next not used element. </td></tr>
    <tr><td class="paramname">1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga076b7e6736c0bf0a9e9bf7542e4746c8"></a><!-- doxytag: member="JOIN::rollup_process_const_fields" ref="ga076b7e6736c0bf0a9e9bf7542e4746c8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga076b7e6736c0bf0a9e9bf7542e4746c8">JOIN::rollup_process_const_fields</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrap all constant Items in GROUP BY list.</p>
<p>For ROLLUP queries each constant item referenced in GROUP BY list is wrapped up into an <a class="el" href="classItem__func.html">Item_func</a> object yielding the same value as the constant item. The objects of the wrapper class are never considered as constant items and besides they inherit all properties of the <a class="el" href="classItem__result__field.html">Item_result_field</a> class. This wrapping allows us to ensure writing constant items into temporary tables whenever the result of the ROLLUP operation has to be written into a temporary table, e.g. when ROLLUP is used together with DISTINCT in the SELECT list. Usually when creating temporary tables for a intermidiate result we do not include fields for constant expressions.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if ok </td></tr>
    <tr><td class="paramname">1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga52d3829776ab95dee43086b5aa43b234"></a><!-- doxytag: member="JOIN::set_semijoin_embedding" ref="ga52d3829776ab95dee43086b5aa43b234" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga52d3829776ab95dee43086b5aa43b234">JOIN::set_semijoin_embedding</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set semi-join embedding join nest pointers.</p>
<p>Set pointer to embedding semi-join nest for all semi-joined tables. Note that this must be done for every table inside all semi-join nests, even for tables within outer join nests embedded in semi-join nests. A table can never be part of multiple semi-join nests, hence no ambiguities can ever occur. Note also that the pointer is not set for <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> objects that are outer join nests within semi-join nests. </p>

</div>
</div>
<a class="anchor" id="gadbc980a72c17c8442fab87af085697d4"></a><!-- doxytag: member="sql_select.cc::simple_remove_const" ref="gadbc980a72c17c8442fab87af085697d4" args="(ORDER *order, Item *where)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structst__order.html">ORDER</a>* <a class="el" href="group__Query__Optimizer.html#gadbc980a72c17c8442fab87af085697d4">simple_remove_const</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>where</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Filter out ORDER items those are equal to constants in WHERE</p>
<p>This function is a limited version of remove_const() for use with non-JOIN statements (i.e. single-table UPDATE and DELETE).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramname">cond</td><td>WHERE expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to new filtered ORDER list or NULL if whole list eliminated</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function overwrites input order list. </dd></dl>

</div>
</div>
<a class="anchor" id="gad1d0a40533b54750b9335583b4c19dda"></a><!-- doxytag: member="st_join_table::sjm_query_block_id" ref="gad1d0a40533b54750b9335583b4c19dda" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Query__Optimizer.html#gad1d0a40533b54750b9335583b4c19dda">JOIN_TAB::sjm_query_block_id</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>query block id for an inner table of materialized semi-join, and 0 for all other tables. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6afa1e2231c8090ecae73554fca37c41"></a><!-- doxytag: member="JOIN_CACHE_BKA_UNIQUE::skip_index_tuple" ref="ga6afa1e2231c8090ecae73554fca37c41" args="(range_seq_t rseq, char *range_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga6afa1e2231c8090ecae73554fca37c41">JOIN_CACHE_BKA_UNIQUE::skip_index_tuple</a> </td>
          <td>(</td>
          <td class="paramtype">range_seq_t&#160;</td>
          <td class="paramname"><em>rseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>range_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the record combination matches the index condition</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rseq</td><td>Value returned by bka_range_seq_init() </td></tr>
    <tr><td class="paramname">range_info</td><td>MRR range association data</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>JOIN_CACHE_BKA::skip_index_tuple(). This function is the variant for use with <a class="el" href="classJOIN__CACHE__BKA__UNIQUE.html">JOIN_CACHE_BKA_UNIQUE</a>. The difference from <a class="el" href="classJOIN__CACHE__BKA.html">JOIN_CACHE_BKA</a> case is that there may be multiple previous table record combinations that share the same key, i.e. they map to the same MRR range. And for all of those records, we have just done one single key lookup in the current table, found an index tuple. If in this function we discard this index tuple, all those records will be eliminated from the result. Thus, in this function we can discard the index tuple only if _all_ those cached records and the index tuple don't match the pushed index condition. It's a "group-wide
  decision". Thus we must here loop through all previous table records combinations that match the given MRR range key range_info, searching for a single one matching the index condition. If we find none, we can safely discard the index tuple here, which avoids retrieving the record from the current table. If we instead find one, we cannot discard the index tuple here; later in execution, in join_matching_records(), we can finally take one "case-by-case decision" per cached record, by checking again the index condition (</dd>
<dd>
<a class="el" href="group__Query__Optimizer.html#gafd031be055cee296d6629313a333b56f">JOIN_CACHE_BKA_UNIQUE::check_match</a>).</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Possible optimization: Before we unpack the record from a previous table check if this table is used in the condition. If so then unpack the record otherwise skip the unpacking. This should be done by a special virtual method get_partial_record_by_pos().</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>The record combination satisfies the index condition </td></tr>
    <tr><td class="paramname">true</td><td>Otherwise </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classJOIN__CACHE__BKA.html">JOIN_CACHE_BKA</a>.</p>

</div>
</div>
<a class="anchor" id="ga253393c0747cf378b9cefa109662bd17"></a><!-- doxytag: member="sql_optimizer.cc::substitute_for_best_equal_field" ref="ga253393c0747cf378b9cefa109662bd17" args="(Item *cond, COND_EQUAL *cond_equal, void *table_join_idx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a>* <a class="el" href="group__Query__Optimizer.html#ga253393c0747cf378b9cefa109662bd17">substitute_for_best_equal_field</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCOND__EQUAL.html">COND_EQUAL</a> *&#160;</td>
          <td class="paramname"><em>cond_equal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>table_join_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Substitute every field reference in a condition by the best equal field and eliminate all multiple equality predicates.</p>
<p>The function retrieves the cond condition and for each encountered multiple equality predicate it sorts the field references in it according to the order of tables specified by the table_join_idx parameter. Then it eliminates the multiple equality predicate it replacing it by the conjunction of simple equality predicates equating every field from the multiple equality to the first field in it, or to the constant, if there is any. After this the function retrieves all other conjuncted predicates substitute every field reference by the field reference to the first equal field or equal constant if there are any.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition to process </td></tr>
    <tr><td class="paramname">cond_equal</td><td>multiple equalities to take into consideration </td></tr>
    <tr><td class="paramname">table_join_idx</td><td>index to tables determining field preference</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>At the first glance full sort of fields in multiple equality seems to be an overkill. Yet it's not the case due to possible new fields in multiple equality item of lower levels. We want the order in them to comply with the order of upper levels.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The transformed condition, or NULL in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga96dc524565684a4e258c98f5b7fd1541"></a><!-- doxytag: member="sql_select.cc::test_if_order_by_key" ref="ga96dc524565684a4e258c98f5b7fd1541" args="(ORDER *order, TABLE *table, uint idx, uint *used_key_parts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Query__Optimizer.html#ga96dc524565684a4e258c98f5b7fd1541">test_if_order_by_key</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>used_key_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test if one can use the key to resolve ORDER BY.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Sort order </td></tr>
    <tr><td class="paramname">table</td><td>Table to sort </td></tr>
    <tr><td class="paramname">idx</td><td>Index to check </td></tr>
    <tr><td class="paramname">used_key_parts</td><td>[out] NULL by default, otherwise return value for used key parts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>used_key_parts is set to correct key parts used if return value != 0 (On other cases, used_key_part may be changed) Note that the value may actually be greater than the number of index key parts. This can happen for storage engines that have the primary key parts as a suffix for every secondary key.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">1</td><td>key is ok. </td></tr>
    <tr><td class="paramname">0</td><td><a class="el" href="classKey.html">Key</a> can't be used </td></tr>
    <tr><td class="paramname">-1</td><td>Reverse key can be used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga14a304484212b5489e8e995539493dd0"></a><!-- doxytag: member="sql_select.cc::test_if_skip_sort_order" ref="ga14a304484212b5489e8e995539493dd0" args="(JOIN_TAB *tab, ORDER *order, ha_rows select_limit, const bool no_changes, const key_map *map, const char *clause_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga14a304484212b5489e8e995539493dd0">test_if_skip_sort_order</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__join__table.html">JOIN_TAB</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>select_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>no_changes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>clause_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test if we can skip the ORDER BY by using an index.</p>
<p>SYNOPSIS <a class="el" href="group__Query__Optimizer.html#ga14a304484212b5489e8e995539493dd0">test_if_skip_sort_order()</a> tab order select_limit no_changes map</p>
<p>If we can use an index, the JOIN_TAB / tab-&gt;select struct is changed to use the index.</p>
<p>The index must cover all fields in &lt;order&gt;, or it will not be considered.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tab</td><td>NULL or JOIN_TAB of the accessed table </td></tr>
    <tr><td class="paramname">order</td><td>Linked list of ORDER BY arguments </td></tr>
    <tr><td class="paramname">select_limit</td><td>LIMIT value, or HA_POS_ERROR if no limit </td></tr>
    <tr><td class="paramname">no_changes</td><td>No changes will be made to the query plan. </td></tr>
    <tr><td class="paramname">map</td><td>key_map of applicable indexes. </td></tr>
    <tr><td class="paramname">clause_type</td><td>"ORDER BY" etc for printing in optimizer trace</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000106">Todo:</a></b></dt><dd><ul>
<li>sergeyp: Results of all index merge selects actually are ordered by clustered PK values.</li>
</ul>
</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>We have to use filesort to do the sorting </td></tr>
    <tr><td class="paramname">1</td><td>We can use an index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d5a2e1822e2131fcfbe6501a8a97525"></a><!-- doxytag: member="sql_select.cc::test_if_subpart" ref="ga4d5a2e1822e2131fcfbe6501a8a97525" args="(ORDER *a, ORDER *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga4d5a2e1822e2131fcfbe6501a8a97525">test_if_subpart</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__order.html">ORDER</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if second is a subpart of first argument.</p>
<p>If first parts has different direction, change it to second part (group is sorted like order) </p>

</div>
</div>
<a class="anchor" id="ga410e1c85b186cd5520a7d21930ead6e5"></a><!-- doxytag: member="sql_select.cc::types_allow_materialization" ref="ga410e1c85b186cd5520a7d21930ead6e5" args="(Item *outer, Item *inner)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#ga410e1c85b186cd5520a7d21930ead6e5">types_allow_materialization</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>inner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if two items are compatible wrt. materialization. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">outer</td><td>Expression from outer query </td></tr>
    <tr><td class="paramname">inner</td><td>Expression from inner query</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>If subquery types allow materialization. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeb2dfefe4d4f6a26323a70b37617b0eb"></a><!-- doxytag: member="st_join_table::unified_condition" ref="gaeb2dfefe4d4f6a26323a70b37617b0eb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a> * <a class="el" href="group__Query__Optimizer.html#gaeb2dfefe4d4f6a26323a70b37617b0eb">JOIN_TAB::unified_condition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if JOIN_TAB condition was moved to <a class="el" href="classFilesort.html">Filesort</a> condition. If yes then return condition belonging to <a class="el" href="classFilesort.html">Filesort</a>, otherwise return condition belonging to JOIN_TAB. </p>

</div>
</div>
<a class="anchor" id="ga81ebfe4ef44f9496582b436835f4680c"></a><!-- doxytag: member="sql_optimizer.cc::update_depend_map" ref="ga81ebfe4ef44f9496582b436835f4680c" args="(JOIN *join)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Query__Optimizer.html#ga81ebfe4ef44f9496582b436835f4680c">update_depend_map</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update the dependency map for the tables. </p>

</div>
</div>
<a class="anchor" id="gaeaa6edcfa6c4d934dd42d505d9de2fef"></a><!-- doxytag: member="JOIN::update_equalities_for_sjm" ref="gaeaa6edcfa6c4d934dd42d505d9de2fef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Query__Optimizer.html#gaeaa6edcfa6c4d934dd42d505d9de2fef">JOIN::update_equalities_for_sjm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Update equalities and keyuse references after semi-join materialization strategy is chosen.</p>
<p>For each multiple equality that contains a field that is selected from a subquery, and that subquery is executed using a semi-join materialization strategy, add the corresponding column in the materialized temporary table to the equality. For each injected semi-join equality that is not converted to multiple equality, replace the reference to the expression selected from the subquery with the corresponding column in the temporary table.</p>
<p>This is needed to properly reflect the equalities that involve injected semi-join equalities when materialization strategy is chosen. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>eliminate_item_equal() for how these equalities are used to generate correct equality predicates.</dd></dl>
<p>The MaterializeScan semi-join strategy requires some additional processing: All primary tables after the materialized temporary table must be inspected for keyuse objects that point to expressions from the subquery tables. These references must be replaced with references to corresponding columns in the materialized temporary table instead. Those primary tables using ref access will thus be made to depend on the materialized temporary table instead of the subquery tables.</p>
<p>Only the injected semi-join equalities need this treatment, other predicates will be handled correctly by the regular item substitution process.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if success, true if error </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:47 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
