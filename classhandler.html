<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: handler Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">handler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="handler" --><!-- doxytag: inherits="Sql_alloc" -->
<p><code>#include &lt;<a class="el" href="handler_8h_source.html">handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for handler:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhandler.png" usemap="#handler_map" alt=""/>
  <map id="handler_map" name="handler_map">
<area href="classSql__alloc.html" alt="Sql_alloc" shape="rect" coords="102,0,194,24"/>
<area href="classha__ndbcluster.html" alt="ha_ndbcluster" shape="rect" coords="0,112,92,136"/>
<area href="classha__ndbinfo.html" alt="ha_ndbinfo" shape="rect" coords="102,112,194,136"/>
<area href="classha__partition.html" alt="ha_partition" shape="rect" coords="204,112,296,136"/>
</map>
 </div></div>

<p><a href="classhandler-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>enum_range_scan_direction</b> { <b>RANGE_SCAN_ASC</b>, 
<b>RANGE_SCAN_DESC</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NONE</b> = 0, 
<b>INDEX</b>, 
<b>RND</b>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67af5473a36655c922682399d4c5b6ec"></a><!-- doxytag: member="handler::Table_flags" ref="a67af5473a36655c922682399d4c5b6ec" args="" -->
typedef ulonglong&#160;</td><td class="memItemRight" valign="bottom"><b>Table_flags</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72cfeaceefd05a2f700c138c194770fc"></a><!-- doxytag: member="handler::unbind_psi" ref="a72cfeaceefd05a2f700c138c194770fc" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unbind_psi</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e335a403d8203854bc5b94111992b79"></a><!-- doxytag: member="handler::rebind_psi" ref="a1e335a403d8203854bc5b94111992b79" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>rebind_psi</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ae8f7f7b4f67773b73906143238dc9f"></a><!-- doxytag: member="handler::handler" ref="a9ae8f7f7b4f67773b73906143238dc9f" args="(handlerton *ht_arg, TABLE_SHARE *share_arg)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b> (<a class="el" href="structhandlerton.html">handlerton</a> *ht_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share_arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97fc340039f5cf37a26e7c3b53685794"></a><!-- doxytag: member="handler::clone" ref="a97fc340039f5cf37a26e7c3b53685794" args="(const char *name, MEM_ROOT *mem_root)" -->
virtual <a class="el" href="classhandler.html">handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>clone</b> (const char *name, MEM_ROOT *mem_root)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5e02829386929734724b143391e0a11">ha_open</a> (<a class="el" href="structTABLE.html">TABLE</a> *table, const char *name, int mode, int test_if_locked)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open database-handler.  <a href="#ab5e02829386929734724b143391e0a11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">ha_close</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init</a> (uint idx, bool sorted)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">ha_index_end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init</a> (bool scan)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">ha_rnd_end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">ha_rnd_next</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">ha_rnd_pos</a> (uchar *buf, uchar *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">ha_index_read_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fa9be09b8d0b1c03c96eb95f79dd7c9"></a><!-- doxytag: member="handler::ha_index_read_last_map" ref="a3fa9be09b8d0b1c03c96eb95f79dd7c9" args="(uchar *buf, const uchar *key, key_part_map keypart_map)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_read_last_map</b> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">ha_index_read_idx_map</a> (uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">ha_index_next</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">ha_index_prev</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">ha_index_first</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">ha_index_last</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">ha_index_next_same</a> (uchar *buf, const uchar *key, uint keylen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a37f8c07d2ede3fb1f46fc0afb4052d2c">ha_index_read</a> (uchar *buf, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1790fe12f8d773f27d5b4b1cb30bd7ab">ha_index_read_last</a> (uchar *buf, const uchar *key, uint key_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">ha_reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check handler usage and reset state of file to after 'open'.  <a href="#a53d38f167906d8aaa9e560c71e595a42"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e1ef9b6ab27156116f91bf50b1ac19f"></a><!-- doxytag: member="handler::ha_index_or_rnd_end" ref="a6e1ef9b6ab27156116f91bf50b1ac19f" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_index_or_rnd_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Table_flags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">ha_table_flags</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">ha_external_lock</a> (THD *thd, int lock_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8e651543ba0dbb2257a50dc1cdb5ea9"></a><!-- doxytag: member="handler::ha_write_row" ref="ad8e651543ba0dbb2257a50dc1cdb5ea9" args="(uchar *buf)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_write_row</b> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f6bb19636dda0f1537fe780b6aca17a"></a><!-- doxytag: member="handler::ha_update_row" ref="a1f6bb19636dda0f1537fe780b6aca17a" args="(const uchar *old_data, uchar *new_data)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_update_row</b> (const uchar *old_data, uchar *new_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f0e3b24f5bb5b2a8fa0c45732db8cdd"></a><!-- doxytag: member="handler::ha_delete_row" ref="a3f0e3b24f5bb5b2a8fa0c45732db8cdd" args="(const uchar *buf)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_delete_row</b> (const uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfbcbef5b9b8ed0f76d700a29091ad3f"></a><!-- doxytag: member="handler::ha_release_auto_increment" ref="abfbcbef5b9b8ed0f76d700a29091ad3f" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_release_auto_increment</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">check_collation_compatibility</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79a8030a4a3928d216599e1c03e9b28c"></a><!-- doxytag: member="handler::ha_check_for_upgrade" ref="a79a8030a4a3928d216599e1c03e9b28c" args="(HA_CHECK_OPT *check_opt)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>ha_check_for_upgrade</b> (<a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">ha_check</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">ha_repair</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">ha_start_bulk_insert</a> (ha_rows rows)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">ha_end_bulk_insert</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">ha_bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">ha_delete_all_rows</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a25394328a49d42bb45b3b263009f02c7">ha_truncate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af68b71d64ca04789d1c6130320eaf22c">ha_reset_auto_increment</a> (ulonglong value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">ha_optimize</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">ha_analyze</a> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">ha_check_and_repair</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">ha_disable_indexes</a> (uint mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">ha_enable_indexes</a> (uint mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1f75cf982985d21907140a17521cd6c5">ha_discard_or_import_tablespace</a> (my_bool discard)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ee228a60527e81efd9a49ddfdd4850d">ha_rename_table</a> (const char *from, const char *to)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a28700a3bf1af24f9a31ebae51bf877db">ha_delete_table</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">ha_drop_table</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a14af5825a427ba6baac74b13223637f8">ha_create</a> (const char *name, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a722462d7e71059a8ed1f43d0fb28366b">ha_create_handler_files</a> (const char *name, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab5fb90782fea926f7a4450889d2d4a93">ha_change_partitions</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af575e947965117a3a200aec827b1a7c3">ha_drop_partitions</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a624a8892433666df834a9b6ed6b8c2dd">ha_rename_partitions</a> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c090210fefb7e95d885688f5717028"></a><!-- doxytag: member="handler::adjust_next_insert_id_after_explicit_value" ref="ad4c090210fefb7e95d885688f5717028" args="(ulonglong nr)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>adjust_next_insert_id_after_explicit_value</b> (ulonglong nr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a7d2f9da11425e388640206b4d22241"></a><!-- doxytag: member="handler::update_auto_increment" ref="a8a7d2f9da11425e388640206b4d22241" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>update_auto_increment</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">print_error</a> (int error, myf errflag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">get_error_message</a> (int error, <a class="el" href="classString.html">String</a> *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">get_dup_key</a> (int error)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">get_foreign_dup_key</a> (char *child_table_name, uint child_table_name_len, char *child_key_name, uint child_key_name_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b117a976fc9423d2337da59f35d128c"></a><!-- doxytag: member="handler::change_table_ptr" ref="a2b117a976fc9423d2337da59f35d128c" args="(TABLE *table_arg, TABLE_SHARE *share)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>change_table_ptr</b> (<a class="el" href="structTABLE.html">TABLE</a> *table_arg, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65f8e5188e2bd9636a564bbc0c3fef86"></a><!-- doxytag: member="handler::scan_time" ref="a65f8e5188e2bd9636a564bbc0c3fef86" args="()" -->
virtual double&#160;</td><td class="memItemRight" valign="bottom"><b>scan_time</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">read_time</a> (uint index, uint ranges, ha_rows rows)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">index_only_read_time</a> (uint keynr, double <a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual longlong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a48f5f0da08d94a8d050a48f44d0be575">get_memory_buffer_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">multi_range_read_info_const</a> (uint keyno, <a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint *bufsz, uint *flags, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">multi_range_read_info</a> (uint keyno, uint n_ranges, uint keys, uint *bufsz, uint *flags, <a class="el" href="classCost__estimate.html">Cost_estimate</a> *cost)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init</a> (<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *seq, void *seq_init_param, uint n_ranges, uint mode, <a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">multi_range_read_next</a> (char **range_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29c43b5f1fb4c515d2c5842dcbc24fac"></a><!-- doxytag: member="handler::keys_to_use_for_scanning" ref="a29c43b5f1fb4c515d2c5842dcbc24fac" args="()" -->
virtual const <a class="el" href="classBitmap_3_0164_01_4.html">key_map</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keys_to_use_for_scanning</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae73d4ecfa5cfe85d8179aa52488016d0"></a><!-- doxytag: member="handler::has_transactions" ref="ae73d4ecfa5cfe85d8179aa52488016d0" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_transactions</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e0ecb1fe01d5b21253a6248e725a73d"></a><!-- doxytag: member="handler::extra_rec_buf_length" ref="a5e0ecb1fe01d5b21253a6248e725a73d" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>extra_rec_buf_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">is_fatal_error</a> (int error, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">estimate_rows_upper_bound</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual enum row_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0b8caf0f3c35db1b63d81fd121793d49">get_row_type</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e51a7f02396ce5cef9cbe41a4a0a888"></a><!-- doxytag: member="handler::index_type" ref="a1e51a7f02396ce5cef9cbe41a4a0a888" args="(uint key_number)" -->
virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><b>index_type</b> (uint key_number)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">column_bitmaps_signal</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MySQL signal that it changed the column bitmap.  <a href="#a4de97045e5381007565fd2b0da235c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c8d9712dab7152b2d39a4118969c62a"></a><!-- doxytag: member="handler::get_index" ref="a8c8d9712dab7152b2d39a4118969c62a" args="(void) const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_index</b> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">start_bulk_update</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">start_bulk_delete</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">exec_bulk_update</a> (uint *dup_key_found)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">end_bulk_update</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">end_bulk_delete</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">read_range_first</a> (const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read first row between two ranges. Store ranges for future calls to read_range_next.  <a href="#a3a0d596ff3ddc77b4f0ad990c4c4cb4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">read_range_next</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read next row between two endpoints.  <a href="#ae4632aa56c9c66a57558f849f8e01271"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">set_end_range</a> (const key_range *range, enum_range_scan_direction direction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">compare_key</a> (key_range *range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0223061f004fe8c403ad2b1422fab8a"></a><!-- doxytag: member="handler::compare_key_icp" ref="ae0223061f004fe8c403ad2b1422fab8a" args="(const key_range *range) const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>compare_key_icp</b> (const key_range *range) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab734678f90b9e7cc6b000047f7c89bb1"></a><!-- doxytag: member="handler::ft_init" ref="ab734678f90b9e7cc6b000047f7c89bb1" args="()" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72693b6e25765a4290f531f578bcf2eb"></a><!-- doxytag: member="handler::ft_end" ref="a72693b6e25765a4290f531f578bcf2eb" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>ft_end</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a109448e09ee2c456b1471b74bb9eb8e6"></a><!-- doxytag: member="handler::ft_init_ext" ref="a109448e09ee2c456b1471b74bb9eb8e6" args="(uint flags, uint inx, String *key)" -->
virtual FT_INFO *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_init_ext</b> (uint flags, uint inx, <a class="el" href="classString.html">String</a> *key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c965ae56bcceee3cf63ce0320a5d31b"></a><!-- doxytag: member="handler::ft_read" ref="a0c965ae56bcceee3cf63ce0320a5d31b" args="(uchar *buf)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>ft_read</b> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">rnd_pos_by_record</a> (uchar *record)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">read_first_row</a> (uchar *buf, uint primary_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a730672727f9ad989e80f3732eb838a10">restart_rnd_next</a> (uchar *buf, uchar *pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a590afc40dd01fb9fc387ef1d97370f41"></a><!-- doxytag: member="handler::rnd_same" ref="a590afc40dd01fb9fc387ef1d97370f41" args="(uchar *buf, uint inx)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rnd_same</b> (uchar *buf, uint inx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33ac874ad6fd5a2e6b97376befacb165"></a><!-- doxytag: member="handler::records_in_range" ref="a33ac874ad6fd5a2e6b97376befacb165" args="(uint inx, key_range *min_key, key_range *max_key)" -->
virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>records_in_range</b> (uint inx, key_range *min_key, key_range *max_key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3c1515e7a936fa9cbc19f93d43495b6"></a><!-- doxytag: member="handler::position" ref="ad3c1515e7a936fa9cbc19f93d43495b6" args="(const uchar *record)=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>position</b> (const uchar *record)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab39a38e4a875151379cacd0da1a789c8"></a><!-- doxytag: member="handler::info" ref="ab39a38e4a875151379cacd0da1a789c8" args="(uint)=0" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>info</b> (uint)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c3487f93880d33b4ef37b41c5c5fbb"></a><!-- doxytag: member="handler::get_dynamic_partition_info" ref="a47c3487f93880d33b4ef37b41c5c5fbb" args="(PARTITION_STATS *stat_info, uint part_id)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>get_dynamic_partition_info</b> (<a class="el" href="structPARTITION__STATS.html">PARTITION_STATS</a> *stat_info, uint part_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e746c224b70d3b03b2886ecf4563394"></a><!-- doxytag: member="handler::calculate_key_hash_value" ref="a7e746c224b70d3b03b2886ecf4563394" args="(Field **field_array)" -->
virtual uint32&#160;</td><td class="memItemRight" valign="bottom"><b>calculate_key_hash_value</b> (<a class="el" href="classField.html">Field</a> **field_array)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b7687330aaf0d97540db07ab436e349"></a><!-- doxytag: member="handler::extra" ref="a2b7687330aaf0d97540db07ab436e349" args="(enum ha_extra_function operation)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra</b> (enum ha_extra_function operation)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b7e72da94a7f5577f00ab5c89204ec1"></a><!-- doxytag: member="handler::extra_opt" ref="a6b7e72da94a7f5577f00ab5c89204ec1" args="(enum ha_extra_function operation, ulong cache_size)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>extra_opt</b> (enum ha_extra_function operation, ulong cache_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">start_read_removal</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual ha_rows&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">end_read_removal</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">was_semi_consistent_read</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">try_semi_consistent_read</a> (bool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a48e6fd090f73a8e7e5e94769c9a10733"></a><!-- doxytag: member="handler::unlock_row" ref="a48e6fd090f73a8e7e5e94769c9a10733" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_row</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90c625117fcff640b7af11e7018519cd"></a><!-- doxytag: member="handler::start_stmt" ref="a90c625117fcff640b7af11e7018519cd" args="(THD *thd, thr_lock_type lock_type)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>start_stmt</b> (THD *thd, thr_lock_type lock_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment</a> (ulonglong offset, ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value, ulonglong *nb_reserved_values)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6f9bf8ee63f3b8312fdc31be3819ede"></a><!-- doxytag: member="handler::set_next_insert_id" ref="ab6f9bf8ee63f3b8312fdc31be3819ede" args="(ulonglong id)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_next_insert_id</b> (ulonglong id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15b51670b2497f01f19f587a4a969386"></a><!-- doxytag: member="handler::restore_auto_increment" ref="a15b51670b2497f01f19f587a4a969386" args="(ulonglong prev_insert_id)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>restore_auto_increment</b> (ulonglong <a class="el" href="handler_8cc.html#ae9f796d8fbc7dc812557a17547b8e69e">prev_insert_id</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58141e7b51aaf97bdf63ea68c411f401"></a><!-- doxytag: member="handler::update_create_info" ref="a58141e7b51aaf97bdf63ea68c411f401" args="(HA_CREATE_INFO *create_info)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>update_create_info</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1abc92ca74cd6aca9a6070a186ced4cb"></a><!-- doxytag: member="handler::check_old_types" ref="a1abc92ca74cd6aca9a6070a186ced4cb" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>check_old_types</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1b5fa7360fc536082f495ee7e09bcba"></a><!-- doxytag: member="handler::assign_to_keycache" ref="ab1b5fa7360fc536082f495ee7e09bcba" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>assign_to_keycache</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0061ab331631179647ccdbd71960ba37"></a><!-- doxytag: member="handler::preload_keys" ref="a0061ab331631179647ccdbd71960ba37" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>preload_keys</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bc45e93a1b669fa750f73a617c46bac"></a><!-- doxytag: member="handler::indexes_are_disabled" ref="a8bc45e93a1b669fa750f73a617c46bac" args="(void)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>indexes_are_disabled</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2782719e44a05802e8ee37a738370bdc"></a><!-- doxytag: member="handler::update_table_comment" ref="a2782719e44a05802e8ee37a738370bdc" args="(const char *comment)" -->
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><b>update_table_comment</b> (const char *comment)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a441afeebcb5b56e598fb7f860c9247d1"></a><!-- doxytag: member="handler::append_create_info" ref="a441afeebcb5b56e598fb7f860c9247d1" args="(String *packet)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>append_create_info</b> (<a class="el" href="classString.html">String</a> *packet)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adda33331aacc500b1b974033cb64a869">is_fk_defined_on_table_or_index</a> (uint index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8712abc71df0d89559e2861c100a8e3e"></a><!-- doxytag: member="handler::get_foreign_key_create_info" ref="a8712abc71df0d89559e2861c100a8e3e" args="()" -->
virtual char *&#160;</td><td class="memItemRight" valign="bottom"><b>get_foreign_key_create_info</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">can_switch_engines</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">get_foreign_key_list</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">get_parent_foreign_key_list</a> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *f_key_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28b038c18aeb8114376725e6f8d39871"></a><!-- doxytag: member="handler::referenced_by_foreign_key" ref="a28b038c18aeb8114376725e6f8d39871" args="()" -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>referenced_by_foreign_key</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28dfb73f9401996a25b9cf925db74149"></a><!-- doxytag: member="handler::init_table_handle_for_HANDLER" ref="a28dfb73f9401996a25b9cf925db74149" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>init_table_handle_for_HANDLER</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4457d47baa6d136af65e041da4fe9e0"></a><!-- doxytag: member="handler::free_foreign_key_create_info" ref="aa4457d47baa6d136af65e041da4fe9e0" args="(char *str)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>free_foreign_key_create_info</b> (char *str)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">table_type</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext</a> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8a347e66418fe35a07f24900bcbdce82"></a><!-- doxytag: member="handler::get_default_no_partitions" ref="a8a347e66418fe35a07f24900bcbdce82" args="(HA_CREATE_INFO *info)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>get_default_no_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc4512d49169a2766f5c5b4896a9691c"></a><!-- doxytag: member="handler::set_auto_partitions" ref="abc4512d49169a2766f5c5b4896a9691c" args="(partition_info *part_info)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_auto_partitions</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">get_no_parts</a> (const char *name, uint *no_parts)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa46ea4bb55add228a28b24d748426aa2"></a><!-- doxytag: member="handler::set_part_info" ref="aa46ea4bb55add228a28b24d748426aa2" args="(partition_info *part_info, bool early)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>set_part_info</b> (<a class="el" href="classpartition__info.html">partition_info</a> *part_info, bool early)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a612375d87a4cbb6e7c190ea7d05cf945"></a><!-- doxytag: member="handler::index_flags" ref="a612375d87a4cbb6e7c190ea7d05cf945" args="(uint idx, uint part, bool all_parts) const =0" -->
virtual ulong&#160;</td><td class="memItemRight" valign="bottom"><b>index_flags</b> (uint idx, uint part, bool all_parts) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49abd932562ae54055217a03488ff7c2"></a><!-- doxytag: member="handler::max_record_length" ref="a49abd932562ae54055217a03488ff7c2" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_record_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fc49588730420d81ccb6ecca3d47283"></a><!-- doxytag: member="handler::max_keys" ref="a3fc49588730420d81ccb6ecca3d47283" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_keys</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec4ffff673eb5022a622cff631ef20e0"></a><!-- doxytag: member="handler::max_key_parts" ref="aec4ffff673eb5022a622cff631ef20e0" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_parts</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0132ba9a010a9274a1803d035d9c9647"></a><!-- doxytag: member="handler::max_key_length" ref="a0132ba9a010a9274a1803d035d9c9647" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac25eef9a0736ac52470b2469cf413adb"></a><!-- doxytag: member="handler::max_key_part_length" ref="ac25eef9a0736ac52470b2469cf413adb" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_key_part_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b855a0bbd7aed8e310e2ff87f3b6d06"></a><!-- doxytag: member="handler::max_supported_record_length" ref="a6b855a0bbd7aed8e310e2ff87f3b6d06" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_record_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58ce322254b82b7d5485bf1ba78a044f"></a><!-- doxytag: member="handler::max_supported_keys" ref="a58ce322254b82b7d5485bf1ba78a044f" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_keys</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a720cd8a6ff607890a1e424c7bcec1196"></a><!-- doxytag: member="handler::max_supported_key_parts" ref="a720cd8a6ff607890a1e424c7bcec1196" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_parts</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07727056ce434bc659e8af2dcdfd46c3"></a><!-- doxytag: member="handler::max_supported_key_length" ref="a07727056ce434bc659e8af2dcdfd46c3" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe324b33f59b8b01c9939c6196c1f9be"></a><!-- doxytag: member="handler::max_supported_key_part_length" ref="afe324b33f59b8b01c9939c6196c1f9be" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>max_supported_key_part_length</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bde1cfef937366730b8d1bcefbce795"></a><!-- doxytag: member="handler::min_record_length" ref="a8bde1cfef937366730b8d1bcefbce795" args="(uint options) const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>min_record_length</b> (uint options) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad485ed370dcdb07f1ab17b32d683992f"></a><!-- doxytag: member="handler::low_byte_first" ref="ad485ed370dcdb07f1ab17b32d683992f" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>low_byte_first</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a471fda69da5546e3127db61cb7defb63"></a><!-- doxytag: member="handler::checksum" ref="a471fda69da5546e3127db61cb7defb63" args="() const " -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>checksum</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a416b49915f54f123d55f7d6d7a58affd"></a><!-- doxytag: member="handler::is_crashed" ref="a416b49915f54f123d55f7d6d7a58affd" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_crashed</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64738a678e07b972c1e7b8b620679f11"></a><!-- doxytag: member="handler::auto_repair" ref="a64738a678e07b972c1e7b8b620679f11" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>auto_repair</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13f5a2b8ba9e4b9f9255243f0f1cd525">lock_count</a> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual THR_LOCK_DATA **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock</a> (THD *thd, THR_LOCK_DATA **to, enum thr_lock_type lock_type)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">table_cache_type</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual my_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f">register_query_cache_table</a> (THD *thd, char *table_key, uint key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a named table with a call back function to the query cache.  <a href="#a2ec87bfd95b71d14fafbb3f88569094f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2c0421f0cd48fdf8c3d64fb4c434a8f"></a><!-- doxytag: member="handler::primary_key_is_clustered" ref="ae2c0421f0cd48fdf8c3d64fb4c434a8f" args="()" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>primary_key_is_clustered</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ff2afe807f7e2bbdddb397ee65626ee"></a><!-- doxytag: member="handler::cmp_ref" ref="a4ff2afe807f7e2bbdddb397ee65626ee" args="(const uchar *ref1, const uchar *ref2)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>cmp_ref</b> (const uchar *ref1, const uchar *ref2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">cond_push</a> (const <a class="el" href="classItem.html">Item</a> *cond)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">cond_pop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">idx_cond_push</a> (uint keyno, <a class="el" href="classItem.html">Item</a> *idx_cond)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">cancel_pushed_idx_cond</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a243ce6f51c5538c6d1dae81db1bb1658">number_of_pushed_joins</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae1bf0cbd806508954db72a5707732ee6">root_of_pushed_join</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a915706fa5bb7e07752cc2d89ec467977">parent_of_pushed_join</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a38213f889f5312cd3e452fc34d11a201"></a><!-- doxytag: member="handler::index_read_pushed" ref="a38213f889f5312cd3e452fc34d11a201" args="(uchar *buf, const uchar *key, key_part_map keypart_map)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_pushed</b> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f56e97f4fb1faebbc23145492bf541d"></a><!-- doxytag: member="handler::index_next_pushed" ref="a5f56e97f4fb1faebbc23145492bf541d" args="(uchar *buf)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_next_pushed</b> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">check_if_incompatible_data</a> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, uint table_changes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual enum_alter_inplace_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ad0ecf7f9bf265e6801b625768f0f2bbe">ha_prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">ha_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6ec170a4aa71186f9dc17358b55587c7">ha_commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">ha_notify_table_changed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a923f2b845012582b5a343b5ede6129c1"></a><!-- doxytag: member="handler::alter_table_flags" ref="a923f2b845012582b5a343b5ede6129c1" args="(uint flags)" -->
virtual uint&#160;</td><td class="memItemRight" valign="bottom"><b>alter_table_flags</b> (uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">bulk_update_row</a> (const uchar *old_data, uchar *new_data, uint *dup_key_found)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">delete_all_rows</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">truncate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">reset_auto_increment</a> (ulonglong value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6916ee6d1e764fa795128fd46164f40d"></a><!-- doxytag: member="handler::optimize" ref="a6916ee6d1e764fa795128fd46164f40d" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>optimize</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85dd48aaf0c97e43f02180b45517c4c2"></a><!-- doxytag: member="handler::analyze" ref="a85dd48aaf0c97e43f02180b45517c4c2" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>analyze</b> (THD *thd, <a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *check_opt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9c1378edb4813d141f666ce2b9382a4"></a><!-- doxytag: member="handler::check_and_repair" ref="ac9c1378edb4813d141f666ce2b9382a4" args="(THD *thd)" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_and_repair</b> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a272e3a0622ad461a5a86c74ddb9289c6"></a><!-- doxytag: member="handler::disable_indexes" ref="a272e3a0622ad461a5a86c74ddb9289c6" args="(uint mode)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>disable_indexes</b> (uint mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a22328b49eac2417561360bd00bbe8299"></a><!-- doxytag: member="handler::enable_indexes" ref="a22328b49eac2417561360bd00bbe8299" args="(uint mode)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>enable_indexes</b> (uint mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a561768da16278d66deec08261111dbef"></a><!-- doxytag: member="handler::discard_or_import_tablespace" ref="a561768da16278d66deec08261111dbef" args="(my_bool discard)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>discard_or_import_tablespace</b> (my_bool discard)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac61d474cf912188a562e9f419872031e"></a><!-- doxytag: member="handler::drop_table" ref="ac61d474cf912188a562e9f419872031e" args="(const char *name)" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>drop_table</b> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a741fbc5479d9ee0ccca766f3eca3703f"></a><!-- doxytag: member="handler::create" ref="a741fbc5479d9ee0ccca766f3eca3703f" args="(const char *name, TABLE *form, HA_CREATE_INFO *info)=0" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create</b> (const char *name, <a class="el" href="structTABLE.html">TABLE</a> *form, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75fe1bf5cf87a258787ca67a2add8bd1"></a><!-- doxytag: member="handler::create_handler_files" ref="a75fe1bf5cf87a258787ca67a2add8bd1" args="(const char *name, const char *old_name, int action_flag, HA_CREATE_INFO *info)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>create_handler_files</b> (const char *name, const char *old_name, int action_flag, <a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5be47bbed1ce6bf15d11f786f1a7476c"></a><!-- doxytag: member="handler::change_partitions" ref="a5be47bbed1ce6bf15d11f786f1a7476c" args="(HA_CREATE_INFO *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>change_partitions</b> (<a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ed6471578e35fab41d3d623df55e686"></a><!-- doxytag: member="handler::drop_partitions" ref="a4ed6471578e35fab41d3d623df55e686" args="(const char *path)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>drop_partitions</b> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a579edf594ce51cd019654a790ff5ca64"></a><!-- doxytag: member="handler::rename_partitions" ref="a579edf594ce51cd019654a790ff5ca64" args="(const char *path)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>rename_partitions</b> (const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae370a0f787c1b936e475a5762b91350c"></a><!-- doxytag: member="handler::set_ha_share_ref" ref="ae370a0f787c1b936e475a5762b91350c" args="(Handler_share **arg_ha_share)" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>set_ha_share_ref</b> (<a class="el" href="classHandler__share.html">Handler_share</a> **arg_ha_share)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a26540421037894e478b97e0e829f9f6a"></a><!-- doxytag: member="handler::get_lock_type" ref="a26540421037894e478b97e0e829f9f6a" args="() const " -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>get_lock_type</b> () const </td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a395bae75af9e51a116097a788b2cf57f"></a><!-- doxytag: member="handler::ht" ref="a395bae75af9e51a116097a788b2cf57f" args="" -->
<a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ht</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c7037216007ba6140e6cff5162024d"></a><!-- doxytag: member="handler::ref" ref="a53c7037216007ba6140e6cff5162024d" args="" -->
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7501dc41ecb010069e8bc9d035aae6aa"></a><!-- doxytag: member="handler::dup_ref" ref="a7501dc41ecb010069e8bc9d035aae6aa" args="" -->
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>dup_ref</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1df561df4b2b6552a7b42189feb0400a"></a><!-- doxytag: member="handler::stats" ref="a1df561df4b2b6552a7b42189feb0400a" args="" -->
<a class="el" href="classha__statistics.html">ha_statistics</a>&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ec520eba79eb9f182c534e82c60ebc6"></a><!-- doxytag: member="handler::mrr_iter" ref="a9ec520eba79eb9f182c534e82c60ebc6" args="" -->
range_seq_t&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_iter</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2a51e423645829d3e540c109556931fa"></a><!-- doxytag: member="handler::mrr_funcs" ref="a2a51e423645829d3e540c109556931fa" args="" -->
<a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_funcs</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52372127bd238a7f622190316ba8124f"></a><!-- doxytag: member="handler::multi_range_buffer" ref="a52372127bd238a7f622190316ba8124f" args="" -->
<a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>multi_range_buffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a476dfe8526807dfc820c4b09f7a6d1"></a><!-- doxytag: member="handler::ranges_in_seq" ref="a1a476dfe8526807dfc820c4b09f7a6d1" args="" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>ranges_in_seq</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adff4dfb21c4583b55afc4fe5aba50389"></a><!-- doxytag: member="handler::mrr_is_output_sorted" ref="adff4dfb21c4583b55afc4fe5aba50389" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_is_output_sorted</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2632d137c3a17fa583f08db5681e80a"></a><!-- doxytag: member="handler::mrr_have_range" ref="af2632d137c3a17fa583f08db5681e80a" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_have_range</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2347edc229832e533d1fb73b236e32b"></a><!-- doxytag: member="handler::mrr_cur_range" ref="af2347edc229832e533d1fb73b236e32b" args="" -->
KEY_MULTI_RANGE&#160;</td><td class="memItemRight" valign="bottom"><b>mrr_cur_range</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28d698fe9901f0f487c9618ddbb0f1be"></a><!-- doxytag: member="handler::end_range" ref="a28d698fe9901f0f487c9618ddbb0f1be" args="" -->
key_range *&#160;</td><td class="memItemRight" valign="bottom"><b>end_range</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3186b7c7a70634a8e9758ed51708359c"></a><!-- doxytag: member="handler::errkey" ref="a3186b7c7a70634a8e9758ed51708359c" args="" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>errkey</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ad5efc62f32ef66b55667fd8370ef33"></a><!-- doxytag: member="handler::key_used_on_scan" ref="a5ad5efc62f32ef66b55667fd8370ef33" args="" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>key_used_on_scan</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29f2838eebffef46663c19f85d2ad2cc"></a><!-- doxytag: member="handler::active_index" ref="a29f2838eebffef46663c19f85d2ad2cc" args="" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>active_index</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">ref_length</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a943005f89e7a6d5cee246e1c5b46e9ab"></a><!-- doxytag: member="handler::ft_handler" ref="a943005f89e7a6d5cee246e1c5b46e9ab" args="" -->
FT_INFO *&#160;</td><td class="memItemRight" valign="bottom"><b>ft_handler</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8166b54cfa95075c6700b87a6ae59762"></a><!-- doxytag: member="handler::inited" ref="a8166b54cfa95075c6700b87a6ae59762" args="" -->
enum handler:: { ... } &#160;</td><td class="memItemRight" valign="bottom"><b>inited</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd47d68a7b406d8777396a657095d5e8"></a><!-- doxytag: member="handler::implicit_emptied" ref="afd47d68a7b406d8777396a657095d5e8" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>implicit_emptied</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ed2f8d7155cb44162bb4181cb09f2f3"></a><!-- doxytag: member="handler::pushed_cond" ref="a0ed2f8d7155cb44162bb4181cb09f2f3" args="" -->
const <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_cond</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9b3d956f73649657bad389acfad5f0b"></a><!-- doxytag: member="handler::pushed_idx_cond" ref="ae9b3d956f73649657bad389acfad5f0b" args="" -->
<a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4dc8d81143d1c9c10b976711fe44cf37"></a><!-- doxytag: member="handler::pushed_idx_cond_keyno" ref="a4dc8d81143d1c9c10b976711fe44cf37" args="" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>pushed_idx_cond_keyno</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">next_insert_id</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">insert_id_for_cur_row</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDiscrete__interval.html">Discrete_interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">auto_inc_interval_for_cur_row</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">auto_inc_intervals_count</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PSI_table *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">m_psi</a></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">index_read_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#af8c2b258691e5baac8dd22d19c084b37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">index_read_idx_map</a> (uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index.  <a href="#acba0c549a00023dd44682cd9452cf830"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">index_next</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">index_prev</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">index_first</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">index_last</a> (uchar *buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">index_next_same</a> (uchar *buf, const uchar *key, uint keylen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">index_read_last_map</a> (uchar *buf, const uchar *key, key_part_map keypart_map)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The following functions works like index_read, but it find the last row with the current key value or prefix.  <a href="#ae069d5991214e1fdf14cc44fd865a180"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">rnd_next</a> (uchar *buf)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">rnd_pos</a> (uchar *buf, uchar *pos)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *altered_table, <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *ha_alter_info, bool commit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d2b5f6ee2f6ec8b90d1b1957f22d8cd"></a><!-- doxytag: member="handler::ha_statistic_increment" ref="a5d2b5f6ee2f6ec8b90d1b1957f22d8cd" args="(ulonglong SSV::*offset) const " -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>ha_statistic_increment</b> (ulonglong SSV::*offset) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa38da847f7846a6829a79d66152b4249"></a><!-- doxytag: member="handler::ha_data" ref="aa38da847f7846a6829a79d66152b4249" args="(THD *) const " -->
void **&#160;</td><td class="memItemRight" valign="bottom"><b>ha_data</b> (THD *) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97e6afc31172a1d17b28e5b696e0f41c"></a><!-- doxytag: member="handler::ha_thd" ref="a97e6afc31172a1d17b28e5b696e0f41c" args="(void) const " -->
THD *&#160;</td><td class="memItemRight" valign="bottom"><b>ha_thd</b> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PSI_table_share *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a6fb15a9a57acb926cdb2a9d5fca21f14">ha_table_share_psi</a> (const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">rename_table</a> (const char *from, const char *to)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">delete_table</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ccf806316a9d88a7130d70e7637e8e5"></a><!-- doxytag: member="handler::index_read" ref="a4ccf806316a9d88a7130d70e7637e8e5" args="(uchar *buf, const uchar *key, uint key_len, enum ha_rkey_function find_flag)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read</b> (uchar *buf, const uchar *key, uint key_len, enum ha_rkey_function find_flag)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90af353b21f935dc95212e1cfef50452"></a><!-- doxytag: member="handler::index_read_last" ref="a90af353b21f935dc95212e1cfef50452" args="(uchar *buf, const uchar *key, uint key_len)" -->
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>index_read_last</b> (uchar *buf, const uchar *key, uint key_len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classHandler__share.html">Handler_share</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">get_ha_share_ptr</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">set_ha_share_ptr</a> (<a class="el" href="classHandler__share.html">Handler_share</a> *arg_ha_share)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">lock_shared_ha_data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">unlock_shared_ha_data</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b094cfe680aa06a7d8b70194415aa3b"></a><!-- doxytag: member="handler::table_share" ref="a3b094cfe680aa06a7d8b70194415aa3b" args="" -->
<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table_share</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb0d051d1ef534891b27612cc4ff56f7"></a><!-- doxytag: member="handler::table" ref="abb0d051d1ef534891b27612cc4ff56f7" args="" -->
<a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>table</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98743b18a24c8baef7e22a11df74d6c9"></a><!-- doxytag: member="handler::cached_table_flags" ref="a98743b18a24c8baef7e22a11df74d6c9" args="" -->
Table_flags&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_flags</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf44b6a4c101f982cd13a344dce5a870"></a><!-- doxytag: member="handler::estimation_rows_to_insert" ref="adf44b6a4c101f982cd13a344dce5a870" args="" -->
ha_rows&#160;</td><td class="memItemRight" valign="bottom"><b>estimation_rows_to_insert</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a011df14ecc738037499572c304d8ee90"></a><!-- doxytag: member="handler::range_key_part" ref="a011df14ecc738037499572c304d8ee90" args="" -->
<a class="el" href="classKEY__PART__INFO.html">KEY_PART_INFO</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>range_key_part</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a272c3d9b40a9e7c5de20ed390d23a636"></a><!-- doxytag: member="handler::eq_range" ref="a272c3d9b40a9e7c5de20ed390d23a636" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>eq_range</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a159ca294d8dafe32405e6ad546e6a4"></a><!-- doxytag: member="handler::in_range_check_pushed_down" ref="a1a159ca294d8dafe32405e6ad546e6a4" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>in_range_check_pushed_down</b></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a576b2e6999b5b4fbe40abb7870fe33b2"></a><!-- doxytag: member="handler::DsMrr_impl" ref="a576b2e6999b5b4fbe40abb7870fe33b2" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>DsMrr_impl</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The handler class is the interface for dynamically loadable storage engines. Do not add ifdefs and take care when adding or changing virtual functions to avoid vtable confusion</p>
<p>Functions in this class accept and return table columns data. Two data representation formats are used: 1. TableRecordFormat - Used to pass [partial] table records to/from storage engine</p>
<p>2. KeyTupleFormat - used to pass index search tuples (aka "keys") to storage engine. See opt_range.cc for description of this format.</p>
<p>TableRecordFormat ================= [Warning: this description is work in progress and may be incomplete] The table record is stored in a fixed-size buffer:</p>
<p>record: null_bytes, column1_data, column2_data, ...</p>
<p>The offsets of the parts of the buffer are also fixed: every column has an offset to its column{i}_data, and if it is nullable it also has its own bit in null_bytes.</p>
<p>The record buffer only includes data about columns that are marked in the relevant column set (table-&gt;read_set and/or table-&gt;write_set, depending on the situation). &lt;not-sure&gt;It could be that it is required that null bits of non-present columns are set to 1&lt;/not-sure&gt;</p>
<p>VARIOUS EXCEPTIONS AND SPECIAL CASES</p>
<p>f the table has no nullable columns, then null_bytes is still present, its length is one byte &lt;not-sure&gt; which must be set to 0xFF at all times. &lt;/not-sure&gt;</p>
<p>If the table has columns of type BIT, then certain bits from those columns may be stored in null_bytes as well. Grep around for <a class="el" href="classField__bit.html">Field_bit</a> for details.</p>
<p>For blob columns (see <a class="el" href="classField__blob.html">Field_blob</a>), the record buffer stores length of the data, following by memory pointer to the blob data. The pointer is owned by the storage engine and is valid until the next operation.</p>
<p>If a blob column has NULL value, then its length and blob data pointer must be set to 0. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a748d5e5b6dbbb0681cbac2ad881505c9"></a><!-- doxytag: member="handler::bas_ext" ref="a748d5e5b6dbbb0681cbac2ad881505c9" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char** <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">handler::bas_ext</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If frm_error() is called then we will use this to find out what file extentions exist for the storage engine. This is also used by the default rename_table and delete_table method in <a class="el" href="handler_8cc.html" title="Handler-calling-functions.">handler.cc</a>.</p>
<p>For engines that have two file name extentions (separate meta/index file and data file), the order of elements is relevant. First element of engine file name extentions array should be meta/index file extention. Second element - data file extention. This order is assumed by prepare_for_repair() when REPAIR <a class="el" href="structTABLE.html">TABLE</a> ... USE_FRM is issued. </p>

<p>Implemented in <a class="el" href="classha__partition.html#a439691aabff67557603a69a6318806b7">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#aed09d12596bd65b85c2c6648a9ae2abd">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#ae0e45762a0177988aaff2d8e253c7b3a">ha_ndbinfo</a>.</p>

</div>
</div>
<a class="anchor" id="ac8dd7e44bc71120ace1e467ccb02ad06"></a><!-- doxytag: member="handler::bulk_update_row" ref="ac8dd7e44bc71120ace1e467ccb02ad06" args="(const uchar *old_data, uchar *new_data, uint *dup_key_found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">handler::bulk_update_row</a> </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is similar to update_row, however the handler doesn't need to execute the updates at this point in time. The handler can be certain that another call to bulk_update_row will occur OR a call to exec_bulk_update before the set of updates in this query is concluded.</p>
<p>Note: If HA_ERR_FOUND_DUPP_KEY is returned, the handler must read all columns of the row so MySQL can create an error message. If the columns required for the error message are not read, the error message will contain garbage.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">old_data</td><td>Old record </td></tr>
    <tr><td class="paramname">new_data</td><td>New record </td></tr>
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a89cbc7ca67dcd89d07693186f5de7ca5">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a6baab93a22543b707e6e59b9d59810d2"></a><!-- doxytag: member="handler::can_switch_engines" ref="a6baab93a22543b707e6e59b9d59810d2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a6baab93a22543b707e6e59b9d59810d2">handler::can_switch_engines</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used in ALTER <a class="el" href="structTABLE.html">TABLE</a> to check if changing storage engine is allowed.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Called without holding thr_lock.c lock.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Changing storage engine is allowed. </td></tr>
    <tr><td class="paramname">false</td><td>Changing storage engine not allowed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a8b83aeaba7dadd1b28c22457ac67f43b">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a41cc6ba204aa4d1bacc35d9d1d75ab15"></a><!-- doxytag: member="handler::cancel_pushed_idx_cond" ref="a41cc6ba204aa4d1bacc35d9d1d75ab15" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classhandler.html#a41cc6ba204aa4d1bacc35d9d1d75ab15">handler::cancel_pushed_idx_cond</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset information about pushed index conditions </p>

</div>
</div>
<a class="anchor" id="a234580f9765751ce185182dd1edc3bdb"></a><!-- doxytag: member="handler::check_collation_compatibility" ref="a234580f9765751ce185182dd1edc3bdb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a234580f9765751ce185182dd1edc3bdb">handler::check_collation_compatibility</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check for incompatible collation changes.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ADMIN_NEEDS_UPGRADE</td><td>Table may have data requiring upgrade. </td></tr>
    <tr><td class="paramname">0</td><td>No upgrade required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36d800c8dafbc9efde9af932305529e4"></a><!-- doxytag: member="handler::check_if_incompatible_data" ref="a36d800c8dafbc9efde9af932305529e4" args="(HA_CREATE_INFO *create_info, uint table_changes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a36d800c8dafbc9efde9af932305529e4">handler::check_if_incompatible_data</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_changes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Part of old, deprecated in-place ALTER API. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a66a9fc27dbc3652fec1fab4c7d9c077c">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a67890a9deb89b9ef0128601e7687fcba"></a><!-- doxytag: member="handler::check_if_supported_inplace_alter" ref="a67890a9deb89b9ef0128601e7687fcba" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum_alter_inplace_result <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">handler::check_if_supported_inplace_alter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if a storage engine supports a particular alter table in-place</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ALTER_ERROR</td><td>Unexpected error. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NOT_SUPPORTED</td><td>Not supported, must use copy. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_EXCLUSIVE_LOCK</td><td>Supported, but requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK_AFTER_PREPARE</td><td>Supported, but requires SNW lock during main phase. Prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_SHARED_LOCK</td><td>Supported, but requires SNW lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE</td><td>Supported, concurrent reads/writes allowed. However, prepare phase requires X lock. </td></tr>
    <tr><td class="paramname">HA_ALTER_INPLACE_NO_LOCK</td><td>Supported, concurrent reads/writes allowed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The default implementation uses the old in-place ALTER API to determine if the storage engine supports in-place ALTER or not.</dd>
<dd>
Called without holding thr_lock.c lock. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#aeeb5f75cddb82102a64ac36bfceaef57">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a4de97045e5381007565fd2b0da235c07"></a><!-- doxytag: member="handler::column_bitmaps_signal" ref="a4de97045e5381007565fd2b0da235c07" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07">handler::column_bitmaps_signal</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>MySQL signal that it changed the column bitmap. </p>
<p>Signal that the table-&gt;read_set and table-&gt;write_set table maps changed The handler is allowed to set additional bits in the above map in this call. Normally the handler should ignore all calls until we have done a <a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">ha_rnd_init()</a> or <a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">ha_index_init()</a>, write_row(), update_row or delete_row() as there may be several calls to this routine.</p>
<p>USAGE This is for handlers that needs to setup their own column bitmaps. Normally the handler should set up their own column bitmaps in index_init() or rnd_init() and in any <a class="el" href="classhandler.html#a4de97045e5381007565fd2b0da235c07" title="MySQL signal that it changed the column bitmap.">column_bitmaps_signal()</a> call after this.</p>
<p>The handler is allowd to do changes to the bitmap after a index_init or rnd_init() call is made as after this, MySQL will not use the bitmap for any program logic checking. </p>

</div>
</div>
<a class="anchor" id="a0786a5f57ccd3c97bff07b1afeae9c06"></a><!-- doxytag: member="handler::commit_inplace_alter_table" ref="a0786a5f57ccd3c97bff07b1afeae9c06" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info, bool commit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">handler::commit_inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Commit or rollback the changes made during <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> and <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> inside the storage engine. Note that in case of rollback the allowed level of concurrency during this operation will be the same as for <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> and thus might be higher than during <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a>. (For example, concurrent writes were blocked during prepare, but might not be during rollback).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function with commit= true reports error, it will be called again with commit= false.</dd>
<dd>
In case of partitioning, this function might be called for rollback without <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> having been called first. Also partitioned tables sets ha_alter_info-&gt;group_commit_ctx to a NULL terminated array of the partitions handlers and if all of them are committed as one, then group_commit_ctx should be set to NULL to indicate to the partitioning handler that all partitions handlers are committed. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a>.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter. </td></tr>
    <tr><td class="paramname">commit</td><td>True =&gt; Commit, False =&gt; Rollback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#aa1797e0d681f755287d7858157a646e3">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="af0ef38e7407e87ba5d1ccde59c3e94bb"></a><!-- doxytag: member="handler::compare_key" ref="af0ef38e7407e87ba5d1ccde59c3e94bb" args="(key_range *range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#af0ef38e7407e87ba5d1ccde59c3e94bb">handler::compare_key</a> </td>
          <td>(</td>
          <td class="paramtype">key_range *&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compare if found key (in row) is over max-value.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>range to compare to row. May be 0 for no range</td></tr>
  </table>
  </dd>
</dl>
<p>key.cc::key_cmp()</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return value is SIGN(key_in_row - range_key):</dd></dl>
<ul>
<li>0 : <a class="el" href="classKey.html">Key</a> is equal to range or 'range' == 0 (no range)</li>
<li>-1 : <a class="el" href="classKey.html">Key</a> is less than range</li>
<li>1 : <a class="el" href="classKey.html">Key</a> is larger than range </li>
</ul>

</div>
</div>
<a class="anchor" id="ac3eb8d2966b848ec4beea5a25cba9dea"></a><!-- doxytag: member="handler::cond_pop" ref="ac3eb8d2966b848ec4beea5a25cba9dea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classhandler.html#ac3eb8d2966b848ec4beea5a25cba9dea">handler::cond_pop</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pop the top condition from the condition stack of the handler instance.</p>
<p>Pops the top if condition stack, if stack is not empty. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a0de805435e8251f27ba3394052f6b1c7">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a5e765264bd31e0519e03e1bd53d8c6d2"></a><!-- doxytag: member="handler::cond_push" ref="a5e765264bd31e0519e03e1bd53d8c6d2" args="(const Item *cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classItem.html">Item</a>* <a class="el" href="classhandler.html#a5e765264bd31e0519e03e1bd53d8c6d2">handler::cond_push</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push condition down to the table handler.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>Condition to be pushed. The condition tree must not be modified by the by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 'remainder' condition that caller must use to filter out records. NULL means the handler will not return rows that do not match the passed condition.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The pushed conditions form a stack (from which one can remove the last pushed condition using cond_pop). The table handler filters out rows using (pushed_cond1 AND pushed_cond2 AND ... AND pushed_condN) or less restrictive condition, depending on handler's capabilities.</dd></dl>
<p>handler-&gt;<a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42" title="Check handler usage and reset state of file to after &#39;open&#39;.">ha_reset()</a> call empties the condition stack. Calls to rnd_init/rnd_end, index_init/index_end etc do not affect the condition stack. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a37925498bba3ddd31b4afee378c640b1">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="ac24fcaab09a75e81702c2e2c34fa0b62"></a><!-- doxytag: member="handler::delete_all_rows" ref="ac24fcaab09a75e81702c2e2c34fa0b62" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">handler::delete_all_rows</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is called to delete all rows in a table If the handler don't support this, then this function will return HA_ERR_WRONG_COMMAND and MySQL will delete the rows one by one. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#ad162b32125ed0d7fb4b5b8167ce0269d">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="ae53ec34116b901cc08e5a87f5ec681a6"></a><!-- doxytag: member="handler::delete_table" ref="ae53ec34116b901cc08e5a87f5ec681a6" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler::delete_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a table in the engine. Called for base as well as temporary tables.</p>
<p>Delete all files with extension from <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext()</a>.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Base name of table</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>We assume that the handler may return more extensions than was actually used for the file.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>If we successfully deleted at least one file from base_ext and didn't get any other errors than ENOENT </td></tr>
    <tr><td class="paramname">!0</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a4d32721908372dc62c490e14a005e03c">ha_ndbcluster</a>, and <a class="el" href="classha__partition.html#aafdb3caedb579b35d9cda963b7a3c25f">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="af5f9f1ca2b5efc0b41e96c6b793d9bb1"></a><!-- doxytag: member="handler::end_bulk_delete" ref="af5f9f1ca2b5efc0b41e96c6b793d9bb1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#af5f9f1ca2b5efc0b41e96c6b793d9bb1">handler::end_bulk_delete</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Execute all outstanding deletes and close down the bulk delete.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2bf6c46d66ca282a4cbd6118e4c99e03"></a><!-- doxytag: member="handler::end_bulk_update" ref="a2bf6c46d66ca282a4cbd6118e4c99e03" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classhandler.html#a2bf6c46d66ca282a4cbd6118e4c99e03">handler::end_bulk_update</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Perform any needed clean-up, no outstanding updates are there at the moment. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a3c3b80b72e921059f62aed3eda1db911">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a517d99c283e85e8d97460f07a781dabf"></a><!-- doxytag: member="handler::end_read_removal" ref="a517d99c283e85e8d97460f07a781dabf" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows <a class="el" href="classhandler.html#a517d99c283e85e8d97460f07a781dabf">handler::end_read_removal</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>End read (before write) removal and return the number of rows really written </p>
<dl class="see"><dt><b>See also:</b></dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a81e58b0a19c7cc7d857a3f00e039ae37">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="ae59e9a1d36d852f4dd5dd00bff5f1ae4"></a><!-- doxytag: member="handler::estimate_rows_upper_bound" ref="ae59e9a1d36d852f4dd5dd00bff5f1ae4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows <a class="el" href="classhandler.html#ae59e9a1d36d852f4dd5dd00bff5f1ae4">handler::estimate_rows_upper_bound</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return upper bound of current number of records in the table (max. of how many records one will retrieve when doing a full table scan) If upper bound is not known, HA_POS_ERROR should be returned as a max possible upper bound. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a663485370abf958b89641924402db405">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a59555b02c52fc703e99a41d3ee3a04c3">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a886bf2fbf16de7e200e3ebc0765fb6e4"></a><!-- doxytag: member="handler::exec_bulk_update" ref="a886bf2fbf16de7e200e3ebc0765fb6e4" args="(uint *dup_key_found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#a886bf2fbf16de7e200e3ebc0765fb6e4">handler::exec_bulk_update</a> </td>
          <td>(</td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>After this call all outstanding updates must be performed. The number of duplicate key errors are reported in the duplicate key parameter. It is allowed to continue to the batched update after this call, the handler has to wait until end_bulk_update with changing state.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">dup_key_found</td><td>Number of duplicate keys found</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">&gt;0</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a5c9f552924c7168373ab0d1c2ba0e049">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="aaf6af760a4ef09984a5cc1dc58db9a40"></a><!-- doxytag: member="handler::get_auto_increment" ref="aaf6af760a4ef09984a5cc1dc58db9a40" args="(ulonglong offset, ulonglong increment, ulonglong nb_desired_values, ulonglong *first_value, ulonglong *nb_reserved_values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">handler::get_auto_increment</a> </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>increment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>nb_desired_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>first_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>nb_reserved_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserves an interval of auto_increment values from the handler.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">offset</td><td>offset (modulus increment) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">increment</td><td>increment between calls </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nb_desired_values</td><td>how many values we want </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">first_value</td><td>the first value reserved by the handler </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nb_reserved_values</td><td>how many values the handler reserved</td></tr>
  </table>
  </dd>
</dl>
<p>offset and increment means that we want values to be of the form offset + N * increment, where N&gt;=0 is integer. If the function sets *first_value to ULONGLONG_MAX it means an error. If the function sets *nb_reserved_values to ULONGLONG_MAX it means it has reserved to "positive infinite". </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a7668775be94bce9d7cf799c051096380">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="ad5eede0999f8273864faa40c5e181793"></a><!-- doxytag: member="handler::get_dup_key" ref="ad5eede0999f8273864faa40c5e181793" args="(int error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="classhandler.html#ad5eede0999f8273864faa40c5e181793">handler::get_dup_key</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>key if error because of duplicated keys </dd></dl>

</div>
</div>
<a class="anchor" id="afce8ffd064ce683481494c7503ef820c"></a><!-- doxytag: member="handler::get_error_message" ref="afce8ffd064ce683481494c7503ef820c" args="(int error, String *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhandler.html#afce8ffd064ce683481494c7503ef820c">handler::get_error_message</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an error message specific to this handler.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>error code previously returned by handler </td></tr>
    <tr><td class="paramname">buf</td><td>pointer to <a class="el" href="classString.html">String</a> where to add error message</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if this is a temporary error </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a4fb5ad51d61c07878d5626a315534497">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a31a5f675ffb30d67ba91bb1cb9ec9dc8">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#ab3693b75133ce5d4e4861ef5627ebbdc">ha_ndbinfo</a>.</p>

</div>
</div>
<a class="anchor" id="a20878b1fb8d31b91dbf53ac963d90f78"></a><!-- doxytag: member="handler::get_foreign_dup_key" ref="a20878b1fb8d31b91dbf53ac963d90f78" args="(char *child_table_name, uint child_table_name_len, char *child_key_name, uint child_key_name_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a20878b1fb8d31b91dbf53ac963d90f78">handler::get_foreign_dup_key</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>child_table_name_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>child_key_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>child_key_name_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the names of the table and the key for which there was a duplicate entry in the case of HA_ERR_FOREIGN_DUPLICATE_KEY.</p>
<p>If any of the table or key name is not available this method will return false and will not change any of child_table_name or child_key_name.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">child_table_name[out]</td><td>Table name </td></tr>
    <tr><td class="paramname">child_table_name_len[in]</td><td>Table name buffer size </td></tr>
    <tr><td class="paramname">child_key_name[out]</td><td><a class="el" href="classKey.html">Key</a> name </td></tr>
    <tr><td class="paramname">child_key_name_len[in]</td><td><a class="el" href="classKey.html">Key</a> name buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>table and key names were available and were written into the corresponding out parameters. </td></tr>
    <tr><td class="paramname">false</td><td>table and key names were not available, the out parameters were not touched. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81064e61d4c08261af409fb6ee34e3ca"></a><!-- doxytag: member="handler::get_foreign_key_list" ref="a81064e61d4c08261af409fb6ee34e3ca" args="(THD *thd, List&lt; FOREIGN_KEY_INFO &gt; *f_key_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#a81064e61d4c08261af409fb6ee34e3ca">handler::get_foreign_key_list</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the list of foreign keys in this table.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Returns the set of foreign keys where this table is the dependent or child table.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The handler error code or zero for success. </dd></dl>

</div>
</div>
<a class="anchor" id="a13bf21a8ad4be872bbfe94f5cb40abca"></a><!-- doxytag: member="handler::get_ha_share_ptr" ref="a13bf21a8ad4be872bbfe94f5cb40abca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classHandler__share.html">Handler_share</a> * <a class="el" href="classhandler.html#a13bf21a8ad4be872bbfe94f5cb40abca">handler::get_ha_share_ptr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get an initialized ha_share.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Initialized ha_share </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>ha_share is not yet initialized. </td></tr>
    <tr><td class="paramname">!=</td><td>NULL previous initialized ha_share.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If not a temp table, then LOCK_ha_data must be held. </dd></dl>

</div>
</div>
<a class="anchor" id="a48f5f0da08d94a8d050a48f44d0be575"></a><!-- doxytag: member="handler::get_memory_buffer_size" ref="a48f5f0da08d94a8d050a48f44d0be575" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual longlong <a class="el" href="classhandler.html#a48f5f0da08d94a8d050a48f44d0be575">handler::get_memory_buffer_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an estimate on the amount of memory the storage engine will use for caching data in memory. If this is unknown or the storage engine does not cache data in memory -1 is returned. </p>

</div>
</div>
<a class="anchor" id="ab3cad9d951b59dd0b705e6861dc489e7"></a><!-- doxytag: member="handler::get_no_parts" ref="ab3cad9d951b59dd0b705e6861dc489e7" args="(const char *name, uint *no_parts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#ab3cad9d951b59dd0b705e6861dc489e7">handler::get_no_parts</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>no_parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get number of partitions for table in SE</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>normalized path(same as open) to the table</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">no_parts</td><td>Number of partitions</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>for success </td></tr>
    <tr><td class="paramname">true</td><td>for failure, for example table didn't exist in engine </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a36ca395ca5c6066f00b30a9ccedfc43d">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#ad4c8240f36397911132c71d6080c0659">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a9187eea9999eba802ee4ae01f91dda3b"></a><!-- doxytag: member="handler::get_parent_foreign_key_list" ref="a9187eea9999eba802ee4ae01f91dda3b" args="(THD *thd, List&lt; FOREIGN_KEY_INFO &gt; *f_key_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#a9187eea9999eba802ee4ae01f91dda3b">handler::get_parent_foreign_key_list</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a> &gt; *&#160;</td>
          <td class="paramname"><em>f_key_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the list of foreign keys referencing this table.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>Returns the set of foreign keys where this table is the referenced or parent table.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The thread handle. </td></tr>
    <tr><td class="paramname">f_key_list[out]</td><td>The list of foreign keys.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The handler error code or zero for success. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b8caf0f3c35db1b63d81fd121793d49"></a><!-- doxytag: member="handler::get_row_type" ref="a0b8caf0f3c35db1b63d81fd121793d49" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual enum row_type <a class="el" href="classhandler.html#a0b8caf0f3c35db1b63d81fd121793d49">handler::get_row_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the row type from the storage engine. If this method returns ROW_TYPE_NOT_USED, the information in HA_CREATE_INFO should be used. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a8c2bdc154c11f31207e3636c1a3ad3e2">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a66cc9e4971b8e768c102398da0656a7f"></a><!-- doxytag: member="handler::ha_analyze" ref="a66cc9e4971b8e768c102398da0656a7f" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a66cc9e4971b8e768c102398da0656a7f">handler::ha_analyze</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Analyze table: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::analyze() </dd></dl>

</div>
</div>
<a class="anchor" id="a49c8ce82a564b0cbf6340dc9b74a9c23"></a><!-- doxytag: member="handler::ha_bulk_update_row" ref="a49c8ce82a564b0cbf6340dc9b74a9c23" args="(const uchar *old_data, uchar *new_data, uint *dup_key_found)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a49c8ce82a564b0cbf6340dc9b74a9c23">handler::ha_bulk_update_row</a> </td>
          <td>(</td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>old_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>new_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>dup_key_found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bulk update row: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#ac8dd7e44bc71120ace1e467ccb02ad06">handler::bulk_update_row()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab5fb90782fea926f7a4450889d2d4a93"></a><!-- doxytag: member="handler::ha_change_partitions" ref="ab5fb90782fea926f7a4450889d2d4a93" args="(HA_CREATE_INFO *create_info, const char *path, ulonglong *const copied, ulonglong *const deleted, const uchar *pack_frm_data, size_t pack_frm_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ab5fb90782fea926f7a4450889d2d4a93">handler::ha_change_partitions</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>create_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *const&#160;</td>
          <td class="paramname"><em>copied</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *const&#160;</td>
          <td class="paramname"><em>deleted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>pack_frm_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pack_frm_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change partitions: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::change_partitions() </dd></dl>

</div>
</div>
<a class="anchor" id="a56545ec9967544c80d5612f8ac9b8e6e"></a><!-- doxytag: member="handler::ha_check" ref="a56545ec9967544c80d5612f8ac9b8e6e" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a56545ec9967544c80d5612f8ac9b8e6e">handler::ha_check</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>to be actually called to get 'check()' functionality</p>
<p>Performs checks upon the table.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread doing CHECK <a class="el" href="structTABLE.html">TABLE</a> operation </td></tr>
    <tr><td class="paramname">check_opt</td><td>options from the parser</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_ADMIN_OK</td><td>Successful upgrade </td></tr>
    <tr><td class="paramname">HA_ADMIN_NEEDS_UPGRADE</td><td>Table has structures requiring upgrade </td></tr>
    <tr><td class="paramname">HA_ADMIN_NEEDS_ALTER</td><td>Table has structures requiring ALTER <a class="el" href="structTABLE.html">TABLE</a> </td></tr>
    <tr><td class="paramname">HA_ADMIN_NOT_IMPLEMENTED</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a169d5287bdf480f8cd20f758bb2d9bd1"></a><!-- doxytag: member="handler::ha_check_and_repair" ref="a169d5287bdf480f8cd20f758bb2d9bd1" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhandler.html#a169d5287bdf480f8cd20f758bb2d9bd1">handler::ha_check_and_repair</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check and repair table: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::check_and_repair() </dd></dl>

</div>
</div>
<a class="anchor" id="ae28824cdff2c1812e282463c908e84c2"></a><!-- doxytag: member="handler::ha_close" ref="ae28824cdff2c1812e282463c908e84c2" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ae28824cdff2c1812e282463c908e84c2">handler::ha_close</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close handler. </p>

</div>
</div>
<a class="anchor" id="a6ec170a4aa71186f9dc17358b55587c7"></a><!-- doxytag: member="handler::ha_commit_inplace_alter_table" ref="a6ec170a4aa71186f9dc17358b55587c7" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info, bool commit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhandler.html#a6ec170a4aa71186f9dc17358b55587c7">handler::ha_commit_inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public function wrapping the actual handler call. Allows us to enforce asserts regardless of handler implementation. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a14af5825a427ba6baac74b13223637f8"></a><!-- doxytag: member="handler::ha_create" ref="a14af5825a427ba6baac74b13223637f8" args="(const char *name, TABLE *form, HA_CREATE_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a14af5825a427ba6baac74b13223637f8">handler::ha_create</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a table in the engine: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::create() </dd></dl>

</div>
</div>
<a class="anchor" id="a722462d7e71059a8ed1f43d0fb28366b"></a><!-- doxytag: member="handler::ha_create_handler_files" ref="a722462d7e71059a8ed1f43d0fb28366b" args="(const char *name, const char *old_name, int action_flag, HA_CREATE_INFO *info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a722462d7e71059a8ed1f43d0fb28366b">handler::ha_create_handler_files</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>old_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>action_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create handler files for CREATE <a class="el" href="structTABLE.html">TABLE</a>: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::create_handler_files() </dd></dl>

</div>
</div>
<a class="anchor" id="a1fef228137a11565f7d52a60ad802004"></a><!-- doxytag: member="handler::ha_delete_all_rows" ref="a1fef228137a11565f7d52a60ad802004" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a1fef228137a11565f7d52a60ad802004">handler::ha_delete_all_rows</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete all rows: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#ac24fcaab09a75e81702c2e2c34fa0b62">handler::delete_all_rows()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a28700a3bf1af24f9a31ebae51bf877db"></a><!-- doxytag: member="handler::ha_delete_table" ref="a28700a3bf1af24f9a31ebae51bf877db" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a28700a3bf1af24f9a31ebae51bf877db">handler::ha_delete_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete table: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">handler::delete_table()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeeb079b3dc59160ba828ef89b4463921"></a><!-- doxytag: member="handler::ha_disable_indexes" ref="aeeb079b3dc59160ba828ef89b4463921" args="(uint mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#aeeb079b3dc59160ba828ef89b4463921">handler::ha_disable_indexes</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable indexes: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::disable_indexes() </dd></dl>

</div>
</div>
<a class="anchor" id="a1f75cf982985d21907140a17521cd6c5"></a><!-- doxytag: member="handler::ha_discard_or_import_tablespace" ref="a1f75cf982985d21907140a17521cd6c5" args="(my_bool discard)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a1f75cf982985d21907140a17521cd6c5">handler::ha_discard_or_import_tablespace</a> </td>
          <td>(</td>
          <td class="paramtype">my_bool&#160;</td>
          <td class="paramname"><em>discard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Discard or import tablespace: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::discard_or_import_tablespace() </dd></dl>

</div>
</div>
<a class="anchor" id="af575e947965117a3a200aec827b1a7c3"></a><!-- doxytag: member="handler::ha_drop_partitions" ref="af575e947965117a3a200aec827b1a7c3" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#af575e947965117a3a200aec827b1a7c3">handler::ha_drop_partitions</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Drop partitions: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::drop_partitions() </dd></dl>

</div>
</div>
<a class="anchor" id="a6bcc37ec84386f5d6cc86448781666cb"></a><!-- doxytag: member="handler::ha_drop_table" ref="a6bcc37ec84386f5d6cc86448781666cb" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#a6bcc37ec84386f5d6cc86448781666cb">handler::ha_drop_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Drop table in the engine: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::drop_table() </dd></dl>

</div>
</div>
<a class="anchor" id="a36e9c53758728e07eb37cbb65ea3ab50"></a><!-- doxytag: member="handler::ha_enable_indexes" ref="a36e9c53758728e07eb37cbb65ea3ab50" args="(uint mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a36e9c53758728e07eb37cbb65ea3ab50">handler::ha_enable_indexes</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable indexes: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::enable_indexes() </dd></dl>

</div>
</div>
<a class="anchor" id="a30f3cbf4a769155c994ed39f76433106"></a><!-- doxytag: member="handler::ha_end_bulk_insert" ref="a30f3cbf4a769155c994ed39f76433106" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a30f3cbf4a769155c994ed39f76433106">handler::ha_end_bulk_insert</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>End bulk insert.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Failure (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a99b5f8ae28bc5c374919396f8dcf08"></a><!-- doxytag: member="handler::ha_external_lock" ref="a9a99b5f8ae28bc5c374919396f8dcf08" args="(THD *thd, int lock_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a9a99b5f8ae28bc5c374919396f8dcf08">handler::ha_external_lock</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions represent the public interface to *users* of the handler class, hence they are *not* virtual. For the inheritance interface, see the (private) functions write_row(), update_row(), and delete_row() below. </p>

</div>
</div>
<a class="anchor" id="afa6bd01057c6cdd86d2ea2ee4ea65ca3"></a><!-- doxytag: member="handler::ha_index_end" ref="afa6bd01057c6cdd86d2ea2ee4ea65ca3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#afa6bd01057c6cdd86d2ea2ee4ea65ca3">handler::ha_index_end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>End use of index.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd574a3025588e9b0cd49e0d6908e3b8"></a><!-- doxytag: member="handler::ha_index_first" ref="abd574a3025588e9b0cd49e0d6908e3b8" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#abd574a3025588e9b0cd49e0d6908e3b8">handler::ha_index_first</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the first row via index.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0af23462b249041a0db03c1c7139d76b"></a><!-- doxytag: member="handler::ha_index_init" ref="a0af23462b249041a0db03c1c7139d76b" args="(uint idx, bool sorted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a0af23462b249041a0db03c1c7139d76b">handler::ha_index_init</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize use of index.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index to use </td></tr>
    <tr><td class="paramname">sorted</td><td>Use sorted order</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a7415f1744039a51ef15e923ef7da1b"></a><!-- doxytag: member="handler::ha_index_last" ref="a2a7415f1744039a51ef15e923ef7da1b" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a2a7415f1744039a51ef15e923ef7da1b">handler::ha_index_last</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the last row via index.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c99e96a8350ff577a94529be9387a30"></a><!-- doxytag: member="handler::ha_index_next" ref="a4c99e96a8350ff577a94529be9387a30" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a4c99e96a8350ff577a94529be9387a30">handler::ha_index_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the next row via index.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f79360a45d50c6b558feb1c308c4157"></a><!-- doxytag: member="handler::ha_index_next_same" ref="a3f79360a45d50c6b558feb1c308c4157" args="(uchar *buf, const uchar *key, uint keylen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a3f79360a45d50c6b558feb1c308c4157">handler::ha_index_next_same</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the next same row via index.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="classKey.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keylen</td><td>Length of key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb977dac0435158be227e45e04c8b798"></a><!-- doxytag: member="handler::ha_index_prev" ref="abb977dac0435158be227e45e04c8b798" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#abb977dac0435158be227e45e04c8b798">handler::ha_index_prev</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the previous row via index.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37f8c07d2ede3fb1f46fc0afb4052d2c"></a><!-- doxytag: member="handler::ha_index_read" ref="a37f8c07d2ede3fb1f46fc0afb4052d2c" args="(uchar *buf, const uchar *key, uint key_len, enum ha_rkey_function find_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a37f8c07d2ede3fb1f46fc0afb4052d2c">handler::ha_index_read</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read one row via index.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="classKey.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keylen</td><td>Length of key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">find_flag</td><td>Direction/condition on key usage</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac831321e8d33958db4fd4968de932acf"></a><!-- doxytag: member="handler::ha_index_read_idx_map" ref="ac831321e8d33958db4fd4968de932acf" args="(uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ac831321e8d33958db4fd4968de932acf">handler::ha_index_read_idx_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes an index and read it.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">handler::ha_index_read_map</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1790fe12f8d773f27d5b4b1cb30bd7ab"></a><!-- doxytag: member="handler::ha_index_read_last" ref="a1790fe12f8d773f27d5b4b1cb30bd7ab" args="(uchar *buf, const uchar *key, uint key_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a1790fe12f8d773f27d5b4b1cb30bd7ab">handler::ha_index_read_last</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the last row via index.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Row data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="classKey.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keylen</td><td>Length of key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a729d9c9c011527b81287574294887bf3"></a><!-- doxytag: member="handler::ha_index_read_map" ref="a729d9c9c011527b81287574294887bf3" args="(uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a729d9c9c011527b81287574294887bf3">handler::ha_index_read_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read [part of] row via [part of] index. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer where store the data </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td><a class="el" href="classKey.html">Key</a> to search for </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">keypart_map</td><td>Which part of key to use </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">find_flag</td><td>Direction/condition on key usage</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success (found a record, and function has set table-&gt;status to 0) </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>Row not found (function has set table-&gt;status to STATUS_NOT_FOUND) </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Positions an index cursor to the index specified in the handle. Fetches the row if available. If the key value is null, begin at the first key of the index. ha_index_read_map can be restarted without calling index_end on the previous index scan and without calling ha_index_init. In this case the ha_index_read_map is on the same index as the previous ha_index_scan. This is particularly used in conjunction with multi read ranges. </dd></dl>

</div>
</div>
<a class="anchor" id="a96b182710a133be9561afc149cb6aa8f"></a><!-- doxytag: member="handler::ha_inplace_alter_table" ref="a96b182710a133be9561afc149cb6aa8f" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhandler.html#a96b182710a133be9561afc149cb6aa8f">handler::ha_inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public function wrapping the actual handler call. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5b81b74b0b7b87de4f99ebe20c49dc44"></a><!-- doxytag: member="handler::ha_notify_table_changed" ref="a5b81b74b0b7b87de4f99ebe20c49dc44" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#a5b81b74b0b7b87de4f99ebe20c49dc44">handler::ha_notify_table_changed</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public function wrapping the actual handler call. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab5e02829386929734724b143391e0a11"></a><!-- doxytag: member="handler::ha_open" ref="ab5e02829386929734724b143391e0a11" args="(TABLE *table, const char *name, int mode, int test_if_locked)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ab5e02829386929734724b143391e0a11">handler::ha_open</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>test_if_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open database-handler. </p>
<p>IMPLEMENTATION Try O_RDONLY if cannot open as O_RDWR Don't wait for locks if not HA_OPEN_WAIT_IF_LOCKED is set </p>

</div>
</div>
<a class="anchor" id="a980a8a7650a41fd9a05a32521826ccd5"></a><!-- doxytag: member="handler::ha_optimize" ref="a980a8a7650a41fd9a05a32521826ccd5" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a980a8a7650a41fd9a05a32521826ccd5">handler::ha_optimize</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Optimize table: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::optimize() </dd></dl>

</div>
</div>
<a class="anchor" id="ad0ecf7f9bf265e6801b625768f0f2bbe"></a><!-- doxytag: member="handler::ha_prepare_inplace_alter_table" ref="ad0ecf7f9bf265e6801b625768f0f2bbe" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classhandler.html#ad0ecf7f9bf265e6801b625768f0f2bbe">handler::ha_prepare_inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Public functions wrapping the actual handler call. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a624a8892433666df834a9b6ed6b8c2dd"></a><!-- doxytag: member="handler::ha_rename_partitions" ref="a624a8892433666df834a9b6ed6b8c2dd" args="(const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a624a8892433666df834a9b6ed6b8c2dd">handler::ha_rename_partitions</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rename partitions: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::rename_partitions() </dd></dl>

</div>
</div>
<a class="anchor" id="a6ee228a60527e81efd9a49ddfdd4850d"></a><!-- doxytag: member="handler::ha_rename_table" ref="a6ee228a60527e81efd9a49ddfdd4850d" args="(const char *from, const char *to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a6ee228a60527e81efd9a49ddfdd4850d">handler::ha_rename_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rename table: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler::rename_table()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad28d70543d9566894b5a81d25eca2e8e"></a><!-- doxytag: member="handler::ha_repair" ref="ad28d70543d9566894b5a81d25eca2e8e" args="(THD *thd, HA_CHECK_OPT *check_opt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ad28d70543d9566894b5a81d25eca2e8e">handler::ha_repair</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__ha__check__opt.html">HA_CHECK_OPT</a> *&#160;</td>
          <td class="paramname"><em>check_opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Repair table: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>handler::repair() </dd></dl>

</div>
</div>
<a class="anchor" id="a53d38f167906d8aaa9e560c71e595a42"></a><!-- doxytag: member="handler::ha_reset" ref="a53d38f167906d8aaa9e560c71e595a42" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a53d38f167906d8aaa9e560c71e595a42">handler::ha_reset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check handler usage and reset state of file to after 'open'. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>can be called regardless of it is locked or not. </dd></dl>

</div>
</div>
<a class="anchor" id="af68b71d64ca04789d1c6130320eaf22c"></a><!-- doxytag: member="handler::ha_reset_auto_increment" ref="af68b71d64ca04789d1c6130320eaf22c" args="(ulonglong value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#af68b71d64ca04789d1c6130320eaf22c">handler::ha_reset_auto_increment</a> </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset auto increment: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">handler::reset_auto_increment()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad4d9bf34ac0a004d8c5c32267f20842f"></a><!-- doxytag: member="handler::ha_rnd_end" ref="ad4d9bf34ac0a004d8c5c32267f20842f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ad4d9bf34ac0a004d8c5c32267f20842f">handler::ha_rnd_end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>End use of random access.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb5c99736cb400350e007578889b8375"></a><!-- doxytag: member="handler::ha_rnd_init" ref="afb5c99736cb400350e007578889b8375" args="(bool scan)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#afb5c99736cb400350e007578889b8375">handler::ha_rnd_init</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize table for random read or scan.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">scan</td><td>if true: Initialize for random scans through <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">rnd_next()</a> if false: Initialize for random reads through <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">rnd_pos()</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3743f3a48e7be751dbb2691be4c992a"></a><!-- doxytag: member="handler::ha_rnd_next" ref="ad3743f3a48e7be751dbb2691be4c992a" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ad3743f3a48e7be751dbb2691be4c992a">handler::ha_rnd_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read next row via random scan.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>Buffer to read the row into</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcd8615219b3e692e7d484d2ba6cfa86"></a><!-- doxytag: member="handler::ha_rnd_pos" ref="abcd8615219b3e692e7d484d2ba6cfa86" args="(uchar *buf, uchar *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#abcd8615219b3e692e7d484d2ba6cfa86">handler::ha_rnd_pos</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read row via random scan from position.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Buffer to read the row into </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pos</td><td>Position from position() call</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Success </td></tr>
    <tr><td class="paramname">!=</td><td>0 Error (error code returned) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f09a15d46c019a621b0a65bb1ec89d3"></a><!-- doxytag: member="handler::ha_start_bulk_insert" ref="a3f09a15d46c019a621b0a65bb1ec89d3" args="(ha_rows rows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#a3f09a15d46c019a621b0a65bb1ec89d3">handler::ha_start_bulk_insert</a> </td>
          <td>(</td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start bulk insert.</p>
<p>Allow the handler to optimize for multiple row insert.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>Estimated rows to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaba28e58d3a9fab58402bda6f2be6fe"></a><!-- doxytag: member="handler::ha_table_flags" ref="aaaba28e58d3a9fab58402bda6f2be6fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Table_flags <a class="el" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">handler::ha_table_flags</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The cached_table_flags is set at ha_open and ha_external_lock </p>

</div>
</div>
<a class="anchor" id="a6fb15a9a57acb926cdb2a9d5fca21f14"></a><!-- doxytag: member="handler::ha_table_share_psi" ref="a6fb15a9a57acb926cdb2a9d5fca21f14" args="(const TABLE_SHARE *share) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PSI_table_share * <a class="el" href="classhandler.html#a6fb15a9a57acb926cdb2a9d5fca21f14">handler::ha_table_share_psi</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire the instrumented table information from a table share. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>a table share </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>an instrumented table share, or NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a25394328a49d42bb45b3b263009f02c7"></a><!-- doxytag: member="handler::ha_truncate" ref="a25394328a49d42bb45b3b263009f02c7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a25394328a49d42bb45b3b263009f02c7">handler::ha_truncate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Truncate table: public interface.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">handler::truncate()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0bb554282443af443fc8aae4533e1407"></a><!-- doxytag: member="handler::idx_cond_push" ref="a0bb554282443af443fc8aae4533e1407" args="(uint keyno, Item *idx_cond)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classItem.html">Item</a>* <a class="el" href="classhandler.html#a0bb554282443af443fc8aae4533e1407">handler::idx_cond_push</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>idx_cond</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push down an index condition to the handler.</p>
<p>The server will use this method to push down a condition it wants the handler to evaluate when retrieving records using a specified index. The pushed index condition will only refer to fields from this handler that is contained in the index (but it may also refer to fields in other handlers). Before the handler evaluates the condition it must read the content of the index entry into the record buffer.</p>
<p>The handler is free to decide if and how much of the condition it will take responsibility for evaluating. Based on this evaluation it should return the part of the condition it will not evaluate. If it decides to evaluate the entire condition it should return NULL. If it decides not to evaluate any part of the condition it should return a pointer to the same condition as given as argument.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>the index number to evaluate the condition on </td></tr>
    <tr><td class="paramname">idx_cond</td><td>the condition to be evaluated by the handler</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The part of the pushed condition that the handler decides not to evaluate </dd></dl>

</div>
</div>
<a class="anchor" id="af37bd518c53c966459632584c34855d0"></a><!-- doxytag: member="handler::index_first" ref="af37bd518c53c966459632584c34855d0" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#af37bd518c53c966459632584c34855d0">handler::index_first</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#acc714b62d79e24a9c1d4f3db712322b1">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a1d3598345c3543f684c566f79a61cedc">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="aa1d62ffab7408a031b13e547eb58be09"></a><!-- doxytag: member="handler::index_last" ref="aa1d62ffab7408a031b13e547eb58be09" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#aa1d62ffab7408a031b13e547eb58be09">handler::index_last</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a4e4defdf04378b86f231928ed21e017b">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a6f6e9347ec700ee952a998fa88ae68b2">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="aca48f687872e10a4fdc35b418d98b761"></a><!-- doxytag: member="handler::index_next" ref="aca48f687872e10a4fdc35b418d98b761" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#aca48f687872e10a4fdc35b418d98b761">handler::index_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a6a599d1fe239ff7d7dba0b3984fc8bea">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a865afdc25ee4ca42fafde872e476e0ff">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a5459b92420f74e6f88dec137e1941d22"></a><!-- doxytag: member="handler::index_next_same" ref="a5459b92420f74e6f88dec137e1941d22" args="(uchar *buf, const uchar *key, uint keylen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a5459b92420f74e6f88dec137e1941d22">handler::index_next_same</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keylen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a2769f8f7dd54eebb15c6baa6c4651b2b">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a4a2ac6b2908a899c0ce230818bb7a993"></a><!-- doxytag: member="handler::index_only_read_time" ref="a4a2ac6b2908a899c0ce230818bb7a993" args="(uint keynr, double records)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classhandler.html#a4a2ac6b2908a899c0ce230818bb7a993">handler::index_only_read_time</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keynr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate cost of 'index only' scan for given index and number of records</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keynr</td><td>Index number </td></tr>
    <tr><td class="paramname">records</td><td>Estimated number of records to be retrieved</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is assumed that we will read trough the whole key range and that all key blocks are half full (normally things are much better). It is also assumed that each time we read the next key from the index, the handler performs a random seek, thus the cost is proportional to the number of blocks read.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>Consider joining this function and <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler::read_time()</a> into one handler::read_time(keynr, records, ranges, bool index_only) function.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Estimated cost of 'index only' scan </dd></dl>

</div>
</div>
<a class="anchor" id="a1ab892ae78db6437119d2d25621118b7"></a><!-- doxytag: member="handler::index_prev" ref="a1ab892ae78db6437119d2d25621118b7" args="(uchar *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#a1ab892ae78db6437119d2d25621118b7">handler::index_prev</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a25706609cb26f778dd90cc2611b112fd">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a824559f84d7f256052f0394e9276774f">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="acba0c549a00023dd44682cd9452cf830"></a><!-- doxytag: member="handler::index_read_idx_map" ref="acba0c549a00023dd44682cd9452cf830" args="(uchar *buf, uint index, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#acba0c549a00023dd44682cd9452cf830">handler::index_read_idx_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positions an index cursor to the index specified in argument. Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#aee13430aea3946ffa6cf2c00104ba19c">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a3287fe133e918396f19004472c3b8afa">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="ae069d5991214e1fdf14cc44fd865a180"></a><!-- doxytag: member="handler::index_read_last_map" ref="ae069d5991214e1fdf14cc44fd865a180" args="(uchar *buf, const uchar *key, key_part_map keypart_map)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#ae069d5991214e1fdf14cc44fd865a180">handler::index_read_last_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The following functions works like index_read, but it find the last row with the current key value or prefix. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#ae28896451f43f7b821e441413936c93c">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="af8c2b258691e5baac8dd22d19c084b37"></a><!-- doxytag: member="handler::index_read_map" ref="af8c2b258691e5baac8dd22d19c084b37" args="(uchar *buf, const uchar *key, key_part_map keypart_map, enum ha_rkey_function find_flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37">handler::index_read_map</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uchar *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">key_part_map&#160;</td>
          <td class="paramname"><em>keypart_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_rkey_function&#160;</td>
          <td class="paramname"><em>find_flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Positions an index cursor to the index specified in the handle ('active_index'). Fetches the row if available. If the key value is null, begin at the first key of the index. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 if success (found a record, and function has set table-&gt;status to 0); non-zero if no record (function has set table-&gt;status to STATUS_NOT_FOUND). </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a7e153d8c7280e6d4440b09c61976e7f3">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="ab1ad6edb66592b200a7c7ac0f947dc66"></a><!-- doxytag: member="handler::init" ref="ab1ad6edb66592b200a7c7ac0f947dc66" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">handler::init</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is called after create to allow us to set up cached variables </p>

</div>
</div>
<a class="anchor" id="a90b4c3a8fe1c89c6ccfec1f4b144754a"></a><!-- doxytag: member="handler::inplace_alter_table" ref="a90b4c3a8fe1c89c6ccfec1f4b144754a" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">handler::inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Alter the table structure in-place with operations specified using HA_ALTER_FLAGS and <a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a>. The level of concurrency allowed during this operation depends on the return value from <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called with commit= false.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a772afdad3f8e79ecf0c176dfee5c95d2">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a1bc56a8f3a2c01c127ad553fdf2a8c18"></a><!-- doxytag: member="handler::is_fatal_error" ref="a1bc56a8f3a2c01c127ad553fdf2a8c18" args="(int error, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a1bc56a8f3a2c01c127ad553fdf2a8c18">handler::is_fatal_error</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is used to analyse the error to see whether the error is ignorable or not, certain handlers can have more error that are ignorable than others. E.g. the partition handler can get inserts into a range where there is no partition and this is an ignorable error. HA_ERR_FOUND_DUP_UNIQUE is a special case in MyISAM that means the same thing as HA_ERR_FOUND_DUP_KEY but can in some cases lead to a slightly different error message. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a18e8ff8fce23b0ca305755e60d960cd9">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a176722dc40003b949613f8a6e253445d">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="adda33331aacc500b1b974033cb64a869"></a><!-- doxytag: member="handler::is_fk_defined_on_table_or_index" ref="adda33331aacc500b1b974033cb64a869" args="(uint index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#adda33331aacc500b1b974033cb64a869">handler::is_fk_defined_on_table_or_index</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If index == MAX_KEY then a check for table is made and if index &lt; MAX_KEY then a check is made if the table has foreign keys and if a foreign key uses this index (and thus the index cannot be dropped).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index to check if foreign key uses it</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Foreign key defined on table or index </td></tr>
    <tr><td class="paramname">FALSE</td><td>No foreign key defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13f5a2b8ba9e4b9f9255243f0f1cd525"></a><!-- doxytag: member="handler::lock_count" ref="a13f5a2b8ba9e4b9f9255243f0f1cd525" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint <a class="el" href="classhandler.html#a13f5a2b8ba9e4b9f9255243f0f1cd525">handler::lock_count</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classhandler.html#a13f5a2b8ba9e4b9f9255243f0f1cd525">lock_count()</a> can return &gt; 1 if the table is MERGE or partitioned. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a94af2b65d4d966d480185f2a80009f38">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="aa3a39db9dc1cca31f4a3ec0e0e1d7300"></a><!-- doxytag: member="handler::lock_shared_ha_data" ref="aa3a39db9dc1cca31f4a3ec0e0e1d7300" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#aa3a39db9dc1cca31f4a3ec0e0e1d7300">handler::lock_shared_ha_data</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Take a lock for protecting shared handler data. </p>

</div>
</div>
<a class="anchor" id="a5add40a6cd7088ffef25a3816294b624"></a><!-- doxytag: member="handler::multi_range_read_info" ref="a5add40a6cd7088ffef25a3816294b624" args="(uint keyno, uint n_ranges, uint keys, uint *bufsz, uint *flags, Cost_estimate *cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows <a class="el" href="classhandler.html#a5add40a6cd7088ffef25a3816294b624">handler::multi_range_read_info</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get cost and other information about MRR scan over some sequence of ranges</p>
<p>Calculate estimated cost and other information about an MRR scan for some sequence of ranges.</p>
<p>The ranges themselves will be known only at execution phase. When this function is called we only know number of ranges and a (rough) E(<a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">records</a>) within those ranges.</p>
<p>Currently this function is only called for "n-keypart singlepoint" ranges, i.e. each range is "keypart1=someconst1 AND ... AND keypartN=someconstN"</p>
<p>The flags parameter is a combination of those flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION, HA_MRR_LIMITS.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramname">n_ranges</td><td>Estimated number of ranges (i.e. intervals) in the range sequence. </td></tr>
    <tr><td class="paramname">n_rows</td><td>Estimated total number of records contained within all of the ranges </td></tr>
    <tr><td class="paramname">bufsz</td><td>INOUT IN: Size of the buffer available for use OUT: Size of the buffer that will be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramname">flags</td><td>INOUT A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramname">cost</td><td>OUT Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
    <tr><td class="paramname">other</td><td>Error or can't perform the requested scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ee356d2340552eb121d423fc01597f8"></a><!-- doxytag: member="handler::multi_range_read_info_const" ref="a5ee356d2340552eb121d423fc01597f8" args="(uint keyno, RANGE_SEQ_IF *seq, void *seq_init_param, uint n_ranges, uint *bufsz, uint *flags, Cost_estimate *cost)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ha_rows <a class="el" href="classhandler.html#a5ee356d2340552eb121d423fc01597f8">handler::multi_range_read_info_const</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>keyno</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>bufsz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCost__estimate.html">Cost_estimate</a> *&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get cost and other information about MRR scan over a known list of ranges</p>
<p>Calculate estimated cost and other information about an MRR scan for given sequence of ranges.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">keyno</td><td>Index number </td></tr>
    <tr><td class="paramname">seq</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;<a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init()</a> </td></tr>
    <tr><td class="paramname">n_ranges_arg</td><td>Number of ranges in the sequence, or 0 if the caller can't efficiently determine it </td></tr>
    <tr><td class="paramname">bufsz</td><td>INOUT IN: Size of the buffer available for use OUT: Size of the buffer that is expected to be actually used, or 0 if buffer is not needed. </td></tr>
    <tr><td class="paramname">flags</td><td>INOUT A combination of HA_MRR_* flags </td></tr>
    <tr><td class="paramname">cost</td><td>OUT Estimated cost of MRR access</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This method (or an overriding one in a derived class) must check for thd-&gt;killed and return HA_POS_ERROR if it is not zero. This is required for a user to be able to interrupt the calculation by killing the connection/query.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">HA_POS_ERROR</td><td>Error or the engine is unable to perform the requested scan. Values of OUT parameters are undefined. </td></tr>
    <tr><td class="paramname">other</td><td>OK, *cost contains cost of the scan, *bufsz and *flags contain scan parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33e8899f4bae262b6b91c7284f1d946e"></a><!-- doxytag: member="handler::multi_range_read_init" ref="a33e8899f4bae262b6b91c7284f1d946e" args="(RANGE_SEQ_IF *seq, void *seq_init_param, uint n_ranges, uint mode, HANDLER_BUFFER *buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">handler::multi_range_read_init</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structst__range__seq__if.html">RANGE_SEQ_IF</a> *&#160;</td>
          <td class="paramname"><em>seq_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>seq_init_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>n_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structst__handler__buffer.html">HANDLER_BUFFER</a> *&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the MRR scan</p>
<p>Initialize the MRR scan. This function may do heavyweight scan initialization like row prefetching/sorting/etc (NOTE: but better not do it here as we may not need it, e.g. if we never satisfy WHERE clause on previous tables. For many implementations it would be natural to do such initializations in the first multi_read_range_next() call)</p>
<p>mode is a combination of the following flags: HA_MRR_SORTED, HA_MRR_INDEX_ONLY, HA_MRR_NO_ASSOCIATION</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq</td><td>Range sequence to be traversed </td></tr>
    <tr><td class="paramname">seq_init_param</td><td>First parameter for seq-&gt;<a class="el" href="classhandler.html#ab1ad6edb66592b200a7c7ac0f947dc66">init()</a> </td></tr>
    <tr><td class="paramname">n_ranges</td><td>Number of ranges in the sequence </td></tr>
    <tr><td class="paramname">mode</td><td>Flags, see the description section for the details </td></tr>
    <tr><td class="paramname">buf</td><td>INOUT: memory buffer to be used</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>One must have called index_init() before calling this function. Several <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init()</a> calls may be made in course of one query.</dd></dl>
<p>Until WL#2623 is done (see its text, section 3.2), the following will also hold: The caller will guarantee that if "seq-&gt;init == mrr_ranges_array_init" then seq_init_param is an array of n_ranges KEY_MULTI_RANGE structures. This property will only be used by NDB handler until WL#2623 is done.</p>
<p>Buffer memory management is done according to the following scenario: The caller allocates the buffer and provides it to the callee by filling the members of HANDLER_BUFFER structure. The callee consumes all or some fraction of the provided buffer space, and sets the HANDLER_BUFFER members accordingly. The callee may use the buffer memory until the next <a class="el" href="classhandler.html#a33e8899f4bae262b6b91c7284f1d946e">multi_range_read_init()</a> call is made, all records have been read, or until index_end() call is made, whichever comes first.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3419071f3d4abf183dac95ef565adfff"></a><!-- doxytag: member="handler::multi_range_read_next" ref="a3419071f3d4abf183dac95ef565adfff" args="(char **range_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a3419071f3d4abf183dac95ef565adfff">handler::multi_range_read_next</a> </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>range_info</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get next record in MRR scan</p>
<p>Default MRR implementation: read the next record</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">range_info</td><td>OUT Undefined if HA_MRR_NO_ASSOCIATION flag is in effect Otherwise, the opaque value associated with the range that contains the returned record.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">other</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26aaaf2105e60ca590b79fae82e48960"></a><!-- doxytag: member="handler::notify_table_changed" ref="a26aaaf2105e60ca590b79fae82e48960" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">handler::notify_table_changed</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify the storage engine that the table structure (.FRM) has been updated.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>No errors are allowed during <a class="el" href="classhandler.html#a26aaaf2105e60ca590b79fae82e48960">notify_table_changed()</a>. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a4350de763daa055bf18a26267664bda2">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a243ce6f51c5538c6d1dae81db1bb1658"></a><!-- doxytag: member="handler::number_of_pushed_joins" ref="a243ce6f51c5538c6d1dae81db1bb1658" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint <a class="el" href="classhandler.html#a243ce6f51c5538c6d1dae81db1bb1658">handler::number_of_pushed_joins</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reports #tables included in pushed join which this handler instance is part of. ==0 -&gt; Not pushed </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a0659ab063c018e687c3d25a1b9a6352b">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a915706fa5bb7e07752cc2d89ec467977"></a><!-- doxytag: member="handler::parent_of_pushed_join" ref="a915706fa5bb7e07752cc2d89ec467977" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="classhandler.html#a915706fa5bb7e07752cc2d89ec467977">handler::parent_of_pushed_join</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this handler instance is a child in a pushed join sequence returned <a class="el" href="structTABLE.html">TABLE</a> instance being my parent? </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#aa53823a45dfd6e3f1cd372c65a9486bc">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="ab25b3931a457f1821ba55ae9cce79d98"></a><!-- doxytag: member="handler::prepare_inplace_alter_table" ref="ab25b3931a457f1821ba55ae9cce79d98" args="(TABLE *altered_table, Alter_inplace_info *ha_alter_info)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">handler::prepare_inplace_alter_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>altered_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAlter__inplace__info.html">Alter_inplace_info</a> *&#160;</td>
          <td class="paramname"><em>ha_alter_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows the storage engine to update internal structures with concurrent writes blocked. If <a class="el" href="classhandler.html#a67890a9deb89b9ef0128601e7687fcba">check_if_supported_inplace_alter()</a> returns HA_ALTER_INPLACE_NO_LOCK_AFTER_PREPARE or HA_ALTER_INPLACE_SHARED_AFTER_PREPARE, this function is called with exclusive lock otherwise the same level of locking as for <a class="el" href="classhandler.html#a90b4c3a8fe1c89c6ccfec1f4b144754a">inplace_alter_table()</a> will be used.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Storage engines are responsible for reporting any errors by calling my_error()/print_error()</dd>
<dd>
If this function reports error, <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called with commit= false.</dd>
<dd>
For partitioning, failing to prepare one partition, means that <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> will be called to roll back changes for all partitions. This means that <a class="el" href="classhandler.html#a0786a5f57ccd3c97bff07b1afeae9c06">commit_inplace_alter_table()</a> might be called without <a class="el" href="classhandler.html#ab25b3931a457f1821ba55ae9cce79d98">prepare_inplace_alter_table()</a> having been called first for a given partition.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">altered_table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for new version of table. </td></tr>
    <tr><td class="paramname">ha_alter_info</td><td>Structure describing changes to be done by ALTER <a class="el" href="structTABLE.html">TABLE</a> and holding data used during in-place alter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Error </td></tr>
    <tr><td class="paramname">false</td><td>Success </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a60893ae5e2153faa3f35ffde0460d9d6">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="afda4f1390385a4dc0bfd2981fee23e6c"></a><!-- doxytag: member="handler::print_error" ref="afda4f1390385a4dc0bfd2981fee23e6c" args="(int error, myf errflag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#afda4f1390385a4dc0bfd2981fee23e6c">handler::print_error</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">myf&#160;</td>
          <td class="paramname"><em>errflag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Print error that we got from handler function.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In case of delete table it's only safe to use the following parts of the 'table' structure:<ul>
<li>table-&gt;s-&gt;path</li>
<li>table-&gt;alias </li>
</ul>
</dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#afbddb8246029958806a6078b3ea71b32">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#ab4b4b9ed3726be8a4a0887785a5ed530">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="aff50b704d53d715d6b0fd3534c6107d8"></a><!-- doxytag: member="handler::read_first_row" ref="aff50b704d53d715d6b0fd3534c6107d8" args="(uchar *buf, uint primary_key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#aff50b704d53d715d6b0fd3534c6107d8">handler::read_first_row</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>primary_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read first row (only) from a table.</p>
<p>This is never called for InnoDB tables, as these table types has the HA_STATS_RECORDS_IS_EXACT set. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a184b8fcfc296599d9a82b0d36444ec30">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a3a0d596ff3ddc77b4f0ad990c4c4cb4b"></a><!-- doxytag: member="handler::read_range_first" ref="a3a0d596ff3ddc77b4f0ad990c4c4cb4b" args="(const key_range *start_key, const key_range *end_key, bool eq_range, bool sorted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a3a0d596ff3ddc77b4f0ad990c4c4cb4b">handler::read_range_first</a> </td>
          <td>(</td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>start_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>end_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>eq_range_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read first row between two ranges. Store ranges for future calls to read_range_next. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">start_key</td><td>Start key. Is 0 if no min range </td></tr>
    <tr><td class="paramname">end_key</td><td>End key. Is 0 if no max range </td></tr>
    <tr><td class="paramname">eq_range_arg</td><td>Set to 1 if start_key == end_key </td></tr>
    <tr><td class="paramname">sorted</td><td>Set to 1 if result should be sorted per key</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname">\::</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#aa0217cd2a331904f87fbfcbe4dde5800">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a4ebf9b2b84870f08b62e5e3f5465aae8">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="ae4632aa56c9c66a57558f849f8e01271"></a><!-- doxytag: member="handler::read_range_next" ref="ae4632aa56c9c66a57558f849f8e01271" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#ae4632aa56c9c66a57558f849f8e01271">handler::read_range_next</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read next row between two endpoints. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Record is read into table-&gt;record[0]</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Found row </td></tr>
    <tr><td class="paramname">HA_ERR_END_OF_FILE</td><td>No rows in range </td></tr>
    <tr><td class="paramname">\::</td><td>Error code </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#ae77ce0688d4d2c0451dcb930e6ca42bc">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#ac4ca12e4aa287eaf6a50c43219a1c776">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a061b519fb16fbff126b0e21530973c2e"></a><!-- doxytag: member="handler::read_time" ref="a061b519fb16fbff126b0e21530973c2e" args="(uint index, uint ranges, ha_rows rows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual double <a class="el" href="classhandler.html#a061b519fb16fbff126b0e21530973c2e">handler::read_time</a> </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ha_rows&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The cost of reading a set of ranges from the table using an index to access it.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index number. </td></tr>
    <tr><td class="paramname">ranges</td><td>The number of ranges to be read. </td></tr>
    <tr><td class="paramname">rows</td><td>Total number of rows to be read.</td></tr>
  </table>
  </dd>
</dl>
<p>This method can be used to calculate the total cost of scanning a table using an index by calling it using read_time(index, 1, table_size). </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#ae2cd9274cdcf243f53efc8c236bb8379">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a85c1bde4ae61f0aee31d241b0821369c"></a><!-- doxytag: member="handler::records" ref="a85c1bde4ae61f0aee31d241b0821369c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ha_rows <a class="el" href="classhandler.html#a85c1bde4ae61f0aee31d241b0821369c">handler::records</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of rows in table. It will only be called if (table_flags() &amp; (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT)) != 0 </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#ada684ff4029d92f8b693952ccb780948">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#afbffd5437c38bf4be8e08e1797324711">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a2ec87bfd95b71d14fafbb3f88569094f"></a><!-- doxytag: member="handler::register_query_cache_table" ref="a2ec87bfd95b71d14fafbb3f88569094f" args="(THD *thd, char *table_key, uint key_length, qc_engine_callback *engine_callback, ulonglong *engine_data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual my_bool <a class="el" href="classhandler.html#a2ec87bfd95b71d14fafbb3f88569094f">handler::register_query_cache_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">qc_engine_callback *&#160;</td>
          <td class="paramname"><em>engine_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulonglong *&#160;</td>
          <td class="paramname"><em>engine_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Register a named table with a call back function to the query cache. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>The thread handle </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table_key</td><td>A pointer to the table name in the table cache </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_length</td><td>The length of the table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_callback</td><td>The pointer to the storage engine call back function </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">engine_data</td><td>Storage engine specific data which could be anything</td></tr>
  </table>
  </dd>
</dl>
<p>This method offers the storage engine, the possibility to store a reference to a table name which is going to be used with query cache. The method is called each time a statement is written to the cache and can be used to verify if a specific statement is cachable. It also offers the possibility to register a generic (but static) call back function which is called each time a statement is matched against the query cache.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If engine_data supplied with this function is different from engine_data supplied with the callback function, and the callback returns FALSE, a table invalidation on the current table will occur.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Upon success the engine_callback will point to the storage engine call back function, if any, and engine_data will point to any storage engine data used in the specific implementation. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Success </td></tr>
    <tr><td class="paramname">FALSE</td><td>The specified table or current statement should not be cached </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a4673b0434ccbcd97542e1f7636d61db2">ha_partition</a>, and <a class="el" href="classha__ndbcluster.html#a678f400a15ca14442e0ad11c39748de0">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a58bf8fa32d87654794e6b1c3b3fb8d32"></a><!-- doxytag: member="handler::rename_table" ref="a58bf8fa32d87654794e6b1c3b3fb8d32" args="(const char *from, const char *to)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">handler::rename_table</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default <a class="el" href="classhandler.html#a58bf8fa32d87654794e6b1c3b3fb8d32">rename_table()</a> and <a class="el" href="classhandler.html#ae53ec34116b901cc08e5a87f5ec681a6">delete_table()</a> rename/delete files with a given name and extensions from <a class="el" href="classhandler.html#a748d5e5b6dbbb0681cbac2ad881505c9">bas_ext()</a>.</p>
<p>These methods can be overridden, but their default implementation provide useful functionality. </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a5609bf8b91966dacc3610fc7ceffc314">ha_ndbcluster</a>, and <a class="el" href="classha__partition.html#a7dbc26903dfbc0128c0d5a7e68d3681b">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a27e343a6e97ad5264e1fe5a70659899f"></a><!-- doxytag: member="handler::reset_auto_increment" ref="a27e343a6e97ad5264e1fe5a70659899f" args="(ulonglong value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#a27e343a6e97ad5264e1fe5a70659899f">handler::reset_auto_increment</a> </td>
          <td>(</td>
          <td class="paramtype">ulonglong&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the auto-increment counter to the given value, i.e. the next row inserted will get the given value. HA_ERR_WRONG_COMMAND is returned by storage engines that don't support this operation. </p>

</div>
</div>
<a class="anchor" id="a730672727f9ad989e80f3732eb838a10"></a><!-- doxytag: member="handler::restart_rnd_next" ref="a730672727f9ad989e80f3732eb838a10" args="(uchar *buf, uchar *pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#a730672727f9ad989e80f3732eb838a10">handler::restart_rnd_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The following function is only needed for tables that may be temporary tables during joins. </p>

</div>
</div>
<a class="anchor" id="a48cb9c94ca93dbfbb7e92822caba82a1"></a><!-- doxytag: member="handler::rnd_next" ref="a48cb9c94ca93dbfbb7e92822caba82a1" args="(uchar *buf)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#a48cb9c94ca93dbfbb7e92822caba82a1">handler::rnd_next</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implemented in <a class="el" href="classha__partition.html#ad468c67dd2f37885994530f9e2ad2266">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#adc93bae43a800cc5ba5057b306136de1">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#aafb71ce870019170b8949672a26387c3">ha_ndbinfo</a>.</p>

</div>
</div>
<a class="anchor" id="adf659edd9d870e90c8974ae0eba7a082"></a><!-- doxytag: member="handler::rnd_pos" ref="adf659edd9d870e90c8974ae0eba7a082" args="(uchar *buf, uchar *pos)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#adf659edd9d870e90c8974ae0eba7a082">handler::rnd_pos</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classhandler.html#af8c2b258691e5baac8dd22d19c084b37" title="Positions an index cursor to the index specified in the handle (&#39;active_index&#39;). Fetches the row if a...">index_read_map()</a>. </dd></dl>

<p>Implemented in <a class="el" href="classha__partition.html#a7b052173ced1b88687dafba28a170335">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a8980053ce56e386ced321a1ad88d1cc2">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#a3c82928e6d10f1e83b118cc6fa7ce088">ha_ndbinfo</a>.</p>

</div>
</div>
<a class="anchor" id="ac2be2fa5d347252f8a28dce931654b76"></a><!-- doxytag: member="handler::rnd_pos_by_record" ref="ac2be2fa5d347252f8a28dce931654b76" args="(uchar *record)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#ac2be2fa5d347252f8a28dce931654b76">handler::rnd_pos_by_record</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>record</em></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function only works for handlers having HA_PRIMARY_KEY_REQUIRED_FOR_POSITION set. It will return the row with the PK given in the record argument. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a58bbc7153fa41de3b53872cb8f4b4e6e">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="ae1bf0cbd806508954db72a5707732ee6"></a><!-- doxytag: member="handler::root_of_pushed_join" ref="ae1bf0cbd806508954db72a5707732ee6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="classhandler.html#ae1bf0cbd806508954db72a5707732ee6">handler::root_of_pushed_join</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If this handler instance is part of a pushed join sequence returned <a class="el" href="structTABLE.html">TABLE</a> instance being root of the pushed query? </p>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a0e13f467924c64f4929dc6db8b9d1dd3">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a4b7dfb95a0da2e828ac018aa2b4abe3a"></a><!-- doxytag: member="handler::set_end_range" ref="a4b7dfb95a0da2e828ac018aa2b4abe3a" args="(const key_range *range, enum_range_scan_direction direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#a4b7dfb95a0da2e828ac018aa2b4abe3a">handler::set_end_range</a> </td>
          <td>(</td>
          <td class="paramtype">const key_range *&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_range_scan_direction&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the end position for a range scan. This is used for checking for when to end the range scan and by the ICP code to determine that the next record is within the current range.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The end value for the range scan </td></tr>
    <tr><td class="paramname">direction</td><td>Direction of the range scan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab24470ac1d4ac336cedbe7c245d321c9"></a><!-- doxytag: member="handler::set_ha_share_ptr" ref="ab24470ac1d4ac336cedbe7c245d321c9" args="(Handler_share *arg_ha_share)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#ab24470ac1d4ac336cedbe7c245d321c9">handler::set_ha_share_ptr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classHandler__share.html">Handler_share</a> *&#160;</td>
          <td class="paramname"><em>arg_ha_share</em></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set ha_share to be used by all instances of the same table/partition.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ha_share</td><td><a class="el" href="classHandler__share.html">Handler_share</a> to be shared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If not a temp table, then LOCK_ha_data must be held. </dd></dl>

</div>
</div>
<a class="anchor" id="acdaf7319a6498f655f8f07b1b34b12fc"></a><!-- doxytag: member="handler::start_bulk_delete" ref="acdaf7319a6498f655f8f07b1b34b12fc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#acdaf7319a6498f655f8f07b1b34b12fc">handler::start_bulk_delete</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Bulk delete used by handler </td></tr>
    <tr><td class="paramname">1</td><td>Bulk delete not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7488245f51aa4676c872bb0564dbe71f"></a><!-- doxytag: member="handler::start_bulk_update" ref="a7488245f51aa4676c872bb0564dbe71f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a7488245f51aa4676c872bb0564dbe71f">handler::start_bulk_update</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Bulk update used by handler </td></tr>
    <tr><td class="paramname">1</td><td>Bulk update not used, normal operation used </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#aa852a48bce2fe6fbbe70b83022d74ed2">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a3e2428788c2437e4e33c4b390cc697f7"></a><!-- doxytag: member="handler::start_read_removal" ref="a3e2428788c2437e4e33c4b390cc697f7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a3e2428788c2437e4e33c4b390cc697f7">handler::start_read_removal</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start read (before write) removal on the current table. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>HA_READ_BEFORE_WRITE_REMOVAL </dd></dl>

<p>Reimplemented in <a class="el" href="classha__ndbcluster.html#a55b76e2e6595d838981a54951aa3f002">ha_ndbcluster</a>.</p>

</div>
</div>
<a class="anchor" id="a2502e460566f2c4b506cc1b30eb79e0a"></a><!-- doxytag: member="handler::store_lock" ref="a2502e460566f2c4b506cc1b30eb79e0a" args="(THD *thd, THR_LOCK_DATA **to, enum thr_lock_type lock_type)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual THR_LOCK_DATA** <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">handler::store_lock</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THR_LOCK_DATA **&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Is not invoked for non-transactional temporary tables.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a> can return more than one lock if the table is MERGE or partitioned.</dd>
<dd>
that one can NOT rely on table-&gt;in_use in <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a>. It may refer to a different thread if called from <a class="el" href="group__Locking.html#ga321511c56502643e5aecbe6ed3e43b58">mysql_lock_abort_for_thread()</a>.</dd>
<dd>
If the table is MERGE, <a class="el" href="classhandler.html#a2502e460566f2c4b506cc1b30eb79e0a">store_lock()</a> can return less locks than <a class="el" href="classhandler.html#a13f5a2b8ba9e4b9f9255243f0f1cd525">lock_count()</a> claimed. This can happen when the MERGE children are not attached when this is called from another thread. </dd></dl>

<p>Implemented in <a class="el" href="classha__partition.html#a590ff604823725a59b5b7dd1fa83ac35">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#a66a20a04ade6a21ac16a81c12d021659">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#a7169a09db353528ca14a979b01e56eb6">ha_ndbinfo</a>.</p>

</div>
</div>
<a class="anchor" id="ab4d7cf309121ec10e4150860c8caa12a"></a><!-- doxytag: member="handler::table_cache_type" ref="ab4d7cf309121ec10e4150860c8caa12a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint8 <a class="el" href="classhandler.html#ab4d7cf309121ec10e4150860c8caa12a">handler::table_cache_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Type of table for caching query </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a2b4f4002504f73ed3ae195729b95603b">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#ac3a23eb89230938663a59fcf8fbe908b">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#ab23949e133485226e2c90e78eb914b60">ha_ndbinfo</a>.</p>

</div>
</div>
<a class="anchor" id="ad38f5d3f1e026a0af32b5542aa5ac2f9"></a><!-- doxytag: member="handler::table_type" ref="ad38f5d3f1e026a0af32b5542aa5ac2f9" args="() const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classhandler.html#ad38f5d3f1e026a0af32b5542aa5ac2f9">handler::table_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The following can be called without an open handler </p>

<p>Implemented in <a class="el" href="classha__partition.html#a4cb39c8b7ba6dabe242f3205c86f59f2">ha_partition</a>, <a class="el" href="classha__ndbcluster.html#aa545546481cd90b1ea4564229d65034c">ha_ndbcluster</a>, and <a class="el" href="classha__ndbinfo.html#ac6f433f95702fd10c14ba81b34f2fd6e">ha_ndbinfo</a>.</p>

</div>
</div>
<a class="anchor" id="a13fdf15d81c256d3e6a9643532ff2126"></a><!-- doxytag: member="handler::truncate" ref="a13fdf15d81c256d3e6a9643532ff2126" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classhandler.html#a13fdf15d81c256d3e6a9643532ff2126">handler::truncate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Quickly remove all rows from a table.</p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>This method is responsible for implementing MySQL's TRUNCATE <a class="el" href="structTABLE.html">TABLE</a> statement, which is a DDL operation. As such, a engine can bypass certain integrity checks and in some cases avoid fine-grained locking (e.g. row locks) which would normally be required for a DELETE statement.</dd>
<dd>
Typically, truncate is not used if it can result in integrity violation. For example, truncate is not used when a foreign key references the table, but it might be used if foreign key checks are disabled.</dd>
<dd>
Engine is responsible for resetting the auto-increment counter.</dd>
<dd>
The table is locked in exclusive mode. </dd></dl>

<p>Reimplemented in <a class="el" href="classha__partition.html#a42819e5cf989a23c0ade56feece2bcf4">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="ab3e767094bff139a26743e9314df8476"></a><!-- doxytag: member="handler::try_semi_consistent_read" ref="ab3e767094bff139a26743e9314df8476" args="(bool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classhandler.html#ab3e767094bff139a26743e9314df8476">handler::try_semi_consistent_read</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Tell the engine whether it should avoid unnecessary lock waits. If yes, in an UPDATE or DELETE, if the row under the cursor was locked by another transaction, the engine may try an optimistic read of the last committed row value under the cursor. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a45235c1c364a4b1ac4a2b97134f7a4b4">ha_partition</a>.</p>

</div>
</div>
<a class="anchor" id="a8059bbed3de416b3bea51c69dc064e79"></a><!-- doxytag: member="handler::unlock_shared_ha_data" ref="a8059bbed3de416b3bea51c69dc064e79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#a8059bbed3de416b3bea51c69dc064e79">handler::unlock_shared_ha_data</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release lock for protecting ha_share. </p>

</div>
</div>
<a class="anchor" id="adac21f2d10c4463fb1d7e14882c6314f"></a><!-- doxytag: member="handler::use_hidden_primary_key" ref="adac21f2d10c4463fb1d7e14882c6314f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">handler::use_hidden_primary_key</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classhandler.html#adac21f2d10c4463fb1d7e14882c6314f">use_hidden_primary_key()</a> is called in case of an update/delete when (table_flags() and HA_PRIMARY_KEY_REQUIRED_FOR_DELETE) is defined but we don't have a primary key </p>

</div>
</div>
<a class="anchor" id="a54d92f647a4ca5a3b7867fa5538242a6"></a><!-- doxytag: member="handler::was_semi_consistent_read" ref="a54d92f647a4ca5a3b7867fa5538242a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classhandler.html#a54d92f647a4ca5a3b7867fa5538242a6">handler::was_semi_consistent_read</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In an UPDATE or DELETE, if the row under the cursor was locked by another transaction, and the engine used an optimistic read of the last committed row value under the cursor, then the engine returns 1 from this function. MySQL must NOT try to update this optimistic value. If the optimistic value does not match the WHERE condition, MySQL can decide to skip over this row. Currently only works for InnoDB. This can be used to avoid unnecessary lock waits.</p>
<p>If this method returns nonzero, it will also signal the storage engine that the next read will be a locking re-read of the row. </p>

<p>Reimplemented in <a class="el" href="classha__partition.html#a2a059c1ac08f3cd71b7087b876664e18">ha_partition</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a1540a47a05c03724f1102aaaa623131e"></a><!-- doxytag: member="handler::auto_inc_interval_for_cur_row" ref="a1540a47a05c03724f1102aaaa623131e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDiscrete__interval.html">Discrete_interval</a> <a class="el" href="classhandler.html#a1540a47a05c03724f1102aaaa623131e">handler::auto_inc_interval_for_cur_row</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Interval returned by <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a> and being consumed by the inserter. </p>

</div>
</div>
<a class="anchor" id="acdfcef0738a89138c8f41ded8da17c0a"></a><!-- doxytag: member="handler::auto_inc_intervals_count" ref="acdfcef0738a89138c8f41ded8da17c0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="classhandler.html#acdfcef0738a89138c8f41ded8da17c0a">handler::auto_inc_intervals_count</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of reserved auto-increment intervals. Serves as a heuristic when we have no estimation of how many records the statement will insert: the more intervals we have reserved, the bigger the next one. Reset in handler::ha_release_auto_increment(). </p>

</div>
</div>
<a class="anchor" id="a05dd2cafd83ae60562649bf9688aebf1"></a><!-- doxytag: member="handler::insert_id_for_cur_row" ref="a05dd2cafd83ae60562649bf9688aebf1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong <a class="el" href="classhandler.html#a05dd2cafd83ae60562649bf9688aebf1">handler::insert_id_for_cur_row</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>insert id for the current row (*autogenerated*; if not autogenerated, it's 0). At first successful insertion, this variable is stored into THD::first_successful_insert_id_in_cur_stmt. </p>

</div>
</div>
<a class="anchor" id="a881e7cba3fe3bf9731a91be82983cc35"></a><!-- doxytag: member="handler::m_psi" ref="a881e7cba3fe3bf9731a91be82983cc35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PSI_table* <a class="el" href="classhandler.html#a881e7cba3fe3bf9731a91be82983cc35">handler::m_psi</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instrumented table associated with this handler. This member should be set to NULL when no instrumentation is in place, so that linking an instrumented/non instrumented server/plugin works. For example:</p>
<ul>
<li>the server is compiled with the instrumentation. The server expects either NULL or valid pointers in m_psi.</li>
<li>an engine plugin is compiled without instrumentation. The plugin can not leave this pointer uninitialized, or can not leave a trash value on purpose in this pointer, as this would crash the server. </li>
</ul>

</div>
</div>
<a class="anchor" id="a62ab295e407d8a5c50087fed0f4fcd18"></a><!-- doxytag: member="handler::next_insert_id" ref="a62ab295e407d8a5c50087fed0f4fcd18" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong <a class="el" href="classhandler.html#a62ab295e407d8a5c50087fed0f4fcd18">handler::next_insert_id</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>next_insert_id is the next value which should be inserted into the auto_increment column: in a inserting-multi-row statement (like INSERT SELECT), for the first row where the autoinc value is not specified by the statement, <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a> called and asked to generate a value, next_insert_id is set to the next value, then for all other rows next_insert_id is used (and increased each time) without calling <a class="el" href="classhandler.html#aaf6af760a4ef09984a5cc1dc58db9a40">get_auto_increment()</a>. </p>

</div>
</div>
<a class="anchor" id="a64def328ff0ca7e391b217c2d3a758ec"></a><!-- doxytag: member="handler::ref_length" ref="a64def328ff0ca7e391b217c2d3a758ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="classhandler.html#a64def328ff0ca7e391b217c2d3a758ec">handler::ref_length</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Length of ref (1-8 or the clustered key length) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="handler_8h_source.html">handler.h</a></li>
<li><a class="el" href="handler_8cc.html">handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:35:45 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
