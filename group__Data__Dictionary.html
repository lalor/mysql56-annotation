<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: Data Dictionary</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Data Dictionary</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__deadlock__handler.html">MDL_deadlock_handler</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMDL__deadlock__discovery__repair__handler.html">MDL_deadlock_discovery_repair_handler</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9103f1fde040b45e171c6df146d812f1"></a><!-- doxytag: member="Data_Dictionary::WRONG_GRANT" ref="ga9103f1fde040b45e171c6df146d812f1" args="" -->
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WRONG_GRANT</b>&#160;&#160;&#160;(<a class="el" href="classField.html">Field</a>*) -1</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga352a69aae26f998d4cbbf1d1d4937349">get_table_def_key</a> (const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char **key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae612f5e3d874864273e839029d1da07c"></a><!-- doxytag: member="Data_Dictionary::table_def_key" ref="gae612f5e3d874864273e839029d1da07c" args="(const uchar *record, size_t *length, my_bool not_used __attribute__((unused)))" -->
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_key</b> (const uchar *record, size_t *length, my_bool not_used __attribute__((unused)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad9f57ec544a178c11c18d6900e2dcf6c"></a><!-- doxytag: member="Data_Dictionary::table_def_init" ref="gad9f57ec544a178c11c18d6900e2dcf6c" args="(void)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_init</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gabb94e7a0682741b06d662be41fae480f">table_def_start_shutdown</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b09d5446051abdac04bf96a4d6a0c12"></a><!-- doxytag: member="Data_Dictionary::table_def_free" ref="ga8b09d5446051abdac04bf96a4d6a0c12" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_free</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb76a30ed423c4cb98689fcedae48c60"></a><!-- doxytag: member="Data_Dictionary::cached_table_definitions" ref="gabb76a30ed423c4cb98689fcedae48c60" args="(void)" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>cached_table_definitions</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga29a949628c076eb6e613b819c5359e23"></a><!-- doxytag: member="Data_Dictionary::get_table_share" ref="ga29a949628c076eb6e613b819c5359e23" args="(THD *thd, TABLE_LIST *table_list, const char *key, uint key_length, uint db_flags, int *error, my_hash_value_type hash_value)" -->
<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_table_share</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *key, uint key_length, uint db_flags, int *error, my_hash_value_type hash_value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0f27eb7444d2cec48296785a54e229f2">release_table_share</a> (<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0da69eeda10a9b209a7daccf71afeb48"></a><!-- doxytag: member="Data_Dictionary::get_cached_table_share" ref="ga0da69eeda10a9b209a7daccf71afeb48" args="(const char *db, const char *table_name)" -->
<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_cached_table_share</b> (const char *db, const char *table_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54b0693677aeecf9a38e98f36d3d31eb"></a><!-- doxytag: member="Data_Dictionary::list_open_tables" ref="ga54b0693677aeecf9a38e98f36d3d31eb" args="(THD *thd, const char *db, const char *wild)" -->
<a class="el" href="structst__open__table__list.html">OPEN_TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>list_open_tables</b> (THD *thd, const char *db, const char *wild)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaff2849c2d4c8cec7a89054e0033a8707"></a><!-- doxytag: member="Data_Dictionary::intern_close_table" ref="gaff2849c2d4c8cec7a89054e0033a8707" args="(TABLE *table)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>intern_close_table</b> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga055df8e4470e8dfd7f8b41f4402f6774"></a><!-- doxytag: member="Data_Dictionary::free_io_cache" ref="ga055df8e4470e8dfd7f8b41f4402f6774" args="(TABLE *table)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_io_cache</b> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8504b9f30ae84e60749639a2d03bc0d0"></a><!-- doxytag: member="Data_Dictionary::close_cached_tables" ref="ga8504b9f30ae84e60749639a2d03bc0d0" args="(THD *thd, TABLE_LIST *tables, bool wait_for_refresh, ulong timeout)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>close_cached_tables</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, bool wait_for_refresh, ulong timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab247c23689b3ce8b377cde2cbc0e47ef">close_cached_connection_tables</a> (THD *thd, LEX_STRING *connection)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae2cc536b80faf27a1017cf4ddcc988ad">mark_tmp_table_for_reuse</a> (<a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga86713fadf907edf57606406a10c1f994">close_all_tables_for_name</a> (THD *thd, <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, bool remove_from_locked_tables, <a class="el" href="structTABLE.html">TABLE</a> *skip_table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ded5accefd985fce6ed115038ea92f7"></a><!-- doxytag: member="Data_Dictionary::close_thread_tables" ref="ga3ded5accefd985fce6ed115038ea92f7" args="(THD *thd)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_thread_tables</b> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac52b8d7410875b0048421f9386b4b6bd"></a><!-- doxytag: member="Data_Dictionary::close_thread_table" ref="gac52b8d7410875b0048421f9386b4b6bd" args="(THD *thd, TABLE **table_ptr)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_thread_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> **table_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa4991367acddcb2b2a0edeb169029917"></a><!-- doxytag: member="Data_Dictionary::close_temporary_tables" ref="gaa4991367acddcb2b2a0edeb169029917" args="(THD *thd)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary_tables</b> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga98920037a85177667356d2364893271d"></a><!-- doxytag: member="Data_Dictionary::find_table_in_list" ref="ga98920037a85177667356d2364893271d" args="(TABLE_LIST *table, TABLE_LIST *TABLE_LIST::*link, const char *db_name, const char *table_name)" -->
<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_table_in_list</b> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *TABLE_LIST::*link, const char *db_name, const char *table_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga5095dfc37db0400dbc6cb9f5efb38951">unique_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool check_alias)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa62ea49fa4b58a38f20af4754928e1be"></a><!-- doxytag: member="Data_Dictionary::update_non_unique_table_error" ref="gaa62ea49fa4b58a38f20af4754928e1be" args="(TABLE_LIST *update, const char *operation, TABLE_LIST *duplicate)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_non_unique_table_error</b> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *update, const char *operation, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *duplicate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0734400e8b6f0dab464f0da0f177086b">find_temporary_table</a> (THD *thd, const char *db, const char *table_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4d31aeecf54e9bf14d05fa8a6478b7e0">find_temporary_table</a> (THD *thd, const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga16b087bb99ab090df96292f53805138c">find_temporary_table</a> (THD *thd, const char *table_key, uint table_key_length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab5683a94b25579c456f2c9f55f9f9b35">drop_temporary_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *is_trans)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga62f62c19b7f434d061bee6a75402aca1"></a><!-- doxytag: member="Data_Dictionary::close_temporary_table" ref="ga62f62c19b7f434d061bee6a75402aca1" args="(THD *thd, TABLE *table, bool free_share, bool delete_table)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, bool free_share, bool delete_table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4998a4b0d6b30f4f9669a8c1169ef41d"></a><!-- doxytag: member="Data_Dictionary::close_temporary" ref="ga4998a4b0d6b30f4f9669a8c1169ef41d" args="(TABLE *table, bool free_share, bool delete_table)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_temporary</b> (<a class="el" href="structTABLE.html">TABLE</a> *table, bool free_share, bool delete_table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1f79c4227effeafa7bad8b4582682e9a"></a><!-- doxytag: member="Data_Dictionary::rename_temporary_table" ref="ga1f79c4227effeafa7bad8b4582682e9a" args="(THD *thd, TABLE *table, const char *db, const char *table_name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>rename_temporary_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const char *db, const char *table_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac19a8c14e089f35b82dc7a2ded67ea4b">wait_while_table_is_used</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, enum ha_extra_function function)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac9f2e6710ec001734614f4a11cde9f0f">drop_open_table</a> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const char *db_name, const char *table_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga0f7967950b623499bad7a7fc81612e16">check_if_table_exists</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table, bool *exists)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <a class="el" href="classOpen__table__context.html">Open_table_context</a> *ot_ctx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4458592b1c4d9ed293e5b2033349c3fb">find_locked_table</a> (<a class="el" href="structTABLE.html">TABLE</a> *list, const char *db, const char *table_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8692f5ebd7f6483f1dcc576eb2346f52">find_table_for_mdl_upgrade</a> (THD *thd, const char *db, const char *table_name, bool no_error)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga098cb47bbc8bbdb790fcf28c253ab2b6"></a><!-- doxytag: member="Data_Dictionary::assign_new_table_id" ref="ga098cb47bbc8bbdb790fcf28c253ab2b6" args="(TABLE_SHARE *share)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>assign_new_table_id</b> (<a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga97a6db70d8b4bedd682115942e96b09e">tdc_open_view</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *alias, const char *cache_key, uint cache_key_length, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24fe4cc1a004bb6b5f07556a182f945b"></a><!-- doxytag: member="Data_Dictionary::read_lock_type_for_table" ref="ga24fe4cc1a004bb6b5f07556a182f945b" args="(THD *thd, Query_tables_list *prelocking_ctx, TABLE_LIST *table_list, bool routine_modifies_data)" -->
thr_lock_type&#160;</td><td class="memItemRight" valign="bottom"><b>read_lock_type_for_table</b> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool routine_modifies_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae5c019d8ad6321d2bdb56aa234a19e35"></a><!-- doxytag: member="Data_Dictionary::schema_set_get_key" ref="gae5c019d8ad6321d2bdb56aa234a19e35" args="(const uchar *record, size_t *length, my_bool not_used __attribute__((unused)))" -->
uchar *&#160;</td><td class="memItemRight" valign="bottom"><b>schema_set_get_key</b> (const uchar *record, size_t *length, my_bool not_used __attribute__((unused)))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gae06de7ce22001b035ca61edf2a3dea09">lock_table_names</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_start, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables_end, ulong lock_wait_timeout, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **start, uint *counter, uint flags, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga86a68932d1c35b3fd820c99d185d7888">open_n_lock_single_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_l, thr_lock_type lock_type, uint flags, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Open and lock one table.  <a href="#ga86a68932d1c35b3fd820c99d185d7888"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3b5263e110baf47c9fe2f820bc649be5"></a><!-- doxytag: member="Data_Dictionary::open_ltable" ref="ga3b5263e110baf47c9fe2f820bc649be5" args="(THD *thd, TABLE_LIST *table_list, thr_lock_type lock_type, uint lock_flags)" -->
<a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>open_ltable</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, thr_lock_type lock_type, uint lock_flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga38f8435e686a352b75b449c7bcd4c82c">open_and_lock_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, bool derived, uint flags, <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *prelocking_strategy)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga258e3d35dfa1dbef9586f6f3d6a76326">open_normal_and_derived_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, uint count, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga92bec964ecaaa7270a429e664643b746">close_tables_for_reopen</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **tables, const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;start_of_statement_svp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga35659d6f0f8a6d39ee3f3db7c233df52">open_table_uncached</a> (THD *thd, const char *path, const char *db, const char *table_name, bool add_to_temporary_tables_list, bool open_in_engine)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga2f6730cd1feb3014042adbf998ca9203">rm_temporary_table</a> (<a class="el" href="structhandlerton.html">handlerton</a> *base, const char *path)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab5c68673b37e4f394de31ffe4ac80fcc">open_temporary_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gac4c1cb71807d09d53273048447abf301">open_temporary_tables</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl_list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3607b2bf7c5d8073f388bb12f42a2464"></a><!-- doxytag: member="Data_Dictionary::find_field_in_table" ref="ga3607b2bf7c5d8073f388bb12f42a2464" args="(THD *thd, TABLE *table, const char *name, uint length, bool allow_rowid, uint *cached_field_index_ptr)" -->
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table</b> (THD *thd, <a class="el" href="structTABLE.html">TABLE</a> *table, const char *name, uint length, bool allow_rowid, uint *cached_field_index_ptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8826dc597c12ef7501738af9da70e90d"></a><!-- doxytag: member="Data_Dictionary::find_field_in_table_ref" ref="ga8826dc597c12ef7501738af9da70e90d" args="(THD *thd, TABLE_LIST *table_list, const char *name, uint length, const char *item_name, const char *db_name, const char *table_name, Item **ref, bool check_privileges, bool allow_rowid, uint *cached_field_index_ptr, bool register_tree_change, TABLE_LIST **actual_table)" -->
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table_ref</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, const char *name, uint length, const char *item_name, const char *db_name, const char *table_name, <a class="el" href="classItem.html">Item</a> **ref, bool check_privileges, bool allow_rowid, uint *cached_field_index_ptr, bool register_tree_change, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **actual_table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga795c727f9014b6fd6d0eed974e26c5c3"></a><!-- doxytag: member="Data_Dictionary::find_field_in_table_sef" ref="ga795c727f9014b6fd6d0eed974e26c5c3" args="(TABLE *table, const char *name)" -->
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_table_sef</b> (<a class="el" href="structTABLE.html">TABLE</a> *table, const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4e9247db04d273c378aab8d6e1daff7c"></a><!-- doxytag: member="Data_Dictionary::find_field_in_tables" ref="ga4e9247db04d273c378aab8d6e1daff7c" args="(THD *thd, Item_ident *item, TABLE_LIST *first_table, TABLE_LIST *last_table, Item **ref, find_item_error_report_type report_error, bool check_privileges, bool register_tree_change)" -->
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>find_field_in_tables</b> (THD *thd, <a class="el" href="classItem__ident.html">Item_ident</a> *item, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *first_table, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *last_table, <a class="el" href="classItem.html">Item</a> **ref, find_item_error_report_type report_error, bool check_privileges, bool register_tree_change)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad8a568dc8a852240a792309974498e53"></a><!-- doxytag: member="Data_Dictionary::find_item_in_list" ref="gad8a568dc8a852240a792309974498e53" args="(Item *find, List&lt; Item &gt; &amp;items, uint *counter, find_item_error_report_type report_error, enum_resolution_type *resolution)" -->
<a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>find_item_in_list</b> (<a class="el" href="classItem.html">Item</a> *find, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;items, uint *counter, find_item_error_report_type report_error, enum_resolution_type *resolution)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga34fa1840c6d201b60e6e9a7c2ed4675c"></a><!-- doxytag: member="Data_Dictionary::setup_wild" ref="ga34fa1840c6d201b60e6e9a7c2ed4675c" args="(THD *thd, TABLE_LIST *tables, List&lt; Item &gt; &amp;fields, List&lt; Item &gt; *sum_func_list, uint wild_num)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>setup_wild</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *sum_func_list, uint wild_num)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa7a4772fb39984086378ab04521264f0"></a><!-- doxytag: member="Data_Dictionary::setup_fields" ref="gaa7a4772fb39984086378ab04521264f0" args="(THD *thd, Ref_ptr_array ref_pointer_array, List&lt; Item &gt; &amp;fields, enum_mark_columns mark_used_columns, List&lt; Item &gt; *sum_func_list, bool allow_sum_func)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setup_fields</b> (THD *thd, <a class="el" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, enum_mark_columns mark_used_columns, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *sum_func_list, bool allow_sum_func)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac64373a3f8c4719f908ffc114c6d410c"></a><!-- doxytag: member="Data_Dictionary::make_leaves_list" ref="gac64373a3f8c4719f908ffc114c6d410c" args="(TABLE_LIST **list, TABLE_LIST *tables)" -->
<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>make_leaves_list</b> (<a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **list, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga246a04773028f8776103a747a94d4c19"></a><!-- doxytag: member="Data_Dictionary::setup_tables" ref="ga246a04773028f8776103a747a94d4c19" args="(THD *thd, Name_resolution_context *context, List&lt; TABLE_LIST &gt; *from_clause, TABLE_LIST *tables, TABLE_LIST **leaves, bool select_insert)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setup_tables</b> (THD *thd, <a class="el" href="structName__resolution__context.html">Name_resolution_context</a> *context, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *from_clause, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **leaves, bool select_insert)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga1cbd71e573571827be66b1314f50827f">setup_tables_and_check_access</a> (THD *thd, <a class="el" href="structName__resolution__context.html">Name_resolution_context</a> *context, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *from_clause, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **leaves, bool select_insert, ulong want_access_first, ulong want_access)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3ed6f7a411697a21f8e57aee4e40dcc9"></a><!-- doxytag: member="Data_Dictionary::insert_fields" ref="ga3ed6f7a411697a21f8e57aee4e40dcc9" args="(THD *thd, Name_resolution_context *context, const char *db_name, const char *table_name, List_iterator&lt; Item &gt; *it, bool any_privileges)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>insert_fields</b> (THD *thd, <a class="el" href="structName__resolution__context.html">Name_resolution_context</a> *context, const char *db_name, const char *table_name, <a class="el" href="classList__iterator.html">List_iterator</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; *it, bool any_privileges)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9e628d6e5bb1c49fc6c885b85adfc489"></a><!-- doxytag: member="Data_Dictionary::setup_conds" ref="ga9e628d6e5bb1c49fc6c885b85adfc489" args="(THD *thd, TABLE_LIST *tables, TABLE_LIST *leaves, Item **conds)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>setup_conds</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *leaves, <a class="el" href="classItem.html">Item</a> **conds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a8650491e7b1b416b0a6864721a2458"></a><!-- doxytag: member="Data_Dictionary::fill_record" ref="ga1a8650491e7b1b416b0a6864721a2458" args="(THD *thd, List&lt; Item &gt; &amp;fields, List&lt; Item &gt; &amp;values, bool ignore_errors, MY_BITMAP *bitmap)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record</b> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;values, bool ignore_errors, MY_BITMAP *bitmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2ba4b3e68ad8c8e28445ebb8fb181ae7"></a><!-- doxytag: member="Data_Dictionary::fill_record_n_invoke_before_triggers" ref="ga2ba4b3e68ad8c8e28445ebb8fb181ae7" args="(THD *thd, List&lt; Item &gt; &amp;fields, List&lt; Item &gt; &amp;values, bool ignore_errors, Table_triggers_list *triggers, enum trg_event_type event)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record_n_invoke_before_triggers</b> (THD *thd, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;fields, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;values, bool ignore_errors, <a class="el" href="classTable__triggers__list.html">Table_triggers_list</a> *triggers, enum trg_event_type event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf">fill_record</a> (THD *thd, <a class="el" href="classField.html">Field</a> **ptr, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;values, bool ignore_errors, MY_BITMAP *bitmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga083df16f298e6e3257a7449c086f2222"></a><!-- doxytag: member="Data_Dictionary::fill_record_n_invoke_before_triggers" ref="ga083df16f298e6e3257a7449c086f2222" args="(THD *thd, Field **ptr, List&lt; Item &gt; &amp;values, bool ignore_errors, Table_triggers_list *triggers, enum trg_event_type event)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>fill_record_n_invoke_before_triggers</b> (THD *thd, <a class="el" href="classField.html">Field</a> **ptr, <a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;values, bool ignore_errors, <a class="el" href="classTable__triggers__list.html">Table_triggers_list</a> *triggers, enum trg_event_type event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadded8328656d64a663d994979a50b956"></a><!-- doxytag: member="Data_Dictionary::mysql_rm_tmp_tables" ref="gadded8328656d64a663d994979a50b956" args="(void)" -->
my_bool&#160;</td><td class="memItemRight" valign="bottom"><b>mysql_rm_tmp_tables</b> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaae1459addd4c75ddbf76468ba9a26a6"></a><!-- doxytag: member="Data_Dictionary::tdc_flush_unused_tables" ref="gaaae1459addd4c75ddbf76468ba9a26a6" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>tdc_flush_unused_tables</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8faf6c6118b6677394e14994ae614075">tdc_remove_table</a> (THD *thd, enum_tdc_remove_table_type remove_type, const char *db, const char *table_name, bool has_lock)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga481e7e276a23583989ab7fc28bf70928"></a><!-- doxytag: member="Data_Dictionary::setup_ftfuncs" ref="ga481e7e276a23583989ab7fc28bf70928" args="(SELECT_LEX *select_lex)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>setup_ftfuncs</b> (SELECT_LEX *select_lex)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f79de1da20c6d99638e79c46b1606ef"></a><!-- doxytag: member="Data_Dictionary::init_ftfuncs" ref="ga8f79de1da20c6d99638e79c46b1606ef" args="(THD *thd, SELECT_LEX *select_lex, bool no_order)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>init_ftfuncs</b> (THD *thd, SELECT_LEX *select_lex, bool no_order)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8b26ffd4f5885a763dc68dccf87ae547"></a><!-- doxytag: member="Data_Dictionary::is_equal" ref="ga8b26ffd4f5885a763dc68dccf87ae547" args="(const LEX_STRING *a, const LEX_STRING *b)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_equal</b> (const LEX_STRING *a, const LEX_STRING *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf149aa7c1952464ab621b3eb4a4f73d2"></a><!-- doxytag: member="Data_Dictionary::open_system_tables_for_read" ref="gaf149aa7c1952464ab621b3eb4a4f73d2" args="(THD *thd, TABLE_LIST *table_list, Open_tables_backup *backup)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>open_system_tables_for_read</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, Open_tables_backup *backup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeae2add5b186deba41c77685a8f19c90"></a><!-- doxytag: member="Data_Dictionary::close_system_tables" ref="gaeae2add5b186deba41c77685a8f19c90" args="(THD *thd, Open_tables_backup *backup)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>close_system_tables</b> (THD *thd, Open_tables_backup *backup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga9467ef8e03a8afbe8b937d699a0537f2">close_mysql_tables</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7f08738b93443c024318ecbcc739f6f1"></a><!-- doxytag: member="Data_Dictionary::open_system_table_for_update" ref="ga7f08738b93443c024318ecbcc739f6f1" args="(THD *thd, TABLE_LIST *one_table)" -->
<a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>open_system_table_for_update</b> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *one_table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga065f6a0326ab135938fb38fd371dace5">open_log_table</a> (THD *thd, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *one_table, Open_tables_backup *backup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8f22fa867e1bb56d350834b5497c9d6d">close_log_table</a> (THD *thd, Open_tables_backup *backup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9dc37b30f3c1c06eeef7d1661381f9a6"></a><!-- doxytag: member="Data_Dictionary::handle_condition" ref="ga9dc37b30f3c1c06eeef7d1661381f9a6" args="(THD *thd, uint sql_errno, const char *sqlstate, Sql_condition::enum_warning_level level, const char *msg, Sql_condition **cond_hdl)" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>MDL_deadlock_handler::handle_condition</b> (THD *thd, uint sql_errno, const char *sqlstate, Sql_condition::enum_warning_level level, const char *msg, <a class="el" href="classSql__condition.html">Sql_condition</a> **cond_hdl)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga8eaa3b1fdce29eac72028f96c55607d3">Open_table_context::Open_table_context</a> (THD *thd, uint flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gaf35889f70c8719510fb76899cf9cf20b">Open_table_context::request_backoff_action</a> (enum_open_table_action action_arg, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gade48892bc4607303f7f4d3d6df4c39de">Open_table_context::recover_from_failed_open</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga4d51adf9905616e57f7b572081f537ac">DML_prelocking_strategy::handle_routine</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp, bool *need_prelocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#gab4041a333019fb1a8ffb4e3772f627cf">DML_prelocking_strategy::handle_table</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga757cc4c5e9baf4dfae041368257e46e4">DML_prelocking_strategy::handle_view</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga7e0d0312d3f9e2abb42e91b74f045d79">Alter_table_prelocking_strategy::handle_routine</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *rt, <a class="el" href="classsp__head.html">sp_head</a> *sp, bool *need_prelocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga572cfaf98399c14ebe9e318b4197c6f5">Alter_table_prelocking_strategy::handle_table</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga3da56b0df4158af2defc12e836983529">Alter_table_prelocking_strategy::handle_view</a> (THD *thd, Query_tables_list *prelocking_ctx, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, bool *need_prelocking)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">mysql_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Data__Dictionary.html#ga99c8e1e3e72cd74032d5f11c486911fd">LOCK_open</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3f89faf859f3162a4d7476410c4a69e"></a><!-- doxytag: member="Data_Dictionary::table_def_cache" ref="gaf3f89faf859f3162a4d7476410c4a69e" args="" -->
HASH&#160;</td><td class="memItemRight" valign="bottom"><b>table_def_cache</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9133e87930df59fe74ca492acf5295f7"></a><!-- doxytag: member="Data_Dictionary::not_found_field" ref="ga9133e87930df59fe74ca492acf5295f7" args="" -->
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>not_found_field</b> = (<a class="el" href="classField.html">Field</a>*) 0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaba50986729b2cfd3be1c762e666d3d18"></a><!-- doxytag: member="Data_Dictionary::view_ref_found" ref="gaba50986729b2cfd3be1c762e666d3d18" args="" -->
<a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>view_ref_found</b> = (<a class="el" href="classField.html">Field</a>*) 0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac130a94f4d55acec35aa42626af9f37f"></a><!-- doxytag: member="Data_Dictionary::not_found_item" ref="gac130a94f4d55acec35aa42626af9f37f" args="" -->
<a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>not_found_item</b> = (<a class="el" href="classItem.html">Item</a>**) 0x1</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0f7967950b623499bad7a7fc81612e16"></a><!-- doxytag: member="sql_base.cc::check_if_table_exists" ref="ga0f7967950b623499bad7a7fc81612e16" args="(THD *thd, TABLE_LIST *table, bool *exists)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga0f7967950b623499bad7a7fc81612e16">check_if_table_exists</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>exists</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check that table exists in table definition cache, on disk or in some storage engine.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>Table list element </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">exists</td><td>Out parameter which is set to TRUE if table exists and to FALSE otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function acquires LOCK_open internally.</dd>
<dd>
If there is no .FRM file for the table but it exists in one of engines (e.g. it was created on another node of NDB cluster) this function will fetch and create proper .FRM file for it.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Some error occurred </td></tr>
    <tr><td class="paramname">FALSE</td><td>No error. 'exists' out parameter set accordingly. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga86713fadf907edf57606406a10c1f994"></a><!-- doxytag: member="sql_base.cc::close_all_tables_for_name" ref="ga86713fadf907edf57606406a10c1f994" args="(THD *thd, TABLE_SHARE *share, bool remove_from_locked_tables, TABLE *skip_table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#ga86713fadf907edf57606406a10c1f994">close_all_tables_for_name</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_from_locked_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>skip_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close all open instances of the table but keep the MDL lock.</p>
<p>Works both under LOCK TABLES and in the normal mode. Removes all closed instances of the table from the table cache.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">share</td><td>table share, but is just a handy way to access the table cache key</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">remove_from_locked_tables</td><td>TRUE if the table is being dropped or renamed. In that case the documented behaviour is to implicitly remove the table from LOCK TABLES list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_table</td><td><a class="el" href="structTABLE.html">TABLE</a> instance that should be kept open.</td></tr>
  </table>
  </dd>
</dl>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>Must be called with an X MDL lock on the table. </dd></dl>

</div>
</div>
<a class="anchor" id="gab247c23689b3ce8b377cde2cbc0e47ef"></a><!-- doxytag: member="sql_base.cc::close_cached_connection_tables" ref="gab247c23689b3ce8b377cde2cbc0e47ef" args="(THD *thd, LEX_STRING *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gab247c23689b3ce8b377cde2cbc0e47ef">close_cached_connection_tables</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LEX_STRING *&#160;</td>
          <td class="paramname"><em>connection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close all tables which match specified connection string or if specified string is NULL, then any table with a connection string. </p>

</div>
</div>
<a class="anchor" id="ga8f22fa867e1bb56d350834b5497c9d6d"></a><!-- doxytag: member="sql_base.cc::close_log_table" ref="ga8f22fa867e1bb56d350834b5497c9d6d" args="(THD *thd, Open_tables_backup *backup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#ga8f22fa867e1bb56d350834b5497c9d6d">close_log_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Open_tables_backup *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a log table. The last table opened by <a class="el" href="group__Data__Dictionary.html#ga065f6a0326ab135938fb38fd371dace5">open_log_table()</a> is closed, then the thread context is restored. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">backup</td><td>[in] the context to restore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9467ef8e03a8afbe8b937d699a0537f2"></a><!-- doxytag: member="sql_base.cc::close_mysql_tables" ref="ga9467ef8e03a8afbe8b937d699a0537f2" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#ga9467ef8e03a8afbe8b937d699a0537f2">close_mysql_tables</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A helper function to close a mysql.* table opened in an auxiliary THD during bootstrap or in the main connection, when we know that there are no locks held by the connection due to a preceding implicit commit.</p>
<p>This function assumes that there is no statement transaction started for the operation itself, since mysql.* tables are not transactional and when they are used the binlog is off (DDL binlogging is always statement-based.</p>
<p>We need this function since we'd like to not just close the system table, but also release the metadata lock on it.</p>
<p>Note, that in LOCK TABLES mode this function does not release the metadata lock. But in this mode the table can be opened only if it is locked explicitly with LOCK TABLES. </p>

</div>
</div>
<a class="anchor" id="ga92bec964ecaaa7270a429e664643b746"></a><!-- doxytag: member="sql_base.cc::close_tables_for_reopen" ref="ga92bec964ecaaa7270a429e664643b746" args="(THD *thd, TABLE_LIST **tables, const MDL_savepoint &amp;start_of_statement_svp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#ga92bec964ecaaa7270a429e664643b746">close_tables_for_reopen</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMDL__savepoint.html">MDL_savepoint</a> &amp;&#160;</td>
          <td class="paramname"><em>start_of_statement_svp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepare statement for reopening of tables and recalculation of set of prelocked tables.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tables</td><td><a class="el" href="classList.html">List</a> of tables which we were trying to open and lock. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_of_statement_svp</td><td>MDL savepoint which represents the set of metadata locks which the current transaction managed to acquire before execution of the current statement and to which we should revert before trying to reopen tables. NULL if no metadata locks were held and thus all metadata locks should be released. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac9f2e6710ec001734614f4a11cde9f0f"></a><!-- doxytag: member="sql_base.cc::drop_open_table" ref="gac9f2e6710ec001734614f4a11cde9f0f" args="(THD *thd, TABLE *table, const char *db_name, const char *table_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#gac9f2e6710ec001734614f4a11cde9f0f">drop_open_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close a and drop a just created table in CREATE <a class="el" href="structTABLE.html">TABLE</a> ... SELECT.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table</td><td><a class="el" href="structTABLE.html">TABLE</a> object for the table to be dropped </td></tr>
    <tr><td class="paramname">db_name</td><td>Name of database for this table </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of this table</td></tr>
  </table>
  </dd>
</dl>
<p>This routine assumes that the table to be closed is open only by the calling thread, so we needn't wait until other threads close the table. It also assumes that the table is first in thd-&gt;open_ables and a data lock on it, if any, has been released. To sum up, it's tuned to work with CREATE <a class="el" href="structTABLE.html">TABLE</a> ... SELECT and CREATE <a class="el" href="structTABLE.html">TABLE</a> .. SELECT only. Note, that currently CREATE <a class="el" href="structTABLE.html">TABLE</a> ... SELECT is not supported under LOCK TABLES. This function, still, can be called in prelocked mode, e.g. if we do CREATE <a class="el" href="structTABLE.html">TABLE</a> .. SELECT f1(); </p>

</div>
</div>
<a class="anchor" id="gab5683a94b25579c456f2c9f55f9f9b35"></a><!-- doxytag: member="sql_base.cc::drop_temporary_table" ref="gab5683a94b25579c456f2c9f55f9f9b35" args="(THD *thd, TABLE_LIST *table_list, bool *is_trans)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__Data__Dictionary.html#gab5683a94b25579c456f2c9f55f9f9b35">drop_temporary_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>is_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Drop a temporary table.</p>
<p>Try to locate the table in the list of thd-&gt;temporary_tables. If the table is found:</p>
<ul>
<li>if the table is being used by some outer statement, fail.</li>
<li>if the table is locked with LOCK TABLES or by prelocking, unlock it and remove it from the list of locked tables (THD::lock). Currently only transactional temporary tables are locked.</li>
<li>Close the temporary table, remove its .FRM</li>
<li>remove the table from the list of temporary tables</li>
</ul>
<p>This function is used to drop user temporary tables, as well as internal tables created in CREATE TEMPORARY <a class="el" href="structTABLE.html">TABLE</a> ... SELECT or ALTER <a class="el" href="structTABLE.html">TABLE</a>. Even though part of the work done by this function is redundant when the table is internal, as long as we link both internal and user temporary tables into the same thd-&gt;temporary_tables list, it's impossible to tell here whether we're dealing with an internal or a user temporary table.</p>
<p>In is_trans out-parameter, we return the type of the table: either transactional (e.g. innodb) as TRUE or non-transactional (e.g. myisam) as FALSE.</p>
<p>This function assumes that table to be dropped was pre-opened using table list provided.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>the table was found and dropped successfully. </td></tr>
    <tr><td class="paramname">1</td><td>the table was not found in the list of temporary tables of this thread </td></tr>
    <tr><td class="paramname">-1</td><td>the table is in use by a outer query </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf"></a><!-- doxytag: member="sql_base.cc::fill_record" ref="gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf" args="(THD *thd, Field **ptr, List&lt; Item &gt; &amp;values, bool ignore_errors, MY_BITMAP *bitmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gaeba2e65f1f64b4cfb1f4e74b4ad4ddaf">fill_record</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classField.html">Field</a> **&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MY_BITMAP *&#160;</td>
          <td class="paramname"><em>bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill field buffer with values from <a class="el" href="classField.html">Field</a> list.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">ptr</td><td>pointer on pointer to record </td></tr>
    <tr><td class="paramname">values</td><td>list of fields </td></tr>
    <tr><td class="paramname">ignore_errors</td><td>True if we should ignore errors </td></tr>
    <tr><td class="paramname">bitmap</td><td><a class="el" href="classBitmap.html">Bitmap</a> over fields to fill</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>fill_record() may set table-&gt;auto_increment_field_not_null and a caller should make sure that it is reset after their last call to this function.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Operation status </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>OK </td></tr>
    <tr><td class="paramname">true</td><td>Error occured </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4458592b1c4d9ed293e5b2033349c3fb"></a><!-- doxytag: member="sql_base.cc::find_locked_table" ref="ga4458592b1c4d9ed293e5b2033349c3fb" args="(TABLE *list, const char *db, const char *table_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="group__Data__Dictionary.html#ga4458592b1c4d9ed293e5b2033349c3fb">find_locked_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find table in the list of open tables.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td><a class="el" href="classList.html">List</a> of <a class="el" href="structTABLE.html">TABLE</a> objects to be inspected. </td></tr>
    <tr><td class="paramname">db</td><td>Database name </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the <a class="el" href="structTABLE.html">TABLE</a> object found, 0 if no table found. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8692f5ebd7f6483f1dcc576eb2346f52"></a><!-- doxytag: member="sql_base.cc::find_table_for_mdl_upgrade" ref="ga8692f5ebd7f6483f1dcc576eb2346f52" args="(THD *thd, const char *db, const char *table_name, bool no_error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="group__Data__Dictionary.html#ga8692f5ebd7f6483f1dcc576eb2346f52">find_table_for_mdl_upgrade</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find instance of <a class="el" href="structTABLE.html">TABLE</a> with upgradable or exclusive metadata lock from the list of open tables, emit error if no such table found.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table. </td></tr>
    <tr><td class="paramname">no_error</td><td>Don't emit error if no suitable <a class="el" href="structTABLE.html">TABLE</a> instance were found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function checks if the connection holds a global IX metadata lock. If no such lock is found, it is not safe to upgrade the lock and ER_TABLE_NOT_LOCKED_FOR_WRITE will be reported.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to <a class="el" href="structTABLE.html">TABLE</a> instance with MDL_SHARED_UPGRADABLE MDL_SHARED_NO_WRITE, MDL_SHARED_NO_READ_WRITE, or MDL_EXCLUSIVE metadata lock, NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0734400e8b6f0dab464f0da0f177086b"></a><!-- doxytag: member="sql_base.cc::find_temporary_table" ref="ga0734400e8b6f0dab464f0da0f177086b" args="(THD *thd, const char *db, const char *table_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="group__Data__Dictionary.html#ga16b087bb99ab090df96292f53805138c">find_temporary_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find temporary table specified by database and table names in the THD::temporary_tables list.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structTABLE.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d31aeecf54e9bf14d05fa8a6478b7e0"></a><!-- doxytag: member="sql_base.cc::find_temporary_table" ref="ga4d31aeecf54e9bf14d05fa8a6478b7e0" args="(THD *thd, const TABLE_LIST *tl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="group__Data__Dictionary.html#ga16b087bb99ab090df96292f53805138c">find_temporary_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a temporary table specified by <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> instance in the THD::temporary_tables list.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structTABLE.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16b087bb99ab090df96292f53805138c"></a><!-- doxytag: member="sql_base.cc::find_temporary_table" ref="ga16b087bb99ab090df96292f53805138c" args="(THD *thd, const char *table_key, uint table_key_length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="group__Data__Dictionary.html#ga16b087bb99ab090df96292f53805138c">find_temporary_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>table_key_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a temporary table specified by a key in the THD::temporary_tables list.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structTABLE.html">TABLE</a> instance if a temporary table has been found; NULL otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga352a69aae26f998d4cbbf1d1d4937349"></a><!-- doxytag: member="sql_base.cc::get_table_def_key" ref="ga352a69aae26f998d4cbbf1d1d4937349" args="(const TABLE_LIST *table_list, const char **key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint <a class="el" href="group__Data__Dictionary.html#ga352a69aae26f998d4cbbf1d1d4937349">get_table_def_key</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get table cache key for a table list element.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">table_list[in]</td><td>Table list element. </td></tr>
    <tr><td class="paramname">key[out]</td><td>On return points to table cache key for the table.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Unlike create_table_def_key() call this function doesn't construct key in a buffer provider by caller. Instead it relies on the fact that table list element for which key is requested has properly initialized <a class="el" href="classMDL__request.html">MDL_request</a> object and the fact that table definition cache key is suffix of key used in MDL subsystem. So to get table definition key it simply needs to return pointer to appropriate part of <a class="el" href="classMDL__key.html">MDL_key</a> object nested in this table list element. Indeed, this means that lifetime of key produced by this call is limited by the lifetime of table list element which it got as parameter.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Length of key. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4d51adf9905616e57f7b572081f537ac"></a><!-- doxytag: member="DML_prelocking_strategy::handle_routine" ref="ga4d51adf9905616e57f7b572081f537ac" args="(THD *thd, Query_tables_list *prelocking_ctx, Sroutine_hash_entry *rt, sp_head *sp, bool *need_prelocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga4d51adf9905616e57f7b572081f537ac">DML_prelocking_strategy::handle_routine</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines how prelocking algorithm for DML statements should handle routines:</p>
<ul>
<li>For CALL statements we do unrolling (i.e. open and lock tables for each sub-statement individually). So for such statements prelocking is enabled only if stored functions are used in parameter list and only for period during which we calculate values of parameters. Thus in this strategy we ignore procedure which is directly called by such statement and extend the prelocking set only with tables/functions used by SF called from the parameter list.</li>
<li>For any other statement any routine which is directly or indirectly called by statement is going to be executed in prelocked mode. So in this case we simply add all tables and routines used by it to the prelocking set.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rt</td><td>Prelocking set element describing routine. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a class="anchor" id="ga7e0d0312d3f9e2abb42e91b74f045d79"></a><!-- doxytag: member="Alter_table_prelocking_strategy::handle_routine" ref="ga7e0d0312d3f9e2abb42e91b74f045d79" args="(THD *thd, Query_tables_list *prelocking_ctx, Sroutine_hash_entry *rt, sp_head *sp, bool *need_prelocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga7e0d0312d3f9e2abb42e91b74f045d79">Alter_table_prelocking_strategy::handle_routine</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSroutine__hash__entry.html">Sroutine_hash_entry</a> *&#160;</td>
          <td class="paramname"><em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsp__head.html">sp_head</a> *&#160;</td>
          <td class="paramname"><em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines how prelocking algorithm for ALTER <a class="el" href="structTABLE.html">TABLE</a> statement should handle routines - do nothing as this statement is not supposed to call routines.</p>
<p>We still can end up in this method when someone tries to define a foreign key referencing a view, and not just a simple view, but one that uses stored routines. </p>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a class="anchor" id="gab4041a333019fb1a8ffb4e3772f627cf"></a><!-- doxytag: member="DML_prelocking_strategy::handle_table" ref="gab4041a333019fb1a8ffb4e3772f627cf" args="(THD *thd, Query_tables_list *prelocking_ctx, TABLE_LIST *table_list, bool *need_prelocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gab4041a333019fb1a8ffb4e3772f627cf">DML_prelocking_strategy::handle_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines how prelocking algorithm for DML statements should handle table list elements:</p>
<ul>
<li>If table has triggers we should add all tables and routines used by them to the prelocking set.</li>
</ul>
<p>We do not need to acquire metadata locks on trigger names in DML statements, since all DDL statements that change trigger metadata always lock their subject tables.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a class="anchor" id="ga572cfaf98399c14ebe9e318b4197c6f5"></a><!-- doxytag: member="Alter_table_prelocking_strategy::handle_table" ref="ga572cfaf98399c14ebe9e318b4197c6f5" args="(THD *thd, Query_tables_list *prelocking_ctx, TABLE_LIST *table_list, bool *need_prelocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga572cfaf98399c14ebe9e318b4197c6f5">Alter_table_prelocking_strategy::handle_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines how prelocking algorithm for ALTER <a class="el" href="structTABLE.html">TABLE</a> statement should handle table list elements.</p>
<p>Unlike in DML, we do not process triggers here.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for table. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a class="anchor" id="ga757cc4c5e9baf4dfae041368257e46e4"></a><!-- doxytag: member="DML_prelocking_strategy::handle_view" ref="ga757cc4c5e9baf4dfae041368257e46e4" args="(THD *thd, Query_tables_list *prelocking_ctx, TABLE_LIST *table_list, bool *need_prelocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga757cc4c5e9baf4dfae041368257e46e4">DML_prelocking_strategy::handle_view</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines how prelocking algorithm for DML statements should handle view - all view routines should be added to the prelocking set.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_ctx</td><td>Prelocking context of the statement. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_list</td><td>Table list element for view. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sp</td><td>Routine body. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">need_prelocking</td><td>Set to TRUE if method detects that prelocking required, not changed otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (OOM). </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a class="anchor" id="ga3da56b0df4158af2defc12e836983529"></a><!-- doxytag: member="Alter_table_prelocking_strategy::handle_view" ref="ga3da56b0df4158af2defc12e836983529" args="(THD *thd, Query_tables_list *prelocking_ctx, TABLE_LIST *table_list, bool *need_prelocking)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga3da56b0df4158af2defc12e836983529">Alter_table_prelocking_strategy::handle_view</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Query_tables_list *&#160;</td>
          <td class="paramname"><em>prelocking_ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>need_prelocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines how prelocking algorithm for ALTER <a class="el" href="structTABLE.html">TABLE</a> statement should handle view - do nothing. We don't need to add view routines to the prelocking set in this case as view is not going to be materialized. </p>

<p>Implements <a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a>.</p>

</div>
</div>
<a class="anchor" id="gae06de7ce22001b035ca61edf2a3dea09"></a><!-- doxytag: member="sql_base.cc::lock_table_names" ref="gae06de7ce22001b035ca61edf2a3dea09" args="(THD *thd, TABLE_LIST *tables_start, TABLE_LIST *tables_end, ulong lock_wait_timeout, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gae06de7ce22001b035ca61edf2a3dea09">lock_table_names</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>lock_wait_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acquire upgradable (SNW, SNRW) metadata locks on tables used by LOCK TABLES or by a DDL statement. Acquire lock "S" on table being created in CREATE <a class="el" href="structTABLE.html">TABLE</a> statement.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Under LOCK TABLES, we can't take new locks, so use open_tables_check_upgradable_mdl() instead.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables_start</td><td>Start of list of tables on which upgradable locks should be acquired. </td></tr>
    <tr><td class="paramname">tables_end</td><td>End of list of tables. </td></tr>
    <tr><td class="paramname">lock_wait_timeout</td><td>Seconds to wait before timeout. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classBitmap.html">Bitmap</a> of flags to modify how the tables will be open, see <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> description for details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (e.g. connection was killed) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga399ec28859bb54829b1cabbeed845f78"></a><!-- doxytag: member="sql_base.cc::lock_tables" ref="ga399ec28859bb54829b1cabbeed845f78" args="(THD *thd, TABLE_LIST *tables, uint count, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lock all tables in a list.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>Tables to lock </td></tr>
    <tr><td class="paramname">count</td><td>Number of opened tables </td></tr>
    <tr><td class="paramname">flags</td><td>Options (see <a class="el" href="group__Locking.html#ga3a5f18c7a05b36a6e93c1d8e33cece78">mysql_lock_tables()</a> for details)</td></tr>
  </table>
  </dd>
</dl>
<p>You can't call <a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a> while holding thr_lock locks, as this would break the dead-lock-free handling thr_lock gives us. You must always get all needed locks at once.</p>
<p>If the query for which we are calling this function is marked as requiring prelocking, this function will change locked_tables_mode to LTM_PRELOCKED.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>A lock wait timeout, deadlock or out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae2cc536b80faf27a1017cf4ddcc988ad"></a><!-- doxytag: member="sql_base.cc::mark_tmp_table_for_reuse" ref="gae2cc536b80faf27a1017cf4ddcc988ad" args="(TABLE *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#gae2cc536b80faf27a1017cf4ddcc988ad">mark_tmp_table_for_reuse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset a single temporary table. Effectively this "closes" one temporary table, in a session.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>Temporary table. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga38f8435e686a352b75b449c7bcd4c82c"></a><!-- doxytag: member="sql_base.cc::open_and_lock_tables" ref="ga38f8435e686a352b75b449c7bcd4c82c" args="(THD *thd, TABLE_LIST *tables, bool derived, uint flags, Prelocking_strategy *prelocking_strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga38f8435e686a352b75b449c7bcd4c82c">open_and_lock_tables</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>derived</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open all tables in list, locks them and optionally process derived tables.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">tables</td><td><a class="el" href="classList.html">List</a> of tables for open and locking. </td></tr>
    <tr><td class="paramname">derived</td><td>If to handle derived tables. </td></tr>
    <tr><td class="paramname">flags</td><td><a class="el" href="classBitmap.html">Bitmap</a> of options to be used to open and lock tables (see <a class="el" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables()</a> and <a class="el" href="group__Locking.html#ga3a5f18c7a05b36a6e93c1d8e33cece78">mysql_lock_tables()</a> for details). </td></tr>
    <tr><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The thr_lock locks will automatically be freed by close_thread_tables().</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>OK. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga065f6a0326ab135938fb38fd371dace5"></a><!-- doxytag: member="sql_base.cc::open_log_table" ref="ga065f6a0326ab135938fb38fd371dace5" args="(THD *thd, TABLE_LIST *one_table, Open_tables_backup *backup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="group__Data__Dictionary.html#ga065f6a0326ab135938fb38fd371dace5">open_log_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>one_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Open_tables_backup *&#160;</td>
          <td class="paramname"><em>backup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open a log table. Opening such tables is performed internally in the server implementation, and is a 'nested' open, since some tables might be already opened by the current thread. The thread context before this call is saved, and is restored when calling <a class="el" href="group__Data__Dictionary.html#ga8f22fa867e1bb56d350834b5497c9d6d">close_log_table()</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>The current thread </td></tr>
    <tr><td class="paramname">one_table</td><td>Log table to open </td></tr>
    <tr><td class="paramname">backup</td><td>[out] Temporary storage used to save the thread context </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga86a68932d1c35b3fd820c99d185d7888"></a><!-- doxytag: member="sql_base.cc::open_n_lock_single_table" ref="ga86a68932d1c35b3fd820c99d185d7888" args="(THD *thd, TABLE_LIST *table_l, thr_lock_type lock_type, uint flags, Prelocking_strategy *prelocking_strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="group__Data__Dictionary.html#ga86a68932d1c35b3fd820c99d185d7888">open_n_lock_single_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thr_lock_type&#160;</td>
          <td class="paramname"><em>lock_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Open and lock one table. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table_l</td><td>table to open is first table in this list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_type</td><td>lock to use for table </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>options to be used while opening and locking table (see <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a>, <a class="el" href="group__Locking.html#ga3a5f18c7a05b36a6e93c1d8e33cece78">mysql_lock_tables()</a>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>table </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">!=</td><td>NULL OK, opened table returned </td></tr>
    <tr><td class="paramname">NULL</td><td>Error</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If ok, the following are also set: table_list-&gt;lock_type lock_type table_list-&gt;table table</dd>
<dd>
If table_l is a list, not a single table, the list is temporarily broken.</dd></dl>
<p>This function is meant as a replacement for open_ltable() when MERGE tables can be opened. open_ltable() cannot open MERGE tables.</p>
<p>There may be more differences between <a class="el" href="group__Data__Dictionary.html#ga86a68932d1c35b3fd820c99d185d7888" title="Open and lock one table.">open_n_lock_single_table()</a> and open_ltable(). One known difference is that open_ltable() does neither call thd-&gt;decide_logging_format() nor handle some other logging and locking issues because it does not call <a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a>. </p>

</div>
</div>
<a class="anchor" id="ga258e3d35dfa1dbef9586f6f3d6a76326"></a><!-- doxytag: member="sql_base.cc::open_normal_and_derived_tables" ref="ga258e3d35dfa1dbef9586f6f3d6a76326" args="(THD *thd, TABLE_LIST *tables, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga258e3d35dfa1dbef9586f6f3d6a76326">open_normal_and_derived_tables</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open all tables in list and process derived tables</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>thread handler </td></tr>
    <tr><td class="paramname">tables</td><td>list of tables for open </td></tr>
    <tr><td class="paramname">flags</td><td>bitmap of flags to modify how the tables will be open: MYSQL_LOCK_IGNORE_FLUSH - open table even if someone has done a flush on it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- ok </td></tr>
    <tr><td class="paramname">true</td><td>- error</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This is to be used on prepare stage when you don't read any data from the tables.</dd>
<dd>
Updates Query_tables_list::table_count as side-effect. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43cb5a9ba1064a36db89ad5c4d645528"></a><!-- doxytag: member="sql_base.cc::open_table" ref="ga43cb5a9ba1064a36db89ad5c4d645528" args="(THD *thd, TABLE_LIST *table_list, Open_table_context *ot_ctx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpen__table__context.html">Open_table_context</a> *&#160;</td>
          <td class="paramname"><em>ot_ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open a base table.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">table_list</td><td>Open first table in list. </td></tr>
    <tr><td class="paramname">ot_ctx</td><td>Context with flags which modify how open works and which is used to recover from a failed <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> attempt. Some examples of flags: MYSQL_OPEN_IGNORE_FLUSH - Open table even if someone has done a flush. No version number checking is done. MYSQL_OPEN_HAS_MDL_LOCK - instead of acquiring metadata locks rely on that caller already has appropriate ones.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses a cache of open tables to find a <a class="el" href="structTABLE.html">TABLE</a> instance not in use.</p>
<p>If <a class="el" href="structTABLE__LIST.html#a2f91ffa46082ff0e3bf0800de997117a">TABLE_LIST::open_strategy</a> is set to OPEN_IF_EXISTS, the table is opened only if it exists. If the open strategy is OPEN_STUB, the underlying table is never opened. In both cases, metadata locks are always taken according to the lock strategy.</p>
<p>The function used to open temporary tables, but now it opens base tables only.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Open failed. "action" parameter may contain type of action needed to remedy problem before retrying again. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Success. Members of <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> structure are filled properly (e.g. TABLE_LIST::table is set for real tables and TABLE_LIST::view is set for views). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8eaa3b1fdce29eac72028f96c55607d3"></a><!-- doxytag: member="Open_table_context::Open_table_context" ref="ga8eaa3b1fdce29eac72028f96c55607d3" args="(THD *thd, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__Data__Dictionary.html#ga8eaa3b1fdce29eac72028f96c55607d3">Open_table_context::Open_table_context</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classOpen__table__context.html">Open_table_context</a> </p>

</div>
</div>
<a class="anchor" id="ga35659d6f0f8a6d39ee3f3db7c233df52"></a><!-- doxytag: member="sql_base.cc::open_table_uncached" ref="ga35659d6f0f8a6d39ee3f3db7c233df52" args="(THD *thd, const char *path, const char *db, const char *table_name, bool add_to_temporary_tables_list, bool open_in_engine)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE.html">TABLE</a>* <a class="el" href="group__Data__Dictionary.html#ga35659d6f0f8a6d39ee3f3db7c233df52">open_table_uncached</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_to_temporary_tables_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>open_in_engine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open a single table without table caching and don't add it to THD::open_tables. Depending on the 'add_to_temporary_tables_list' value, the opened <a class="el" href="structTABLE.html">TABLE</a> instance will be addded to THD::temporary_tables list.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">path</td><td>Path (without .frm) </td></tr>
    <tr><td class="paramname">db</td><td>Database name. </td></tr>
    <tr><td class="paramname">table_name</td><td>Table name. </td></tr>
    <tr><td class="paramname">add_to_temporary_tables_list</td><td>Specifies if the opened <a class="el" href="structTABLE.html">TABLE</a> instance should be linked into THD::temporary_tables list. </td></tr>
    <tr><td class="paramname">open_in_engine</td><td>Indicates that we need to open table in storage engine in addition to constructing <a class="el" href="structTABLE.html">TABLE</a> object for it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is used:<ul>
<li>by alter_table() to open a temporary table;</li>
<li>when creating a temporary table with CREATE TEMPORARY <a class="el" href="structTABLE.html">TABLE</a>.</li>
</ul>
</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="structTABLE.html">TABLE</a> instance for opened table. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga59e488af7a3f47be08fad22370de07c5"></a><!-- doxytag: member="sql_base.cc::open_tables" ref="ga59e488af7a3f47be08fad22370de07c5" args="(THD *thd, TABLE_LIST **start, uint *counter, uint flags, Prelocking_strategy *prelocking_strategy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPrelocking__strategy.html">Prelocking_strategy</a> *&#160;</td>
          <td class="paramname"><em>prelocking_strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open all tables in list</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">start</td><td><a class="el" href="classList.html">List</a> of tables to be open (it can be adjusted for statement that uses tables only implicitly, e.g. for "SELECT f1()"). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counter</td><td>Number of tables which were open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td><a class="el" href="classBitmap.html">Bitmap</a> of flags to modify how the tables will be open, see <a class="el" href="group__Data__Dictionary.html#ga43cb5a9ba1064a36db89ad5c4d645528">open_table()</a> description for details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prelocking_strategy</td><td>Strategy which specifies how prelocking algorithm should work for this statement.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Unless we are already in prelocked mode and prelocking strategy prescribes so this function will also precache all SP/SFs explicitly or implicitly (via views and triggers) used by the query and add tables needed for their execution to table list. Statement that uses SFs, invokes triggers or requires foreign key checks will be marked as requiring prelocking. Prelocked mode will be enabled for such query during <a class="el" href="group__Data__Dictionary.html#ga399ec28859bb54829b1cabbeed845f78">lock_tables()</a> call.</dd></dl>
<p>If query for which we are opening tables is already marked as requiring prelocking it won't do such precaching and will simply reuse table list which is already built.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Error, reported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab5c68673b37e4f394de31ffe4ac80fcc"></a><!-- doxytag: member="sql_base.cc::open_temporary_table" ref="gab5c68673b37e4f394de31ffe4ac80fcc" args="(THD *thd, TABLE_LIST *tl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gab5c68673b37e4f394de31ffe4ac80fcc">open_temporary_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find a temporary table specified by <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> instance in the cache and prepare its <a class="el" href="structTABLE.html">TABLE</a> instance for use.</p>
<p>This function tries to resolve this table in the list of temporary tables of this thread. Temporary tables are thread-local and "shadow" base tables with the same name.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>In most cases one should use <a class="el" href="group__Data__Dictionary.html#gac4c1cb71807d09d53273048447abf301">open_temporary_tables()</a> instead of this call.</dd>
<dd>
One should finalize process of opening temporary table for table list element by calling open_and_process_table(). This function is responsible for table version checking and handling of merge tables.</dd>
<dd>
We used to check global_read_lock before opening temporary tables. However, that limitation was artificial and is removed now.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>On success. If a temporary table exists for the given key, tl-&gt;table is set. </td></tr>
    <tr><td class="paramname">TRUE</td><td>On error. my_error() has been called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac4c1cb71807d09d53273048447abf301"></a><!-- doxytag: member="sql_base.cc::open_temporary_tables" ref="gac4c1cb71807d09d53273048447abf301" args="(THD *thd, TABLE_LIST *tl_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gac4c1cb71807d09d53273048447abf301">open_temporary_tables</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pre-open temporary tables corresponding to table list elements.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>One should finalize process of opening temporary tables by calling <a class="el" href="group__Data__Dictionary.html#ga59e488af7a3f47be08fad22370de07c5">open_tables()</a>. This function is responsible for table version checking and handling of merge tables.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Error status. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>On success. If a temporary tables exists for the given element, tl-&gt;table is set. </td></tr>
    <tr><td class="paramname">TRUE</td><td>On error. my_error() has been called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade48892bc4607303f7f4d3d6df4c39de"></a><!-- doxytag: member="Open_table_context::recover_from_failed_open" ref="gade48892bc4607303f7f4d3d6df4c39de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gade48892bc4607303f7f4d3d6df4c39de">Open_table_context::recover_from_failed_open</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Recover from failed attempt of open table by performing requested action.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>This function should be called only with "action" != OT_NO_ACTION and after having called </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__Data__Dictionary.html#ga92bec964ecaaa7270a429e664643b746">close_tables_for_reopen()</a>.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>- Success. One should try to open tables once again. </td></tr>
    <tr><td class="paramname">TRUE</td><td>- Error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0f27eb7444d2cec48296785a54e229f2"></a><!-- doxytag: member="sql_base.cc::release_table_share" ref="ga0f27eb7444d2cec48296785a54e229f2" args="(TABLE_SHARE *share)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#ga0f27eb7444d2cec48296785a54e229f2">release_table_share</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> *&#160;</td>
          <td class="paramname"><em>share</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mark that we are not using table share anymore.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">share</td><td>Table share</td></tr>
  </table>
  </dd>
</dl>
<p>If the share has no open tables and (we have done a refresh or if we have already too many open table shares) then delete the definition. </p>

</div>
</div>
<a class="anchor" id="gaf35889f70c8719510fb76899cf9cf20b"></a><!-- doxytag: member="Open_table_context::request_backoff_action" ref="gaf35889f70c8719510fb76899cf9cf20b" args="(enum_open_table_action action_arg, TABLE_LIST *table)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gaf35889f70c8719510fb76899cf9cf20b">Open_table_context::request_backoff_action</a> </td>
          <td>(</td>
          <td class="paramtype">enum_open_table_action&#160;</td>
          <td class="paramname"><em>action_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if we can back-off and set back off action if we can. Otherwise report and return error.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if back-off is impossible. </td></tr>
    <tr><td class="paramname">FALSE</td><td>if we can back off. Back off action has been set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f6730cd1feb3014042adbf998ca9203"></a><!-- doxytag: member="sql_base.cc::rm_temporary_table" ref="ga2f6730cd1feb3014042adbf998ca9203" args="(handlerton *base, const char *path)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga2f6730cd1feb3014042adbf998ca9203">rm_temporary_table</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlerton.html">handlerton</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Delete a temporary table.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Handlerton for table to be deleted. </td></tr>
    <tr><td class="paramname">path</td><td>Path to the table to be deleted (i.e. path to its .frm without an extension).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>- success. </td></tr>
    <tr><td class="paramname">true</td><td>- failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1cbd71e573571827be66b1314f50827f"></a><!-- doxytag: member="sql_base.cc::setup_tables_and_check_access" ref="ga1cbd71e573571827be66b1314f50827f" args="(THD *thd, Name_resolution_context *context, List&lt; TABLE_LIST &gt; *from_clause, TABLE_LIST *tables, TABLE_LIST **leaves, bool select_insert, ulong want_access_first, ulong want_access)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga1cbd71e573571827be66b1314f50827f">setup_tables_and_check_access</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structName__resolution__context.html">Name_resolution_context</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classList.html">List</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> &gt; *&#160;</td>
          <td class="paramname"><em>from_clause</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> **&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>select_insert</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>want_access_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulong&#160;</td>
          <td class="paramname"><em>want_access</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepare tables and check access for the view tables.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context. </td></tr>
    <tr><td class="paramname">context</td><td>Name resolution contest to setup table list there. </td></tr>
    <tr><td class="paramname">from_clause</td><td>Top-level list of table references in the FROM clause. </td></tr>
    <tr><td class="paramname">tables</td><td>Table list (select_lex-&gt;table_list). </td></tr>
    <tr><td class="paramname">leaves[in/out]</td><td><a class="el" href="classList.html">List</a> of join table leaves list (select_lex-&gt;leaf_tables). </td></tr>
    <tr><td class="paramname">select_insert</td><td>It is SELECT ... INSERT command/ </td></tr>
    <tr><td class="paramname">want_access_first</td><td>What access is requested of the first leaf. </td></tr>
    <tr><td class="paramname">want_access</td><td>What access is requested on the rest of leaves.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>A wrapper for check_tables that will also check the resulting table leaves list for access to all the tables that belong to a view.</dd>
<dd>
Beware that it can't properly check privileges in cases when table being changed is not the first table in the list of leaf tables (for example, for multi-UPDATE).</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>- Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>- Error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabb94e7a0682741b06d662be41fae480f"></a><!-- doxytag: member="sql_base.cc::table_def_start_shutdown" ref="gabb94e7a0682741b06d662be41fae480f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#gabb94e7a0682741b06d662be41fae480f">table_def_start_shutdown</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Notify table definition cache that process of shutting down server has started so it has to keep number of <a class="el" href="structTABLE.html">TABLE</a> and <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> objects minimal in order to reduce number of references to pluggable engines. </p>

</div>
</div>
<a class="anchor" id="ga97a6db70d8b4bedd682115942e96b09e"></a><!-- doxytag: member="sql_base.cc::tdc_open_view" ref="ga97a6db70d8b4bedd682115942e96b09e" args="(THD *thd, TABLE_LIST *table_list, const char *alias, const char *cache_key, uint cache_key_length, uint flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#ga97a6db70d8b4bedd682115942e96b09e">tdc_open_view</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cache_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>cache_key_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Open view by getting its definition from disk (and table cache in future).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handle </td></tr>
    <tr><td class="paramname">table_list</td><td><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> with db, table_name &amp; belong_to_view </td></tr>
    <tr><td class="paramname">alias</td><td>Alias name </td></tr>
    <tr><td class="paramname">cache_key</td><td><a class="el" href="classKey.html">Key</a> for table definition cache </td></tr>
    <tr><td class="paramname">cache_key_length</td><td>Length of cache_key </td></tr>
    <tr><td class="paramname">flags</td><td>Flags which modify how we open the view</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000071">Todo:</a></b></dt><dd>This function is needed for special handling of views under LOCK TABLES. We probably should get rid of it in long term.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>FALSE if success, TRUE - otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8faf6c6118b6677394e14994ae614075"></a><!-- doxytag: member="sql_base.cc::tdc_remove_table" ref="ga8faf6c6118b6677394e14994ae614075" args="(THD *thd, enum_tdc_remove_table_type remove_type, const char *db, const char *table_name, bool has_lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="group__Data__Dictionary.html#ga8faf6c6118b6677394e14994ae614075">tdc_remove_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_tdc_remove_table_type&#160;</td>
          <td class="paramname"><em>remove_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>table_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all or some (depending on parameter) instances of <a class="el" href="structTABLE.html">TABLE</a> and <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> from the table definition cache.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread context </td></tr>
    <tr><td class="paramname">remove_type</td><td>Type of removal: TDC_RT_REMOVE_ALL - remove all <a class="el" href="structTABLE.html">TABLE</a> instances and <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> instance. There should be no used <a class="el" href="structTABLE.html">TABLE</a> objects and caller should have exclusive metadata lock on the table. TDC_RT_REMOVE_NOT_OWN - remove all <a class="el" href="structTABLE.html">TABLE</a> instances except those that belong to this thread. There should be no <a class="el" href="structTABLE.html">TABLE</a> objects used by other threads and caller should have exclusive metadata lock on the table. TDC_RT_REMOVE_UNUSED - remove all unused <a class="el" href="structTABLE.html">TABLE</a> instances (if there are no used instances will also remove <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a>). TDC_RT_REMOVE_NOT_OWN_KEEP_SHARE - remove all <a class="el" href="structTABLE.html">TABLE</a> instances except those that belong to this thread, but don't mark <a class="el" href="structTABLE__SHARE.html">TABLE_SHARE</a> as old. There should be no <a class="el" href="structTABLE.html">TABLE</a> objects used by other threads and caller should have exclusive metadata lock on the table. </td></tr>
    <tr><td class="paramname">db</td><td>Name of database </td></tr>
    <tr><td class="paramname">table_name</td><td>Name of table </td></tr>
    <tr><td class="paramname">has_lock</td><td>If TRUE, LOCK_open is already acquired</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It assumes that table instances are already not used by any (other) thread (this should be achieved by using meta-data locks). </dd></dl>

</div>
</div>
<a class="anchor" id="ga5095dfc37db0400dbc6cb9f5efb38951"></a><!-- doxytag: member="sql_base.cc::unique_table" ref="ga5095dfc37db0400dbc6cb9f5efb38951" args="(THD *thd, TABLE_LIST *table, TABLE_LIST *table_list, bool check_alias)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a>* <a class="el" href="group__Data__Dictionary.html#ga5095dfc37db0400dbc6cb9f5efb38951">unique_table</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>table_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_alias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test that the subject table of INSERT/UPDATE/DELETE/CREATE or (in case of MyISAMMRG) one of its children are not used later in the query.</p>
<p>For MyISAMMRG tables, it is assumed that all the underlying tables of <code>table</code> (if any) are listed right after it and that their <code>parent_l</code> field points at the main table.</p>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">non-NULL</td><td>The table list element for the table that represents the duplicate. </td></tr>
    <tr><td class="paramname">NULL</td><td>No duplicates found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac19a8c14e089f35b82dc7a2ded67ea4b"></a><!-- doxytag: member="sql_base.cc::wait_while_table_is_used" ref="gac19a8c14e089f35b82dc7a2ded67ea4b" args="(THD *thd, TABLE *table, enum ha_extra_function function)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__Data__Dictionary.html#gac19a8c14e089f35b82dc7a2ded67ea4b">wait_while_table_is_used</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum ha_extra_function&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Force all other threads to stop using the table by upgrading metadata lock on it and remove unused <a class="el" href="structTABLE.html">TABLE</a> instances from cache.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler </td></tr>
    <tr><td class="paramname">table</td><td>Table to remove from cache </td></tr>
    <tr><td class="paramname">function</td><td>HA_EXTRA_PREPARE_FOR_DROP if table is to be deleted HA_EXTRA_FORCE_REOPEN if table is not be used HA_EXTRA_PREPARE_FOR_RENAME if table is to be renamed</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>When returning, the table will be unusable for other threads until metadata lock is downgraded.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>Success. </td></tr>
    <tr><td class="paramname">TRUE</td><td>Failure (e.g. because thread was killed). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga99c8e1e3e72cd74032d5f11c486911fd"></a><!-- doxytag: member="sql_base.cc::LOCK_open" ref="ga99c8e1e3e72cd74032d5f11c486911fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mysql_mutex_t <a class="el" href="group__Data__Dictionary.html#ga99c8e1e3e72cd74032d5f11c486911fd">LOCK_open</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>LOCK_open protects the following variables/objects:</p>
<p>1) The table_def_cache This is the hash table mapping table name to a table share object. The hash table can only be manipulated while holding LOCK_open. 2) last_table_id Generation of a new unique table_map_id for a table share is done through incrementing last_table_id, a global variable used for this purpose. 3) LOCK_open protects the initialisation of the table share object and all its members and also protects reading the .frm file from where the table share is initialised. 4) In particular the share-&gt;ref_count is updated each time a new table object is created that refers to a table share. This update is protected by LOCK_open. 5) oldest_unused_share, end_of_unused_share and share-&gt;next and share-&gt;prev are variables to handle the lists of table share objects, these can only be read and manipulated while holding the LOCK_open mutex. 6) table_def_shutdown_in_progress can be updated only while holding LOCK_open and ALL table cache mutexes. 7) refresh_version This variable can only be updated while holding LOCK_open AND all table cache mutexes. 8) share-&gt;version This variable is initialised while holding LOCK_open. It can only be updated while holding LOCK_open AND all table cache mutexes. So if a table share is found through a reference its version won't change if any of those mutexes are held. 9) share-&gt;m_flush_tickets </p>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:47 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
