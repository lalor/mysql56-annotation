<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: rpl_gtid.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">rpl_gtid.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* Copyright (c) 2011, 2015, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00002"></a>00002 <span class="comment"></span>
<a name="l00003"></a>00003 <span class="comment">   This program is free software; you can redistribute it and/or</span>
<a name="l00004"></a>00004 <span class="comment">   modify it under the terms of the GNU General Public License as</span>
<a name="l00005"></a>00005 <span class="comment">   published by the Free Software Foundation; version 2 of the</span>
<a name="l00006"></a>00006 <span class="comment">   License.</span>
<a name="l00007"></a>00007 <span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">   This program is distributed in the hope that it will be useful, but</span>
<a name="l00009"></a>00009 <span class="comment">   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00010"></a>00010 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU</span>
<a name="l00011"></a>00011 <span class="comment">   General Public License for more details.</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00014"></a>00014 <span class="comment">   along with this program; if not, write to the Free Software</span>
<a name="l00015"></a>00015 <span class="comment">   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA</span>
<a name="l00016"></a>00016 <span class="comment">   02110-1301 USA */</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#ifndef RPL_GTID_H_INCLUDED</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#define RPL_GTID_H_INCLUDED</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;m_string.h&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;mysqld_error.h&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;my_global.h&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#ifdef MYSQL_SERVER</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#include &lt;mysqld.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#endif</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="preprocessor">#ifdef MYSQL_CLIENT</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span><span class="preprocessor">#define BINLOG_ERROR(MYSQLBINLOG_ERROR, SERVER_ERROR) error MYSQLBINLOG_ERROR</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span><span class="preprocessor">#define BINLOG_ERROR(MYSQLBINLOG_ERROR, SERVER_ERROR) my_error SERVER_ERROR</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;hash.h&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;lf.h&quot;</span>
<a name="l00049"></a>00049 <span class="preprocessor">#include &quot;my_atomic.h&quot;</span>
<a name="l00050"></a>00050 
<a name="l00055"></a>00055 <span class="preprocessor">#define SKIP_WHITESPACE() while (my_isspace(&amp;my_charset_utf8_general_ci, *s)) s++</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="comment">/*</span>
<a name="l00057"></a>00057 <span class="comment">  This macro must be used to filter out parts of the code that</span>
<a name="l00058"></a>00058 <span class="comment">  is not used now but may be useful in future. In other words,</span>
<a name="l00059"></a>00059 <span class="comment">  we want to keep such code until we make up our minds on whether</span>
<a name="l00060"></a>00060 <span class="comment">  it should be removed or not.</span>
<a name="l00061"></a>00061 <span class="comment">*/</span>
<a name="l00062"></a>00062 <span class="preprocessor">#undef NON_DISABLED_GTID</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="comment">/*</span>
<a name="l00065"></a>00065 <span class="comment">  This macro must be used to filter out parts of the code that</span>
<a name="l00066"></a>00066 <span class="comment">  is not used now but we are not sure if there is a bug around</span>
<a name="l00067"></a>00067 <span class="comment">  them. In other words, we want to keep such code until we have</span>
<a name="l00068"></a>00068 <span class="comment">  time to investigate it.</span>
<a name="l00069"></a>00069 <span class="comment">*/</span>
<a name="l00070"></a>00070 <span class="preprocessor">#undef NON_ERROR_GTID</span>
<a name="l00071"></a>00071 <span class="preprocessor"></span>
<a name="l00072"></a>00072 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classString.html">String</a>;
<a name="l00074"></a>00074 <span class="keyword">class </span>THD;
<a name="l00075"></a>00075 <span class="preprocessor">#endif // ifndef MYSQL_CLIENT</span>
<a name="l00076"></a>00076 <span class="preprocessor"></span>
<a name="l00077"></a>00077 
<a name="l00079"></a>00079 <span class="keyword">typedef</span> int32 rpl_sidno;
<a name="l00081"></a>00081 <span class="keyword">typedef</span> int64 rpl_gno;
<a name="l00083"></a>00083 <span class="keyword">typedef</span> int64 rpl_binlog_pos;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 
<a name="l00102"></a>00102 <span class="keyword">enum</span> enum_return_status
<a name="l00103"></a>00103 {
<a name="l00105"></a>00105   RETURN_STATUS_OK= 0,
<a name="l00107"></a>00107   RETURN_STATUS_UNREPORTED_ERROR= 1,
<a name="l00109"></a>00109   RETURN_STATUS_REPORTED_ERROR= 2
<a name="l00110"></a>00110 };
<a name="l00111"></a>00111 
<a name="l00129"></a>00129 <span class="preprocessor">#ifdef DBUG_OFF</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span><span class="preprocessor">#define __CHECK_RETURN_STATUS(STATUS, ACTION, STATUS_NAME, ALLOW_UNREPORTED)</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00132"></a>00132 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">void</span> check_return_status(enum_return_status status,
<a name="l00133"></a>00133                                 <span class="keyword">const</span> <span class="keywordtype">char</span> *action, <span class="keyword">const</span> <span class="keywordtype">char</span> *status_name,
<a name="l00134"></a>00134                                 <span class="keywordtype">int</span> allow_unreported);
<a name="l00135"></a>00135 <span class="preprocessor">#define __CHECK_RETURN_STATUS(STATUS, ACTION, STATUS_NAME, ALLOW_UNREPORTED) \</span>
<a name="l00136"></a>00136 <span class="preprocessor">  check_return_status(STATUS, ACTION, STATUS_NAME, ALLOW_UNREPORTED);</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00138"></a>00138 <span class="preprocessor"></span>
<a name="l00143"></a>00143 <span class="preprocessor">#define __PROPAGATE_ERROR(STATUS, RETURN_VALUE, ALLOW_UNREPORTED)       \</span>
<a name="l00144"></a>00144 <span class="preprocessor">  do                                                                    \</span>
<a name="l00145"></a>00145 <span class="preprocessor">  {                                                                     \</span>
<a name="l00146"></a>00146 <span class="preprocessor">    enum_return_status __propagate_error_status= STATUS;                \</span>
<a name="l00147"></a>00147 <span class="preprocessor">    if (__propagate_error_status != RETURN_STATUS_OK) {                 \</span>
<a name="l00148"></a>00148 <span class="preprocessor">      __CHECK_RETURN_STATUS(__propagate_error_status, &quot;Propagating&quot;,    \</span>
<a name="l00149"></a>00149 <span class="preprocessor">                            #STATUS, ALLOW_UNREPORTED);                 \</span>
<a name="l00150"></a>00150 <span class="preprocessor">      DBUG_RETURN(RETURN_VALUE);                                        \</span>
<a name="l00151"></a>00151 <span class="preprocessor">    }                                                                   \</span>
<a name="l00152"></a>00152 <span class="preprocessor">  } while (0)</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span>
<a name="l00154"></a>00154 <span class="preprocessor">#define __RETURN_STATUS(STATUS, ALLOW_UNREPORTED)                       \</span>
<a name="l00155"></a>00155 <span class="preprocessor">  do                                                                    \</span>
<a name="l00156"></a>00156 <span class="preprocessor">  {                                                                     \</span>
<a name="l00157"></a>00157 <span class="preprocessor">    enum_return_status __return_status_status= STATUS;                  \</span>
<a name="l00158"></a>00158 <span class="preprocessor">    __CHECK_RETURN_STATUS(__return_status_status, &quot;Returning&quot;,          \</span>
<a name="l00159"></a>00159 <span class="preprocessor">                          #STATUS, ALLOW_UNREPORTED);                   \</span>
<a name="l00160"></a>00160 <span class="preprocessor">    DBUG_RETURN(__return_status_status);                                \</span>
<a name="l00161"></a>00161 <span class="preprocessor">  } while (0)</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span>
<a name="l00166"></a>00166 <span class="preprocessor">#define PROPAGATE_ERROR(STATUS)                                 \</span>
<a name="l00167"></a>00167 <span class="preprocessor">  __PROPAGATE_ERROR(STATUS, __propagate_error_status, true)</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>
<a name="l00173"></a>00173 <span class="preprocessor">#define PROPAGATE_REPORTED_ERROR(STATUS)                        \</span>
<a name="l00174"></a>00174 <span class="preprocessor">  __PROPAGATE_ERROR(STATUS, __propagate_error_status, false)</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>
<a name="l00180"></a>00180 <span class="preprocessor">#define PROPAGATE_REPORTED_ERROR_INT(STATUS)    \</span>
<a name="l00181"></a>00181 <span class="preprocessor">  __PROPAGATE_ERROR(STATUS, 1, false)</span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>
<a name="l00186"></a>00186 <span class="preprocessor">#define RETURN_STATUS(STATUS) __RETURN_STATUS(STATUS, true)</span>
<a name="l00187"></a>00187 <span class="preprocessor"></span>
<a name="l00192"></a>00192 <span class="preprocessor">#define RETURN_REPORTED_STATUS(STATUS) __RETURN_STATUS(STATUS, false)</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span>
<a name="l00194"></a>00194 <span class="preprocessor">#define RETURN_OK DBUG_RETURN(RETURN_STATUS_OK)</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span>
<a name="l00196"></a>00196 <span class="preprocessor">#define RETURN_REPORTED_ERROR RETURN_STATUS(RETURN_STATUS_REPORTED_ERROR)</span>
<a name="l00197"></a>00197 <span class="preprocessor"></span>
<a name="l00198"></a>00198 <span class="preprocessor">#define RETURN_UNREPORTED_ERROR RETURN_STATUS(RETURN_STATUS_UNREPORTED_ERROR)</span>
<a name="l00199"></a>00199 <span class="preprocessor"></span>
<a name="l00200"></a>00200 
<a name="l00202"></a>00202 <span class="keyword">const</span> rpl_gno MAX_GNO= LONGLONG_MAX;
<a name="l00204"></a>00204 <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_GNO_TEXT_LENGTH= 19;
<a name="l00206"></a>00206 <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_THREAD_ID_TEXT_LENGTH= 19;
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 
<a name="l00217"></a>00217 rpl_gno parse_gno(<span class="keyword">const</span> <span class="keywordtype">char</span> **s);
<a name="l00225"></a>00225 <span class="keywordtype">int</span> format_gno(<span class="keywordtype">char</span> *s, rpl_gno gno);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 
<a name="l00234"></a><a class="code" href="structUuid.html">00234</a> <span class="keyword">struct </span><a class="code" href="structUuid.html">Uuid</a>
<a name="l00235"></a>00235 {
<a name="l00241"></a>00241   enum_return_status <a class="code" href="structUuid.html#afd8cd95e3d337ac3324d4d6dbc0430bc">parse</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>);
<a name="l00243"></a><a class="code" href="structUuid.html#ac2b7f68ff2004c6dc231a90e6fd14428">00243</a>   <span class="keywordtype">void</span> <a class="code" href="structUuid.html#ac2b7f68ff2004c6dc231a90e6fd14428" title="Set to all zeros.">clear</a>() { memset(<a class="code" href="structUuid.html#a55716e4095497645d393804146331350" title="The data for this Uuid.">bytes</a>, 0, <a class="code" href="structUuid.html#a2e9ce46a4a0186039b0b8df442ad6bb5" title="The number of bytes in the data of a Uuid.">BYTE_LENGTH</a>); }
<a name="l00245"></a><a class="code" href="structUuid.html#ae353820c6466ffa8300f707a0a5562ad">00245</a>   <span class="keywordtype">void</span> <a class="code" href="structUuid.html#ae353820c6466ffa8300f707a0a5562ad" title="Copies the given 16-byte data to this UUID.">copy_from</a>(<span class="keyword">const</span> uchar *data) { memcpy(<a class="code" href="structUuid.html#a55716e4095497645d393804146331350" title="The data for this Uuid.">bytes</a>, data, <a class="code" href="structUuid.html#a2e9ce46a4a0186039b0b8df442ad6bb5" title="The number of bytes in the data of a Uuid.">BYTE_LENGTH</a>); }
<a name="l00247"></a><a class="code" href="structUuid.html#a021286108ae7918b2bbddff15c08e75a">00247</a>   <span class="keywordtype">void</span> <a class="code" href="structUuid.html#a021286108ae7918b2bbddff15c08e75a" title="Copies the given UUID object to this UUID.">copy_from</a>(<span class="keyword">const</span> <a class="code" href="structUuid.html">Uuid</a> &amp;data) { <a class="code" href="structUuid.html#a021286108ae7918b2bbddff15c08e75a" title="Copies the given UUID object to this UUID.">copy_from</a>(data.<a class="code" href="structUuid.html#a55716e4095497645d393804146331350" title="The data for this Uuid.">bytes</a>); }
<a name="l00249"></a><a class="code" href="structUuid.html#a4f79a64f48fef26c3265d3d3ff1529bf">00249</a>   <span class="keywordtype">void</span> <a class="code" href="structUuid.html#a4f79a64f48fef26c3265d3d3ff1529bf" title="Copies the given UUID object to this UUID.">copy_to</a>(uchar *data)<span class="keyword"> const </span>{ memcpy(data, <a class="code" href="structUuid.html#a55716e4095497645d393804146331350" title="The data for this Uuid.">bytes</a>, <a class="code" href="structUuid.html#a2e9ce46a4a0186039b0b8df442ad6bb5" title="The number of bytes in the data of a Uuid.">BYTE_LENGTH</a>); }
<a name="l00251"></a><a class="code" href="structUuid.html#aea60de579164e7ca3be805c1d0facb54">00251</a>   <span class="keywordtype">bool</span> <a class="code" href="structUuid.html#aea60de579164e7ca3be805c1d0facb54" title="Returns true if this UUID is equal the given UUID.">equals</a>(<span class="keyword">const</span> <a class="code" href="structUuid.html">Uuid</a> &amp;other)<span class="keyword"> const</span>
<a name="l00252"></a>00252 <span class="keyword">  </span>{ <span class="keywordflow">return</span> memcmp(<a class="code" href="structUuid.html#a55716e4095497645d393804146331350" title="The data for this Uuid.">bytes</a>, other.<a class="code" href="structUuid.html#a55716e4095497645d393804146331350" title="The data for this Uuid.">bytes</a>, <a class="code" href="structUuid.html#a2e9ce46a4a0186039b0b8df442ad6bb5" title="The number of bytes in the data of a Uuid.">BYTE_LENGTH</a>) == 0; }
<a name="l00259"></a>00259   <span class="keywordtype">size_t</span> <a class="code" href="structUuid.html#abce62683cfb88ec82d5a3b1e39bb1688">to_string</a>(<span class="keywordtype">char</span> *buf) <span class="keyword">const</span>;
<a name="l00261"></a>00261   <span class="keyword">static</span> <span class="keywordtype">size_t</span> <a class="code" href="structUuid.html#abce62683cfb88ec82d5a3b1e39bb1688">to_string</a>(<span class="keyword">const</span> uchar* bytes_arg, <span class="keywordtype">char</span> *buf);
<a name="l00262"></a>00262 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00263"></a>00263 <span class="preprocessor"></span>
<a name="l00264"></a><a class="code" href="structUuid.html#a4a2317667cc995d5d5a5147bad1e9fe1">00264</a>   <span class="keywordtype">void</span> <a class="code" href="structUuid.html#a4a2317667cc995d5d5a5147bad1e9fe1" title="Debugging only: Print this Uuid to stdout.">print</a>()<span class="keyword"> const</span>
<a name="l00265"></a>00265 <span class="keyword">  </span>{
<a name="l00266"></a>00266     <span class="keywordtype">char</span> buf[<a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c" title="The number of bytes in the textual representation of a Uuid.">TEXT_LENGTH</a> + 1];
<a name="l00267"></a>00267     <a class="code" href="structUuid.html#abce62683cfb88ec82d5a3b1e39bb1688">to_string</a>(buf);
<a name="l00268"></a>00268     printf(<span class="stringliteral">&quot;%s\n&quot;</span>, buf);
<a name="l00269"></a>00269   }
<a name="l00270"></a>00270 <span class="preprocessor">#endif</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span>
<a name="l00272"></a><a class="code" href="structUuid.html#aa8131c13c9aa092b894bc7408995e876">00272</a>   <span class="keywordtype">void</span> <a class="code" href="structUuid.html#aa8131c13c9aa092b894bc7408995e876" title="Print this Uuid to the trace file if debug is enabled; no-op otherwise.">dbug_print</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text= <span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l00273"></a>00273 <span class="keyword">  </span>{
<a name="l00274"></a>00274 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span>    <span class="keywordtype">char</span> buf[<a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c" title="The number of bytes in the textual representation of a Uuid.">TEXT_LENGTH</a> + 1];
<a name="l00276"></a>00276     <a class="code" href="structUuid.html#abce62683cfb88ec82d5a3b1e39bb1688">to_string</a>(buf);
<a name="l00277"></a>00277     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>, (<span class="stringliteral">&quot;%s%s%s&quot;</span>, text, *text ? <span class="stringliteral">&quot;: &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, buf));
<a name="l00278"></a>00278 <span class="preprocessor">#endif</span>
<a name="l00279"></a>00279 <span class="preprocessor"></span>  }
<a name="l00284"></a>00284   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="structUuid.html#a93eebc0e2df47b7c688aad6c4e92990f">is_valid</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<span class="keywordtype">string</span>);
<a name="l00286"></a><a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c">00286</a>   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c" title="The number of bytes in the textual representation of a Uuid.">TEXT_LENGTH</a>= 36;
<a name="l00288"></a><a class="code" href="structUuid.html#a2e9ce46a4a0186039b0b8df442ad6bb5">00288</a>   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="structUuid.html#a2e9ce46a4a0186039b0b8df442ad6bb5" title="The number of bytes in the data of a Uuid.">BYTE_LENGTH</a>= 16;
<a name="l00290"></a><a class="code" href="structUuid.html#a3612eda8011aaf086d5e5a8d663b39c6">00290</a>   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> <a class="code" href="structUuid.html#a3612eda8011aaf086d5e5a8d663b39c6" title="The number of bits in the data of a Uuid.">BIT_LENGTH</a>= 128;
<a name="l00292"></a><a class="code" href="structUuid.html#a55716e4095497645d393804146331350">00292</a>   uchar <a class="code" href="structUuid.html#a55716e4095497645d393804146331350" title="The data for this Uuid.">bytes</a>[<a class="code" href="structUuid.html#a2e9ce46a4a0186039b0b8df442ad6bb5" title="The number of bytes in the data of a Uuid.">BYTE_LENGTH</a>];
<a name="l00293"></a>00293 <span class="keyword">private</span>:
<a name="l00294"></a>00294   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> NUMBER_OF_SECTIONS= 5;
<a name="l00295"></a>00295   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> bytes_per_section[NUMBER_OF_SECTIONS];
<a name="l00296"></a>00296   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> hex_to_byte[256];
<a name="l00297"></a>00297 };
<a name="l00298"></a>00298 
<a name="l00299"></a>00299 
<a name="l00300"></a>00300 <span class="keyword">typedef</span> <a class="code" href="structUuid.html">Uuid</a> <a class="code" href="structUuid.html">rpl_sid</a>;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 
<a name="l00317"></a><a class="code" href="classCheckable__rwlock.html">00317</a> <span class="keyword">class </span><a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a>
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319 <span class="keyword">public</span>:
<a name="l00321"></a><a class="code" href="classCheckable__rwlock.html#acd95df77c30e253460b37564dbc62438">00321</a>   <a class="code" href="classCheckable__rwlock.html#acd95df77c30e253460b37564dbc62438" title="Initialize this Checkable_rwlock.">Checkable_rwlock</a>()
<a name="l00322"></a>00322   {
<a name="l00323"></a>00323 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span>    my_atomic_rwlock_init(&amp;atomic_lock);
<a name="l00325"></a>00325     lock_state= 0;
<a name="l00326"></a>00326 <span class="preprocessor">#else</span>
<a name="l00327"></a>00327 <span class="preprocessor"></span>    is_write_lock= <span class="keyword">false</span>;
<a name="l00328"></a>00328 <span class="preprocessor">#endif</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span><span class="preprocessor">#ifdef MYSQL_SERVER</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span>    mysql_rwlock_init(key_rwlock_global_sid_lock, &amp;rwlock);
<a name="l00331"></a>00331 <span class="preprocessor">#else</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span>    mysql_rwlock_init(0, &amp;rwlock);
<a name="l00333"></a>00333 <span class="preprocessor">#endif</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span>  }
<a name="l00336"></a><a class="code" href="classCheckable__rwlock.html#a723b97572b532987ba8e6a0b8c7a1ecf">00336</a>   <a class="code" href="classCheckable__rwlock.html#a723b97572b532987ba8e6a0b8c7a1ecf" title="Destroy this Checkable_lock.">~Checkable_rwlock</a>()
<a name="l00337"></a>00337   {
<a name="l00338"></a>00338 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00339"></a>00339 <span class="preprocessor"></span>    my_atomic_rwlock_destroy(&amp;atomic_lock);
<a name="l00340"></a>00340 <span class="preprocessor">#endif</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span>    mysql_rwlock_destroy(&amp;rwlock);
<a name="l00342"></a>00342   }
<a name="l00343"></a>00343 
<a name="l00345"></a><a class="code" href="classCheckable__rwlock.html#a4ad513078fb56a8124851230698302de">00345</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#a4ad513078fb56a8124851230698302de" title="Acquire the read lock.">rdlock</a>()
<a name="l00346"></a>00346   {
<a name="l00347"></a>00347     mysql_rwlock_rdlock(&amp;rwlock);
<a name="l00348"></a>00348     <a class="code" href="classCheckable__rwlock.html#a57caa67c212b79b75a8f2336d180cc12" title="Assert that no thread holds the write lock.">assert_no_wrlock</a>();
<a name="l00349"></a>00349 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00350"></a>00350 <span class="preprocessor"></span>    my_atomic_rwlock_wrlock(&amp;atomic_lock);
<a name="l00351"></a>00351     my_atomic_add32(&amp;lock_state, 1);
<a name="l00352"></a>00352     my_atomic_rwlock_wrunlock(&amp;atomic_lock);
<a name="l00353"></a>00353 <span class="preprocessor">#endif</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span>  }
<a name="l00356"></a><a class="code" href="classCheckable__rwlock.html#a4bd09795d0037c26253c97fdc9d7747b">00356</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#a4bd09795d0037c26253c97fdc9d7747b" title="Acquire the write lock.">wrlock</a>()
<a name="l00357"></a>00357   {
<a name="l00358"></a>00358     mysql_rwlock_wrlock(&amp;rwlock);
<a name="l00359"></a>00359     <a class="code" href="classCheckable__rwlock.html#a47b9b6f22fa39edeafd8c5a19ae030a4" title="Assert that no thread holds read or write lock.">assert_no_lock</a>();
<a name="l00360"></a>00360 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>    my_atomic_rwlock_wrlock(&amp;atomic_lock);
<a name="l00362"></a>00362     my_atomic_store32(&amp;lock_state, -1);
<a name="l00363"></a>00363     my_atomic_rwlock_wrunlock(&amp;atomic_lock);
<a name="l00364"></a>00364 <span class="preprocessor">#else</span>
<a name="l00365"></a>00365 <span class="preprocessor"></span>    is_write_lock= <span class="keyword">true</span>;
<a name="l00366"></a>00366 <span class="preprocessor">#endif</span>
<a name="l00367"></a>00367 <span class="preprocessor"></span>  }
<a name="l00369"></a><a class="code" href="classCheckable__rwlock.html#ad2eb6c44afcc5d29561c39312764235b">00369</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#ad2eb6c44afcc5d29561c39312764235b" title="Release the lock (whether it is a write or read lock).">unlock</a>()
<a name="l00370"></a>00370   {
<a name="l00371"></a>00371     <a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l00372"></a>00372 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00373"></a>00373 <span class="preprocessor"></span>    my_atomic_rwlock_wrlock(&amp;atomic_lock);
<a name="l00374"></a>00374     <span class="keywordtype">int</span> val= my_atomic_load32(&amp;lock_state);
<a name="l00375"></a>00375     <span class="keywordflow">if</span> (val &gt; 0)
<a name="l00376"></a>00376       my_atomic_add32(&amp;lock_state, -1);
<a name="l00377"></a>00377     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (val == -1)
<a name="l00378"></a>00378       my_atomic_store32(&amp;lock_state, 0);
<a name="l00379"></a>00379     <span class="keywordflow">else</span>
<a name="l00380"></a>00380       DBUG_ASSERT(0);
<a name="l00381"></a>00381     my_atomic_rwlock_wrunlock(&amp;atomic_lock);
<a name="l00382"></a>00382 <span class="preprocessor">#else</span>
<a name="l00383"></a>00383 <span class="preprocessor"></span>    is_write_lock= <span class="keyword">false</span>;
<a name="l00384"></a>00384 <span class="preprocessor">#endif</span>
<a name="l00385"></a>00385 <span class="preprocessor"></span>    mysql_rwlock_unlock(&amp;rwlock);
<a name="l00386"></a>00386   }
<a name="l00391"></a><a class="code" href="classCheckable__rwlock.html#ae0c50e01a86f053d4bc6f6a3d12fa8d6">00391</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classCheckable__rwlock.html#ae0c50e01a86f053d4bc6f6a3d12fa8d6">is_wrlock</a>()
<a name="l00392"></a>00392   {
<a name="l00393"></a>00393     <a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l00394"></a>00394 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00395"></a>00395 <span class="preprocessor"></span>    <span class="keywordflow">return</span> get_state() == -1;
<a name="l00396"></a>00396 <span class="preprocessor">#else</span>
<a name="l00397"></a>00397 <span class="preprocessor"></span>    <span class="keywordflow">return</span> is_write_lock;
<a name="l00398"></a>00398 <span class="preprocessor">#endif</span>
<a name="l00399"></a>00399 <span class="preprocessor"></span>  }
<a name="l00400"></a>00400 
<a name="l00402"></a><a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae">00402</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>()<span class="keyword"> const</span>
<a name="l00403"></a>00403 <span class="keyword">  </span>{ DBUG_ASSERT(get_state() != 0); }
<a name="l00405"></a><a class="code" href="classCheckable__rwlock.html#ac8870894ecf169c9f8e90cd90902c4d8">00405</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#ac8870894ecf169c9f8e90cd90902c4d8" title="Assert that some thread holds the read lock.">assert_some_rdlock</a>()<span class="keyword"> const</span>
<a name="l00406"></a>00406 <span class="keyword">  </span>{ DBUG_ASSERT(get_state() &gt; 0); }
<a name="l00408"></a><a class="code" href="classCheckable__rwlock.html#a5e9fdb488d310af3e6048066280babef">00408</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#a5e9fdb488d310af3e6048066280babef" title="Assert that some thread holds the write lock.">assert_some_wrlock</a>()<span class="keyword"> const</span>
<a name="l00409"></a>00409 <span class="keyword">  </span>{ DBUG_ASSERT(get_state() == -1); }
<a name="l00411"></a><a class="code" href="classCheckable__rwlock.html#a57caa67c212b79b75a8f2336d180cc12">00411</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#a57caa67c212b79b75a8f2336d180cc12" title="Assert that no thread holds the write lock.">assert_no_wrlock</a>()<span class="keyword"> const</span>
<a name="l00412"></a>00412 <span class="keyword">  </span>{ DBUG_ASSERT(get_state() &gt;= 0); }
<a name="l00414"></a><a class="code" href="classCheckable__rwlock.html#ab4cb9da96ac34bab9bfa1c88c8e524d2">00414</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#ab4cb9da96ac34bab9bfa1c88c8e524d2" title="Assert that no thread holds the read lock.">assert_no_rdlock</a>()<span class="keyword"> const</span>
<a name="l00415"></a>00415 <span class="keyword">  </span>{ DBUG_ASSERT(get_state() &lt;= 0); }
<a name="l00417"></a><a class="code" href="classCheckable__rwlock.html#a47b9b6f22fa39edeafd8c5a19ae030a4">00417</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classCheckable__rwlock.html#a47b9b6f22fa39edeafd8c5a19ae030a4" title="Assert that no thread holds read or write lock.">assert_no_lock</a>()<span class="keyword"> const</span>
<a name="l00418"></a>00418 <span class="keyword">  </span>{ DBUG_ASSERT(get_state() == 0); }
<a name="l00419"></a>00419 
<a name="l00420"></a>00420 <span class="keyword">private</span>:
<a name="l00421"></a>00421 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00422"></a>00422 <span class="preprocessor"></span>
<a name="l00428"></a>00428   <span class="keyword">volatile</span> int32 lock_state;
<a name="l00430"></a>00430   <span class="keyword">mutable</span> my_atomic_rwlock_t atomic_lock;
<a name="l00432"></a>00432   <span class="keyword">inline</span> int32 get_state()<span class="keyword"> const</span>
<a name="l00433"></a>00433 <span class="keyword">  </span>{
<a name="l00434"></a>00434     int32 ret;
<a name="l00435"></a>00435     my_atomic_rwlock_rdlock(&amp;atomic_lock);
<a name="l00436"></a>00436     ret= my_atomic_load32(const_cast&lt;volatile int32*&gt;(&amp;lock_state));
<a name="l00437"></a>00437     my_atomic_rwlock_rdunlock(&amp;atomic_lock);
<a name="l00438"></a>00438     <span class="keywordflow">return</span> ret;
<a name="l00439"></a>00439   }
<a name="l00440"></a>00440 <span class="preprocessor">#else</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span>  <span class="keywordtype">bool</span> is_write_lock;
<a name="l00442"></a>00442 <span class="preprocessor">#endif</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span>
<a name="l00444"></a>00444   mysql_rwlock_t rwlock;
<a name="l00445"></a>00445 };
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 
<a name="l00449"></a>00449 <span class="keyword">extern</span> <a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *global_sid_lock;
<a name="l00450"></a>00450 
<a name="l00451"></a>00451 
<a name="l00467"></a><a class="code" href="classSid__map.html">00467</a> <span class="keyword">class </span><a class="code" href="classSid__map.html">Sid_map</a>
<a name="l00468"></a>00468 {
<a name="l00469"></a>00469 <span class="keyword">public</span>:
<a name="l00476"></a>00476   <a class="code" href="classSid__map.html#adcb420a3241258cc68ab42910133144d">Sid_map</a>(<a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *sid_lock);
<a name="l00478"></a>00478   <a class="code" href="classSid__map.html#a02ebe48caba52d2bccd668088c25a8e8" title="Destroy this Sid_map.">~Sid_map</a>();
<a name="l00479"></a>00479 <span class="preprocessor">#ifdef NON_DISABLED_GTID</span>
<a name="l00480"></a>00480 <span class="preprocessor"></span>
<a name="l00485"></a>00485   enum_return_status clear();
<a name="l00486"></a>00486 <span class="preprocessor">#endif</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>
<a name="l00500"></a>00500   rpl_sidno <a class="code" href="classSid__map.html#a23aa9c0f385a44772e9e5c3955cca0cf">add_sid</a>(<span class="keyword">const</span> <a class="code" href="structUuid.html">rpl_sid</a> &amp;sid);
<a name="l00511"></a><a class="code" href="classSid__map.html#a5463e9ffa0cbdfe02fbd7a322590b646">00511</a>   rpl_sidno <a class="code" href="classSid__map.html#a5463e9ffa0cbdfe02fbd7a322590b646">sid_to_sidno</a>(<span class="keyword">const</span> <a class="code" href="structUuid.html">rpl_sid</a> &amp;sid)<span class="keyword"> const</span>
<a name="l00512"></a>00512 <span class="keyword">  </span>{
<a name="l00513"></a>00513     <span class="keywordflow">if</span> (sid_lock != NULL)
<a name="l00514"></a>00514       sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l00515"></a>00515     Node *node= (Node *)my_hash_search(&amp;_sid_to_sidno, sid.<a class="code" href="structUuid.html#a55716e4095497645d393804146331350" title="The data for this Uuid.">bytes</a>,
<a name="l00516"></a>00516                                        <a class="code" href="structUuid.html#a2e9ce46a4a0186039b0b8df442ad6bb5" title="The number of bytes in the data of a Uuid.">rpl_sid::BYTE_LENGTH</a>);
<a name="l00517"></a>00517     <span class="keywordflow">if</span> (node == NULL)
<a name="l00518"></a>00518       <span class="keywordflow">return</span> 0;
<a name="l00519"></a>00519     <span class="keywordflow">return</span> node-&gt;sidno;
<a name="l00520"></a>00520   }
<a name="l00534"></a><a class="code" href="classSid__map.html#a945ea7eccbb14052aa4bd84e5e44545c">00534</a>   <span class="keyword">const</span> <a class="code" href="structUuid.html">rpl_sid</a> &amp;<a class="code" href="classSid__map.html#a945ea7eccbb14052aa4bd84e5e44545c">sidno_to_sid</a>(rpl_sidno sidno)<span class="keyword"> const</span>
<a name="l00535"></a>00535 <span class="keyword">  </span>{
<a name="l00536"></a>00536     <span class="keywordflow">if</span> (sid_lock != NULL)
<a name="l00537"></a>00537       sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l00538"></a>00538     DBUG_ASSERT(sidno &gt;= 1 &amp;&amp; sidno &lt;= <a class="code" href="classSid__map.html#a7bb52a993792edff5d2348c728fb5a08">get_max_sidno</a>());
<a name="l00539"></a>00539     <span class="keywordflow">return</span> (*dynamic_element(&amp;_sidno_to_sid, sidno - 1, Node **))-&gt;sid;
<a name="l00540"></a>00540   }
<a name="l00549"></a><a class="code" href="classSid__map.html#ac62d7fb30ad41dacd77ea0ef842e5d70">00549</a>   rpl_sidno <a class="code" href="classSid__map.html#ac62d7fb30ad41dacd77ea0ef842e5d70">get_sorted_sidno</a>(rpl_sidno n)<span class="keyword"> const</span>
<a name="l00550"></a>00550 <span class="keyword">  </span>{
<a name="l00551"></a>00551     <span class="keywordflow">if</span> (sid_lock != NULL)
<a name="l00552"></a>00552       sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l00553"></a>00553     rpl_sidno ret= *dynamic_element(&amp;_sorted, n, rpl_sidno *);
<a name="l00554"></a>00554     <span class="keywordflow">return</span> ret;
<a name="l00555"></a>00555   }
<a name="l00562"></a><a class="code" href="classSid__map.html#a7bb52a993792edff5d2348c728fb5a08">00562</a>   rpl_sidno <a class="code" href="classSid__map.html#a7bb52a993792edff5d2348c728fb5a08">get_max_sidno</a>()<span class="keyword"> const</span>
<a name="l00563"></a>00563 <span class="keyword">  </span>{
<a name="l00564"></a>00564     <span class="keywordflow">if</span> (sid_lock != NULL)
<a name="l00565"></a>00565       sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l00566"></a>00566     <span class="keywordflow">return</span> _sidno_to_sid.elements;
<a name="l00567"></a>00567   }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 <span class="keyword">private</span>:
<a name="l00571"></a>00571   <span class="keyword">struct </span>Node
<a name="l00572"></a>00572   {
<a name="l00573"></a>00573     rpl_sidno sidno;
<a name="l00574"></a>00574     <a class="code" href="structUuid.html">rpl_sid</a> sid;
<a name="l00575"></a>00575   };
<a name="l00576"></a>00576 
<a name="l00588"></a>00588   enum_return_status add_node(rpl_sidno sidno, <span class="keyword">const</span> <a class="code" href="structUuid.html">rpl_sid</a> &amp;sid);
<a name="l00589"></a>00589 
<a name="l00591"></a>00591   <span class="keyword">mutable</span> <a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *sid_lock;
<a name="l00592"></a>00592 
<a name="l00597"></a>00597   DYNAMIC_ARRAY _sidno_to_sid;
<a name="l00602"></a>00602   HASH _sid_to_sidno;
<a name="l00609"></a>00609   DYNAMIC_ARRAY _sorted;
<a name="l00610"></a>00610 };
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 <span class="keyword">extern</span> <a class="code" href="classSid__map.html">Sid_map</a> *global_sid_map;
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 
<a name="l00636"></a><a class="code" href="classMutex__cond__array.html">00636</a> <span class="keyword">class </span><a class="code" href="classMutex__cond__array.html">Mutex_cond_array</a>
<a name="l00637"></a>00637 {
<a name="l00638"></a>00638 <span class="keyword">public</span>:
<a name="l00645"></a>00645   <a class="code" href="classMutex__cond__array.html#a7daf69af88f2693e9d8ba87a5fa59c2b">Mutex_cond_array</a>(<a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *global_lock);
<a name="l00647"></a>00647   <a class="code" href="classMutex__cond__array.html#a9dd09088240c27e11c270c43ff6c212b" title="Destroy this object.">~Mutex_cond_array</a>();
<a name="l00649"></a><a class="code" href="classMutex__cond__array.html#ac3e2ae5454a39a9b29259bf30cd7cb7e">00649</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classMutex__cond__array.html#ac3e2ae5454a39a9b29259bf30cd7cb7e" title="Lock the n&#39;th mutex.">lock</a>(<span class="keywordtype">int</span> n)<span class="keyword"> const</span>
<a name="l00650"></a>00650 <span class="keyword">  </span>{
<a name="l00651"></a>00651     <a class="code" href="classMutex__cond__array.html#ac6424deffca449b32e6d0338c10a7a92">assert_not_owner</a>(n);
<a name="l00652"></a>00652     mysql_mutex_lock(&amp;get_mutex_cond(n)-&gt;mutex);
<a name="l00653"></a>00653   }
<a name="l00655"></a><a class="code" href="classMutex__cond__array.html#aa00d13e13f3ad768bd3ae3fe95acd7d4">00655</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classMutex__cond__array.html#aa00d13e13f3ad768bd3ae3fe95acd7d4" title="Unlock the n&#39;th mutex.">unlock</a>(<span class="keywordtype">int</span> n)<span class="keyword"> const</span>
<a name="l00656"></a>00656 <span class="keyword">  </span>{
<a name="l00657"></a>00657     <a class="code" href="classMutex__cond__array.html#a09f60861a1433f32e48b4cc4af349e8b">assert_owner</a>(n);
<a name="l00658"></a>00658     mysql_mutex_unlock(&amp;get_mutex_cond(n)-&gt;mutex);
<a name="l00659"></a>00659   }
<a name="l00661"></a><a class="code" href="classMutex__cond__array.html#a1dd2cf64be75681ec1e13e8416bbeb19">00661</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classMutex__cond__array.html#a1dd2cf64be75681ec1e13e8416bbeb19" title="Broadcast the n&#39;th condition.">broadcast</a>(<span class="keywordtype">int</span> n)<span class="keyword"> const</span>
<a name="l00662"></a>00662 <span class="keyword">  </span>{
<a name="l00663"></a>00663     mysql_cond_broadcast(&amp;get_mutex_cond(n)-&gt;cond);
<a name="l00664"></a>00664   }
<a name="l00669"></a><a class="code" href="classMutex__cond__array.html#a09f60861a1433f32e48b4cc4af349e8b">00669</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classMutex__cond__array.html#a09f60861a1433f32e48b4cc4af349e8b">assert_owner</a>(<span class="keywordtype">int</span> n)<span class="keyword"> const</span>
<a name="l00670"></a>00670 <span class="keyword">  </span>{
<a name="l00671"></a>00671 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00672"></a>00672 <span class="preprocessor"></span>    mysql_mutex_assert_owner(&amp;get_mutex_cond(n)-&gt;mutex);
<a name="l00673"></a>00673 <span class="preprocessor">#endif</span>
<a name="l00674"></a>00674 <span class="preprocessor"></span>  }
<a name="l00679"></a><a class="code" href="classMutex__cond__array.html#ac6424deffca449b32e6d0338c10a7a92">00679</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classMutex__cond__array.html#ac6424deffca449b32e6d0338c10a7a92">assert_not_owner</a>(<span class="keywordtype">int</span> n)<span class="keyword"> const</span>
<a name="l00680"></a>00680 <span class="keyword">  </span>{
<a name="l00681"></a>00681 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00682"></a>00682 <span class="preprocessor"></span>    mysql_mutex_assert_not_owner(&amp;get_mutex_cond(n)-&gt;mutex);
<a name="l00683"></a>00683 <span class="preprocessor">#endif</span>
<a name="l00684"></a>00684 <span class="preprocessor"></span>  }
<a name="l00693"></a><a class="code" href="classMutex__cond__array.html#a04097201197f39439ba4a5758aef0933">00693</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classMutex__cond__array.html#a04097201197f39439ba4a5758aef0933">wait</a>(<span class="keywordtype">int</span> n)<span class="keyword"> const</span>
<a name="l00694"></a>00694 <span class="keyword">  </span>{
<a name="l00695"></a>00695     DBUG_ENTER(<span class="stringliteral">&quot;Mutex_cond_array::wait&quot;</span>);
<a name="l00696"></a>00696     Mutex_cond *mutex_cond= get_mutex_cond(n);
<a name="l00697"></a>00697     global_lock-&gt;<a class="code" href="classCheckable__rwlock.html#ad2eb6c44afcc5d29561c39312764235b" title="Release the lock (whether it is a write or read lock).">unlock</a>();
<a name="l00698"></a>00698     mysql_mutex_assert_owner(&amp;mutex_cond-&gt;mutex);
<a name="l00699"></a>00699     mysql_cond_wait(&amp;mutex_cond-&gt;cond, &amp;mutex_cond-&gt;mutex);
<a name="l00700"></a>00700     mysql_mutex_assert_owner(&amp;mutex_cond-&gt;mutex);
<a name="l00701"></a>00701     DBUG_VOID_RETURN;
<a name="l00702"></a>00702   }
<a name="l00703"></a>00703 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l00704"></a>00704 <span class="preprocessor"></span>
<a name="l00705"></a>00705   <span class="keywordtype">void</span> <a class="code" href="classMutex__cond__array.html#a3b88400d8a7ac2ee797c83174035ff18" title="Execute THD::enter_cond for the n&#39;th condition variable.">enter_cond</a>(THD *thd, <span class="keywordtype">int</span> n, PSI_stage_info *stage,
<a name="l00706"></a>00706                   PSI_stage_info *old_stage) <span class="keyword">const</span>;
<a name="l00707"></a>00707 <span class="preprocessor">#endif // ifndef MYSQL_CLIENT</span>
<a name="l00708"></a>00708 <span class="preprocessor"></span>
<a name="l00709"></a><a class="code" href="classMutex__cond__array.html#a957daf939ff01d7b7ec3c104d230ec63">00709</a>   <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classMutex__cond__array.html#a957daf939ff01d7b7ec3c104d230ec63" title="Return the greatest addressable index in this Mutex_cond_array.">get_max_index</a>()<span class="keyword"> const</span>
<a name="l00710"></a>00710 <span class="keyword">  </span>{
<a name="l00711"></a>00711     global_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l00712"></a>00712     <span class="keywordflow">return</span> array.elements - 1;
<a name="l00713"></a>00713   }
<a name="l00724"></a>00724   enum_return_status <a class="code" href="classMutex__cond__array.html#a36690cb3001e20bc5900abce919ea4e1">ensure_index</a>(<span class="keywordtype">int</span> n);
<a name="l00725"></a>00725 <span class="keyword">private</span>:
<a name="l00727"></a>00727   <span class="keyword">struct </span>Mutex_cond
<a name="l00728"></a>00728   {
<a name="l00729"></a>00729     mysql_mutex_t mutex;
<a name="l00730"></a>00730     mysql_cond_t cond;
<a name="l00731"></a>00731   };
<a name="l00733"></a>00733   <span class="keyword">inline</span> Mutex_cond *get_mutex_cond(<span class="keywordtype">int</span> n)<span class="keyword"> const</span>
<a name="l00734"></a>00734 <span class="keyword">  </span>{
<a name="l00735"></a>00735     global_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l00736"></a>00736     DBUG_ASSERT(n &lt;= <a class="code" href="classMutex__cond__array.html#a957daf939ff01d7b7ec3c104d230ec63" title="Return the greatest addressable index in this Mutex_cond_array.">get_max_index</a>());
<a name="l00737"></a>00737     Mutex_cond *ret= *dynamic_element(&amp;array, n, Mutex_cond **);
<a name="l00738"></a>00738     DBUG_ASSERT(ret);
<a name="l00739"></a>00739     <span class="keywordflow">return</span> ret;
<a name="l00740"></a>00740   }
<a name="l00742"></a>00742   <span class="keyword">mutable</span> <a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *global_lock;
<a name="l00743"></a>00743   DYNAMIC_ARRAY array;
<a name="l00744"></a>00744 };
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 
<a name="l00754"></a><a class="code" href="structGtid.html">00754</a> <span class="keyword">struct </span><a class="code" href="structGtid.html">Gtid</a>
<a name="l00755"></a>00755 {
<a name="l00757"></a><a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2">00757</a>   rpl_sidno <a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>;
<a name="l00759"></a><a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a">00759</a>   rpl_gno <a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>;
<a name="l00760"></a>00760 
<a name="l00762"></a><a class="code" href="structGtid.html#a459c77dd4b1918fa7760fa5b0588ce79">00762</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid.html#a459c77dd4b1918fa7760fa5b0588ce79" title="Set both components to 0.">clear</a>() { <a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>= 0; <a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>= 0; }
<a name="l00763"></a>00763   <span class="comment">// Set both components to input values.</span>
<a name="l00764"></a>00764   <span class="keywordtype">void</span> <span class="keyword">set</span>(rpl_sidno sno, rpl_gno gtidno) { <a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>= sno; <a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>= gtidno; }
<a name="l00765"></a>00765   <span class="comment">// check if both components are zero or not.</span>
<a name="l00766"></a>00766   <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a> == 0) &amp;&amp; (<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a> == 0); }
<a name="l00771"></a><a class="code" href="structGtid.html#a16358c79f9923fb0a0aaab4d71e86fc0">00771</a>   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structGtid.html#a16358c79f9923fb0a0aaab4d71e86fc0">MAX_TEXT_LENGTH</a>= <a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c" title="The number of bytes in the textual representation of a Uuid.">Uuid::TEXT_LENGTH</a> + 1 + MAX_GNO_TEXT_LENGTH;
<a name="l00776"></a>00776   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="structGtid.html#afaec04645d158bc4ad9eaa2199cc6951">is_valid</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text);
<a name="l00784"></a>00784   <span class="keywordtype">int</span> <a class="code" href="structGtid.html#a552715694a25a8a26cfd75269e187696">to_string</a>(<span class="keyword">const</span> <a class="code" href="structUuid.html">rpl_sid</a> &amp;sid, <span class="keywordtype">char</span> *buf) <span class="keyword">const</span>;
<a name="l00792"></a>00792   <span class="keywordtype">int</span> <a class="code" href="structGtid.html#a552715694a25a8a26cfd75269e187696">to_string</a>(<span class="keyword">const</span> <a class="code" href="classSid__map.html">Sid_map</a> *sid_map, <span class="keywordtype">char</span> *buf) <span class="keyword">const</span>;
<a name="l00794"></a><a class="code" href="structGtid.html#a34c19daaa1c0b95e2ebed7caf6059f01">00794</a>   <span class="keywordtype">bool</span> <a class="code" href="structGtid.html#a34c19daaa1c0b95e2ebed7caf6059f01" title="Returns true if this Gtid has the same sid and gno as &#39;other&#39;.">equals</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;other)<span class="keyword"> const</span>
<a name="l00795"></a>00795 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a> == other.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a> &amp;&amp; <a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a> == other.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>; }
<a name="l00802"></a>00802   enum_return_status <a class="code" href="structGtid.html#aac7d6a154262abb97af871d7f31aad42">parse</a>(<a class="code" href="classSid__map.html">Sid_map</a> *sid_map, <span class="keyword">const</span> <span class="keywordtype">char</span> *text);
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00805"></a>00805 <span class="preprocessor"></span>
<a name="l00806"></a><a class="code" href="structGtid.html#aca9b647c0ad427eadf9488b4f94775b2">00806</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid.html#aca9b647c0ad427eadf9488b4f94775b2" title="Debug only: print this Gtid to stdout.">print</a>(<span class="keyword">const</span> <a class="code" href="classSid__map.html">Sid_map</a> *sid_map)<span class="keyword"> const</span>
<a name="l00807"></a>00807 <span class="keyword">  </span>{
<a name="l00808"></a>00808     <span class="keywordtype">char</span> buf[<a class="code" href="structGtid.html#a16358c79f9923fb0a0aaab4d71e86fc0">MAX_TEXT_LENGTH</a> + 1];
<a name="l00809"></a>00809     <a class="code" href="structGtid.html#a552715694a25a8a26cfd75269e187696">to_string</a>(sid_map, buf);
<a name="l00810"></a>00810     printf(<span class="stringliteral">&quot;%s\n&quot;</span>, buf);
<a name="l00811"></a>00811   }
<a name="l00812"></a>00812 <span class="preprocessor">#endif</span>
<a name="l00813"></a>00813 <span class="preprocessor"></span>
<a name="l00814"></a><a class="code" href="structGtid.html#acdf2b5c873c50021b91a944ad3a8ffa5">00814</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid.html#acdf2b5c873c50021b91a944ad3a8ffa5" title="Print this Gtid to the trace file if debug is enabled; no-op otherwise.">dbug_print</a>(<span class="keyword">const</span> <a class="code" href="classSid__map.html">Sid_map</a> *sid_map, <span class="keyword">const</span> <span class="keywordtype">char</span> *text= <span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l00815"></a>00815 <span class="keyword">  </span>{
<a name="l00816"></a>00816 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l00817"></a>00817 <span class="preprocessor"></span>    <span class="keywordtype">char</span> buf[<a class="code" href="structGtid.html#a16358c79f9923fb0a0aaab4d71e86fc0">MAX_TEXT_LENGTH</a> + 1];
<a name="l00818"></a>00818     <a class="code" href="structGtid.html#a552715694a25a8a26cfd75269e187696">to_string</a>(sid_map, buf);
<a name="l00819"></a>00819     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>, (<span class="stringliteral">&quot;%s%s%s&quot;</span>, text, *text ? <span class="stringliteral">&quot;: &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, buf));
<a name="l00820"></a>00820 <span class="preprocessor">#endif</span>
<a name="l00821"></a>00821 <span class="preprocessor"></span>  }
<a name="l00822"></a>00822 };
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 
<a name="l00846"></a><a class="code" href="classGtid__set.html">00846</a> <span class="keyword">class </span><a class="code" href="classGtid__set.html">Gtid_set</a>
<a name="l00847"></a>00847 {
<a name="l00848"></a>00848 <span class="keyword">public</span>:
<a name="l00858"></a>00858   <a class="code" href="classGtid__set.html#a048d3934c095e4afed99055334367047">Gtid_set</a>(<a class="code" href="classSid__map.html">Sid_map</a> *sid_map, <a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *sid_lock= NULL);
<a name="l00875"></a>00875   <a class="code" href="classGtid__set.html#a048d3934c095e4afed99055334367047">Gtid_set</a>(<a class="code" href="classSid__map.html">Sid_map</a> *sid_map, <span class="keyword">const</span> <span class="keywordtype">char</span> *text, enum_return_status *status,
<a name="l00876"></a>00876            <a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *sid_lock= NULL);
<a name="l00877"></a>00877 <span class="keyword">private</span>:
<a name="l00879"></a>00879   <span class="keywordtype">void</span> init();
<a name="l00880"></a>00880 <span class="keyword">public</span>:
<a name="l00882"></a>00882   <a class="code" href="classGtid__set.html#ad214bab2852c98a3b0ce39bb305f720f" title="Destroy this Gtid_set.">~Gtid_set</a>();
<a name="l00889"></a>00889   <span class="keywordtype">void</span> <a class="code" href="classGtid__set.html#a8d8130a7559cfd7b940f42e66c9b171a">clear</a>();
<a name="l00899"></a><a class="code" href="classGtid__set.html#ac457d510c14ce9d834ce85268f62f6fe">00899</a>   enum_return_status <a class="code" href="classGtid__set.html#ac457d510c14ce9d834ce85268f62f6fe">_add_gtid</a>(rpl_sidno sidno, rpl_gno gno)
<a name="l00900"></a>00900   {
<a name="l00901"></a>00901     DBUG_ENTER(<span class="stringliteral">&quot;Gtid_set::_add_gtid(sidno, gno)&quot;</span>);
<a name="l00902"></a>00902     <a class="code" href="classGtid__set_1_1Interval__iterator.html">Interval_iterator</a> ivit(<span class="keyword">this</span>, sidno);
<a name="l00903"></a>00903     Free_intervals_lock lock(<span class="keyword">this</span>);
<a name="l00904"></a>00904     enum_return_status ret= add_gno_interval(&amp;ivit, gno, gno + 1, &amp;lock);
<a name="l00905"></a>00905     DBUG_RETURN(ret);
<a name="l00906"></a>00906   }
<a name="l00914"></a><a class="code" href="classGtid__set.html#ae6298a4686b2856153efb1678ef326ce">00914</a>   enum_return_status <a class="code" href="classGtid__set.html#ae6298a4686b2856153efb1678ef326ce">_remove_gtid</a>(rpl_sidno sidno, rpl_gno gno)
<a name="l00915"></a>00915   {
<a name="l00916"></a>00916     DBUG_ENTER(<span class="stringliteral">&quot;Gtid_set::_remove_gtid(rpl_sidno, rpl_gno)&quot;</span>);
<a name="l00917"></a>00917     <span class="keywordflow">if</span> (sidno &lt;= <a class="code" href="classGtid__set.html#a2b2ed87e39d385d4beeeaec3e4c88db8" title="Returns the maximal sidno that this Gtid_set currently has space for.">get_max_sidno</a>())
<a name="l00918"></a>00918     {
<a name="l00919"></a>00919       <a class="code" href="classGtid__set_1_1Interval__iterator.html">Interval_iterator</a> ivit(<span class="keyword">this</span>, sidno);
<a name="l00920"></a>00920       Free_intervals_lock lock(<span class="keyword">this</span>);
<a name="l00921"></a>00921       enum_return_status ret= remove_gno_interval(&amp;ivit, gno, gno + 1, &amp;lock);
<a name="l00922"></a>00922       DBUG_RETURN(ret);
<a name="l00923"></a>00923     }
<a name="l00924"></a>00924     RETURN_OK;
<a name="l00925"></a>00925   }
<a name="l00934"></a><a class="code" href="classGtid__set.html#a0378bb6823f52a48455328515b62c684">00934</a>   enum_return_status <a class="code" href="classGtid__set.html#ac457d510c14ce9d834ce85268f62f6fe">_add_gtid</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid)
<a name="l00935"></a>00935   { <span class="keywordflow">return</span> <a class="code" href="classGtid__set.html#a0378bb6823f52a48455328515b62c684">_add_gtid</a>(gtid.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>, gtid.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>); }
<a name="l00942"></a><a class="code" href="classGtid__set.html#a020ff727cab9d32ce695233376a5383e">00942</a>   enum_return_status <a class="code" href="classGtid__set.html#ae6298a4686b2856153efb1678ef326ce">_remove_gtid</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid)
<a name="l00943"></a>00943   {
<a name="l00944"></a>00944     <span class="keywordflow">return</span> <a class="code" href="classGtid__set.html#ae6298a4686b2856153efb1678ef326ce">_remove_gtid</a>(gtid.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>, gtid.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>);
<a name="l00945"></a>00945   }
<a name="l00958"></a>00958   enum_return_status <a class="code" href="classGtid__set.html#a5a76ae688b1286b8bc51b02619174892">add_gtid_set</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *other);
<a name="l00965"></a>00965   enum_return_status <a class="code" href="classGtid__set.html#afc0a5e109f9b6f5d1fdec79462468340">remove_gtid_set</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *other);
<a name="l00994"></a>00994   enum_return_status <a class="code" href="classGtid__set.html#ae854e77cbadfd86cf28b61d5a8e228b9">add_gtid_text</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text, <span class="keywordtype">bool</span> *anonymous= NULL);
<a name="l01006"></a>01006   enum_return_status <a class="code" href="classGtid__set.html#ae5f1bc4e5fa45a2902ff562df316cf1b">add_gtid_encoding</a>(<span class="keyword">const</span> uchar *encoded, <span class="keywordtype">size_t</span> length,
<a name="l01007"></a>01007                                        <span class="keywordtype">size_t</span> *actual_length= NULL);
<a name="l01009"></a>01009   <span class="keywordtype">bool</span> <a class="code" href="classGtid__set.html#a0764f95ab9fc368a2af4e5f15faab2a7" title="Return true iff the given GTID exists in this set.">contains_gtid</a>(rpl_sidno sidno, rpl_gno gno) <span class="keyword">const</span>;
<a name="l01011"></a><a class="code" href="classGtid__set.html#a6a03ac8bd673ced1c4278d49edc722e2">01011</a>   <span class="keywordtype">bool</span> <a class="code" href="classGtid__set.html#a0764f95ab9fc368a2af4e5f15faab2a7" title="Return true iff the given GTID exists in this set.">contains_gtid</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid)<span class="keyword"> const</span>
<a name="l01012"></a>01012 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="classGtid__set.html#a6a03ac8bd673ced1c4278d49edc722e2" title="Return true iff the given GTID exists in this set.">contains_gtid</a>(gtid.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>, gtid.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>); }
<a name="l01014"></a><a class="code" href="classGtid__set.html#a2b2ed87e39d385d4beeeaec3e4c88db8">01014</a>   rpl_sidno <a class="code" href="classGtid__set.html#a2b2ed87e39d385d4beeeaec3e4c88db8" title="Returns the maximal sidno that this Gtid_set currently has space for.">get_max_sidno</a>()<span class="keyword"> const</span>
<a name="l01015"></a>01015 <span class="keyword">  </span>{
<a name="l01016"></a>01016     <span class="keywordflow">if</span> (sid_lock)
<a name="l01017"></a>01017       sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l01018"></a>01018     <span class="keywordflow">return</span> intervals.elements;
<a name="l01019"></a>01019   }
<a name="l01032"></a>01032   enum_return_status <a class="code" href="classGtid__set.html#a4f026631d33627a5c273bdc35dcc03ef">ensure_sidno</a>(rpl_sidno sidno);
<a name="l01034"></a>01034   <span class="keywordtype">bool</span> <a class="code" href="classGtid__set.html#aa52ca318b535ae2dbd8b40ec49f79b69" title="Returns true if this Gtid_set is a subset of the other Gtid_set.">is_subset</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *super) <span class="keyword">const</span>;
<a name="l01035"></a>01035 
<a name="l01051"></a>01051   <span class="keywordtype">bool</span> <a class="code" href="classGtid__set.html#a9b0c6d8267d511e65243f4275406653a">is_subset_for_sid</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *super, rpl_sidno superset_sidno,
<a name="l01052"></a>01052                          rpl_sidno subset_sidno) <span class="keyword">const</span>;
<a name="l01055"></a>01055   <span class="keywordtype">bool</span> <a class="code" href="classGtid__set.html#a5308098c872810aee29cdd332266f882">is_intersection_nonempty</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *other) <span class="keyword">const</span>;
<a name="l01063"></a>01063   enum_return_status <a class="code" href="classGtid__set.html#a9a384be7c735d018d5fc0c8c0c64344e">intersection</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *other, <a class="code" href="classGtid__set.html">Gtid_set</a> *result);
<a name="l01065"></a><a class="code" href="classGtid__set.html#af1bc45611a7f7852f42958103defec65">01065</a>   <span class="keywordtype">bool</span> <a class="code" href="classGtid__set.html#af1bc45611a7f7852f42958103defec65" title="Returns true if this Gtid_set is empty.">is_empty</a>()<span class="keyword"> const</span>
<a name="l01066"></a>01066 <span class="keyword">  </span>{
<a name="l01067"></a>01067     <a class="code" href="classGtid__set_1_1Gtid__iterator.html">Gtid_iterator</a> git(<span class="keyword">this</span>);
<a name="l01068"></a>01068     <span class="keywordflow">return</span> git.<a class="code" href="classGtid__set_1_1Gtid__iterator.html#a85632ebd49a8363dc819758caa540d81" title="Return next group, or {0,0} if we reached the end.">get</a>().<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a> == 0;
<a name="l01069"></a>01069   }
<a name="l01080"></a><a class="code" href="classGtid__set.html#a61bf4a182e8110a8fd74eb374e45bbd4">01080</a>   <span class="keywordtype">bool</span> <a class="code" href="classGtid__set.html#a61bf4a182e8110a8fd74eb374e45bbd4">contains_sidno</a>(rpl_sidno sidno)<span class="keyword"> const</span>
<a name="l01081"></a>01081 <span class="keyword">  </span>{
<a name="l01082"></a>01082     DBUG_ASSERT(sidno &gt;= 1);
<a name="l01083"></a>01083     <span class="keywordflow">if</span> (sidno &gt; <a class="code" href="classGtid__set.html#a2b2ed87e39d385d4beeeaec3e4c88db8" title="Returns the maximal sidno that this Gtid_set currently has space for.">get_max_sidno</a>())
<a name="l01084"></a>01084       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01085"></a>01085     <a class="code" href="classGtid__set_1_1Const__interval__iterator.html">Const_interval_iterator</a> ivit(<span class="keyword">this</span>, sidno);
<a name="l01086"></a>01086     <span class="keywordflow">return</span> ivit.<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a8feb34a611875f8233d2bd5c38a37d26" title="Return current_elem.">get</a>() != NULL;
<a name="l01087"></a>01087   }
<a name="l01092"></a>01092   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classGtid__set.html#a8a10c1dfb57ac995cbf14b51f83f8e68">is_valid</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text);
<a name="l01097"></a><a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">01097</a>   <span class="keywordtype">char</span> *<a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">to_string</a>()<span class="keyword"> const</span>
<a name="l01098"></a>01098 <span class="keyword">  </span>{
<a name="l01099"></a>01099     <span class="keywordtype">char</span> *str= (<span class="keywordtype">char</span> *)my_malloc(<a class="code" href="classGtid__set.html#aaf41f6a15633a2076cc90b96dfbe7bb2">get_string_length</a>() + 1, MYF(MY_WME));
<a name="l01100"></a>01100     <span class="keywordflow">if</span> (str != NULL)
<a name="l01101"></a>01101       <a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">to_string</a>(str);
<a name="l01102"></a>01102     <span class="keywordflow">return</span> str;
<a name="l01103"></a>01103   }
<a name="l01104"></a>01104 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l01105"></a>01105 <span class="preprocessor"></span>
<a name="l01106"></a><a class="code" href="classGtid__set.html#a9849a55e56aad6fc74bcfce5e54f31bb">01106</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__set.html#a9849a55e56aad6fc74bcfce5e54f31bb" title="Debug only: Print this Gtid_set to stdout.">print</a>()<span class="keyword"> const</span>
<a name="l01107"></a>01107 <span class="keyword">  </span>{
<a name="l01108"></a>01108     <span class="keywordtype">char</span> *str= <a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">to_string</a>();
<a name="l01109"></a>01109     printf(<span class="stringliteral">&quot;%s\n&quot;</span>, str);
<a name="l01110"></a>01110     my_free(str);
<a name="l01111"></a>01111   }
<a name="l01112"></a>01112 <span class="preprocessor">#endif</span>
<a name="l01113"></a>01113 <span class="preprocessor"></span>
<a name="l01117"></a><a class="code" href="classGtid__set.html#a743cf994d4d86067ead478a07abecd82">01117</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__set.html#a743cf994d4d86067ead478a07abecd82">dbug_print</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text= <span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l01118"></a>01118 <span class="keyword">  </span>{
<a name="l01119"></a>01119 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l01120"></a>01120 <span class="preprocessor"></span>    <span class="keywordtype">char</span> *str= <a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">to_string</a>();
<a name="l01121"></a>01121     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>, (<span class="stringliteral">&quot;%s%s&#39;%s&#39;&quot;</span>, text, *text ? <span class="stringliteral">&quot;: &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, str));
<a name="l01122"></a>01122     my_free(str);
<a name="l01123"></a>01123 <span class="preprocessor">#endif</span>
<a name="l01124"></a>01124 <span class="preprocessor"></span>  }
<a name="l01125"></a>01125 
<a name="l01130"></a><a class="code" href="structGtid__set_1_1String__format.html">01130</a>   <span class="keyword">struct </span><a class="code" href="structGtid__set_1_1String__format.html">String_format</a>
<a name="l01131"></a>01131   {
<a name="l01133"></a><a class="code" href="structGtid__set_1_1String__format.html#a87980e69804902aeaee5b8e2450703ae">01133</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structGtid__set_1_1String__format.html#a87980e69804902aeaee5b8e2450703ae" title="The generated string begins with this.">begin</a>;
<a name="l01135"></a><a class="code" href="structGtid__set_1_1String__format.html#a1cb48563a86070eabc8e42bc21f83597">01135</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structGtid__set_1_1String__format.html#a1cb48563a86070eabc8e42bc21f83597" title="The generated string begins with this.">end</a>;
<a name="l01137"></a><a class="code" href="structGtid__set_1_1String__format.html#a473afb96eb16c331e2d43debd1d8aa56">01137</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structGtid__set_1_1String__format.html#a473afb96eb16c331e2d43debd1d8aa56" title="In &#39;SID:GNO&#39;, this is the &#39;:&#39;.">sid_gno_separator</a>;
<a name="l01139"></a><a class="code" href="structGtid__set_1_1String__format.html#ad2a1f82538d7a3e734510f74713ed3fd">01139</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structGtid__set_1_1String__format.html#ad2a1f82538d7a3e734510f74713ed3fd" title="In &#39;SID:GNO-GNO&#39;, this is the &#39;-&#39;.">gno_start_end_separator</a>;
<a name="l01141"></a><a class="code" href="structGtid__set_1_1String__format.html#ab9b060e733a0078fa68045616c4b4893">01141</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structGtid__set_1_1String__format.html#ab9b060e733a0078fa68045616c4b4893" title="In &#39;SID:GNO:GNO&#39;, this is the second &#39;:&#39;.">gno_gno_separator</a>;
<a name="l01143"></a><a class="code" href="structGtid__set_1_1String__format.html#a2ffa890483bc67c05f591ec476f449c4">01143</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structGtid__set_1_1String__format.html#a2ffa890483bc67c05f591ec476f449c4" title="In &#39;SID:GNO,SID:GNO&#39;, this is the &#39;,&#39;.">gno_sid_separator</a>;
<a name="l01145"></a><a class="code" href="structGtid__set_1_1String__format.html#aa43febd91d066c1eb7d0fa050df2c7df">01145</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structGtid__set_1_1String__format.html#aa43febd91d066c1eb7d0fa050df2c7df" title="If the set is empty and this is not NULL, then this string is generated.">empty_set_string</a>;
<a name="l01147"></a><a class="code" href="structGtid__set_1_1String__format.html#a1d5f76899ce6b276d3f98b28e73efe6c">01147</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="structGtid__set_1_1String__format.html#a1d5f76899ce6b276d3f98b28e73efe6c" title="The following fields are the lengths of each field above.">begin_length</a>;
<a name="l01148"></a>01148     <span class="keyword">const</span> <span class="keywordtype">int</span> end_length;
<a name="l01149"></a>01149     <span class="keyword">const</span> <span class="keywordtype">int</span> sid_gno_separator_length;
<a name="l01150"></a>01150     <span class="keyword">const</span> <span class="keywordtype">int</span> gno_start_end_separator_length;
<a name="l01151"></a>01151     <span class="keyword">const</span> <span class="keywordtype">int</span> gno_gno_separator_length;
<a name="l01152"></a>01152     <span class="keyword">const</span> <span class="keywordtype">int</span> gno_sid_separator_length;
<a name="l01153"></a>01153     <span class="keyword">const</span> <span class="keywordtype">int</span> empty_set_string_length;
<a name="l01154"></a>01154   };
<a name="l01165"></a>01165   <span class="keywordtype">int</span> <a class="code" href="classGtid__set.html#aaf41f6a15633a2076cc90b96dfbe7bb2">get_string_length</a>(<span class="keyword">const</span> <a class="code" href="structGtid__set_1_1String__format.html">String_format</a> *string_format= NULL) <span class="keyword">const</span>;
<a name="l01175"></a>01175   <span class="keywordtype">int</span> <a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">to_string</a>(<span class="keywordtype">char</span> *buf, <span class="keyword">const</span> <a class="code" href="structGtid__set_1_1String__format.html">String_format</a> *string_format= NULL) <span class="keyword">const</span>;
<a name="l01176"></a>01176 
<a name="l01184"></a>01184   <span class="keywordtype">int</span> <a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">to_string</a>(<span class="keywordtype">char</span> **buf, <span class="keyword">const</span> <a class="code" href="structGtid__set_1_1String__format.html">String_format</a> *string_format= NULL) <span class="keyword">const</span>;
<a name="l01185"></a>01185 
<a name="l01190"></a><a class="code" href="classGtid__set.html#a65b9f6c31cfc7d5ca7b1564411c2a416">01190</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structGtid__set_1_1String__format.html">String_format</a> <a class="code" href="classGtid__set.html#a65b9f6c31cfc7d5ca7b1564411c2a416">default_string_format</a>;
<a name="l01195"></a><a class="code" href="classGtid__set.html#abefb12fa60900cd38a8abe959b774f54">01195</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structGtid__set_1_1String__format.html">String_format</a> <a class="code" href="classGtid__set.html#abefb12fa60900cd38a8abe959b774f54">sql_string_format</a>;
<a name="l01200"></a><a class="code" href="classGtid__set.html#a4ba668b76ba3d4a4d96a91389dc31817">01200</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="structGtid__set_1_1String__format.html">String_format</a> <a class="code" href="classGtid__set.html#a4ba668b76ba3d4a4d96a91389dc31817">commented_string_format</a>;
<a name="l01201"></a>01201 
<a name="l01203"></a><a class="code" href="classGtid__set.html#a9914637aee651504cce32611761cba05">01203</a>   <a class="code" href="classSid__map.html">Sid_map</a> *<a class="code" href="classGtid__set.html#a9914637aee651504cce32611761cba05" title="Return the Sid_map associated with this Gtid_set.">get_sid_map</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> sid_map; }
<a name="l01204"></a>01204 
<a name="l01209"></a><a class="code" href="structGtid__set_1_1Interval.html">01209</a>   <span class="keyword">struct </span><a class="code" href="structGtid__set_1_1Interval.html">Interval</a>
<a name="l01210"></a>01210   {
<a name="l01211"></a>01211   <span class="keyword">public</span>:
<a name="l01213"></a><a class="code" href="structGtid__set_1_1Interval.html#a0786a895f41f0f6095d5437fbe7854e3">01213</a>     rpl_gno <a class="code" href="structGtid__set_1_1Interval.html#a0786a895f41f0f6095d5437fbe7854e3" title="The first GNO of this interval.">start</a>;
<a name="l01215"></a><a class="code" href="structGtid__set_1_1Interval.html#a2a3ca57b8f934e3c8508cb36b0209589">01215</a>     rpl_gno <a class="code" href="structGtid__set_1_1Interval.html#a2a3ca57b8f934e3c8508cb36b0209589" title="The first GNO after this interval.">end</a>;
<a name="l01217"></a><a class="code" href="structGtid__set_1_1Interval.html#a5abd740117503d09bb420f7f01e6ce7a">01217</a>     <span class="keywordtype">bool</span> <a class="code" href="structGtid__set_1_1Interval.html#a5abd740117503d09bb420f7f01e6ce7a" title="Return true iff this interval is equal to the given interval.">equals</a>(<span class="keyword">const</span> <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> &amp;other)<span class="keyword"> const</span>
<a name="l01218"></a>01218 <span class="keyword">    </span>{
<a name="l01219"></a>01219       <span class="keywordflow">return</span> <a class="code" href="structGtid__set_1_1Interval.html#a0786a895f41f0f6095d5437fbe7854e3" title="The first GNO of this interval.">start</a> == other.<a class="code" href="structGtid__set_1_1Interval.html#a0786a895f41f0f6095d5437fbe7854e3" title="The first GNO of this interval.">start</a> &amp;&amp; <a class="code" href="structGtid__set_1_1Interval.html#a2a3ca57b8f934e3c8508cb36b0209589" title="The first GNO after this interval.">end</a> == other.<a class="code" href="structGtid__set_1_1Interval.html#a2a3ca57b8f934e3c8508cb36b0209589" title="The first GNO after this interval.">end</a>;
<a name="l01220"></a>01220     }
<a name="l01222"></a><a class="code" href="structGtid__set_1_1Interval.html#af6fe023b1dc03f396c3f435fd4c02e7d">01222</a>     <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *<a class="code" href="structGtid__set_1_1Interval.html#af6fe023b1dc03f396c3f435fd4c02e7d" title="Pointer to next interval in list.">next</a>;
<a name="l01223"></a>01223   };
<a name="l01224"></a>01224 
<a name="l01234"></a><a class="code" href="classGtid__set.html#a11541c02363dc7a2877a5a0282d679ab">01234</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__set.html#a11541c02363dc7a2877a5a0282d679ab">add_interval_memory</a>(<span class="keywordtype">int</span> n_intervals, <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *intervals_param)
<a name="l01235"></a>01235   {
<a name="l01236"></a>01236     <span class="keywordflow">if</span> (sid_lock != NULL)
<a name="l01237"></a>01237       mysql_mutex_lock(&amp;free_intervals_mutex);
<a name="l01238"></a>01238     add_interval_memory_lock_taken(n_intervals, intervals_param);
<a name="l01239"></a>01239     <span class="keywordflow">if</span> (sid_lock != NULL)
<a name="l01240"></a>01240       mysql_mutex_unlock(&amp;free_intervals_mutex);
<a name="l01241"></a>01241   }
<a name="l01242"></a>01242 
<a name="l01243"></a>01243 
<a name="l01254"></a><a class="code" href="classGtid__set_1_1Interval__iterator__base.html">01254</a>   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Gt<span class="keywordtype">id</span>_set_p, <span class="keyword">typename</span> Interval_p&gt; <span class="keyword">class </span><a class="code" href="classGtid__set_1_1Interval__iterator__base.html">Interval_iterator_base</a>
<a name="l01255"></a>01255   {
<a name="l01256"></a>01256   <span class="keyword">public</span>:
<a name="l01263"></a><a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a679998deae5692929946999547b888fc">01263</a>     <a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a679998deae5692929946999547b888fc">Interval_iterator_base</a>(Gtid_set_p gtid_set, rpl_sidno sidno)
<a name="l01264"></a>01264     {
<a name="l01265"></a>01265       DBUG_ASSERT(sidno &gt;= 1 &amp;&amp; sidno &lt;= gtid_set-&gt;<a class="code" href="classGtid__set.html#a2b2ed87e39d385d4beeeaec3e4c88db8" title="Returns the maximal sidno that this Gtid_set currently has space for.">get_max_sidno</a>());
<a name="l01266"></a>01266       <a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a08de43d5f9a6fcd8b02a9e0267b62c25" title="Reset this iterator.">init</a>(gtid_set, sidno);
<a name="l01267"></a>01267     }
<a name="l01269"></a><a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab899a786a5ad507a69d0e33ea8866bc9">01269</a>     <a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a679998deae5692929946999547b888fc">Interval_iterator_base</a>(Gtid_set_p gtid_set)
<a name="l01270"></a>01270     { <a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a>= <span class="keyword">const_cast&lt;</span>Interval_p *<span class="keyword">&gt;</span>(&amp;gtid_set-&gt;free_intervals); }
<a name="l01272"></a><a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a08de43d5f9a6fcd8b02a9e0267b62c25">01272</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a08de43d5f9a6fcd8b02a9e0267b62c25" title="Reset this iterator.">init</a>(Gtid_set_p gtid_set, rpl_sidno sidno)
<a name="l01273"></a>01273     { <a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a>= dynamic_element(&amp;gtid_set-&gt;intervals, sidno - 1, Interval_p *); }
<a name="l01275"></a><a class="code" href="classGtid__set_1_1Interval__iterator__base.html#abd5cb3d9c3d4612a6cc8b72c97bec510">01275</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classGtid__set_1_1Interval__iterator__base.html#abd5cb3d9c3d4612a6cc8b72c97bec510" title="Advance current_elem one step.">next</a>()
<a name="l01276"></a>01276     {
<a name="l01277"></a>01277       DBUG_ASSERT(*<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a> != NULL);
<a name="l01278"></a>01278       <a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a>= <span class="keyword">const_cast&lt;</span>Interval_p *<span class="keyword">&gt;</span>(&amp;(*p)-&gt;next);
<a name="l01279"></a>01279     }
<a name="l01281"></a><a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a8feb34a611875f8233d2bd5c38a37d26">01281</a>     <span class="keyword">inline</span> Interval_p <span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keywordflow">return</span> *<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a>; }
<a name="l01282"></a>01282   <span class="keyword">protected</span>:
<a name="l01288"></a><a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">01288</a>     Interval_p *<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a>;
<a name="l01289"></a>01289   };
<a name="l01290"></a>01290 
<a name="l01294"></a><a class="code" href="classGtid__set_1_1Const__interval__iterator.html">01294</a>   <span class="keyword">class </span><a class="code" href="classGtid__set_1_1Const__interval__iterator.html">Const_interval_iterator</a>
<a name="l01295"></a>01295     : <span class="keyword">public</span> <a class="code" href="classGtid__set_1_1Interval__iterator__base.html">Interval_iterator_base</a>&lt;const Gtid_set *, const Interval *&gt;
<a name="l01296"></a>01296   {
<a name="l01297"></a>01297   <span class="keyword">public</span>:
<a name="l01299"></a><a class="code" href="classGtid__set_1_1Const__interval__iterator.html#a515dc66125544645940ffcd8a485ca1e">01299</a>     <a class="code" href="classGtid__set_1_1Const__interval__iterator.html#a515dc66125544645940ffcd8a485ca1e" title="Create this Const_interval_iterator.">Const_interval_iterator</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *gtid_set, rpl_sidno sidno)
<a name="l01300"></a>01300       : <a class="code" href="classGtid__set_1_1Interval__iterator__base.html">Interval_iterator_base</a>&lt;const <a class="code" href="classGtid__set.html">Gtid_set</a> *, const <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *&gt;(gtid_set, sidno) {}
<a name="l01302"></a><a class="code" href="classGtid__set_1_1Const__interval__iterator.html#a1ade845d9c9c0d8eb2f9b1bb4fd70b6d">01302</a>     <a class="code" href="classGtid__set_1_1Const__interval__iterator.html#a515dc66125544645940ffcd8a485ca1e" title="Create this Const_interval_iterator.">Const_interval_iterator</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *gtid_set)
<a name="l01303"></a>01303       : <a class="code" href="classGtid__set_1_1Interval__iterator__base.html">Interval_iterator_base</a>&lt;const <a class="code" href="classGtid__set.html">Gtid_set</a> *, const <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *&gt;(gtid_set) {}
<a name="l01304"></a>01304   };
<a name="l01305"></a>01305 
<a name="l01310"></a><a class="code" href="classGtid__set_1_1Interval__iterator.html">01310</a>   <span class="keyword">class </span><a class="code" href="classGtid__set_1_1Interval__iterator.html">Interval_iterator</a>
<a name="l01311"></a>01311     : <span class="keyword">public</span> <a class="code" href="classGtid__set_1_1Interval__iterator__base.html">Interval_iterator_base</a>&lt;Gtid_set *, Interval *&gt;
<a name="l01312"></a>01312   {
<a name="l01313"></a>01313   <span class="keyword">public</span>:
<a name="l01315"></a><a class="code" href="classGtid__set_1_1Interval__iterator.html#aef2467c6029a1bf88f96e767b3406f54">01315</a>     <a class="code" href="classGtid__set_1_1Interval__iterator.html#aef2467c6029a1bf88f96e767b3406f54" title="Create this Interval_iterator.">Interval_iterator</a>(<a class="code" href="classGtid__set.html">Gtid_set</a> *gtid_set, rpl_sidno sidno)
<a name="l01316"></a>01316       : <a class="code" href="classGtid__set_1_1Interval__iterator__base.html">Interval_iterator_base</a>&lt;<a class="code" href="classGtid__set.html">Gtid_set</a> *, <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *&gt;(gtid_set, sidno) {}
<a name="l01318"></a><a class="code" href="classGtid__set_1_1Interval__iterator.html#a77fcaac128a0d18294e57b2b1566ae20">01318</a>     <a class="code" href="classGtid__set_1_1Interval__iterator.html#aef2467c6029a1bf88f96e767b3406f54" title="Create this Interval_iterator.">Interval_iterator</a>(<a class="code" href="classGtid__set.html">Gtid_set</a> *gtid_set)
<a name="l01319"></a>01319       : <a class="code" href="classGtid__set_1_1Interval__iterator__base.html">Interval_iterator_base</a>&lt;<a class="code" href="classGtid__set.html">Gtid_set</a> *, <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *&gt;(gtid_set) {}
<a name="l01320"></a>01320   <span class="keyword">private</span>:
<a name="l01325"></a>01325     <span class="keyword">inline</span> <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *iv) { *<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a>= iv; }
<a name="l01327"></a>01327     <span class="keyword">inline</span> <span class="keywordtype">void</span> insert(Interval *iv) { iv-&gt;<a class="code" href="structGtid__set_1_1Interval.html#af6fe023b1dc03f396c3f435fd4c02e7d" title="Pointer to next interval in list.">next</a>= *<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a>; <span class="keyword">set</span>(iv); }
<a name="l01329"></a>01329     <span class="keyword">inline</span> <span class="keywordtype">void</span> <span class="keyword">remove</span>(<a class="code" href="classGtid__set.html">Gtid_set</a> *gtid_set)
<a name="l01330"></a>01330     {
<a name="l01331"></a>01331       DBUG_ASSERT(<span class="keyword">get</span>() != NULL);
<a name="l01332"></a>01332       Interval *<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#abd5cb3d9c3d4612a6cc8b72c97bec510" title="Advance current_elem one step.">next</a>= (*p)-&gt;next;
<a name="l01333"></a>01333       gtid_set-&gt;put_free_interval(*<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#ab8609fb05e3782e8a73e496d35cbc217">p</a>);
<a name="l01334"></a>01334       <span class="keyword">set</span>(<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#abd5cb3d9c3d4612a6cc8b72c97bec510" title="Advance current_elem one step.">next</a>);
<a name="l01335"></a>01335     }
<a name="l01343"></a><a class="code" href="classGtid__set_1_1Interval__iterator.html#a437ecb1fc027e7507480556761c81936">01343</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classGtid__set.html">Gtid_set</a>;
<a name="l01344"></a>01344   };
<a name="l01345"></a>01345 
<a name="l01346"></a>01346 
<a name="l01351"></a><a class="code" href="classGtid__set_1_1Gtid__iterator.html">01351</a>   <span class="keyword">class </span><a class="code" href="classGtid__set_1_1Gtid__iterator.html">Gtid_iterator</a>
<a name="l01352"></a>01352   {
<a name="l01353"></a>01353   <span class="keyword">public</span>:
<a name="l01354"></a>01354     <a class="code" href="classGtid__set_1_1Gtid__iterator.html">Gtid_iterator</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *gs)
<a name="l01355"></a>01355       : gtid_set(gs), sidno(0), ivit(gs)
<a name="l01356"></a>01356     {
<a name="l01357"></a>01357       <span class="keywordflow">if</span> (gs-&gt;sid_lock != NULL)
<a name="l01358"></a>01358         gs-&gt;sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#a5e9fdb488d310af3e6048066280babef" title="Assert that some thread holds the write lock.">assert_some_wrlock</a>();
<a name="l01359"></a>01359       next_sidno();
<a name="l01360"></a>01360     }
<a name="l01362"></a><a class="code" href="classGtid__set_1_1Gtid__iterator.html#a5c49b5f8c9dfc58503d5eab219afcfa5">01362</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classGtid__set_1_1Gtid__iterator.html#a5c49b5f8c9dfc58503d5eab219afcfa5" title="Advance to next group.">next</a>()
<a name="l01363"></a>01363     {
<a name="l01364"></a>01364       DBUG_ASSERT(gno &gt; 0 &amp;&amp; sidno &gt; 0);
<a name="l01365"></a>01365       <span class="comment">// go to next group in current interval</span>
<a name="l01366"></a>01366       gno++;
<a name="l01367"></a>01367       <span class="comment">// end of interval? then go to next interval for this sidno</span>
<a name="l01368"></a>01368       <span class="keywordflow">if</span> (gno == ivit.<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a8feb34a611875f8233d2bd5c38a37d26" title="Return current_elem.">get</a>()-&gt;<a class="code" href="structGtid__set_1_1Interval.html#a2a3ca57b8f934e3c8508cb36b0209589" title="The first GNO after this interval.">end</a>)
<a name="l01369"></a>01369       {
<a name="l01370"></a>01370         ivit.<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#abd5cb3d9c3d4612a6cc8b72c97bec510" title="Advance current_elem one step.">next</a>();
<a name="l01371"></a>01371         <span class="keyword">const</span> <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *iv= ivit.<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a8feb34a611875f8233d2bd5c38a37d26" title="Return current_elem.">get</a>();
<a name="l01372"></a>01372         <span class="comment">// last interval for this sidno? then go to next sidno</span>
<a name="l01373"></a>01373         <span class="keywordflow">if</span> (iv == NULL)
<a name="l01374"></a>01374         {
<a name="l01375"></a>01375           next_sidno();
<a name="l01376"></a>01376           <span class="comment">// last sidno? then don&#39;t try more</span>
<a name="l01377"></a>01377           <span class="keywordflow">if</span> (sidno == 0)
<a name="l01378"></a>01378             <span class="keywordflow">return</span>;
<a name="l01379"></a>01379           iv= ivit.<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a8feb34a611875f8233d2bd5c38a37d26" title="Return current_elem.">get</a>();
<a name="l01380"></a>01380         }
<a name="l01381"></a>01381         gno= iv-&gt;<a class="code" href="structGtid__set_1_1Interval.html#a0786a895f41f0f6095d5437fbe7854e3" title="The first GNO of this interval.">start</a>;
<a name="l01382"></a>01382       }
<a name="l01383"></a>01383     }
<a name="l01385"></a><a class="code" href="classGtid__set_1_1Gtid__iterator.html#a85632ebd49a8363dc819758caa540d81">01385</a>     <span class="keyword">inline</span> <a class="code" href="structGtid.html">Gtid</a> <span class="keyword">get</span>() <span class="keyword">const</span>
<a name="l01386"></a>01386     {
<a name="l01387"></a>01387       <a class="code" href="structGtid.html">Gtid</a> ret= { sidno, gno };
<a name="l01388"></a>01388       <span class="keywordflow">return</span> ret;
<a name="l01389"></a>01389     }
<a name="l01390"></a>01390   <span class="keyword">private</span>:
<a name="l01392"></a>01392     <span class="keyword">inline</span> <span class="keywordtype">void</span> next_sidno()
<a name="l01393"></a>01393     {
<a name="l01394"></a>01394       <span class="keyword">const</span> <a class="code" href="structGtid__set_1_1Interval.html">Interval</a> *iv;
<a name="l01395"></a>01395       <span class="keywordflow">do</span>
<a name="l01396"></a>01396       {
<a name="l01397"></a>01397         sidno++;
<a name="l01398"></a>01398         <span class="keywordflow">if</span> (sidno &gt; gtid_set-&gt;<a class="code" href="classGtid__set.html#a2b2ed87e39d385d4beeeaec3e4c88db8" title="Returns the maximal sidno that this Gtid_set currently has space for.">get_max_sidno</a>())
<a name="l01399"></a>01399         {
<a name="l01400"></a>01400           sidno= 0;
<a name="l01401"></a>01401           gno= 0;
<a name="l01402"></a>01402           <span class="keywordflow">return</span>;
<a name="l01403"></a>01403         }
<a name="l01404"></a>01404         ivit.<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a08de43d5f9a6fcd8b02a9e0267b62c25" title="Reset this iterator.">init</a>(gtid_set, sidno);
<a name="l01405"></a>01405         iv= ivit.<a class="code" href="classGtid__set_1_1Interval__iterator__base.html#a8feb34a611875f8233d2bd5c38a37d26" title="Return current_elem.">get</a>();
<a name="l01406"></a>01406       } <span class="keywordflow">while</span> (iv == NULL);
<a name="l01407"></a>01407       gno= iv-&gt;<a class="code" href="structGtid__set_1_1Interval.html#a0786a895f41f0f6095d5437fbe7854e3" title="The first GNO of this interval.">start</a>;
<a name="l01408"></a>01408     }
<a name="l01410"></a>01410     <span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *gtid_set;
<a name="l01415"></a>01415     rpl_sidno sidno;
<a name="l01420"></a>01420     rpl_gno gno;
<a name="l01422"></a>01422     Const_interval_iterator ivit;
<a name="l01423"></a>01423   };
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 <span class="keyword">public</span>:
<a name="l01426"></a>01426 
<a name="l01430"></a>01430   <span class="keywordtype">void</span> <a class="code" href="classGtid__set.html#a7195a4f524b6d0bf7f3bf9df7b6c8694">encode</a>(uchar *buf) <span class="keyword">const</span>;
<a name="l01435"></a>01435   <span class="keywordtype">size_t</span> <a class="code" href="classGtid__set.html#acff96594881942b6bd91cfef6bcb58ee">get_encoded_length</a>() <span class="keyword">const</span>;
<a name="l01436"></a>01436 
<a name="l01437"></a>01437 <span class="keyword">private</span>:
<a name="l01444"></a>01444   <span class="keyword">struct </span>Interval_chunk
<a name="l01445"></a>01445   {
<a name="l01446"></a>01446     Interval_chunk *next;
<a name="l01447"></a>01447     Interval intervals[1];
<a name="l01448"></a>01448   };
<a name="l01450"></a>01450   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> CHUNK_GROW_SIZE= 8;
<a name="l01451"></a>01451 
<a name="l01452"></a>01452 <span class="comment">/*</span>
<a name="l01453"></a>01453 <span class="comment">  Functions sidno_equals() and equals() are only used by unitests</span>
<a name="l01454"></a>01454 <span class="comment">*/</span>
<a name="l01455"></a>01455 <span class="preprocessor">#ifdef NON_DISABLED_UNITTEST_GTID</span>
<a name="l01456"></a>01456 <span class="preprocessor"></span>
<a name="l01465"></a>01465   <span class="keywordtype">bool</span> sidno_equals(rpl_sidno sidno,
<a name="l01466"></a>01466                     <span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *other, rpl_sidno other_sidno) <span class="keyword">const</span>;
<a name="l01468"></a>01468   <span class="keywordtype">bool</span> equals(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *other) <span class="keyword">const</span>;
<a name="l01469"></a>01469 <span class="preprocessor">#endif</span>
<a name="l01470"></a>01470 <span class="preprocessor"></span>
<a name="l01472"></a>01472   <span class="keywordtype">int</span> get_n_intervals(rpl_sidno sidno)<span class="keyword"> const</span>
<a name="l01473"></a>01473 <span class="keyword">  </span>{
<a name="l01474"></a>01474     Const_interval_iterator ivit(<span class="keyword">this</span>, sidno);
<a name="l01475"></a>01475     <span class="keywordtype">int</span> ret= 0;
<a name="l01476"></a>01476     <span class="keywordflow">while</span> (ivit.get() != NULL)
<a name="l01477"></a>01477     {
<a name="l01478"></a>01478       ret++;
<a name="l01479"></a>01479       ivit.next();
<a name="l01480"></a>01480     }
<a name="l01481"></a>01481     <span class="keywordflow">return</span> ret;
<a name="l01482"></a>01482   }
<a name="l01484"></a>01484   <span class="keywordtype">int</span> get_n_intervals()<span class="keyword"> const</span>
<a name="l01485"></a>01485 <span class="keyword">  </span>{
<a name="l01486"></a>01486     <span class="keywordflow">if</span> (sid_lock != NULL)
<a name="l01487"></a>01487       sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#a5e9fdb488d310af3e6048066280babef" title="Assert that some thread holds the write lock.">assert_some_wrlock</a>();
<a name="l01488"></a>01488     rpl_sidno max_sidno= <a class="code" href="classGtid__set.html#a2b2ed87e39d385d4beeeaec3e4c88db8" title="Returns the maximal sidno that this Gtid_set currently has space for.">get_max_sidno</a>();
<a name="l01489"></a>01489     <span class="keywordtype">int</span> ret= 0;
<a name="l01490"></a>01490     <span class="keywordflow">for</span> (rpl_sidno sidno= 1; sidno &lt; max_sidno; sidno++)
<a name="l01491"></a>01491       ret+= get_n_intervals(sidno);
<a name="l01492"></a>01492     <span class="keywordflow">return</span> ret;
<a name="l01493"></a>01493   }
<a name="l01501"></a>01501   enum_return_status create_new_chunk(<span class="keywordtype">int</span> size);
<a name="l01512"></a>01512   enum_return_status get_free_interval(Interval **out);
<a name="l01517"></a>01517   <span class="keywordtype">void</span> put_free_interval(Interval *iv);
<a name="l01523"></a>01523   <span class="keywordtype">void</span> add_interval_memory_lock_taken(<span class="keywordtype">int</span> n_ivs, Interval *ivs);
<a name="l01524"></a>01524 
<a name="l01526"></a>01526   <span class="keyword">mutable</span> <a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *sid_lock;
<a name="l01531"></a>01531   mysql_mutex_t free_intervals_mutex;
<a name="l01545"></a>01545   <span class="keyword">class </span>Free_intervals_lock
<a name="l01546"></a>01546   {
<a name="l01547"></a>01547   <span class="keyword">public</span>:
<a name="l01549"></a>01549     Free_intervals_lock(<a class="code" href="classGtid__set.html">Gtid_set</a> *_gtid_set)
<a name="l01550"></a>01550       : gtid_set(_gtid_set), locked(false) {}
<a name="l01552"></a>01552     <span class="keywordtype">void</span> lock_if_not_locked()
<a name="l01553"></a>01553     {
<a name="l01554"></a>01554       <span class="keywordflow">if</span> (gtid_set-&gt;sid_lock &amp;&amp; !locked)
<a name="l01555"></a>01555       {
<a name="l01556"></a>01556         mysql_mutex_lock(&amp;gtid_set-&gt;free_intervals_mutex);
<a name="l01557"></a>01557         locked= <span class="keyword">true</span>;
<a name="l01558"></a>01558       }
<a name="l01559"></a>01559     }
<a name="l01561"></a>01561     <span class="keywordtype">void</span> unlock_if_locked()
<a name="l01562"></a>01562     {
<a name="l01563"></a>01563       <span class="keywordflow">if</span> (gtid_set-&gt;sid_lock &amp;&amp; locked)
<a name="l01564"></a>01564       {
<a name="l01565"></a>01565         mysql_mutex_unlock(&amp;gtid_set-&gt;free_intervals_mutex);
<a name="l01566"></a>01566         locked= <span class="keyword">false</span>;
<a name="l01567"></a>01567       }
<a name="l01568"></a>01568     }
<a name="l01570"></a>01570     ~Free_intervals_lock()
<a name="l01571"></a>01571     {
<a name="l01572"></a>01572       unlock_if_locked();
<a name="l01573"></a>01573     }
<a name="l01574"></a>01574   <span class="keyword">private</span>:
<a name="l01575"></a>01575     <a class="code" href="classGtid__set.html">Gtid_set</a> *gtid_set;
<a name="l01576"></a>01576     <span class="keywordtype">bool</span> locked;
<a name="l01577"></a>01577   };
<a name="l01578"></a>01578   <span class="keywordtype">void</span> assert_free_intervals_locked()
<a name="l01579"></a>01579   {
<a name="l01580"></a>01580     <span class="keywordflow">if</span> (sid_lock != NULL)
<a name="l01581"></a>01581       mysql_mutex_assert_owner(&amp;free_intervals_mutex);
<a name="l01582"></a>01582   }
<a name="l01583"></a>01583 
<a name="l01603"></a>01603   enum_return_status add_gno_interval(Interval_iterator *ivitp,
<a name="l01604"></a>01604                                       rpl_gno start, rpl_gno end,
<a name="l01605"></a>01605                                       Free_intervals_lock *lock);
<a name="l01628"></a>01628   enum_return_status remove_gno_interval(Interval_iterator *ivitp,
<a name="l01629"></a>01629                                          rpl_gno start, rpl_gno end,
<a name="l01630"></a>01630                                          Free_intervals_lock *lock);
<a name="l01647"></a>01647   enum_return_status add_gno_intervals(rpl_sidno sidno,
<a name="l01648"></a>01648                                        Const_interval_iterator ivit,
<a name="l01649"></a>01649                                        Free_intervals_lock *lock);
<a name="l01666"></a>01666   enum_return_status remove_gno_intervals(rpl_sidno sidno,
<a name="l01667"></a>01667                                           Const_interval_iterator ivit,
<a name="l01668"></a>01668                                           Free_intervals_lock *lock);
<a name="l01669"></a>01669 
<a name="l01672"></a>01672   <span class="keyword">static</span> <span class="keywordtype">bool</span> is_interval_subset(Const_interval_iterator *sub,
<a name="l01673"></a>01673                                  Const_interval_iterator *super);
<a name="l01675"></a>01675   <span class="keyword">static</span> <span class="keywordtype">bool</span> is_interval_intersection_nonempty(Const_interval_iterator *ivit1,
<a name="l01676"></a>01676                                                 Const_interval_iterator *ivit2);
<a name="l01677"></a>01677 
<a name="l01679"></a>01679   <a class="code" href="classSid__map.html">Sid_map</a> *sid_map;
<a name="l01684"></a>01684   DYNAMIC_ARRAY intervals;
<a name="l01686"></a>01686   Interval *free_intervals;
<a name="l01688"></a>01688   Interval_chunk *chunks;
<a name="l01690"></a>01690   <span class="keyword">mutable</span> <span class="keywordtype">int</span> cached_string_length;
<a name="l01692"></a>01692   <span class="keyword">mutable</span> <span class="keyword">const</span> String_format *cached_string_format;
<a name="l01693"></a>01693 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l01694"></a>01694 <span class="preprocessor"></span>
<a name="l01698"></a>01698   <span class="keywordtype">int</span> n_chunks;
<a name="l01699"></a>01699 <span class="preprocessor">#endif</span>
<a name="l01700"></a>01700 <span class="preprocessor"></span>
<a name="l01702"></a>01702 <span class="preprocessor">#ifdef FRIEND_OF_GTID_SET</span>
<a name="l01703"></a>01703 <span class="preprocessor"></span>  <span class="keyword">friend</span> FRIEND_OF_GTID_SET;
<a name="l01704"></a>01704 <span class="preprocessor">#endif</span>
<a name="l01705"></a>01705 <span class="preprocessor"></span>
<a name="l01706"></a><a class="code" href="classGtid__set.html#a59860055a243825524c47d9adc494250">01706</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classGtid__set.html#a59860055a243825524c47d9adc494250" title="Used by unit tests that need to access private members.">Gtid_set::Free_intervals_lock</a>;
<a name="l01707"></a>01707 };
<a name="l01708"></a>01708 
<a name="l01709"></a>01709 
<a name="l01730"></a><a class="code" href="structGtid__set__or__null.html">01730</a> <span class="keyword">struct </span><a class="code" href="structGtid__set__or__null.html">Gtid_set_or_null</a>
<a name="l01731"></a>01731 {
<a name="l01733"></a><a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01">01733</a>   <a class="code" href="classGtid__set.html">Gtid_set</a> *<a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01" title="Pointer to the Gtid_set.">gtid_set</a>;
<a name="l01735"></a><a class="code" href="structGtid__set__or__null.html#afa7c80306b461171a9d594df055592a0">01735</a>   <span class="keywordtype">bool</span> <a class="code" href="structGtid__set__or__null.html#afa7c80306b461171a9d594df055592a0" title="True if this Gtid_set is NULL.">is_non_null</a>;
<a name="l01737"></a><a class="code" href="structGtid__set__or__null.html#a826d70460e2db3c68df9193bf8e71563">01737</a>   <span class="keyword">inline</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *<a class="code" href="structGtid__set__or__null.html#a826d70460e2db3c68df9193bf8e71563" title="Return NULL if this is NULL, otherwise return the Gtid_set.">get_gtid_set</a>()<span class="keyword"> const</span>
<a name="l01738"></a>01738 <span class="keyword">  </span>{
<a name="l01739"></a>01739     DBUG_ASSERT(!(<a class="code" href="structGtid__set__or__null.html#afa7c80306b461171a9d594df055592a0" title="True if this Gtid_set is NULL.">is_non_null</a> &amp;&amp; <a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01" title="Pointer to the Gtid_set.">gtid_set</a> == NULL));
<a name="l01740"></a>01740     <span class="keywordflow">return</span> <a class="code" href="structGtid__set__or__null.html#afa7c80306b461171a9d594df055592a0" title="True if this Gtid_set is NULL.">is_non_null</a> ? <a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01" title="Pointer to the Gtid_set.">gtid_set</a> : NULL;
<a name="l01741"></a>01741   }
<a name="l01747"></a><a class="code" href="structGtid__set__or__null.html#a3a7015e462a30aad90c33e58c99a68c4">01747</a>   <a class="code" href="classGtid__set.html">Gtid_set</a> *<a class="code" href="structGtid__set__or__null.html#a3a7015e462a30aad90c33e58c99a68c4">set_non_null</a>(<a class="code" href="classSid__map.html">Sid_map</a> *sm)
<a name="l01748"></a>01748   {
<a name="l01749"></a>01749     <span class="keywordflow">if</span> (!<a class="code" href="structGtid__set__or__null.html#afa7c80306b461171a9d594df055592a0" title="True if this Gtid_set is NULL.">is_non_null</a>)
<a name="l01750"></a>01750     {
<a name="l01751"></a>01751       <span class="keywordflow">if</span> (<a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01" title="Pointer to the Gtid_set.">gtid_set</a> == NULL)
<a name="l01752"></a>01752         <a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01" title="Pointer to the Gtid_set.">gtid_set</a>= <span class="keyword">new</span> <a class="code" href="classGtid__set.html">Gtid_set</a>(sm);
<a name="l01753"></a>01753       <span class="keywordflow">else</span>
<a name="l01754"></a>01754         <a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01" title="Pointer to the Gtid_set.">gtid_set</a>-&gt;<a class="code" href="classGtid__set.html#a8d8130a7559cfd7b940f42e66c9b171a">clear</a>();
<a name="l01755"></a>01755     }
<a name="l01756"></a>01756     <a class="code" href="structGtid__set__or__null.html#afa7c80306b461171a9d594df055592a0" title="True if this Gtid_set is NULL.">is_non_null</a>= (<a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01" title="Pointer to the Gtid_set.">gtid_set</a> != NULL);
<a name="l01757"></a>01757     <span class="keywordflow">return</span> <a class="code" href="structGtid__set__or__null.html#a3fd61ef2c21ef9f8ae1b0b3f47b9be01" title="Pointer to the Gtid_set.">gtid_set</a>;
<a name="l01758"></a>01758   }
<a name="l01760"></a><a class="code" href="structGtid__set__or__null.html#ac47966d9a50008b0d6cf067f48d224ab">01760</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structGtid__set__or__null.html#ac47966d9a50008b0d6cf067f48d224ab" title="Set this Gtid_set to NULL.">set_null</a>() { <a class="code" href="structGtid__set__or__null.html#afa7c80306b461171a9d594df055592a0" title="True if this Gtid_set is NULL.">is_non_null</a>= <span class="keyword">false</span>; }
<a name="l01761"></a>01761 };
<a name="l01762"></a>01762 
<a name="l01763"></a>01763 
<a name="l01779"></a><a class="code" href="classOwned__gtids.html">01779</a> <span class="keyword">class </span><a class="code" href="classOwned__gtids.html">Owned_gtids</a>
<a name="l01780"></a>01780 {
<a name="l01781"></a>01781 <span class="keyword">public</span>:
<a name="l01788"></a>01788   <a class="code" href="classOwned__gtids.html#a7b91d015754445c004455b37096da3f1">Owned_gtids</a>(<a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *sid_lock);
<a name="l01790"></a>01790   <a class="code" href="classOwned__gtids.html#ad91e433dfe634b5c501a681a145aabfb" title="Destroys this Owned_gtids.">~Owned_gtids</a>();
<a name="l01798"></a>01798   enum_return_status <a class="code" href="classOwned__gtids.html#a323fa3724e5214e36bac9153e9cb3585">add_gtid_owner</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid, my_thread_id owner);
<a name="l01806"></a>01806   my_thread_id <a class="code" href="classOwned__gtids.html#a10765cb3e3a9f2e988de1feef56a3a18">get_owner</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid) <span class="keyword">const</span>;
<a name="l01815"></a>01815   <span class="keywordtype">void</span> <a class="code" href="classOwned__gtids.html#aca939f23a0800c8eb7622be104382a24">remove_gtid</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid);
<a name="l01828"></a>01828   enum_return_status <a class="code" href="classOwned__gtids.html#aed0354047916db07b6a854e621f48674">ensure_sidno</a>(rpl_sidno sidno);
<a name="l01831"></a>01831   <span class="keywordtype">bool</span> <a class="code" href="classOwned__gtids.html#aa71bf675304483256f1a4e62567b20c1">is_intersection_nonempty</a>(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *other) <span class="keyword">const</span>;
<a name="l01833"></a><a class="code" href="classOwned__gtids.html#a5eb41be993322731c8fff875352f6198">01833</a>   <span class="keywordtype">bool</span> <a class="code" href="classOwned__gtids.html#a5eb41be993322731c8fff875352f6198" title="Returns true if this Owned_gtids is empty.">is_empty</a>()<span class="keyword"> const</span>
<a name="l01834"></a>01834 <span class="keyword">  </span>{
<a name="l01835"></a>01835     <a class="code" href="classOwned__gtids_1_1Gtid__iterator.html">Gtid_iterator</a> git(<span class="keyword">this</span>);
<a name="l01836"></a>01836     <span class="keywordflow">return</span> git.<a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#aea37424d671be719269174c7f0987ebe" title="Return next group, or {0,0} if we reached the end.">get</a>().<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a> == 0;
<a name="l01837"></a>01837   }
<a name="l01839"></a><a class="code" href="classOwned__gtids.html#aacef2f7179b71c168e84b6749cbcf019">01839</a>   rpl_sidno <a class="code" href="classOwned__gtids.html#aacef2f7179b71c168e84b6749cbcf019" title="Returns the maximal sidno that this Owned_gtids currently has space for.">get_max_sidno</a>()<span class="keyword"> const</span>
<a name="l01840"></a>01840 <span class="keyword">  </span>{
<a name="l01841"></a>01841     sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l01842"></a>01842     <span class="keywordflow">return</span> sidno_to_hash.elements;
<a name="l01843"></a>01843   }
<a name="l01844"></a>01844 
<a name="l01851"></a><a class="code" href="classOwned__gtids.html#a92ecfa316fd01af97babe268cdcadd9d">01851</a>   <span class="keywordtype">int</span> <a class="code" href="classOwned__gtids.html#a885abd83c946bdb136dd00e423dc0f78">to_string</a>(<span class="keywordtype">char</span> *out)<span class="keyword"> const</span>
<a name="l01852"></a>01852 <span class="keyword">  </span>{
<a name="l01853"></a>01853     <span class="keywordtype">char</span> *p= out;
<a name="l01854"></a>01854     rpl_sidno max_sidno= <a class="code" href="classOwned__gtids.html#aacef2f7179b71c168e84b6749cbcf019" title="Returns the maximal sidno that this Owned_gtids currently has space for.">get_max_sidno</a>();
<a name="l01855"></a>01855     rpl_sidno sid_map_max_sidno= global_sid_map-&gt;<a class="code" href="classSid__map.html#a7bb52a993792edff5d2348c728fb5a08">get_max_sidno</a>();
<a name="l01856"></a>01856     <span class="keywordflow">for</span> (rpl_sidno sid_i= 0; sid_i &lt; sid_map_max_sidno; sid_i++)
<a name="l01857"></a>01857     {
<a name="l01858"></a>01858       rpl_sidno sidno= global_sid_map-&gt;<a class="code" href="classSid__map.html#ac62d7fb30ad41dacd77ea0ef842e5d70">get_sorted_sidno</a>(sid_i);
<a name="l01859"></a>01859       <span class="keywordflow">if</span> (sidno &gt; max_sidno)
<a name="l01860"></a>01860         <span class="keywordflow">continue</span>;
<a name="l01861"></a>01861       HASH *hash= get_hash(sidno);
<a name="l01862"></a>01862       <span class="keywordtype">bool</span> printed_sid= <span class="keyword">false</span>;
<a name="l01863"></a>01863       <span class="keywordflow">for</span> (uint i= 0; i &lt; hash-&gt;records; i++)
<a name="l01864"></a>01864       {
<a name="l01865"></a>01865         Node *node= (Node *)my_hash_element(hash, i);
<a name="l01866"></a>01866         DBUG_ASSERT(node != NULL);
<a name="l01867"></a>01867         <span class="keywordflow">if</span> (!printed_sid)
<a name="l01868"></a>01868         {
<a name="l01869"></a>01869           p+= global_sid_map-&gt;<a class="code" href="classSid__map.html#a945ea7eccbb14052aa4bd84e5e44545c">sidno_to_sid</a>(sidno).<a class="code" href="structUuid.html#abce62683cfb88ec82d5a3b1e39bb1688">to_string</a>(p);
<a name="l01870"></a>01870           printed_sid= <span class="keyword">true</span>;
<a name="l01871"></a>01871         }
<a name="l01872"></a>01872         p+= sprintf(p, <span class="stringliteral">&quot;:%lld#%lu&quot;</span>, node-&gt;gno, node-&gt;owner);
<a name="l01873"></a>01873       }
<a name="l01874"></a>01874     }
<a name="l01875"></a>01875     *p= 0;
<a name="l01876"></a>01876     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(p - out);
<a name="l01877"></a>01877   }
<a name="l01878"></a>01878 
<a name="l01884"></a><a class="code" href="classOwned__gtids.html#a75c6530093fb5112201a895a8c9f381a">01884</a>   <span class="keywordtype">size_t</span> <a class="code" href="classOwned__gtids.html#a75c6530093fb5112201a895a8c9f381a">get_max_string_length</a>()<span class="keyword"> const</span>
<a name="l01885"></a>01885 <span class="keyword">  </span>{
<a name="l01886"></a>01886     rpl_sidno max_sidno= <a class="code" href="classOwned__gtids.html#aacef2f7179b71c168e84b6749cbcf019" title="Returns the maximal sidno that this Owned_gtids currently has space for.">get_max_sidno</a>();
<a name="l01887"></a>01887     <span class="keywordtype">size_t</span> ret= 0;
<a name="l01888"></a>01888     <span class="keywordflow">for</span> (rpl_sidno sidno= 1; sidno &lt;= max_sidno; sidno++)
<a name="l01889"></a>01889     {
<a name="l01890"></a>01890       HASH *hash= get_hash(sidno);
<a name="l01891"></a>01891       <span class="keywordflow">if</span> (hash-&gt;records &gt; 0)
<a name="l01892"></a>01892         ret+= <a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c" title="The number of bytes in the textual representation of a Uuid.">rpl_sid::TEXT_LENGTH</a> +
<a name="l01893"></a>01893           hash-&gt;records * (1 + MAX_GNO_TEXT_LENGTH +
<a name="l01894"></a>01894                            1 + MAX_THREAD_ID_TEXT_LENGTH);
<a name="l01895"></a>01895     }
<a name="l01896"></a>01896     <span class="keywordflow">return</span> 1 + ret;
<a name="l01897"></a>01897   }
<a name="l01898"></a>01898 
<a name="l01902"></a><a class="code" href="classOwned__gtids.html#a50ed35917fd0ec5b07402b360eabee73">01902</a>   <span class="keywordtype">bool</span> <a class="code" href="classOwned__gtids.html#a50ed35917fd0ec5b07402b360eabee73">thread_owns_anything</a>(my_thread_id thd_id)<span class="keyword"> const</span>
<a name="l01903"></a>01903 <span class="keyword">  </span>{
<a name="l01904"></a>01904     <a class="code" href="classOwned__gtids_1_1Gtid__iterator.html">Gtid_iterator</a> git(<span class="keyword">this</span>);
<a name="l01905"></a>01905     Node *node= git.<a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#adbff0990e8cf33999882468c2ef342ca" title="Return next group Node, or NULL if we reached the end.">get_node</a>();
<a name="l01906"></a>01906     <span class="keywordflow">while</span> (node != NULL)
<a name="l01907"></a>01907     {
<a name="l01908"></a>01908       <span class="keywordflow">if</span> (node-&gt;owner == thd_id)
<a name="l01909"></a>01909         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01910"></a>01910       git.<a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#aebabc5ebeef241e0ba3a1ba2d07e9ec3" title="Advance to next group.">next</a>();
<a name="l01911"></a>01911       node= git.<a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#adbff0990e8cf33999882468c2ef342ca" title="Return next group Node, or NULL if we reached the end.">get_node</a>();
<a name="l01912"></a>01912     }
<a name="l01913"></a>01913     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01914"></a>01914   }
<a name="l01915"></a>01915 
<a name="l01916"></a>01916 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l01917"></a>01917 <span class="preprocessor"></span>
<a name="l01921"></a><a class="code" href="classOwned__gtids.html#a885abd83c946bdb136dd00e423dc0f78">01921</a>   <span class="keywordtype">char</span> *<a class="code" href="classOwned__gtids.html#a885abd83c946bdb136dd00e423dc0f78">to_string</a>()<span class="keyword"> const</span>
<a name="l01922"></a>01922 <span class="keyword">  </span>{
<a name="l01923"></a>01923     <span class="keywordtype">char</span> *str= (<span class="keywordtype">char</span> *)my_malloc(<a class="code" href="classOwned__gtids.html#a75c6530093fb5112201a895a8c9f381a">get_max_string_length</a>(), MYF(MY_WME));
<a name="l01924"></a>01924     DBUG_ASSERT(str != NULL);
<a name="l01925"></a>01925     <a class="code" href="classOwned__gtids.html#a885abd83c946bdb136dd00e423dc0f78">to_string</a>(str);
<a name="l01926"></a>01926     <span class="keywordflow">return</span> str;
<a name="l01927"></a>01927   }
<a name="l01929"></a><a class="code" href="classOwned__gtids.html#a607eee678f808566780f9d706fc7daa6">01929</a>   <span class="keywordtype">void</span> <a class="code" href="classOwned__gtids.html#a607eee678f808566780f9d706fc7daa6" title="Debug only: print this Owned_gtids to stdout.">print</a>()<span class="keyword"> const</span>
<a name="l01930"></a>01930 <span class="keyword">  </span>{
<a name="l01931"></a>01931     <span class="keywordtype">char</span> *str= <a class="code" href="classOwned__gtids.html#a885abd83c946bdb136dd00e423dc0f78">to_string</a>();
<a name="l01932"></a>01932     printf(<span class="stringliteral">&quot;%s\n&quot;</span>, str);
<a name="l01933"></a>01933     my_free(str);
<a name="l01934"></a>01934   }
<a name="l01935"></a>01935 <span class="preprocessor">#endif</span>
<a name="l01936"></a>01936 <span class="preprocessor"></span>
<a name="l01940"></a><a class="code" href="classOwned__gtids.html#ab4ee2cfae573514219190d5ebd531b6d">01940</a>   <span class="keywordtype">void</span> <a class="code" href="classOwned__gtids.html#ab4ee2cfae573514219190d5ebd531b6d">dbug_print</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text= <span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l01941"></a>01941 <span class="keyword">  </span>{
<a name="l01942"></a>01942 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l01943"></a>01943 <span class="preprocessor"></span>    <span class="keywordtype">char</span> *str= <a class="code" href="classOwned__gtids.html#a885abd83c946bdb136dd00e423dc0f78">to_string</a>();
<a name="l01944"></a>01944     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>, (<span class="stringliteral">&quot;%s%s%s&quot;</span>, text, *text ? <span class="stringliteral">&quot;: &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, str));
<a name="l01945"></a>01945     my_free(str);
<a name="l01946"></a>01946 <span class="preprocessor">#endif</span>
<a name="l01947"></a>01947 <span class="preprocessor"></span>  }
<a name="l01948"></a>01948 <span class="keyword">private</span>:
<a name="l01950"></a>01950   <span class="keyword">struct </span>Node
<a name="l01951"></a>01951   {
<a name="l01953"></a>01953     rpl_gno gno;
<a name="l01955"></a>01955     my_thread_id owner;
<a name="l01956"></a>01956   };
<a name="l01958"></a>01958   <span class="keyword">mutable</span> <a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *sid_lock;
<a name="l01960"></a>01960   HASH *get_hash(rpl_sidno sidno)<span class="keyword"> const</span>
<a name="l01961"></a>01961 <span class="keyword">  </span>{
<a name="l01962"></a>01962     DBUG_ASSERT(sidno &gt;= 1 &amp;&amp; sidno &lt;= <a class="code" href="classOwned__gtids.html#aacef2f7179b71c168e84b6749cbcf019" title="Returns the maximal sidno that this Owned_gtids currently has space for.">get_max_sidno</a>());
<a name="l01963"></a>01963     sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l01964"></a>01964     <span class="keywordflow">return</span> *dynamic_element(&amp;sidno_to_hash, sidno - 1, HASH **);
<a name="l01965"></a>01965   }
<a name="l01970"></a>01970   Node *get_node(<span class="keyword">const</span> HASH *hash, rpl_gno gno)<span class="keyword"> const</span>
<a name="l01971"></a>01971 <span class="keyword">  </span>{
<a name="l01972"></a>01972     sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#afb8f8e7bd590db1ea2502c3749131bae" title="Assert that some thread holds either the read or the write lock.">assert_some_lock</a>();
<a name="l01973"></a>01973     <span class="keywordflow">return</span> (Node *)my_hash_search(hash, (<span class="keyword">const</span> uchar *)&amp;gno, <span class="keyword">sizeof</span>(rpl_gno));
<a name="l01974"></a>01974   }
<a name="l01979"></a>01979   Node *get_node(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid)<span class="keyword"> const</span>
<a name="l01980"></a>01980 <span class="keyword">  </span>{ <span class="keywordflow">return</span> get_node(get_hash(gtid.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>), gtid.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>); };
<a name="l01982"></a>01982   <span class="keywordtype">bool</span> contains_gtid(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> get_node(gtid) != NULL; }
<a name="l01984"></a>01984   DYNAMIC_ARRAY sidno_to_hash;
<a name="l01985"></a>01985 
<a name="l01986"></a>01986 <span class="keyword">public</span>:
<a name="l01991"></a><a class="code" href="classOwned__gtids_1_1Gtid__iterator.html">01991</a>   <span class="keyword">class </span><a class="code" href="classOwned__gtids_1_1Gtid__iterator.html">Gtid_iterator</a>
<a name="l01992"></a>01992   {
<a name="l01993"></a>01993   <span class="keyword">public</span>:
<a name="l01994"></a>01994     <a class="code" href="classOwned__gtids_1_1Gtid__iterator.html">Gtid_iterator</a>(<span class="keyword">const</span> <a class="code" href="classOwned__gtids.html">Owned_gtids</a>* og)
<a name="l01995"></a>01995       : owned_gtids(og), sidno(1), hash(NULL), node_index(0), node(NULL)
<a name="l01996"></a>01996     {
<a name="l01997"></a>01997       max_sidno= owned_gtids-&gt;<a class="code" href="classOwned__gtids.html#aacef2f7179b71c168e84b6749cbcf019" title="Returns the maximal sidno that this Owned_gtids currently has space for.">get_max_sidno</a>();
<a name="l01998"></a>01998       <span class="keywordflow">if</span> (sidno &lt;= max_sidno)
<a name="l01999"></a>01999         hash= owned_gtids-&gt;get_hash(sidno);
<a name="l02000"></a>02000       <a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#aebabc5ebeef241e0ba3a1ba2d07e9ec3" title="Advance to next group.">next</a>();
<a name="l02001"></a>02001     }
<a name="l02003"></a><a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#aebabc5ebeef241e0ba3a1ba2d07e9ec3">02003</a>     <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#aebabc5ebeef241e0ba3a1ba2d07e9ec3" title="Advance to next group.">next</a>()
<a name="l02004"></a>02004     {
<a name="l02005"></a>02005 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02006"></a>02006 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (owned_gtids-&gt;sid_lock)
<a name="l02007"></a>02007         owned_gtids-&gt;sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#a5e9fdb488d310af3e6048066280babef" title="Assert that some thread holds the write lock.">assert_some_wrlock</a>();
<a name="l02008"></a>02008 <span class="preprocessor">#endif</span>
<a name="l02009"></a>02009 <span class="preprocessor"></span>
<a name="l02010"></a>02010       <span class="keywordflow">while</span> (sidno &lt;= max_sidno)
<a name="l02011"></a>02011       {
<a name="l02012"></a>02012         DBUG_ASSERT(hash != NULL);
<a name="l02013"></a>02013         <span class="keywordflow">if</span> (node_index &lt; hash-&gt;records)
<a name="l02014"></a>02014         {
<a name="l02015"></a>02015           node= (Node *)my_hash_element(hash, node_index);
<a name="l02016"></a>02016           DBUG_ASSERT(node != NULL);
<a name="l02017"></a>02017           <span class="comment">// Jump to next node on next iteration.</span>
<a name="l02018"></a>02018           node_index++;
<a name="l02019"></a>02019           <span class="keywordflow">return</span>;
<a name="l02020"></a>02020         }
<a name="l02021"></a>02021 
<a name="l02022"></a>02022         node_index= 0;
<a name="l02023"></a>02023         <span class="comment">// hash is initialized on constructor or in previous iteration</span>
<a name="l02024"></a>02024         <span class="comment">// for current SIDNO, so we must increment for next iteration.</span>
<a name="l02025"></a>02025         sidno++;
<a name="l02026"></a>02026         <span class="keywordflow">if</span> (sidno &lt;= max_sidno)
<a name="l02027"></a>02027           hash= owned_gtids-&gt;get_hash(sidno);
<a name="l02028"></a>02028       }
<a name="l02029"></a>02029       node= NULL;
<a name="l02030"></a>02030     }
<a name="l02032"></a><a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#aea37424d671be719269174c7f0987ebe">02032</a>     <span class="keyword">inline</span> <a class="code" href="structGtid.html">Gtid</a> <span class="keyword">get</span>() <span class="keyword">const</span>
<a name="l02033"></a>02033     {
<a name="l02034"></a>02034       <a class="code" href="structGtid.html">Gtid</a> ret= { 0, 0 };
<a name="l02035"></a>02035       <span class="keywordflow">if</span> (node)
<a name="l02036"></a>02036       {
<a name="l02037"></a>02037         ret.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>= sidno;
<a name="l02038"></a>02038         ret.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>= node-&gt;gno;
<a name="l02039"></a>02039       }
<a name="l02040"></a>02040       <span class="keywordflow">return</span> ret;
<a name="l02041"></a>02041     }
<a name="l02043"></a><a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#adbff0990e8cf33999882468c2ef342ca">02043</a>     <span class="keyword">inline</span> Node* <a class="code" href="classOwned__gtids_1_1Gtid__iterator.html#adbff0990e8cf33999882468c2ef342ca" title="Return next group Node, or NULL if we reached the end.">get_node</a>()<span class="keyword"> const</span>
<a name="l02044"></a>02044 <span class="keyword">    </span>{
<a name="l02045"></a>02045       <span class="keywordflow">return</span> node;
<a name="l02046"></a>02046     }
<a name="l02047"></a>02047   <span class="keyword">private</span>:
<a name="l02049"></a>02049     <span class="keyword">const</span> <a class="code" href="classOwned__gtids.html">Owned_gtids</a> *owned_gtids;
<a name="l02051"></a>02051     rpl_sidno sidno;
<a name="l02053"></a>02053     rpl_sidno max_sidno;
<a name="l02055"></a>02055     HASH *hash;
<a name="l02057"></a>02057     uint node_index;
<a name="l02059"></a>02059     Node *node;
<a name="l02060"></a>02060   };
<a name="l02061"></a>02061 };
<a name="l02062"></a>02062 
<a name="l02063"></a>02063 
<a name="l02094"></a><a class="code" href="classGtid__state.html">02094</a> <span class="keyword">class </span><a class="code" href="classGtid__state.html">Gtid_state</a>
<a name="l02095"></a>02095 {
<a name="l02096"></a>02096 <span class="keyword">public</span>:
<a name="l02104"></a><a class="code" href="classGtid__state.html#a4e93b5ffa97a101e51aa722cf5f56ef3">02104</a>   <a class="code" href="classGtid__state.html#a4e93b5ffa97a101e51aa722cf5f56ef3">Gtid_state</a>(<a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *_sid_lock, <a class="code" href="classSid__map.html">Sid_map</a> *_sid_map)
<a name="l02105"></a>02105     : sid_lock(_sid_lock),
<a name="l02106"></a>02106     sid_map(_sid_map),
<a name="l02107"></a>02107     sid_locks(sid_lock),
<a name="l02108"></a>02108     logged_gtids(sid_map, sid_lock),
<a name="l02109"></a>02109     lost_gtids(sid_map, sid_lock),
<a name="l02110"></a>02110     owned_gtids(sid_lock) {}
<a name="l02123"></a>02123   <span class="keywordtype">int</span> <a class="code" href="classGtid__state.html#a05bbafc9331c90395789157153fd3601">init</a>();
<a name="l02131"></a>02131   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#adbce72918817e71f0b5af55046f241c5">clear</a>();
<a name="l02140"></a><a class="code" href="classGtid__state.html#a1472a91a5433d7deb340595651329eb6">02140</a>   <span class="keywordtype">bool</span> <a class="code" href="classGtid__state.html#a1472a91a5433d7deb340595651329eb6">is_logged</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid)<span class="keyword"> const</span>
<a name="l02141"></a>02141 <span class="keyword">  </span>{
<a name="l02142"></a>02142     DBUG_ENTER(<span class="stringliteral">&quot;Gtid_state::is_logged&quot;</span>);
<a name="l02143"></a>02143     <span class="keywordtype">bool</span> ret= logged_gtids.<a class="code" href="classGtid__set.html#a0764f95ab9fc368a2af4e5f15faab2a7" title="Return true iff the given GTID exists in this set.">contains_gtid</a>(gtid);
<a name="l02144"></a>02144     DBUG_RETURN(ret);
<a name="l02145"></a>02145   }
<a name="l02153"></a><a class="code" href="classGtid__state.html#a79ad011d1962403c3b3de94ca9b90c0f">02153</a>   my_thread_id <a class="code" href="classGtid__state.html#a79ad011d1962403c3b3de94ca9b90c0f">get_owner</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid)<span class="keyword"> const</span>
<a name="l02154"></a>02154 <span class="keyword">  </span>{ <span class="keywordflow">return</span> owned_gtids.<a class="code" href="classOwned__gtids.html#a10765cb3e3a9f2e988de1feef56a3a18">get_owner</a>(gtid); }
<a name="l02155"></a>02155 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l02156"></a>02156 <span class="preprocessor"></span>
<a name="l02165"></a>02165   enum_return_status <a class="code" href="classGtid__state.html#a3bedc53a5eed5898822ede2a9d5214d6">acquire_ownership</a>(THD *thd, <span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid);
<a name="l02178"></a>02178   enum_return_status <a class="code" href="classGtid__state.html#ab9756ad23cf447d1af2bab3aab726d3d">update_on_flush</a>(THD *thd);
<a name="l02189"></a>02189   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#adc4c103d1209489a7b7e0d179d654faf">update_on_commit</a>(THD *thd);
<a name="l02202"></a>02202   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#a82dacb8e665689ad80e4541cea325897">update_on_rollback</a>(THD *thd);
<a name="l02203"></a>02203 <span class="preprocessor">#endif // ifndef MYSQL_CLIENT</span>
<a name="l02204"></a>02204 <span class="preprocessor"></span>
<a name="l02212"></a>02212   rpl_gno <a class="code" href="classGtid__state.html#a93ac9beb52483c34920f9c725bbcfebe">get_automatic_gno</a>(rpl_sidno sidno) <span class="keyword">const</span>;
<a name="l02214"></a><a class="code" href="classGtid__state.html#ac3d84b821f0021c098306971c6cc75a6">02214</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#ac3d84b821f0021c098306971c6cc75a6" title="Locks a mutex for the given SIDNO.">lock_sidno</a>(rpl_sidno sidno) { sid_locks.<a class="code" href="classMutex__cond__array.html#ac3e2ae5454a39a9b29259bf30cd7cb7e" title="Lock the n&#39;th mutex.">lock</a>(sidno); }
<a name="l02216"></a><a class="code" href="classGtid__state.html#aa28f4660564a239c4e538b86dce1f832">02216</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#aa28f4660564a239c4e538b86dce1f832" title="Unlocks a mutex for the given SIDNO.">unlock_sidno</a>(rpl_sidno sidno) { sid_locks.<a class="code" href="classMutex__cond__array.html#aa00d13e13f3ad768bd3ae3fe95acd7d4" title="Unlock the n&#39;th mutex.">unlock</a>(sidno); }
<a name="l02218"></a><a class="code" href="classGtid__state.html#ae8e2deb3fdc80fcb1931bc422f8382ad">02218</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#ae8e2deb3fdc80fcb1931bc422f8382ad" title="Broadcasts updates for the given SIDNO.">broadcast_sidno</a>(rpl_sidno sidno) { sid_locks.<a class="code" href="classMutex__cond__array.html#a1dd2cf64be75681ec1e13e8416bbeb19" title="Broadcast the n&#39;th condition.">broadcast</a>(sidno); }
<a name="l02220"></a><a class="code" href="classGtid__state.html#a9a3acb3b64327c2a5ce389a04a8ba026">02220</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#a9a3acb3b64327c2a5ce389a04a8ba026" title="Assert that we own the given SIDNO.">assert_sidno_lock_owner</a>(rpl_sidno sidno)
<a name="l02221"></a>02221   { sid_locks.<a class="code" href="classMutex__cond__array.html#a09f60861a1433f32e48b4cc4af349e8b">assert_owner</a>(sidno); }
<a name="l02222"></a>02222 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l02223"></a>02223 <span class="preprocessor"></span>
<a name="l02234"></a>02234   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#a2ff0fe395cbf69d06736fb4117e6b0b6">wait_for_gtid</a>(THD *thd, <span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid);
<a name="l02235"></a>02235 <span class="preprocessor">#endif // ifndef MYSQL_CLIENT</span>
<a name="l02236"></a>02236 <span class="preprocessor"></span><span class="preprocessor">#ifdef HAVE_NDB_BINLOG</span>
<a name="l02237"></a>02237 <span class="preprocessor"></span>
<a name="l02241"></a>02241   <span class="keywordtype">void</span> lock_sidnos(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *<span class="keyword">set</span>);
<a name="l02246"></a>02246   <span class="keywordtype">void</span> unlock_sidnos(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *<span class="keyword">set</span>);
<a name="l02251"></a>02251   <span class="keywordtype">void</span> broadcast_sidnos(<span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *<span class="keyword">set</span>);
<a name="l02252"></a>02252 <span class="preprocessor">#endif // ifdef HAVE_NDB_BINLOG</span>
<a name="l02253"></a>02253 <span class="preprocessor"></span>
<a name="l02267"></a>02267   enum_return_status <a class="code" href="classGtid__state.html#a2c05e7cfec3de4245fbbb515ad253630">ensure_sidno</a>();
<a name="l02278"></a>02278   enum_return_status <a class="code" href="classGtid__state.html#a95a09a004b7145752d3e732b166fc989">add_lost_gtids</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text);
<a name="l02280"></a><a class="code" href="classGtid__state.html#a553fb4be9ed205dd90288fe721a6755c">02280</a>   <span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *<a class="code" href="classGtid__state.html#a553fb4be9ed205dd90288fe721a6755c" title="Return a pointer to the Gtid_set that contains the logged groups.">get_logged_gtids</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;logged_gtids; }
<a name="l02282"></a><a class="code" href="classGtid__state.html#a18c6a08e5c49e6803cd0f2df2a79c7f5">02282</a>   <span class="keyword">const</span> <a class="code" href="classGtid__set.html">Gtid_set</a> *<a class="code" href="classGtid__state.html#a18c6a08e5c49e6803cd0f2df2a79c7f5" title="Return a pointer to the Gtid_set that contains the logged groups.">get_lost_gtids</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;lost_gtids; }
<a name="l02284"></a><a class="code" href="classGtid__state.html#a4c54aa4cf31696ba5bebe8f3decccfed">02284</a>   <span class="keyword">const</span> <a class="code" href="classOwned__gtids.html">Owned_gtids</a> *<a class="code" href="classGtid__state.html#a4c54aa4cf31696ba5bebe8f3decccfed" title="Return a pointer to the Owned_gtids that contains the owned groups.">get_owned_gtids</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;owned_gtids; }
<a name="l02286"></a><a class="code" href="classGtid__state.html#ab7993ed90bebb74e941ad300b781b9c6">02286</a>   rpl_sidno <a class="code" href="classGtid__state.html#ab7993ed90bebb74e941ad300b781b9c6" title="Return the server&#39;s SID&#39;s SIDNO.">get_server_sidno</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> server_sidno; }
<a name="l02288"></a><a class="code" href="classGtid__state.html#af96e2c3f7dfcfeb1b2d101ff2220759a">02288</a>   <span class="keyword">const</span> <a class="code" href="structUuid.html">rpl_sid</a> &amp;<a class="code" href="classGtid__state.html#af96e2c3f7dfcfeb1b2d101ff2220759a" title="Return the server&#39;s SID.">get_server_sid</a>()<span class="keyword"> const</span>
<a name="l02289"></a>02289 <span class="keyword">  </span>{
<a name="l02290"></a>02290     <span class="keywordflow">return</span> global_sid_map-&gt;<a class="code" href="classSid__map.html#a945ea7eccbb14052aa4bd84e5e44545c">sidno_to_sid</a>(server_sidno);
<a name="l02291"></a>02291   }
<a name="l02292"></a>02292 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02293"></a>02293 <span class="preprocessor"></span>
<a name="l02298"></a><a class="code" href="classGtid__state.html#ae63fc3bb46a3b47b393167404eca5996">02298</a>   <span class="keywordtype">size_t</span> <a class="code" href="classGtid__state.html#ae63fc3bb46a3b47b393167404eca5996">get_max_string_length</a>()<span class="keyword"> const</span>
<a name="l02299"></a>02299 <span class="keyword">  </span>{
<a name="l02300"></a>02300     <span class="keywordflow">return</span> owned_gtids.<a class="code" href="classOwned__gtids.html#a75c6530093fb5112201a895a8c9f381a">get_max_string_length</a>() +
<a name="l02301"></a>02301       logged_gtids.<a class="code" href="classGtid__set.html#aaf41f6a15633a2076cc90b96dfbe7bb2">get_string_length</a>() +
<a name="l02302"></a>02302       lost_gtids.<a class="code" href="classGtid__set.html#aaf41f6a15633a2076cc90b96dfbe7bb2">get_string_length</a>() +
<a name="l02303"></a>02303       100;
<a name="l02304"></a>02304   }
<a name="l02306"></a><a class="code" href="classGtid__state.html#a3bf44f80aa98d9a0dbf0bbd52bf2f300">02306</a>   <span class="keywordtype">int</span> <a class="code" href="classGtid__state.html#ae092c4a14135a10d4327821e0fdca0f6" title="Debug only: return a newly allocated string, or NULL on out-of-memory.">to_string</a>(<span class="keywordtype">char</span> *buf)<span class="keyword"> const</span>
<a name="l02307"></a>02307 <span class="keyword">  </span>{
<a name="l02308"></a>02308     <span class="keywordtype">char</span> *p= buf;
<a name="l02309"></a>02309     p+= sprintf(p, <span class="stringliteral">&quot;Logged GTIDs:\n&quot;</span>);
<a name="l02310"></a>02310     p+= logged_gtids.<a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">to_string</a>(p);
<a name="l02311"></a>02311     p+= sprintf(p, <span class="stringliteral">&quot;\nOwned GTIDs:\n&quot;</span>);
<a name="l02312"></a>02312     p+= owned_gtids.<a class="code" href="classOwned__gtids.html#a92ecfa316fd01af97babe268cdcadd9d">to_string</a>(p);
<a name="l02313"></a>02313     p+= sprintf(p, <span class="stringliteral">&quot;\nLost GTIDs:\n&quot;</span>);
<a name="l02314"></a>02314     p+= lost_gtids.<a class="code" href="classGtid__set.html#a7f93abbbf6942fc5f854a1b1504d94e0">to_string</a>(p);
<a name="l02315"></a>02315     <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(p - buf);
<a name="l02316"></a>02316   }
<a name="l02318"></a><a class="code" href="classGtid__state.html#ae092c4a14135a10d4327821e0fdca0f6">02318</a>   <span class="keywordtype">char</span> *<a class="code" href="classGtid__state.html#ae092c4a14135a10d4327821e0fdca0f6" title="Debug only: return a newly allocated string, or NULL on out-of-memory.">to_string</a>()<span class="keyword"> const</span>
<a name="l02319"></a>02319 <span class="keyword">  </span>{
<a name="l02320"></a>02320     <span class="keywordtype">char</span> *str= (<span class="keywordtype">char</span> *)my_malloc(<a class="code" href="classGtid__state.html#ae63fc3bb46a3b47b393167404eca5996">get_max_string_length</a>(), MYF(MY_WME));
<a name="l02321"></a>02321     <a class="code" href="classGtid__state.html#ae092c4a14135a10d4327821e0fdca0f6" title="Debug only: return a newly allocated string, or NULL on out-of-memory.">to_string</a>(str);
<a name="l02322"></a>02322     <span class="keywordflow">return</span> str;
<a name="l02323"></a>02323   }
<a name="l02325"></a><a class="code" href="classGtid__state.html#a2434939a644dcb4f5e777c68ede04750">02325</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#a2434939a644dcb4f5e777c68ede04750" title="Debug only: print this Gtid_state to stdout.">print</a>()<span class="keyword"> const</span>
<a name="l02326"></a>02326 <span class="keyword">  </span>{
<a name="l02327"></a>02327     <span class="keywordtype">char</span> *str= <a class="code" href="classGtid__state.html#ae092c4a14135a10d4327821e0fdca0f6" title="Debug only: return a newly allocated string, or NULL on out-of-memory.">to_string</a>();
<a name="l02328"></a>02328     printf(<span class="stringliteral">&quot;%s&quot;</span>, str);
<a name="l02329"></a>02329     my_free(str);
<a name="l02330"></a>02330   }
<a name="l02331"></a>02331 <span class="preprocessor">#endif</span>
<a name="l02332"></a>02332 <span class="preprocessor"></span>
<a name="l02336"></a><a class="code" href="classGtid__state.html#ac002877152136c2b07ace71069dff2f7">02336</a>   <span class="keywordtype">void</span> <a class="code" href="classGtid__state.html#ac002877152136c2b07ace71069dff2f7">dbug_print</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text= <span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l02337"></a>02337 <span class="keyword">  </span>{
<a name="l02338"></a>02338 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02339"></a>02339 <span class="preprocessor"></span>    sid_lock-&gt;<a class="code" href="classCheckable__rwlock.html#a5e9fdb488d310af3e6048066280babef" title="Assert that some thread holds the write lock.">assert_some_wrlock</a>();
<a name="l02340"></a>02340     <span class="keywordtype">char</span> *str= <a class="code" href="classGtid__state.html#ae092c4a14135a10d4327821e0fdca0f6" title="Debug only: return a newly allocated string, or NULL on out-of-memory.">to_string</a>();
<a name="l02341"></a>02341     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>, (<span class="stringliteral">&quot;%s%s%s&quot;</span>, text, *text ? <span class="stringliteral">&quot;: &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, str));
<a name="l02342"></a>02342     my_free(str);
<a name="l02343"></a>02343 <span class="preprocessor">#endif</span>
<a name="l02344"></a>02344 <span class="preprocessor"></span>  }
<a name="l02345"></a>02345 <span class="keyword">private</span>:
<a name="l02346"></a>02346 <span class="preprocessor">#ifdef HAVE_NDB_BINLOG</span>
<a name="l02347"></a>02347 <span class="preprocessor"></span>
<a name="l02348"></a>02348   <span class="keywordtype">void</span> lock_owned_sidnos(<span class="keyword">const</span> THD *thd);
<a name="l02349"></a>02349 <span class="preprocessor">#endif</span>
<a name="l02350"></a>02350 <span class="preprocessor"></span>
<a name="l02351"></a>02351   <span class="keywordtype">void</span> unlock_owned_sidnos(<span class="keyword">const</span> THD *thd);
<a name="l02353"></a>02353   <span class="keywordtype">void</span> broadcast_owned_sidnos(<span class="keyword">const</span> THD *thd);
<a name="l02361"></a>02361   <span class="keywordtype">void</span> update_owned_gtids_impl(THD *thd, <span class="keywordtype">bool</span> is_commit);
<a name="l02362"></a>02362 
<a name="l02363"></a>02363 
<a name="l02365"></a>02365   <span class="keyword">mutable</span> <a class="code" href="classCheckable__rwlock.html">Checkable_rwlock</a> *sid_lock;
<a name="l02367"></a>02367   <span class="keyword">mutable</span> <a class="code" href="classSid__map.html">Sid_map</a> *sid_map;
<a name="l02369"></a>02369   <a class="code" href="classMutex__cond__array.html">Mutex_cond_array</a> sid_locks;
<a name="l02371"></a>02371   <a class="code" href="classGtid__set.html">Gtid_set</a> logged_gtids;
<a name="l02376"></a>02376   <a class="code" href="classGtid__set.html">Gtid_set</a> lost_gtids;
<a name="l02378"></a>02378   <a class="code" href="classOwned__gtids.html">Owned_gtids</a> owned_gtids;
<a name="l02380"></a>02380   rpl_sidno server_sidno;
<a name="l02381"></a>02381 
<a name="l02383"></a>02383 <span class="preprocessor">#ifdef FRIEND_OF_GTID_STATE</span>
<a name="l02384"></a>02384 <span class="preprocessor"></span>  <span class="keyword">friend</span> FRIEND_OF_GTID_STATE;
<a name="l02385"></a>02385 <span class="preprocessor">#endif</span>
<a name="l02386"></a>02386 <span class="preprocessor"></span>};
<a name="l02387"></a>02387 
<a name="l02388"></a>02388 
<a name="l02390"></a>02390 <span class="keyword">extern</span> <a class="code" href="classGtid__state.html">Gtid_state</a> *gtid_state;
<a name="l02391"></a>02391 
<a name="l02392"></a>02392 
<a name="l02396"></a>02396 <span class="keyword">enum</span> enum_group_type
<a name="l02397"></a>02397 {
<a name="l02402"></a>02402   AUTOMATIC_GROUP= 0, GTID_GROUP, ANONYMOUS_GROUP, INVALID_GROUP, UNDEFINED_GROUP
<a name="l02403"></a>02403 };
<a name="l02404"></a>02404 
<a name="l02405"></a>02405 
<a name="l02412"></a><a class="code" href="structGtid__specification.html">02412</a> <span class="keyword">struct </span><a class="code" href="structGtid__specification.html">Gtid_specification</a>
<a name="l02413"></a>02413 {
<a name="l02415"></a><a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43">02415</a>   enum_group_type <a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a>;
<a name="l02421"></a><a class="code" href="structGtid__specification.html#a4f1f94ceca9d1f0088a929df35c89c01">02421</a>   <a class="code" href="structGtid.html">Gtid</a> <a class="code" href="structGtid__specification.html#a4f1f94ceca9d1f0088a929df35c89c01">gtid</a>;
<a name="l02423"></a><a class="code" href="structGtid__specification.html#ad0a45a963218a0865e720d9aa7e46932">02423</a>   <span class="keywordtype">void</span> <span class="keyword">set</span>(rpl_sidno sidno, rpl_gno gno)
<a name="l02424"></a>02424   { <a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a>= GTID_GROUP; gtid.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>= sidno; gtid.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>= gno; }
<a name="l02426"></a><a class="code" href="structGtid__specification.html#aa3c1d2f7da7b8c5c2aee1a9375cad7b1">02426</a>   <span class="keywordtype">void</span> <span class="keyword">set</span>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid_param) { <span class="keyword">set</span>(gtid_param.sidno, gtid_param.gno); }
<a name="l02428"></a><a class="code" href="structGtid__specification.html#abbccfa0e057200ab56af5887ca967976">02428</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid__specification.html#abbccfa0e057200ab56af5887ca967976" title="Set the type to ANONYMOUS_GROUP and SID, GNO to 0, 0.">set_anonymous</a>()
<a name="l02429"></a>02429   { <a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a>= ANONYMOUS_GROUP; gtid.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>= 0; gtid.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>= 0; }
<a name="l02431"></a><a class="code" href="structGtid__specification.html#acd45912a724778e6f3539cb5abe311dd">02431</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid__specification.html#acd45912a724778e6f3539cb5abe311dd" title="Set the type to AUTOMATIC_GROUP.">set_automatic</a>()
<a name="l02432"></a>02432   {
<a name="l02433"></a>02433     <a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a>= AUTOMATIC_GROUP;
<a name="l02434"></a>02434   }
<a name="l02436"></a><a class="code" href="structGtid__specification.html#ac11af1773aa79146d5048614600bdd82">02436</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid__specification.html#ac11af1773aa79146d5048614600bdd82" title="Set to undefined if the current type is GTID_GROUP.">set_undefined</a>()
<a name="l02437"></a>02437   {
<a name="l02438"></a>02438     <span class="keywordflow">if</span> (<a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a> == GTID_GROUP)
<a name="l02439"></a>02439       <a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a>= UNDEFINED_GROUP;
<a name="l02440"></a>02440   }
<a name="l02442"></a><a class="code" href="structGtid__specification.html#acc45082cef29f7680094d997a0117c83">02442</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid__specification.html#acc45082cef29f7680094d997a0117c83" title="Set the type to GTID_GROUP and SID, GNO to 0, 0.">clear</a>() { <span class="keyword">set</span>(0, 0); }
<a name="l02444"></a><a class="code" href="structGtid__specification.html#aacca226b4d5114d68a4a907637cfc4c8">02444</a>   <span class="keywordtype">bool</span> <a class="code" href="structGtid__specification.html#aacca226b4d5114d68a4a907637cfc4c8" title="Return true if this Gtid_specification is equal to &#39;other&#39;.">equals</a>(<span class="keyword">const</span> <a class="code" href="structGtid__specification.html">Gtid_specification</a> &amp;other)<span class="keyword"> const</span>
<a name="l02445"></a>02445 <span class="keyword">  </span>{
<a name="l02446"></a>02446     <span class="keywordflow">return</span> (<a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a> == other.<a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a> &amp;&amp;
<a name="l02447"></a>02447             (<a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a> != GTID_GROUP || gtid.<a class="code" href="structGtid.html#a34c19daaa1c0b95e2ebed7caf6059f01" title="Returns true if this Gtid has the same sid and gno as &#39;other&#39;.">equals</a>(other.<a class="code" href="structGtid__specification.html#a4f1f94ceca9d1f0088a929df35c89c01">gtid</a>)));
<a name="l02448"></a>02448   }
<a name="l02453"></a><a class="code" href="structGtid__specification.html#a6d7bae4b800bf8eb900f9954d62a7cfb">02453</a>   <span class="keywordtype">bool</span> <a class="code" href="structGtid__specification.html#aacca226b4d5114d68a4a907637cfc4c8" title="Return true if this Gtid_specification is equal to &#39;other&#39;.">equals</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;other_gtid)<span class="keyword"> const</span>
<a name="l02454"></a>02454 <span class="keyword">  </span>{ <span class="keywordflow">return</span> <a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a> == GTID_GROUP &amp;&amp; gtid.<a class="code" href="structGtid.html#a34c19daaa1c0b95e2ebed7caf6059f01" title="Returns true if this Gtid has the same sid and gno as &#39;other&#39;.">equals</a>(other_gtid); }
<a name="l02455"></a>02455 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l02456"></a>02456 <span class="preprocessor"></span>
<a name="l02462"></a>02462   enum_return_status <a class="code" href="structGtid__specification.html#aac8ea9239e9e8a92f6970a172c58f5c0">parse</a>(<a class="code" href="classSid__map.html">Sid_map</a> *sid_map, <span class="keyword">const</span> <span class="keywordtype">char</span> *text);
<a name="l02466"></a>02466   <span class="keyword">static</span> enum_group_type <a class="code" href="structGtid__specification.html#aaa62caf25ce35bddea51bdb68f42f124">get_type</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text);
<a name="l02468"></a><a class="code" href="structGtid__specification.html#a002da0d9e72d056ed6bb4d99f58e51c9">02468</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="structGtid__specification.html#a002da0d9e72d056ed6bb4d99f58e51c9" title="Returns true if the given string is a valid Gtid_specification.">is_valid</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text)
<a name="l02469"></a>02469   { <span class="keywordflow">return</span> <a class="code" href="structGtid__specification.html#aaa62caf25ce35bddea51bdb68f42f124">Gtid_specification::get_type</a>(text) != INVALID_GROUP; }
<a name="l02470"></a>02470 <span class="preprocessor">#endif</span>
<a name="l02471"></a>02471 <span class="preprocessor"></span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_TEXT_LENGTH= <a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c" title="The number of bytes in the textual representation of a Uuid.">Uuid::TEXT_LENGTH</a> + 1 + MAX_GNO_TEXT_LENGTH;
<a name="l02480"></a>02480   <span class="keywordtype">int</span> <a class="code" href="structGtid__specification.html#a49f31bb0f13c8defb18cff272515a6f0">to_string</a>(<span class="keyword">const</span> <a class="code" href="classSid__map.html">Sid_map</a> *sid_map, <span class="keywordtype">char</span> *buf) <span class="keyword">const</span>;
<a name="l02491"></a>02491   <span class="keywordtype">int</span> <a class="code" href="structGtid__specification.html#a49f31bb0f13c8defb18cff272515a6f0">to_string</a>(<span class="keyword">const</span> <a class="code" href="structUuid.html">rpl_sid</a> *sid, <span class="keywordtype">char</span> *buf) <span class="keyword">const</span>;
<a name="l02492"></a>02492 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02493"></a>02493 <span class="preprocessor"></span>
<a name="l02494"></a><a class="code" href="structGtid__specification.html#a8ac3009104ccd5b86df60a1c1d8dc9d3">02494</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid__specification.html#a8ac3009104ccd5b86df60a1c1d8dc9d3" title="Debug only: print this Gtid_specification to stdout.">print</a>()<span class="keyword"> const</span>
<a name="l02495"></a>02495 <span class="keyword">  </span>{
<a name="l02496"></a>02496     <span class="keywordtype">char</span> buf[MAX_TEXT_LENGTH + 1];
<a name="l02497"></a>02497     <a class="code" href="structGtid__specification.html#a49f31bb0f13c8defb18cff272515a6f0">to_string</a>(global_sid_map, buf);
<a name="l02498"></a>02498     printf(<span class="stringliteral">&quot;%s\n&quot;</span>, buf);
<a name="l02499"></a>02499   }
<a name="l02500"></a>02500 <span class="preprocessor">#endif</span>
<a name="l02501"></a>02501 <span class="preprocessor"></span>
<a name="l02505"></a><a class="code" href="structGtid__specification.html#a14162bfc3391ccaa930114d86ada8033">02505</a>   <span class="keywordtype">void</span> <a class="code" href="structGtid__specification.html#a14162bfc3391ccaa930114d86ada8033">dbug_print</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *text= <span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l02506"></a>02506 <span class="keyword">  </span>{
<a name="l02507"></a>02507 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02508"></a>02508 <span class="preprocessor"></span>    <span class="keywordtype">char</span> buf[MAX_TEXT_LENGTH + 1];
<a name="l02509"></a>02509     <a class="code" href="structGtid__specification.html#a49f31bb0f13c8defb18cff272515a6f0">to_string</a>(global_sid_map, buf);
<a name="l02510"></a>02510     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>, (<span class="stringliteral">&quot;%s%s%s&quot;</span>, text, *text ? <span class="stringliteral">&quot;: &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, buf));
<a name="l02511"></a>02511 <span class="preprocessor">#endif</span>
<a name="l02512"></a>02512 <span class="preprocessor"></span>  }
<a name="l02513"></a>02513 };
<a name="l02514"></a>02514 
<a name="l02515"></a>02515 
<a name="l02524"></a><a class="code" href="structCached__group.html">02524</a> <span class="keyword">struct </span><a class="code" href="structCached__group.html">Cached_group</a>
<a name="l02525"></a>02525 {
<a name="l02527"></a><a class="code" href="structCached__group.html#a6d383bed37684d8f431ecd4535c8a23d">02527</a>   <a class="code" href="structGtid__specification.html">Gtid_specification</a> <a class="code" href="structCached__group.html#a6d383bed37684d8f431ecd4535c8a23d" title="The gtid for this group.">spec</a>;
<a name="l02532"></a><a class="code" href="structCached__group.html#abd05e97d04df02bbe0661a95eda3d7c7">02532</a>   rpl_binlog_pos <a class="code" href="structCached__group.html#abd05e97d04df02bbe0661a95eda3d7c7">binlog_offset</a>;
<a name="l02533"></a>02533 };
<a name="l02534"></a>02534 
<a name="l02535"></a>02535 
<a name="l02540"></a><a class="code" href="classGroup__cache.html">02540</a> <span class="keyword">class </span><a class="code" href="classGroup__cache.html">Group_cache</a>
<a name="l02541"></a>02541 {
<a name="l02542"></a>02542 <span class="keyword">public</span>:
<a name="l02544"></a>02544   <a class="code" href="classGroup__cache.html#a5a9042053acd0459a6f5ea4992376f7f" title="Constructs a new Group_cache.">Group_cache</a>();
<a name="l02546"></a>02546   <a class="code" href="classGroup__cache.html#a4b6e251d4126a57946abf396bc926551" title="Deletes a Group_cache.">~Group_cache</a>();
<a name="l02548"></a>02548   <span class="keywordtype">void</span> <a class="code" href="classGroup__cache.html#a1393cb80bf2ae56d6da80d7c9e319aaa" title="Removes all groups from this cache.">clear</a>();
<a name="l02550"></a><a class="code" href="classGroup__cache.html#a5a895b1e3c518c9a3c3783daae937b5d">02550</a>   <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classGroup__cache.html#a5a895b1e3c518c9a3c3783daae937b5d" title="Return the number of groups in this group cache.">get_n_groups</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> groups.elements; }
<a name="l02552"></a><a class="code" href="classGroup__cache.html#adf2953a9b3a90d2891b4832f06ebbf02">02552</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classGroup__cache.html#adf2953a9b3a90d2891b4832f06ebbf02" title="Return true iff the group cache contains zero groups.">is_empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classGroup__cache.html#a5a895b1e3c518c9a3c3783daae937b5d" title="Return the number of groups in this group cache.">get_n_groups</a>() == 0; }
<a name="l02566"></a><a class="code" href="classGroup__cache.html#a64d5a9a56e3c586a9d8ae55e12c97556">02566</a>   <span class="keyword">enum</span> <a class="code" href="classGroup__cache.html#a64d5a9a56e3c586a9d8ae55e12c97556">enum_add_group_status</a>
<a name="l02567"></a>02567   {
<a name="l02568"></a>02568     EXTEND_EXISTING_GROUP, APPEND_NEW_GROUP, ERROR
<a name="l02569"></a>02569   };
<a name="l02570"></a>02570 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l02571"></a>02571 <span class="preprocessor"></span>  <a class="code" href="classGroup__cache.html#a64d5a9a56e3c586a9d8ae55e12c97556">enum_add_group_status</a>
<a name="l02572"></a>02572     add_logged_group(<span class="keyword">const</span> THD *thd, my_off_t binlog_offset);
<a name="l02573"></a>02573 <span class="preprocessor">#endif // ifndef MYSQL_CLIENT</span>
<a name="l02574"></a>02574 <span class="preprocessor"></span><span class="preprocessor">#ifdef NON_DISABLED_GTID</span>
<a name="l02575"></a>02575 <span class="preprocessor"></span>
<a name="l02582"></a>02582   <a class="code" href="classGroup__cache.html#a64d5a9a56e3c586a9d8ae55e12c97556">enum_add_group_status</a> add_empty_group(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid);
<a name="l02583"></a>02583 <span class="preprocessor">#endif // ifdef NON_DISABLED_GTID</span>
<a name="l02584"></a>02584 <span class="preprocessor"></span><span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l02585"></a>02585 <span class="preprocessor"></span>
<a name="l02589"></a>02589   enum_return_status <a class="code" href="classGroup__cache.html#abb3b151fe9cec104795cf651790333f2">write_to_gtid_state</a>() <span class="keyword">const</span>;
<a name="l02601"></a>02601   enum_return_status <a class="code" href="classGroup__cache.html#a49980e7e278e52dcb5376b46c10512e3">generate_automatic_gno</a>(THD *thd);
<a name="l02602"></a>02602 <span class="preprocessor">#endif // ifndef MYSQL_CLIENT</span>
<a name="l02603"></a>02603 <span class="preprocessor"></span>
<a name="l02610"></a>02610   <span class="keywordtype">bool</span> <a class="code" href="classGroup__cache.html#a621d3d0d02f2d0dae2895ef18a80b9d6">contains_gtid</a>(<span class="keyword">const</span> <a class="code" href="structGtid.html">Gtid</a> &amp;gtid) <span class="keyword">const</span>;
<a name="l02617"></a>02617   enum_return_status <a class="code" href="classGroup__cache.html#a9a7aca2041b7a7a9072dc0d793786108">get_gtids</a>(<a class="code" href="classGtid__set.html">Gtid_set</a> *gs) <span class="keyword">const</span>;
<a name="l02618"></a>02618 
<a name="l02619"></a>02619 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02620"></a>02620 <span class="preprocessor"></span>
<a name="l02624"></a><a class="code" href="classGroup__cache.html#a065ad7cc7b3da71d345352ae6f400aa0">02624</a>   <span class="keywordtype">size_t</span> <a class="code" href="classGroup__cache.html#a065ad7cc7b3da71d345352ae6f400aa0">to_string</a>(<span class="keyword">const</span> <a class="code" href="classSid__map.html">Sid_map</a> *sm, <span class="keywordtype">char</span> *buf)<span class="keyword"> const</span>
<a name="l02625"></a>02625 <span class="keyword">  </span>{
<a name="l02626"></a>02626     <span class="keywordtype">int</span> n_groups= <a class="code" href="classGroup__cache.html#a5a895b1e3c518c9a3c3783daae937b5d" title="Return the number of groups in this group cache.">get_n_groups</a>();
<a name="l02627"></a>02627     <span class="keywordtype">char</span> *s= buf;
<a name="l02628"></a>02628 
<a name="l02629"></a>02629     s += sprintf(s, <span class="stringliteral">&quot;%d groups = {\n&quot;</span>, n_groups);
<a name="l02630"></a>02630     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i= 0; i &lt; n_groups; i++)
<a name="l02631"></a>02631     {
<a name="l02632"></a>02632       <a class="code" href="structCached__group.html">Cached_group</a> *group= <a class="code" href="classGroup__cache.html#a221badb1f9c7b38ec0cfca3f19a76c81">get_unsafe_pointer</a>(i);
<a name="l02633"></a>02633       <span class="keywordtype">char</span> uuid[<a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c" title="The number of bytes in the textual representation of a Uuid.">Uuid::TEXT_LENGTH</a> + 1]= <span class="stringliteral">&quot;[]&quot;</span>;
<a name="l02634"></a>02634       <span class="keywordflow">if</span> (group-&gt;<a class="code" href="structCached__group.html#a6d383bed37684d8f431ecd4535c8a23d" title="The gtid for this group.">spec</a>.<a class="code" href="structGtid__specification.html#a4f1f94ceca9d1f0088a929df35c89c01">gtid</a>.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>)
<a name="l02635"></a>02635         sm-&gt;<a class="code" href="classSid__map.html#a945ea7eccbb14052aa4bd84e5e44545c">sidno_to_sid</a>(group-&gt;<a class="code" href="structCached__group.html#a6d383bed37684d8f431ecd4535c8a23d" title="The gtid for this group.">spec</a>.<a class="code" href="structGtid__specification.html#a4f1f94ceca9d1f0088a929df35c89c01">gtid</a>.<a class="code" href="structGtid.html#aad81c0dd59ff02412e507d254c6843d2" title="SIDNO of this Gtid.">sidno</a>).<a class="code" href="structUuid.html#abce62683cfb88ec82d5a3b1e39bb1688">to_string</a>(uuid);
<a name="l02636"></a>02636       s += sprintf(s, <span class="stringliteral">&quot;  %s:%lld [offset %lld] %s\n&quot;</span>,
<a name="l02637"></a>02637                    uuid, group-&gt;<a class="code" href="structCached__group.html#a6d383bed37684d8f431ecd4535c8a23d" title="The gtid for this group.">spec</a>.<a class="code" href="structGtid__specification.html#a4f1f94ceca9d1f0088a929df35c89c01">gtid</a>.<a class="code" href="structGtid.html#a5e35a770a25f71eb749be34477bab48a" title="GNO of this Gtid.">gno</a>, group-&gt;<a class="code" href="structCached__group.html#abd05e97d04df02bbe0661a95eda3d7c7">binlog_offset</a>,
<a name="l02638"></a>02638                    group-&gt;<a class="code" href="structCached__group.html#a6d383bed37684d8f431ecd4535c8a23d" title="The gtid for this group.">spec</a>.<a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a> == GTID_GROUP ? <span class="stringliteral">&quot;GTID&quot;</span> :
<a name="l02639"></a>02639                    group-&gt;<a class="code" href="structCached__group.html#a6d383bed37684d8f431ecd4535c8a23d" title="The gtid for this group.">spec</a>.<a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a> == ANONYMOUS_GROUP ? <span class="stringliteral">&quot;ANONYMOUS&quot;</span> :
<a name="l02640"></a>02640                    group-&gt;<a class="code" href="structCached__group.html#a6d383bed37684d8f431ecd4535c8a23d" title="The gtid for this group.">spec</a>.<a class="code" href="structGtid__specification.html#af11164fbc8f7894da68f5890082bef43" title="The type of this GTID.">type</a> == AUTOMATIC_GROUP ? <span class="stringliteral">&quot;AUTOMATIC&quot;</span> :
<a name="l02641"></a>02641                    <span class="stringliteral">&quot;INVALID-GROUP-TYPE&quot;</span>);
<a name="l02642"></a>02642     }
<a name="l02643"></a>02643     sprintf(s, <span class="stringliteral">&quot;}\n&quot;</span>);
<a name="l02644"></a>02644     <span class="keywordflow">return</span> s - buf;
<a name="l02645"></a>02645   }
<a name="l02650"></a><a class="code" href="classGroup__cache.html#ab5fc3a99a10a7a8e812e39c5457676db">02650</a>   <span class="keywordtype">size_t</span> <a class="code" href="classGroup__cache.html#ab5fc3a99a10a7a8e812e39c5457676db">get_max_string_length</a>()<span class="keyword"> const</span>
<a name="l02651"></a>02651 <span class="keyword">  </span>{
<a name="l02652"></a>02652     <span class="keywordflow">return</span> (2 + <a class="code" href="structUuid.html#ab722c635d156b2399dd03268660f150c" title="The number of bytes in the textual representation of a Uuid.">Uuid::TEXT_LENGTH</a> + 1 + MAX_GNO_TEXT_LENGTH + 4 + 2 +
<a name="l02653"></a>02653             40 + 10 + 21 + 1 + 100<span class="comment">/*margin*/</span>) * <a class="code" href="classGroup__cache.html#a5a895b1e3c518c9a3c3783daae937b5d" title="Return the number of groups in this group cache.">get_n_groups</a>() + 100<span class="comment">/*margin*/</span>;
<a name="l02654"></a>02654   }
<a name="l02660"></a><a class="code" href="classGroup__cache.html#ab88d8ad90b856187160bb2adfbd20e03">02660</a>   <span class="keywordtype">char</span> *<a class="code" href="classGroup__cache.html#a065ad7cc7b3da71d345352ae6f400aa0">to_string</a>(<span class="keyword">const</span> <a class="code" href="classSid__map.html">Sid_map</a> *sm)<span class="keyword"> const</span>
<a name="l02661"></a>02661 <span class="keyword">  </span>{
<a name="l02662"></a>02662     <span class="keywordtype">char</span> *str= (<span class="keywordtype">char</span> *)my_malloc(<a class="code" href="classGroup__cache.html#ab5fc3a99a10a7a8e812e39c5457676db">get_max_string_length</a>(), MYF(MY_WME));
<a name="l02663"></a>02663     <span class="keywordflow">if</span> (str)
<a name="l02664"></a>02664       <a class="code" href="classGroup__cache.html#a065ad7cc7b3da71d345352ae6f400aa0">to_string</a>(sm, str);
<a name="l02665"></a>02665     <span class="keywordflow">return</span> str;
<a name="l02666"></a>02666   }
<a name="l02668"></a><a class="code" href="classGroup__cache.html#a6f8d0063706a38324214225240c4e9a5">02668</a>   <span class="keywordtype">void</span> <a class="code" href="classGroup__cache.html#a6f8d0063706a38324214225240c4e9a5" title="Debug only: print this Group_cache to stdout.">print</a>(<span class="keyword">const</span> <a class="code" href="classSid__map.html">Sid_map</a> *sm)<span class="keyword"> const</span>
<a name="l02669"></a>02669 <span class="keyword">  </span>{
<a name="l02670"></a>02670     <span class="keywordtype">char</span> *str= <a class="code" href="classGroup__cache.html#a065ad7cc7b3da71d345352ae6f400aa0">to_string</a>(sm);
<a name="l02671"></a>02671     printf(<span class="stringliteral">&quot;%s\n&quot;</span>, str);
<a name="l02672"></a>02672     my_free(str);
<a name="l02673"></a>02673   }
<a name="l02674"></a>02674 <span class="preprocessor">#endif</span>
<a name="l02675"></a>02675 <span class="preprocessor"></span>
<a name="l02679"></a><a class="code" href="classGroup__cache.html#a24ef897d01217dddd791e639f7a3c21c">02679</a>   <span class="keywordtype">void</span> <a class="code" href="classGroup__cache.html#a24ef897d01217dddd791e639f7a3c21c">dbug_print</a>(<span class="keyword">const</span> <a class="code" href="classSid__map.html">Sid_map</a> *sid_map, <span class="keyword">const</span> <span class="keywordtype">char</span> *text= <span class="stringliteral">&quot;&quot;</span>)<span class="keyword"> const</span>
<a name="l02680"></a>02680 <span class="keyword">  </span>{
<a name="l02681"></a>02681 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02682"></a>02682 <span class="preprocessor"></span>    <span class="keywordtype">char</span> *str= <a class="code" href="classGroup__cache.html#a065ad7cc7b3da71d345352ae6f400aa0">to_string</a>(sid_map);
<a name="l02683"></a>02683     DBUG_PRINT(<span class="stringliteral">&quot;info&quot;</span>, (<span class="stringliteral">&quot;%s%s%s&quot;</span>, text, *text ? <span class="stringliteral">&quot;: &quot;</span> : <span class="stringliteral">&quot;&quot;</span>, str));
<a name="l02684"></a>02684     my_free(str);
<a name="l02685"></a>02685 <span class="preprocessor">#endif</span>
<a name="l02686"></a>02686 <span class="preprocessor"></span>  }
<a name="l02687"></a>02687 
<a name="l02694"></a><a class="code" href="classGroup__cache.html#a221badb1f9c7b38ec0cfca3f19a76c81">02694</a>   <span class="keyword">inline</span> <a class="code" href="structCached__group.html">Cached_group</a> *<a class="code" href="classGroup__cache.html#a221badb1f9c7b38ec0cfca3f19a76c81">get_unsafe_pointer</a>(<span class="keywordtype">int</span> index)<span class="keyword"> const</span>
<a name="l02695"></a>02695 <span class="keyword">  </span>{
<a name="l02696"></a>02696     DBUG_ASSERT(index &gt;= 0 &amp;&amp; index &lt; <a class="code" href="classGroup__cache.html#a5a895b1e3c518c9a3c3783daae937b5d" title="Return the number of groups in this group cache.">get_n_groups</a>());
<a name="l02697"></a>02697     <span class="keywordflow">return</span> dynamic_element(&amp;groups, index, <a class="code" href="structCached__group.html">Cached_group</a> *);
<a name="l02698"></a>02698   }
<a name="l02699"></a>02699 
<a name="l02700"></a>02700 <span class="keyword">private</span>:
<a name="l02702"></a>02702   DYNAMIC_ARRAY groups;
<a name="l02703"></a>02703 
<a name="l02708"></a>02708   <a class="code" href="structCached__group.html">Cached_group</a> *get_last_group()
<a name="l02709"></a>02709   {
<a name="l02710"></a>02710     <span class="keywordtype">int</span> n_groups= <a class="code" href="classGroup__cache.html#a5a895b1e3c518c9a3c3783daae937b5d" title="Return the number of groups in this group cache.">get_n_groups</a>();
<a name="l02711"></a>02711     <span class="keywordflow">return</span> n_groups == 0 ? NULL : <a class="code" href="classGroup__cache.html#a221badb1f9c7b38ec0cfca3f19a76c81">get_unsafe_pointer</a>(n_groups - 1);
<a name="l02712"></a>02712   }
<a name="l02713"></a>02713 
<a name="l02718"></a>02718   <a class="code" href="structCached__group.html">Cached_group</a> *allocate_group()
<a name="l02719"></a>02719   {
<a name="l02720"></a>02720     <a class="code" href="structCached__group.html">Cached_group</a> *ret= (<a class="code" href="structCached__group.html">Cached_group</a> *)alloc_dynamic(&amp;groups);
<a name="l02721"></a>02721     <span class="keywordflow">if</span> (ret == NULL)
<a name="l02722"></a>02722       BINLOG_ERROR((<span class="stringliteral">&quot;Out of memory.&quot;</span>), (ER_OUT_OF_RESOURCES, MYF(0)));
<a name="l02723"></a>02723     <span class="keywordflow">return</span> ret;
<a name="l02724"></a>02724   }
<a name="l02725"></a>02725 
<a name="l02733"></a>02733   enum_return_status add_group(<span class="keyword">const</span> <a class="code" href="structCached__group.html">Cached_group</a> *group);
<a name="l02742"></a>02742   enum_return_status
<a name="l02743"></a>02743     write_to_log_prepare(<a class="code" href="classGroup__cache.html">Group_cache</a> *trx_group_cache,
<a name="l02744"></a>02744                          rpl_binlog_pos offset_after_last_statement,
<a name="l02745"></a>02745                          <a class="code" href="structCached__group.html">Cached_group</a> **last_non_empty_group);
<a name="l02746"></a>02746 
<a name="l02748"></a>02748 <span class="preprocessor">#ifdef FRIEND_OF_GROUP_CACHE</span>
<a name="l02749"></a>02749 <span class="preprocessor"></span>  <span class="keyword">friend</span> FRIEND_OF_GROUP_CACHE;
<a name="l02750"></a>02750 <span class="preprocessor">#endif</span>
<a name="l02751"></a>02751 <span class="preprocessor"></span>};
<a name="l02752"></a>02752 
<a name="l02757"></a>02757 <span class="keyword">enum</span> enum_gtid_statement_status
<a name="l02758"></a>02758 {
<a name="l02760"></a>02760   GTID_STATEMENT_EXECUTE,
<a name="l02762"></a>02762   GTID_STATEMENT_CANCEL,
<a name="l02767"></a>02767   GTID_STATEMENT_SKIP
<a name="l02768"></a>02768 };
<a name="l02769"></a>02769 
<a name="l02770"></a>02770 
<a name="l02771"></a>02771 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l02772"></a>02772 <span class="preprocessor"></span>
<a name="l02783"></a>02783 enum_gtid_statement_status
<a name="l02784"></a>02784 gtid_before_statement(THD *thd, <a class="code" href="classGroup__cache.html">Group_cache</a> *gsc, <a class="code" href="classGroup__cache.html">Group_cache</a> *gtc);
<a name="l02785"></a>02785 
<a name="l02794"></a>02794 enum_gtid_statement_status gtid_pre_statement_checks(<span class="keyword">const</span> THD *thd);
<a name="l02795"></a>02795 
<a name="l02802"></a>02802 <span class="keywordtype">void</span> gtid_post_statement_checks(THD *thd);
<a name="l02803"></a>02803 
<a name="l02808"></a>02808 <span class="keywordtype">int</span> gtid_rollback(THD *thd);
<a name="l02809"></a>02809 
<a name="l02810"></a>02810 <span class="keywordtype">int</span> gtid_acquire_ownership_single(THD *thd);
<a name="l02811"></a>02811 <span class="preprocessor">#ifdef HAVE_NDB_BINLOG</span>
<a name="l02812"></a>02812 <span class="preprocessor"></span><span class="keywordtype">int</span> gtid_acquire_ownership_multiple(THD *thd);
<a name="l02813"></a>02813 <span class="preprocessor">#endif</span>
<a name="l02814"></a>02814 <span class="preprocessor"></span>
<a name="l02815"></a>02815 <span class="preprocessor">#endif // ifndef MYSQL_CLIENT</span>
<a name="l02816"></a>02816 <span class="preprocessor"></span>
<a name="l02817"></a>02817 <span class="preprocessor">#endif </span><span class="comment">/* RPL_GTID_H_INCLUDED */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:46 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
