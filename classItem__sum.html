<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: Item_sum Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">Item_sum Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="Item_sum" --><!-- doxytag: inherits="Item_result_field" -->
<p><code>#include &lt;<a class="el" href="item__sum_8h_source.html">item_sum.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Item_sum:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classItem__sum.png" usemap="#Item_sum_map" alt=""/>
  <map id="Item_sum_map" name="Item_sum_map">
<area href="classItem__result__field.html" alt="Item_result_field" shape="rect" coords="161,56,312,80"/>
<area href="classItem.html" alt="Item" shape="rect" coords="161,0,312,24"/>
<area href="classItem__func__group__concat.html" alt="Item_func_group_concat" shape="rect" coords="0,168,151,192"/>
<area href="classItem__sum__hybrid.html" alt="Item_sum_hybrid" shape="rect" coords="161,168,312,192"/>
<area href="classItem__sum__num.html" alt="Item_sum_num" shape="rect" coords="483,168,634,192"/>
<area href="classItem__sum__max.html" alt="Item_sum_max" shape="rect" coords="322,224,473,248"/>
<area href="classItem__sum__min.html" alt="Item_sum_min" shape="rect" coords="322,280,473,304"/>
<area href="classItem__sum__int.html" alt="Item_sum_int" shape="rect" coords="644,224,795,248"/>
<area href="classItem__sum__sum.html" alt="Item_sum_sum" shape="rect" coords="644,280,795,304"/>
<area href="classItem__sum__udf__decimal.html" alt="Item_sum_udf_decimal" shape="rect" coords="644,336,795,360"/>
<area href="classItem__sum__udf__float.html" alt="Item_sum_udf_float" shape="rect" coords="644,392,795,416"/>
<area href="classItem__sum__udf__int.html" alt="Item_sum_udf_int" shape="rect" coords="644,448,795,472"/>
<area href="classItem__sum__udf__str.html" alt="Item_sum_udf_str" shape="rect" coords="644,504,795,528"/>
<area href="classItem__sum__variance.html" alt="Item_sum_variance" shape="rect" coords="644,560,795,584"/>
</map>
 </div></div>

<p><a href="classItem__sum-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><b>Sumfunctype</b> { <br/>
&#160;&#160;<b>COUNT_FUNC</b>, 
<b>COUNT_DISTINCT_FUNC</b>, 
<b>SUM_FUNC</b>, 
<b>SUM_DISTINCT_FUNC</b>, 
<br/>
&#160;&#160;<b>AVG_FUNC</b>, 
<b>AVG_DISTINCT_FUNC</b>, 
<b>MIN_FUNC</b>, 
<b>MAX_FUNC</b>, 
<br/>
&#160;&#160;<b>STD_FUNC</b>, 
<b>VARIANCE_FUNC</b>, 
<b>SUM_BIT_FUNC</b>, 
<b>UDF_SUM_FUNC</b>, 
<br/>
&#160;&#160;<b>GROUP_CONCAT_FUNC</b>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9a7017351ddc646e3da4c35b6de7647"></a><!-- doxytag: member="Item_sum::has_force_copy_fields" ref="ab9a7017351ddc646e3da4c35b6de7647" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_force_copy_fields</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a011af87522ea7e6503f1217fc5565f1e"></a><!-- doxytag: member="Item_sum::has_with_distinct" ref="a011af87522ea7e6503f1217fc5565f1e" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_with_distinct</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb41146ee1289cefbc30fabaeee43a47"></a><!-- doxytag: member="Item_sum::mark_as_sum_func" ref="acb41146ee1289cefbc30fabaeee43a47" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>mark_as_sum_func</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab37017d1c1c59664864a89a9935969dd"></a><!-- doxytag: member="Item_sum::Item_sum" ref="ab37017d1c1c59664864a89a9935969dd" args="(Item *a)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>Item_sum</b> (<a class="el" href="classItem.html">Item</a> *a)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a840dc9485a78347e2ffa68799d6cc4f6"></a><!-- doxytag: member="Item_sum::Item_sum" ref="a840dc9485a78347e2ffa68799d6cc4f6" args="(Item *a, Item *b)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>Item_sum</b> (<a class="el" href="classItem.html">Item</a> *a, <a class="el" href="classItem.html">Item</a> *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8693c5debba53deed0226fcf35f2dd46"></a><!-- doxytag: member="Item_sum::Item_sum" ref="a8693c5debba53deed0226fcf35f2dd46" args="(List&lt; Item &gt; &amp;list)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>Item_sum</b> (<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem.html">Item</a> &gt; &amp;list)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#ab22d52290db63c5048f1aa712be2cad7">Item_sum</a> (THD *thd, <a class="el" href="classItem__sum.html">Item_sum</a> *item)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e8ba14629d41b02875a6a264a647f99"></a><!-- doxytag: member="Item_sum::type" ref="a1e8ba14629d41b02875a6a264a647f99" args="() const " -->
enum Type&#160;</td><td class="memItemRight" valign="bottom"><b>type</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed1d2a2c7b4239179501cf8077ad4c3d"></a><!-- doxytag: member="Item_sum::sum_func" ref="aed1d2a2c7b4239179501cf8077ad4c3d" args="() const =0" -->
virtual enum Sumfunctype&#160;</td><td class="memItemRight" valign="bottom"><b>sum_func</b> () const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#a5d29c1ad81ae5e0193775cb360f4a74a">reset_and_add</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8389f10b8d24086cf3a3177b40b84378"></a><!-- doxytag: member="Item_sum::reset_field" ref="a8389f10b8d24086cf3a3177b40b84378" args="()=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>reset_field</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b214bf6962a21455aaa537f5833e226"></a><!-- doxytag: member="Item_sum::update_field" ref="a6b214bf6962a21455aaa537f5833e226" args="()=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>update_field</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afaae54db9f8c65716eb36a8af5f54aab"></a><!-- doxytag: member="Item_sum::keep_field_type" ref="afaae54db9f8c65716eb36a8af5f54aab" args="(void) const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>keep_field_type</b> (void) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad189ead425c2289611aff88166a65574"></a><!-- doxytag: member="Item_sum::fix_length_and_dec" ref="ad189ead425c2289611aff88166a65574" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>fix_length_and_dec</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d3f5893bf56f30e06bc88684ce00e89"></a><!-- doxytag: member="Item_sum::result_item" ref="a0d3f5893bf56f30e06bc88684ce00e89" args="(Field *field)" -->
virtual <a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>result_item</b> (<a class="el" href="classField.html">Field</a> *field)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a432dab187979f78ddf21c68bf43a24d2"></a><!-- doxytag: member="Item_sum::used_tables" ref="a432dab187979f78ddf21c68bf43a24d2" args="() const " -->
table_map&#160;</td><td class="memItemRight" valign="bottom"><b>used_tables</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaab945bdb327a02540a0b9c6030ff026"></a><!-- doxytag: member="Item_sum::update_used_tables" ref="aaab945bdb327a02540a0b9c6030ff026" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_used_tables</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a34d803f255ce76bcd00d58ef3323cc15"></a><!-- doxytag: member="Item_sum::is_null" ref="a34d803f255ce76bcd00d58ef3323cc15" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_null</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50f352c59bf4d0305bffda80520f70f8"></a><!-- doxytag: member="Item_sum::make_const" ref="a50f352c59bf4d0305bffda80520f70f8" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>make_const</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add01eb1fa8f53a5fc1541e1e57bd6d48"></a><!-- doxytag: member="Item_sum::const_item" ref="add01eb1fa8f53a5fc1541e1e57bd6d48" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>const_item</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8fa6c9377718516656f6f957ec29df0a"></a><!-- doxytag: member="Item_sum::const_during_execution" ref="a8fa6c9377718516656f6f957ec29df0a" args="() const " -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>const_during_execution</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#a0c176fad01253e4a168d0956eb1f6fc5">print</a> (<a class="el" href="classString.html">String</a> *str, enum_query_type query_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa89090ccb5f49afc194007e95ac2eb4c"></a><!-- doxytag: member="Item_sum::fix_num_length_and_dec" ref="aa89090ccb5f49afc194007e95ac2eb4c" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>fix_num_length_and_dec</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#aba62f301a61ca3e686abf23e109bb0a8">no_rows_in_result</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a551fb0c43e28ae3088d71625d47c23f8"></a><!-- doxytag: member="Item_sum::make_unique" ref="a551fb0c43e28ae3088d71625d47c23f8" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>make_unique</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a33829c2bee05108c95e713d5b57eda"></a><!-- doxytag: member="Item_sum::get_tmp_table_item" ref="a7a33829c2bee05108c95e713d5b57eda" args="(THD *thd)" -->
<a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_tmp_table_item</b> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa1c5a95d9e25a0b4ec6775eb9d13ecbf"></a><!-- doxytag: member="Item_sum::create_tmp_field" ref="aa1c5a95d9e25a0b4ec6775eb9d13ecbf" args="(bool group, TABLE *table)" -->
virtual <a class="el" href="classField.html">Field</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>create_tmp_field</b> (bool group, <a class="el" href="structTABLE.html">TABLE</a> *table)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d298ec54c2276ce3aa8371f379546d7"></a><!-- doxytag: member="Item_sum::walk" ref="a2d298ec54c2276ce3aa8371f379546d7" args="(Item_processor processor, bool walk_subquery, uchar *argument)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>walk</b> (Item_processor processor, bool walk_subquery, uchar *argument)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#a838d698110f5c45d6ad3ba1c6e5b2a95">clean_up_after_removal</a> (uchar *arg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#a34894a53489b9c2757491908222208bd">init_sum_func_check</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#a6de4d25ee11eb43798effbd4968236bd">check_sum_func</a> (THD *thd, <a class="el" href="classItem.html">Item</a> **ref)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#a15a75b6a683912f8222f7091b3714ec8">register_sum_func</a> (THD *thd, <a class="el" href="classItem.html">Item</a> **ref)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add3e06f8ee2cbae4f1eb1ef3c662c21a"></a><!-- doxytag: member="Item_sum::depended_from" ref="add3e06f8ee2cbae4f1eb1ef3c662c21a" args="()" -->
st_select_lex *&#160;</td><td class="memItemRight" valign="bottom"><b>depended_from</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8a61e6787ef93f6a5f348971426402b"></a><!-- doxytag: member="Item_sum::get_arg" ref="ab8a61e6787ef93f6a5f348971426402b" args="(uint i)" -->
<a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_arg</b> (uint i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acdfbfe05103c88d3d1ffefe1cf12afc3"></a><!-- doxytag: member="Item_sum::set_arg" ref="acdfbfe05103c88d3d1ffefe1cf12afc3" args="(uint i, THD *thd, Item *new_val)" -->
<a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>set_arg</b> (uint i, THD *thd, <a class="el" href="classItem.html">Item</a> *new_val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bbc6ce2dd8ae78d460ff3962785824f"></a><!-- doxytag: member="Item_sum::get_arg_count" ref="a1bbc6ce2dd8ae78d460ff3962785824f" args="() const " -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>get_arg_count</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2f367d4660a3ccec53fd4d0efb925b17"></a><!-- doxytag: member="Item_sum::init_aggregator" ref="a2f367d4660a3ccec53fd4d0efb925b17" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>init_aggregator</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#ac84fa680a8b3690c6735474c9476f312">aggregator_setup</a> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#a15e7047e85571842d5aada49784f4278">aggregator_clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#ab090330ed58167234556e1f906976c0c">aggregator_add</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6d6dadc286edb069d017f4e24dbaa3e"></a><!-- doxytag: member="Item_sum::set_distinct" ref="ab6d6dadc286edb069d017f4e24dbaa3e" args="(bool distinct)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_distinct</b> (bool distinct)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab0685e05aefcfee71e20d11bcb06e406"></a><!-- doxytag: member="Item_sum::set_aggregator" ref="ab0685e05aefcfee71e20d11bcb06e406" args="(Aggregator::Aggregator_type aggregator)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>set_aggregator</b> (Aggregator::Aggregator_type aggregator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a25abf6a2e7f8e21b54b6e3e163efb6"></a><!-- doxytag: member="Item_sum::clear" ref="a7a25abf6a2e7f8e21b54b6e3e163efb6" args="()=0" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41c914f3c66a8f4f2f7347d84a5146e7"></a><!-- doxytag: member="Item_sum::add" ref="a41c914f3c66a8f4f2f7347d84a5146e7" args="()=0" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>add</b> ()=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4be3f81909455d393f78956d701ebe9c"></a><!-- doxytag: member="Item_sum::setup" ref="a4be3f81909455d393f78956d701ebe9c" args="(THD *thd)" -->
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>setup</b> (THD *thd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a684aa82ea6a3865ccd33e1d6a35af4df"></a><!-- doxytag: member="Item_sum::cleanup" ref="a684aa82ea6a3865ccd33e1d6a35af4df" args="()" -->
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanup</b> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a258a11a7a37d6691b29eea7d1a3763ed"></a><!-- doxytag: member="Item_sum::ref_by" ref="a258a11a7a37d6691b29eea7d1a3763ed" args="" -->
<a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>ref_by</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem__sum.html">Item_sum</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#aebfdf84a6004bd7911e9530667fcf94c">next</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac0b8ea2a1e56beef4716d1dbdd9c3785"></a><!-- doxytag: member="Item_sum::in_sum_func" ref="ac0b8ea2a1e56beef4716d1dbdd9c3785" args="" -->
<a class="el" href="classItem__sum.html">Item_sum</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>in_sum_func</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab23f43a29e2173f24250d05afdb3e76c"></a><!-- doxytag: member="Item_sum::aggr_sel" ref="ab23f43a29e2173f24250d05afdb3e76c" args="" -->
st_select_lex *&#160;</td><td class="memItemRight" valign="bottom"><b>aggr_sel</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ac0e233d4d6559207672c962da4e99b"></a><!-- doxytag: member="Item_sum::nest_level" ref="a6ac0e233d4d6559207672c962da4e99b" args="" -->
int8&#160;</td><td class="memItemRight" valign="bottom"><b>nest_level</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac46d96adf08d77895aaee0fc35b22e31"></a><!-- doxytag: member="Item_sum::aggr_level" ref="ac46d96adf08d77895aaee0fc35b22e31" args="" -->
int8&#160;</td><td class="memItemRight" valign="bottom"><b>aggr_level</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a254522bb2b44291d437b68702c324b73"></a><!-- doxytag: member="Item_sum::max_arg_level" ref="a254522bb2b44291d437b68702c324b73" args="" -->
int8&#160;</td><td class="memItemRight" valign="bottom"><b>max_arg_level</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4ed820ab7c0fe088d07e2d9a20f4e4d"></a><!-- doxytag: member="Item_sum::max_sum_func_level" ref="ae4ed820ab7c0fe088d07e2d9a20f4e4d" args="" -->
int8&#160;</td><td class="memItemRight" valign="bottom"><b>max_sum_func_level</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af2ad77502fcc4fa45bdcec6ed29d471a"></a><!-- doxytag: member="Item_sum::quick_group" ref="af2ad77502fcc4fa45bdcec6ed29d471a" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>quick_group</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a636cd53de2c9be651319c707b03b602a"></a><!-- doxytag: member="Item_sum::outer_fields" ref="a636cd53de2c9be651319c707b03b602a" args="" -->
<a class="el" href="classList.html">List</a>&lt; <a class="el" href="classItem__field.html">Item_field</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>outer_fields</b></td></tr>
<tr><td colspan="2"><h2><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static ulonglong&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#ad70361f29a92bb55dccd236ddd5e9a53">ram_limitation</a> (THD *thd)</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAggregator.html">Aggregator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classItem__sum.html#a6ff5bd547facf5c328841cf385e59509">aggr</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a7743356151cb7a567ff1a39078949f"></a><!-- doxytag: member="Item_sum::arg_count" ref="a1a7743356151cb7a567ff1a39078949f" args="" -->
uint&#160;</td><td class="memItemRight" valign="bottom"><b>arg_count</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae77718273b245bde4165dd5ecc201746"></a><!-- doxytag: member="Item_sum::args" ref="ae77718273b245bde4165dd5ecc201746" args="" -->
<a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>args</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe612a6d8a11a53dd6783c6ccef29fe8"></a><!-- doxytag: member="Item_sum::tmp_args" ref="abe612a6d8a11a53dd6783c6ccef29fe8" args="[2]" -->
<a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>tmp_args</b> [2]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d54c527be66add9a9de76d07df6d0f1"></a><!-- doxytag: member="Item_sum::orig_args" ref="a6d54c527be66add9a9de76d07df6d0f1" args="" -->
<a class="el" href="classItem.html">Item</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>orig_args</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1deaa6ed7a544de69bccd210b54bf7d9"></a><!-- doxytag: member="Item_sum::tmp_orig_args" ref="a1deaa6ed7a544de69bccd210b54bf7d9" args="[2]" -->
<a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>tmp_orig_args</b> [2]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a058b0e6d479d59d533c2e790b8ae6c7d"></a><!-- doxytag: member="Item_sum::used_tables_cache" ref="a058b0e6d479d59d533c2e790b8ae6c7d" args="" -->
table_map&#160;</td><td class="memItemRight" valign="bottom"><b>used_tables_cache</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67b53e7725198c9280538ca643c88e32"></a><!-- doxytag: member="Item_sum::forced_const" ref="a67b53e7725198c9280538ca643c88e32" args="" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>forced_const</b></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a40fcb2830e29e49349d865893b6d0b7d"></a><!-- doxytag: member="Item_sum::Aggregator_distinct" ref="a40fcb2830e29e49349d865893b6d0b7d" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>Aggregator_distinct</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa25c05c6bfa3091d6d165dc8af5fecb8"></a><!-- doxytag: member="Item_sum::Aggregator_simple" ref="aa25c05c6bfa3091d6d165dc8af5fecb8" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>Aggregator_simple</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Class <a class="el" href="classItem__sum.html">Item_sum</a> is the base class used for special expressions that SQL calls 'set functions'. These expressions are formed with the help of aggregate functions such as SUM, MAX, GROUP_CONCAT etc.</p>
<p>GENERAL NOTES</p>
<p>A set function cannot be used in certain positions where expressions are accepted. There are some quite explicable restrictions for the usage of set functions.</p>
<p>In the query: SELECT AVG(b) FROM t1 WHERE SUM(b) &gt; 20 GROUP by a the usage of the set function AVG(b) is legal, while the usage of SUM(b) is illegal. A WHERE condition must contain expressions that can be evaluated for each row of the table. Yet the expression SUM(b) can be evaluated only for each group of rows with the same value of column a. In the query: SELECT AVG(b) FROM t1 WHERE c &gt; 30 GROUP BY a HAVING SUM(b) &gt; 20 both set function expressions AVG(b) and SUM(b) are legal.</p>
<p>We can say that in a query without nested selects an occurrence of a set function in an expression of the SELECT list or/and in the HAVING clause is legal, while in the WHERE clause it's illegal.</p>
<p>The general rule to detect whether a set function is legal in a query with nested subqueries is much more complicated.</p>
<p>Consider the the following query: SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a &gt; ALL (SELECT t2.c FROM t2 WHERE SUM(t1.b) &lt; t2.c). The set function SUM(b) is used here in the WHERE clause of the subquery. Nevertheless it is legal since it is under the HAVING clause of the query to which this function relates. The expression SUM(t1.b) is evaluated for each group defined in the main query, not for groups of the subquery.</p>
<p>The problem of finding the query where to aggregate a particular set function is not so simple as it seems to be.</p>
<p>In the query: SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a &gt; ALL(SELECT t2.c FROM t2 GROUP BY t2.c HAVING SUM(t1.a) &lt; t2.c) the set function can be evaluated for both outer and inner selects. If we evaluate SUM(t1.a) for the outer query then we get the value of t1.a multiplied by the cardinality of a group in table t1. In this case in each correlated subquery SUM(t1.a) is used as a constant. But we also can evaluate SUM(t1.a) for the inner query. In this case t1.a will be a constant for each correlated subquery and summation is performed for each group of table t2. (Here it makes sense to remind that the query SELECT c FROM t GROUP BY a HAVING SUM(1) &lt; a is quite legal in our SQL).</p>
<p>So depending on what query we assign the set function to we can get different result sets.</p>
<p>The general rule to detect the query where a set function is to be evaluated can be formulated as follows. Consider a set function S(E) where E is an expression with occurrences of column references C1, ..., CN. Resolve these column references against subqueries that contain the set function S(E). Let Q be the innermost subquery of those subqueries. (It should be noted here that S(E) in no way can be evaluated in the subquery embedding the subquery Q, otherwise S(E) would refer to at least one unbound column reference) If S(E) is used in a construct of Q where set functions are allowed then we evaluate S(E) in Q. Otherwise we look for a innermost subquery containing S(E) of those where usage of S(E) is allowed.</p>
<p>Let's demonstrate how this rule is applied to the following queries.</p>
<p>1. SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a &gt; ALL(SELECT t2.b FROM t2 GROUP BY t2.b HAVING t2.b &gt; ALL(SELECT t3.c FROM t3 GROUP BY t3.c HAVING SUM(t1.a+t2.b) &lt; t3.c)) For this query the set function SUM(t1.a+t2.b) depends on t1.a and t2.b with t1.a defined in the outermost query, and t2.b defined for its subquery. The set function is in the HAVING clause of the subquery and can be evaluated in this subquery.</p>
<p>2. SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a &gt; ALL(SELECT t2.b FROM t2 WHERE t2.b &gt; ALL (SELECT t3.c FROM t3 GROUP BY t3.c HAVING SUM(t1.a+t2.b) &lt; t3.c)) Here the set function SUM(t1.a+t2.b)is in the WHERE clause of the second subquery - the most upper subquery where t1.a and t2.b are defined. If we evaluate the function in this subquery we violate the context rules. So we evaluate the function in the third subquery (over table t3) where it is used under the HAVING clause.</p>
<p>3. SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a &gt; ALL(SELECT t2.b FROM t2 WHERE t2.b &gt; ALL (SELECT t3.c FROM t3 WHERE SUM(t1.a+t2.b) &lt; t3.c)) In this query evaluation of SUM(t1.a+t2.b) is not legal neither in the second nor in the third subqueries. So this query is invalid.</p>
<p>Mostly set functions cannot be nested. In the query SELECT t1.a from t1 GROUP BY t1.a HAVING AVG(SUM(t1.b)) &gt; 20 the expression SUM(b) is not acceptable, though it is under a HAVING clause. Yet it is acceptable in the query: SELECT t.1 FROM t1 GROUP BY t1.a HAVING SUM(t1.b) &gt; 20.</p>
<p>An argument of a set function does not have to be a reference to a table column as we saw it in examples above. This can be a more complex expression SELECT t1.a FROM t1 GROUP BY t1.a HAVING SUM(t1.b+1) &gt; 20. The expression SUM(t1.b+1) has a very clear semantics in this context: we sum up the values of t1.b+1 where t1.b varies for all values within a group of rows that contain the same t1.a value.</p>
<p>A set function for an outer query yields a constant within a subquery. So the semantics of the query SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a IN (SELECT t2.c FROM t2 GROUP BY t2.c HAVING AVG(t2.c+SUM(t1.b)) &gt; 20) is still clear. For a group of the rows with the same t1.a values we calculate the value of SUM(t1.b). This value 's' is substituted in the the subquery: SELECT t2.c FROM t2 GROUP BY t2.c HAVING AVG(t2.c+s) than returns some result set.</p>
<p>By the same reason the following query with a subquery SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a IN (SELECT t2.c FROM t2 GROUP BY t2.c HAVING AVG(SUM(t1.b)) &gt; 20) is also acceptable.</p>
<p>IMPLEMENTATION NOTES</p>
<p>Three methods were added to the class to check the constraints specified in the previous section. These methods utilize several new members.</p>
<p>The field 'nest_level' contains the number of the level for the subquery containing the set function. The main SELECT is of level 0, its subqueries are of levels 1, the subqueries of the latter are of level 2 and so on.</p>
<p>The field 'aggr_level' is to contain the nest level of the subquery where the set function is aggregated.</p>
<p>The field 'max_arg_level' is for the maximun of the nest levels of the unbound column references occurred in the set function. A column reference is unbound within a set function if it is not bound by any subquery used as a subexpression in this function. A column reference is bound by a subquery if it is a reference to the column by which the aggregation of some set function that is used in the subquery is calculated. For the set function used in the query SELECT t1.a FROM t1 GROUP BY t1.a HAVING t1.a &gt; ALL(SELECT t2.b FROM t2 GROUP BY t2.b HAVING t2.b &gt; ALL(SELECT t3.c FROM t3 GROUP BY t3.c HAVING SUM(t1.a+t2.b) &lt; t3.c)) the value of max_arg_level is equal to 1 since t1.a is bound in the main query, and t2.b is bound by the first subquery whose nest level is 1. Obviously a set function cannot be aggregated in the subquery whose nest level is less than max_arg_level. (Yet it can be aggregated in the subqueries whose nest level is greater than max_arg_level.) In the query SELECT t.a FROM t1 HAVING AVG(t1.a+(SELECT MIN(t2.c) FROM t2)) the value of the max_arg_level for the AVG set function is 0 since the reference t2.c is bound in the subquery.</p>
<p>The field 'max_sum_func_level' is to contain the maximum of the nest levels of the set functions that are used as subexpressions of the arguments of the given set function, but not aggregated in any subquery within this set function. A nested set function s1 can be used within set function s0 only if s1.max_sum_func_level &lt; s0.max_sum_func_level. Set function s1 is considered as nested for set function s0 if s1 is not calculated in any subquery within s0.</p>
<p>A set function that is used as a subexpression in an argument of another set function refers to the latter via the field 'in_sum_func'.</p>
<p>The condition imposed on the usage of set functions are checked when we traverse query subexpressions with the help of the recursive method fix_fields. When we apply this method to an object of the class <a class="el" href="classItem__sum.html">Item_sum</a>, first, on the descent, we call the method init_sum_func_check that initialize members used at checking. Then, on the ascent, we call the method check_sum_func that validates the set function usage and reports an error if it is illegal. The method register_sum_func serves to link the items for the set functions that are aggregated in the embedding (sub)queries. Circular chains of such functions are attached to the corresponding st_select_lex structures through the field inner_sum_func_list.</p>
<p>Exploiting the fact that the members mentioned above are used in one recursive function we could have allocated them on the thread stack. Yet we don't do it now.</p>
<p>We assume that the nesting level of subquries does not exceed 127. TODO: to catch queries where the limit is exceeded to make the code clean here. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ab22d52290db63c5048f1aa712be2cad7"></a><!-- doxytag: member="Item_sum::Item_sum" ref="ab22d52290db63c5048f1aa712be2cad7" args="(THD *thd, Item_sum *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Item_sum::Item_sum </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem__sum.html">Item_sum</a> *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructor used in processing select with temporary tebles. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab090330ed58167234556e1f906976c0c"></a><!-- doxytag: member="Item_sum::aggregator_add" ref="ab090330ed58167234556e1f906976c0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classItem__sum.html#ab090330ed58167234556e1f906976c0c">Item_sum::aggregator_add</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called to add value to the aggregator. </p>

</div>
</div>
<a class="anchor" id="a15e7047e85571842d5aada49784f4278"></a><!-- doxytag: member="Item_sum::aggregator_clear" ref="a15e7047e85571842d5aada49784f4278" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classItem__sum.html#a15e7047e85571842d5aada49784f4278">Item_sum::aggregator_clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called to cleanup the aggregator. </p>

</div>
</div>
<a class="anchor" id="ac84fa680a8b3690c6735474c9476f312"></a><!-- doxytag: member="Item_sum::aggregator_setup" ref="ac84fa680a8b3690c6735474c9476f312" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classItem__sum.html#ac84fa680a8b3690c6735474c9476f312">Item_sum::aggregator_setup</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Called to initialize the aggregator. </p>

</div>
</div>
<a class="anchor" id="a6de4d25ee11eb43798effbd4968236bd"></a><!-- doxytag: member="Item_sum::check_sum_func" ref="a6de4d25ee11eb43798effbd4968236bd" args="(THD *thd, Item **ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classItem__sum.html#a6de4d25ee11eb43798effbd4968236bd">Item_sum::check_sum_func</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check constraints imposed on a usage of a set function.</p>
<p>The method verifies whether context conditions imposed on a usage of any set function are met for this occurrence. It checks whether the set function occurs in the position where it can be aggregated and, when it happens to occur in argument of another set function, the method checks that these two functions are aggregated in different subqueries. If the context conditions are not met the method reports an error. If the set function is aggregated in some outer subquery the method adds it to the chain of items for such set functions that is attached to the the st_select_lex structure for this subquery.</p>
<p>A number of designated members of the object are used to check the conditions. They are specified in the comment before the <a class="el" href="classItem__sum.html">Item_sum</a> class declaration. Additionally a bitmap variable called allow_sum_func is employed. It is included into the thd-&gt;lex structure. The bitmap contains 1 at n-th position if the set function happens to occur under a construct of the n-th level subquery where usage of set functions are allowed (i.e either in the SELECT list or in the HAVING clause of the corresponding subquery) Consider the query: </p>
<div class="fragment"><pre class="fragment">       SELECT SUM(t1.b) FROM t1 GROUP BY t1.a
         HAVING t1.a IN (SELECT t2.c FROM t2 WHERE AVG(t1.b) &gt; 20) AND
                t1.a &gt; (SELECT MIN(t2.d) FROM t2);
</pre></div><p> allow_sum_func will contain:</p>
<ul>
<li>for SUM(t1.b) - 1 at the first position</li>
<li>for AVG(t1.b) - 1 at the first position, 0 at the second position</li>
<li>for MIN(t2.d) - 1 at the first position, 1 at the second position.</li>
</ul>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>reference to the thread context info </td></tr>
    <tr><td class="paramname">ref</td><td>location of the pointer to this item in the embedding expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is to be called for any item created for a set function object when the traversal of trees built for expressions used in the query is performed at the phase of context analysis. This function is to be invoked at the ascent of this traversal.</dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if an error is reported </td></tr>
    <tr><td class="paramname">FALSE</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a838d698110f5c45d6ad3ba1c6e5b2a95"></a><!-- doxytag: member="Item_sum::clean_up_after_removal" ref="a838d698110f5c45d6ad3ba1c6e5b2a95" args="(uchar *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classItem__sum.html#a838d698110f5c45d6ad3ba1c6e5b2a95">Item_sum::clean_up_after_removal</a> </td>
          <td>(</td>
          <td class="paramtype">uchar *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the item from the list of inner aggregation functions in the SELECT_LEX it was moved to by <a class="el" href="classItem__sum.html#a15a75b6a683912f8222f7091b3714ec8">Item_sum::register_sum_func()</a>.</p>
<p>This is done to undo some of the effects of <a class="el" href="classItem__sum.html#a15a75b6a683912f8222f7091b3714ec8">Item_sum::register_sum_func()</a> so that the item may be removed from the query.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This doesn't completely undo <a class="el" href="classItem__sum.html#a15a75b6a683912f8222f7091b3714ec8">Item_sum::register_sum_func()</a>, as with_sum_func information is left untouched. This means that if this item is removed, aggr_sel and all Item_subselects between aggr_sel and this item may be left with with_sum_func set to true, even if there are no aggregation functions. To our knowledge, this has no impact on the query result.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classItem__sum.html#a15a75b6a683912f8222f7091b3714ec8">Item_sum::register_sum_func()</a> </dd>
<dd>
remove_redundant_subquery_clauses() </dd></dl>

<p>Reimplemented from <a class="el" href="classItem.html#a649bf72a4ae639e262d147cf5beaa30a">Item</a>.</p>

</div>
</div>
<a class="anchor" id="a34894a53489b9c2757491908222208bd"></a><!-- doxytag: member="Item_sum::init_sum_func_check" ref="a34894a53489b9c2757491908222208bd" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classItem__sum.html#a34894a53489b9c2757491908222208bd">Item_sum::init_sum_func_check</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepare an aggregate function item for checking context conditions.</p>
<p>The function initializes the members of the <a class="el" href="classItem__sum.html">Item_sum</a> object created for a set function that are used to check validity of the set function occurrence. If the set function is not allowed in any subquery where it occurs an error is reported immediately.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>reference to the thread context info</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is to be called for any item created for a set function object when the traversal of trees built for expressions used in the query is performed at the phase of context analysis. This function is to be invoked at the descent of this traversal. </dd></dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>if an error is reported </td></tr>
    <tr><td class="paramname">FALSE</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba62f301a61ca3e686abf23e109bb0a8"></a><!-- doxytag: member="Item_sum::no_rows_in_result" ref="aba62f301a61ca3e686abf23e109bb0a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classItem__sum.html#aba62f301a61ca3e686abf23e109bb0a8">Item_sum::no_rows_in_result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mark an aggregate as having no rows.</p>
<p>This function is called by the execution engine to assign 'NO ROWS FOUND' value to an aggregate item, when the underlying result set has no rows. Such value, in a general case, may be different from the default value of the item after 'clear()': e.g. a numeric item may be initialized to 0 by clear() and to NULL by <a class="el" href="classItem__sum.html#aba62f301a61ca3e686abf23e109bb0a8">no_rows_in_result()</a>. </p>

<p>Reimplemented from <a class="el" href="classItem.html">Item</a>.</p>

<p>Reimplemented in <a class="el" href="classItem__func__group__concat.html#a89dcd722bccaa2c1b16d972ce823087f">Item_func_group_concat</a>, <a class="el" href="classItem__sum__hybrid.html#a7b06af139e0b7f7b0153252aa8f2e992">Item_sum_hybrid</a>, <a class="el" href="classItem__sum__variance.html#a510a0268827bac0bf1fc4cf933813745">Item_sum_variance</a>, <a class="el" href="classItem__sum__avg.html#ab4cfa5a3c42abc40f7f3fdb95c92d568">Item_sum_avg</a>, <a class="el" href="classItem__sum__count.html#a74ba6f4c6812411fa43d9d942d949863">Item_sum_count</a>, and <a class="el" href="classItem__sum__sum.html#aa610e5d4e5371dcea4625416d7d79d93">Item_sum_sum</a>.</p>

</div>
</div>
<a class="anchor" id="a0c176fad01253e4a168d0956eb1f6fc5"></a><!-- doxytag: member="Item_sum::print" ref="a0c176fad01253e4a168d0956eb1f6fc5" args="(String *str, enum_query_type query_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classItem__sum.html#a0c176fad01253e4a168d0956eb1f6fc5">Item_sum::print</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classString.html">String</a> *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum_query_type&#160;</td>
          <td class="paramname"><em>query_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method is used for to:</p>
<ul>
<li>to generate a view definition query (SELECT-statement);</li>
<li>to generate a SQL-query for EXPLAIN EXTENDED;</li>
<li>to generate a SQL-query to be shown in INFORMATION_SCHEMA;</li>
<li>debug.</li>
</ul>
<p>For more information about view definition query, INFORMATION_SCHEMA query and why they should be generated from the Item-tree, </p>
<dl class="see"><dt><b>See also:</b></dt><dd>mysql_register_view(). </dd></dl>

<p>Reimplemented from <a class="el" href="classItem.html#aa7ba4bde739d83adec8edf3bf1596d94">Item</a>.</p>

<p>Reimplemented in <a class="el" href="classItem__func__group__concat.html#aec51f14b9c22c61d5ac4e58add30365b">Item_func_group_concat</a>.</p>

</div>
</div>
<a class="anchor" id="ad70361f29a92bb55dccd236ddd5e9a53"></a><!-- doxytag: member="Item_sum::ram_limitation" ref="ad70361f29a92bb55dccd236ddd5e9a53" args="(THD *thd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulonglong <a class="el" href="classItem__sum.html#ad70361f29a92bb55dccd236ddd5e9a53">Item_sum::ram_limitation</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td><code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculate the affordable RAM limit for structures like TREE or Unique used in Item_sum_* </p>

</div>
</div>
<a class="anchor" id="a15a75b6a683912f8222f7091b3714ec8"></a><!-- doxytag: member="Item_sum::register_sum_func" ref="a15a75b6a683912f8222f7091b3714ec8" args="(THD *thd, Item **ref)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classItem__sum.html#a15a75b6a683912f8222f7091b3714ec8">Item_sum::register_sum_func</a> </td>
          <td>(</td>
          <td class="paramtype">THD *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> **&#160;</td>
          <td class="paramname"><em>ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Attach a set function to the subquery where it must be aggregated.</p>
<p>The function looks for an outer subquery where the set function must be aggregated. If it finds such a subquery then aggr_level is set to the nest level of this subquery and the item for the set function is added to the list of set functions used in nested subqueries inner_sum_func_list defined for each subquery. When the item is placed there the field 'ref_by' is set to ref.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Now we 'register' only set functions that are aggregated in outer subqueries. Actually it makes sense to link all set function for a subquery in one chain. It would simplify the process of 'splitting' for set functions.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>reference to the thread context info </td></tr>
    <tr><td class="paramname">ref</td><td>location of the pointer to this item in the embedding expression</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">FALSE</td><td>if the executes without failures (currently always) </td></tr>
    <tr><td class="paramname">TRUE</td><td>otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d29c1ad81ae5e0193775cb360f4a74a"></a><!-- doxytag: member="Item_sum::reset_and_add" ref="a5d29c1ad81ae5e0193775cb360f4a74a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classItem__sum.html#a5d29c1ad81ae5e0193775cb360f4a74a">Item_sum::reset_and_add</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the aggregate value to its default and aggregates the current value of its attribute(s). </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a6ff5bd547facf5c328841cf385e59509"></a><!-- doxytag: member="Item_sum::aggr" ref="a6ff5bd547facf5c328841cf385e59509" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAggregator.html">Aggregator</a>* <a class="el" href="classItem__sum.html#a6ff5bd547facf5c328841cf385e59509">Item_sum::aggr</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classAggregator.html">Aggregator</a> class instance. Not set initially. Allocated only after it is determined if the incoming data are already distinct. </p>

</div>
</div>
<a class="anchor" id="aebfdf84a6004bd7911e9530667fcf94c"></a><!-- doxytag: member="Item_sum::next" ref="aebfdf84a6004bd7911e9530667fcf94c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem__sum.html">Item_sum</a>* <a class="el" href="classItem__sum.html#aebfdf84a6004bd7911e9530667fcf94c">Item_sum::next</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Intrusive list pointer for free list. If not null, points to the next <a class="el" href="classItem.html">Item</a> on some Query_arena's free list. For instance, stored procedures have their own Query_arena's.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>Query_arena::free_list </dd></dl>

<p>Reimplemented from <a class="el" href="classItem.html#af41ed24b86b2126cf7eacc591a863f47">Item</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="item__sum_8h_source.html">item_sum.h</a></li>
<li><a class="el" href="item__sum_8cc.html">item_sum.cc</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:36:51 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
