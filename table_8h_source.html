<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: table.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">table.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef TABLE_INCLUDED</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define TABLE_INCLUDED</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment">   the Free Software Foundation; version 2 of the License.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment">   along with this program; if not, write to the Free Software</span>
<a name="l00017"></a>00017 <span class="comment">   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;my_global.h&quot;</span>                          <span class="comment">/* NO_EMBEDDED_ACCESS_CHECKS */</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;sql_plist.h&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;sql_alloc.h&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;mdl.h&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;datadict.h&quot;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="preprocessor">#ifndef MYSQL_CLIENT</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;hash.h&quot;</span>                               <span class="comment">/* HASH */</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;handler.h&quot;</span>                <span class="comment">/* row_type, ha_choice, handler */</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;mysql_com.h&quot;</span>              <span class="comment">/* enum_field_types */</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;thr_lock.h&quot;</span>                  <span class="comment">/* thr_lock_type */</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;filesort_utils.h&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;parse_file.h&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;table_id.h&quot;</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="comment">/* Structs that defines the TABLE */</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keyword">class </span><a class="code" href="classItem.html">Item</a>;                             <span class="comment">/* Needed by ORDER */</span>
<a name="l00038"></a>00038 <span class="keyword">class </span><a class="code" href="classItem__subselect.html">Item_subselect</a>;
<a name="l00039"></a>00039 <span class="keyword">class </span><a class="code" href="classItem__field.html">Item_field</a>;
<a name="l00040"></a>00040 <span class="keyword">class </span><a class="code" href="classGRANT__TABLE.html">GRANT_TABLE</a>;
<a name="l00041"></a>00041 <span class="keyword">class </span>st_select_lex_unit;
<a name="l00042"></a>00042 <span class="keyword">class </span>st_select_lex;
<a name="l00043"></a>00043 <span class="keyword">class </span><a class="code" href="classpartition__info.html">partition_info</a>;
<a name="l00044"></a>00044 <span class="keyword">class </span><a class="code" href="classCOND__EQUAL.html">COND_EQUAL</a>;
<a name="l00045"></a>00045 <span class="keyword">class </span>Security_context;
<a name="l00046"></a>00046 <span class="keyword">struct </span><a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>;
<a name="l00047"></a>00047 <span class="keyword">class </span><a class="code" href="classACL__internal__schema__access.html">ACL_internal_schema_access</a>;
<a name="l00048"></a>00048 <span class="keyword">class </span><a class="code" href="classACL__internal__table__access.html">ACL_internal_table_access</a>;
<a name="l00049"></a>00049 <span class="keyword">class </span><a class="code" href="classField.html">Field</a>;
<a name="l00050"></a>00050 <span class="keyword">class </span><a class="code" href="classField__temporal__with__date__and__time.html">Field_temporal_with_date_and_time</a>;
<a name="l00051"></a>00051 <span class="keyword">class </span><a class="code" href="classTable__cache__element.html">Table_cache_element</a>;
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="comment">/*</span>
<a name="l00054"></a>00054 <span class="comment">  Used to identify NESTED_JOIN structures within a join (applicable to</span>
<a name="l00055"></a>00055 <span class="comment">  structures representing outer joins that have not been simplified away).</span>
<a name="l00056"></a>00056 <span class="comment">*/</span>
<a name="l00057"></a>00057 <span class="keyword">typedef</span> ulonglong nested_join_map;
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="preprocessor">#define tmp_file_prefix &quot;#sql&quot;                  </span>
<a name="l00061"></a>00061 <span class="preprocessor">#define tmp_file_prefix_length 4</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define TMP_TABLE_KEY_EXTRA 8</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00079"></a>00079 <span class="keyword">enum</span> enum_table_ref_type
<a name="l00080"></a>00080 {
<a name="l00082"></a>00082   TABLE_REF_NULL= 0,
<a name="l00083"></a>00083   TABLE_REF_VIEW,
<a name="l00084"></a>00084   TABLE_REF_BASE_TABLE,
<a name="l00085"></a>00085   TABLE_REF_I_S_TABLE,
<a name="l00086"></a>00086   TABLE_REF_TMP_TABLE
<a name="l00087"></a>00087 };
<a name="l00088"></a>00088 
<a name="l00093"></a>00093 <span class="keyword">enum</span> enum_ident_name_check
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095   IDENT_NAME_OK,
<a name="l00096"></a>00096   IDENT_NAME_WRONG,
<a name="l00097"></a>00097   IDENT_NAME_TOO_LONG
<a name="l00098"></a>00098 };
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">/*************************************************************************/</span>
<a name="l00101"></a>00101 
<a name="l00109"></a><a class="code" href="classObject__creation__ctx.html">00109</a> <span class="keyword">class </span><a class="code" href="classObject__creation__ctx.html">Object_creation_ctx</a>
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111 <span class="keyword">public</span>:
<a name="l00112"></a>00112   <a class="code" href="classObject__creation__ctx.html">Object_creation_ctx</a> *set_n_backup(THD *thd);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114   <span class="keywordtype">void</span> restore_env(THD *thd, <a class="code" href="classObject__creation__ctx.html">Object_creation_ctx</a> *backup_ctx);
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="keyword">protected</span>:
<a name="l00117"></a>00117   <a class="code" href="classObject__creation__ctx.html">Object_creation_ctx</a>() {}
<a name="l00118"></a>00118   <span class="keyword">virtual</span> <a class="code" href="classObject__creation__ctx.html">Object_creation_ctx</a> *create_backup_ctx(THD *thd) <span class="keyword">const</span> = 0;
<a name="l00119"></a>00119 
<a name="l00120"></a>00120   <span class="keyword">virtual</span> <span class="keywordtype">void</span> change_env(THD *thd) <span class="keyword">const</span> = 0;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="keyword">public</span>:
<a name="l00123"></a>00123   <span class="keyword">virtual</span> ~<a class="code" href="classObject__creation__ctx.html">Object_creation_ctx</a>()
<a name="l00124"></a>00124   { }
<a name="l00125"></a>00125 };
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="comment">/*************************************************************************/</span>
<a name="l00128"></a>00128 
<a name="l00134"></a><a class="code" href="classDefault__object__creation__ctx.html">00134</a> <span class="keyword">class </span><a class="code" href="classDefault__object__creation__ctx.html">Default_object_creation_ctx</a> : <span class="keyword">public</span> <a class="code" href="classObject__creation__ctx.html">Object_creation_ctx</a>
<a name="l00135"></a>00135 {
<a name="l00136"></a>00136 <span class="keyword">public</span>:
<a name="l00137"></a>00137   <span class="keyword">const</span> CHARSET_INFO *get_client_cs()
<a name="l00138"></a>00138   {
<a name="l00139"></a>00139     <span class="keywordflow">return</span> <a class="code" href="classDefault__object__creation__ctx.html#af69e5434f52f8465d05a7831429137b5">m_client_cs</a>;
<a name="l00140"></a>00140   }
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="keyword">const</span> CHARSET_INFO *get_connection_cl()
<a name="l00143"></a>00143   {
<a name="l00144"></a>00144     <span class="keywordflow">return</span> <a class="code" href="classDefault__object__creation__ctx.html#ac3d2574166b4be26f3a6f967e4a6ac18">m_connection_cl</a>;
<a name="l00145"></a>00145   }
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="keyword">protected</span>:
<a name="l00148"></a>00148   <a class="code" href="classDefault__object__creation__ctx.html">Default_object_creation_ctx</a>(THD *thd);
<a name="l00149"></a>00149 
<a name="l00150"></a>00150   <a class="code" href="classDefault__object__creation__ctx.html">Default_object_creation_ctx</a>(<span class="keyword">const</span> CHARSET_INFO *client_cs,
<a name="l00151"></a>00151                               <span class="keyword">const</span> CHARSET_INFO *connection_cl);
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="keyword">protected</span>:
<a name="l00154"></a>00154   <span class="keyword">virtual</span> <a class="code" href="classObject__creation__ctx.html">Object_creation_ctx</a> *create_backup_ctx(THD *thd) <span class="keyword">const</span>;
<a name="l00155"></a>00155 
<a name="l00156"></a>00156   <span class="keyword">virtual</span> <span class="keywordtype">void</span> change_env(THD *thd) <span class="keyword">const</span>;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="keyword">protected</span>:
<a name="l00168"></a><a class="code" href="classDefault__object__creation__ctx.html#af69e5434f52f8465d05a7831429137b5">00168</a>   <span class="keyword">const</span> CHARSET_INFO *<a class="code" href="classDefault__object__creation__ctx.html#af69e5434f52f8465d05a7831429137b5">m_client_cs</a>;
<a name="l00169"></a>00169 
<a name="l00178"></a><a class="code" href="classDefault__object__creation__ctx.html#ac3d2574166b4be26f3a6f967e4a6ac18">00178</a>   <span class="keyword">const</span> CHARSET_INFO *<a class="code" href="classDefault__object__creation__ctx.html#ac3d2574166b4be26f3a6f967e4a6ac18">m_connection_cl</a>;
<a name="l00179"></a>00179 };
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 
<a name="l00186"></a><a class="code" href="classView__creation__ctx.html">00186</a> <span class="keyword">class </span><a class="code" href="classView__creation__ctx.html">View_creation_ctx</a> : <span class="keyword">public</span> <a class="code" href="classDefault__object__creation__ctx.html">Default_object_creation_ctx</a>,
<a name="l00187"></a>00187                           <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l00188"></a>00188 {
<a name="l00189"></a>00189 <span class="keyword">public</span>:
<a name="l00190"></a>00190   <span class="keyword">static</span> <a class="code" href="classView__creation__ctx.html">View_creation_ctx</a> *create(THD *thd);
<a name="l00191"></a>00191 
<a name="l00192"></a>00192   <span class="keyword">static</span> <a class="code" href="classView__creation__ctx.html">View_creation_ctx</a> *create(THD *thd,
<a name="l00193"></a>00193                                    <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *view);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 <span class="keyword">private</span>:
<a name="l00196"></a>00196   <a class="code" href="classView__creation__ctx.html">View_creation_ctx</a>(THD *thd)
<a name="l00197"></a>00197     : <a class="code" href="classDefault__object__creation__ctx.html">Default_object_creation_ctx</a>(thd)
<a name="l00198"></a>00198   { }
<a name="l00199"></a>00199 };
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="comment">/*************************************************************************/</span>
<a name="l00202"></a>00202 
<a name="l00205"></a><a class="code" href="structst__order.html">00205</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__order.html">st_order</a> {
<a name="l00206"></a>00206   <span class="keyword">struct </span><a class="code" href="structst__order.html">st_order</a> *next;
<a name="l00207"></a>00207   <a class="code" href="classItem.html">Item</a>   **item;                        <span class="comment">/* Point at item in select fields */</span>
<a name="l00208"></a>00208   <a class="code" href="classItem.html">Item</a>   *item_ptr;                     <span class="comment">/* Storage for initial item */</span>
<a name="l00209"></a>00209   <span class="keywordtype">int</span>    counter;                       <span class="comment">/* position in SELECT list, correct</span>
<a name="l00210"></a>00210 <span class="comment">                                           only if counter_used is true */</span>
<a name="l00211"></a>00211   <span class="keyword">enum</span> enum_order {
<a name="l00212"></a>00212     ORDER_NOT_RELEVANT,
<a name="l00213"></a>00213     ORDER_ASC,
<a name="l00214"></a>00214     ORDER_DESC
<a name="l00215"></a>00215   };
<a name="l00216"></a>00216 
<a name="l00217"></a>00217   enum_order direction;                 <span class="comment">/* Requested direction of ordering */</span>
<a name="l00218"></a>00218   <span class="keywordtype">bool</span>   in_field_list;                 <span class="comment">/* true if in select field list */</span>
<a name="l00219"></a>00219   <span class="keywordtype">bool</span>   counter_used;                  <span class="comment">/* parameter was counter of columns */</span>
<a name="l00226"></a><a class="code" href="structst__order.html#a450b9735d629184c9f33b86d7a42749c">00226</a>   <span class="keywordtype">bool</span>   <a class="code" href="structst__order.html#a450b9735d629184c9f33b86d7a42749c">used_alias</a>;
<a name="l00227"></a>00227   <a class="code" href="classField.html">Field</a>  *field;                        <span class="comment">/* If tmp-table group */</span>
<a name="l00228"></a>00228   <span class="keywordtype">char</span>   *buff;                         <span class="comment">/* If tmp-table group */</span>
<a name="l00229"></a>00229   table_map used, depend_map;
<a name="l00230"></a>00230 } <a class="code" href="structst__order.html">ORDER</a>;
<a name="l00231"></a>00231 
<a name="l00238"></a><a class="code" href="structst__grant__internal__info.html">00238</a> <span class="keyword">struct </span><a class="code" href="structst__grant__internal__info.html">st_grant_internal_info</a>
<a name="l00239"></a>00239 {
<a name="l00241"></a><a class="code" href="structst__grant__internal__info.html#aa4d19ba7b520900124141b8791164d10">00241</a>   <span class="keywordtype">bool</span> <a class="code" href="structst__grant__internal__info.html#aa4d19ba7b520900124141b8791164d10">m_schema_lookup_done</a>;
<a name="l00243"></a><a class="code" href="structst__grant__internal__info.html#aec9e5211996315052a77537b1ef9fb1a">00243</a>   <span class="keyword">const</span> <a class="code" href="classACL__internal__schema__access.html">ACL_internal_schema_access</a> *<a class="code" href="structst__grant__internal__info.html#aec9e5211996315052a77537b1ef9fb1a">m_schema_access</a>;
<a name="l00245"></a><a class="code" href="structst__grant__internal__info.html#a7090d20ebfb36c89ab1ebb1ecb44ee6e">00245</a>   <span class="keywordtype">bool</span> <a class="code" href="structst__grant__internal__info.html#a7090d20ebfb36c89ab1ebb1ecb44ee6e">m_table_lookup_done</a>;
<a name="l00247"></a><a class="code" href="structst__grant__internal__info.html#abd72783bc9bc5ac6ab3e7871d5ef4c19">00247</a>   <span class="keyword">const</span> <a class="code" href="classACL__internal__table__access.html">ACL_internal_table_access</a> *<a class="code" href="structst__grant__internal__info.html#abd72783bc9bc5ac6ab3e7871d5ef4c19">m_table_access</a>;
<a name="l00248"></a>00248 };
<a name="l00249"></a>00249 <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__grant__internal__info.html">st_grant_internal_info</a> <a class="code" href="structst__grant__internal__info.html">GRANT_INTERNAL_INFO</a>;
<a name="l00250"></a>00250 
<a name="l00265"></a><a class="code" href="structst__grant__info.html">00265</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__grant__info.html" title="The current state of the privilege checking process for the current user, SQL statement and SQL objec...">st_grant_info</a>
<a name="l00266"></a>00266 {
<a name="l00273"></a><a class="code" href="structst__grant__info.html#ac849fe5641f44a14c59310ff096f6c19">00273</a>   <a class="code" href="classGRANT__TABLE.html">GRANT_TABLE</a> *<a class="code" href="structst__grant__info.html#ac849fe5641f44a14c59310ff096f6c19" title="A copy of the privilege information regarding the current host, database, object and user...">grant_table</a>;
<a name="l00289"></a><a class="code" href="structst__grant__info.html#ab300506d239ca14a0503cb42974a1e83">00289</a>   uint <a class="code" href="structst__grant__info.html#ab300506d239ca14a0503cb42974a1e83" title="Used for cache invalidation when caching privilege information.">version</a>;
<a name="l00301"></a><a class="code" href="structst__grant__info.html#ae315c408f02729c4b4eb341d7165df89">00301</a>   ulong <a class="code" href="structst__grant__info.html#ae315c408f02729c4b4eb341d7165df89" title="The set of privileges that the current user has fulfilled for a certain host, database, and object.">privilege</a>;
<a name="l00306"></a><a class="code" href="structst__grant__info.html#a670de39ab9af5bc2140796431cf4d404">00306</a>   ulong <a class="code" href="structst__grant__info.html#a670de39ab9af5bc2140796431cf4d404" title="the set of privileges that the current user needs to fulfil in order to carry out the requested opera...">want_privilege</a>;
<a name="l00311"></a><a class="code" href="structst__grant__info.html#a5129d7a4f4f070d00e18cba071be7fb5">00311</a>   ulong <a class="code" href="structst__grant__info.html#a5129d7a4f4f070d00e18cba071be7fb5">orig_want_privilege</a>;
<a name="l00313"></a><a class="code" href="structst__grant__info.html#a260710aca070d35a67109ae0324dfe19">00313</a>   <a class="code" href="structst__grant__internal__info.html">GRANT_INTERNAL_INFO</a> <a class="code" href="structst__grant__info.html#a260710aca070d35a67109ae0324dfe19">m_internal</a>;
<a name="l00314"></a>00314 } <a class="code" href="structst__grant__info.html" title="The current state of the privilege checking process for the current user, SQL statement and SQL objec...">GRANT_INFO</a>;
<a name="l00315"></a>00315 
<a name="l00316"></a>00316 <span class="keyword">enum</span> tmp_table_type
<a name="l00317"></a>00317 {
<a name="l00318"></a>00318   NO_TMP_TABLE, NON_TRANSACTIONAL_TMP_TABLE, TRANSACTIONAL_TMP_TABLE,
<a name="l00319"></a>00319   INTERNAL_TMP_TABLE, SYSTEM_TMP_TABLE
<a name="l00320"></a>00320 };
<a name="l00321"></a>00321 <span class="keyword">enum</span> release_type { RELEASE_NORMAL, RELEASE_WAIT_FOR_DROP };
<a name="l00322"></a>00322 
<a name="l00323"></a>00323 
<a name="l00324"></a><a class="code" href="classFilesort__info.html">00324</a> <span class="keyword">class </span><a class="code" href="classFilesort__info.html">Filesort_info</a>
<a name="l00325"></a>00325 {
<a name="l00327"></a>00327   <a class="code" href="classFilesort__buffer.html">Filesort_buffer</a> filesort_buffer;
<a name="l00328"></a>00328 
<a name="l00329"></a>00329 <span class="keyword">public</span>:
<a name="l00330"></a>00330   IO_CACHE *io_cache;           <span class="comment">/* If sorted through filesort */</span>
<a name="l00331"></a>00331   uchar     *buffpek;           <span class="comment">/* Buffer for buffpek structures */</span>
<a name="l00332"></a>00332   uint      buffpek_len;        <span class="comment">/* Max number of buffpeks in the buffer */</span>
<a name="l00333"></a>00333   uchar     *addon_buf;         <span class="comment">/* Pointer to a buffer if sorted with fields */</span>
<a name="l00334"></a>00334   <span class="keywordtype">size_t</span>    addon_length;       <span class="comment">/* Length of the buffer */</span>
<a name="l00335"></a>00335   <span class="keyword">struct </span><a class="code" href="structst__sort__addon__field.html">st_sort_addon_field</a> *addon_field;     <span class="comment">/* Pointer to the fields info */</span>
<a name="l00336"></a>00336   void    (*unpack)(<span class="keyword">struct </span><a class="code" href="structst__sort__addon__field.html">st_sort_addon_field</a> *, uchar *); <span class="comment">/* To unpack back */</span>
<a name="l00337"></a>00337   uchar     *record_pointers;    <span class="comment">/* If sorted in memory */</span>
<a name="l00338"></a>00338   ha_rows   found_records;      <span class="comment">/* How many records in sort */</span>
<a name="l00339"></a>00339 
<a name="l00340"></a>00340   <a class="code" href="classFilesort__info.html">Filesort_info</a>(): record_pointers(0) {};
<a name="l00342"></a><a class="code" href="classFilesort__info.html#a1112e3f4717a0cc05c50c94ef3b21c1a">00342</a>   <span class="keywordtype">void</span> <a class="code" href="classFilesort__info.html#a1112e3f4717a0cc05c50c94ef3b21c1a">sort_buffer</a>(<a class="code" href="classSort__param.html">Sort_param</a> *param, uint count)
<a name="l00343"></a>00343   { filesort_buffer.<a class="code" href="classFilesort__buffer.html#adb7d7a439a496d0ab703c193dced5e32">sort_buffer</a>(param, count); }
<a name="l00344"></a>00344 
<a name="l00348"></a><a class="code" href="classFilesort__info.html#a934745b4e74f464c2e934d6b6422ba7a">00348</a>   uchar *<a class="code" href="classFilesort__info.html#a934745b4e74f464c2e934d6b6422ba7a">get_record_buffer</a>(uint idx)
<a name="l00349"></a>00349   { <span class="keywordflow">return</span> filesort_buffer.<a class="code" href="classFilesort__buffer.html#afa2e6f53dadfc8a5b8b16647d91cbfaf" title="Initializes a record pointer.">get_record_buffer</a>(idx); }
<a name="l00350"></a>00350 
<a name="l00351"></a>00351   uchar **get_sort_keys()
<a name="l00352"></a>00352   { <span class="keywordflow">return</span> filesort_buffer.<a class="code" href="classFilesort__buffer.html#ab833d1ea135e1651b55087cbe923dbf5" title="Getter, for calling routines which still use the uchar** interface.">get_sort_keys</a>(); }
<a name="l00353"></a>00353 
<a name="l00354"></a>00354   uchar **alloc_sort_buffer(uint num_records, uint record_length)
<a name="l00355"></a>00355   { <span class="keywordflow">return</span> filesort_buffer.<a class="code" href="classFilesort__buffer.html#ab289855a7d9c62d79895ac7d17e7e2ea" title="Allocates the buffer, but does *not* initialize pointers.">alloc_sort_buffer</a>(num_records, record_length); }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357   <span class="keywordtype">void</span> free_sort_buffer()
<a name="l00358"></a>00358   { filesort_buffer.<a class="code" href="classFilesort__buffer.html#a967d857a913b61ef3957d094ac227eca" title="Frees the buffer.">free_sort_buffer</a>(); }
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="keywordtype">void</span> init_record_pointers()
<a name="l00361"></a>00361   { filesort_buffer.<a class="code" href="classFilesort__buffer.html#acde96dcd74d1e6594c7055196e316d35" title="Initializes all the record pointers.">init_record_pointers</a>(); }
<a name="l00362"></a>00362 
<a name="l00363"></a>00363   <span class="keywordtype">size_t</span> sort_buffer_size()<span class="keyword"> const</span>
<a name="l00364"></a>00364 <span class="keyword">  </span>{ <span class="keywordflow">return</span> filesort_buffer.<a class="code" href="classFilesort__buffer.html#ad6f1d5b77024c3a12756311ffaeeaf69" title="Returns total size: pointer array + record buffers.">sort_buffer_size</a>(); }
<a name="l00365"></a>00365 };
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 <span class="keyword">class </span><a class="code" href="classField__blob.html">Field_blob</a>;
<a name="l00368"></a>00368 <span class="keyword">class </span><a class="code" href="classTable__triggers__list.html">Table_triggers_list</a>;
<a name="l00369"></a>00369 
<a name="l00373"></a>00373 <span class="keyword">enum</span> enum_table_category
<a name="l00374"></a>00374 {
<a name="l00378"></a>00378   TABLE_UNKNOWN_CATEGORY=0,
<a name="l00379"></a>00379 
<a name="l00391"></a>00391   TABLE_CATEGORY_TEMPORARY=1,
<a name="l00392"></a>00392 
<a name="l00401"></a>00401   TABLE_CATEGORY_USER=2,
<a name="l00402"></a>00402 
<a name="l00413"></a>00413   TABLE_CATEGORY_SYSTEM=3,
<a name="l00414"></a>00414 
<a name="l00430"></a>00430   <span class="comment">/*</span>
<a name="l00431"></a>00431 <span class="comment">    TODO: Fixing the performance issues of I_S will lead</span>
<a name="l00432"></a>00432 <span class="comment">    to I_S tables in the table cache, which should use</span>
<a name="l00433"></a>00433 <span class="comment">    this table type.</span>
<a name="l00434"></a>00434 <span class="comment">  */</span>
<a name="l00435"></a>00435   TABLE_CATEGORY_INFORMATION=4,
<a name="l00436"></a>00436 
<a name="l00457"></a>00457   TABLE_CATEGORY_LOG=5,
<a name="l00458"></a>00458 
<a name="l00479"></a>00479   TABLE_CATEGORY_PERFORMANCE=6,
<a name="l00480"></a>00480 
<a name="l00498"></a>00498   TABLE_CATEGORY_RPL_INFO=7
<a name="l00499"></a>00499 };
<a name="l00500"></a>00500 <span class="keyword">typedef</span> <span class="keyword">enum</span> enum_table_category TABLE_CATEGORY;
<a name="l00501"></a>00501 
<a name="l00502"></a>00502 TABLE_CATEGORY get_table_category(<span class="keyword">const</span> LEX_STRING *db,
<a name="l00503"></a>00503                                   <span class="keyword">const</span> LEX_STRING *name);
<a name="l00504"></a>00504 
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="keyword">extern</span> ulong refresh_version;
<a name="l00507"></a>00507 
<a name="l00508"></a><a class="code" href="structst__table__field__type.html">00508</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__table__field__type.html">st_table_field_type</a>
<a name="l00509"></a>00509 {
<a name="l00510"></a>00510   LEX_STRING name;
<a name="l00511"></a>00511   LEX_STRING type;
<a name="l00512"></a>00512   LEX_STRING cset;
<a name="l00513"></a>00513 } <a class="code" href="structst__table__field__type.html">TABLE_FIELD_TYPE</a>;
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 
<a name="l00516"></a><a class="code" href="structst__table__field__def.html">00516</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__table__field__def.html">st_table_field_def</a>
<a name="l00517"></a>00517 {
<a name="l00518"></a>00518   uint count;
<a name="l00519"></a>00519   <span class="keyword">const</span> <a class="code" href="structst__table__field__type.html">TABLE_FIELD_TYPE</a> *field;
<a name="l00520"></a>00520 } <a class="code" href="structst__table__field__def.html">TABLE_FIELD_DEF</a>;
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 
<a name="l00523"></a><a class="code" href="classTable__check__intact.html">00523</a> <span class="keyword">class </span><a class="code" href="classTable__check__intact.html">Table_check_intact</a>
<a name="l00524"></a>00524 {
<a name="l00525"></a>00525 <span class="keyword">protected</span>:
<a name="l00526"></a>00526   <span class="keyword">virtual</span> <span class="keywordtype">void</span> report_error(uint code, <span class="keyword">const</span> <span class="keywordtype">char</span> *fmt, ...)= 0;
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="keyword">public</span>:
<a name="l00529"></a>00529   <a class="code" href="classTable__check__intact.html">Table_check_intact</a>() {}
<a name="l00530"></a>00530   <span class="keyword">virtual</span> ~<a class="code" href="classTable__check__intact.html">Table_check_intact</a>() {}
<a name="l00531"></a>00531 
<a name="l00533"></a>00533   <span class="keywordtype">bool</span> <a class="code" href="classTable__check__intact.html#a6ddfab1ea1b4e7bdfcefe9525d1c4b4c">check</a>(<a class="code" href="structTABLE.html">TABLE</a> *table, <span class="keyword">const</span> <a class="code" href="structst__table__field__def.html">TABLE_FIELD_DEF</a> *<a class="code" href="classtable__def.html">table_def</a>);
<a name="l00534"></a>00534 };
<a name="l00535"></a>00535 
<a name="l00536"></a>00536 
<a name="l00543"></a><a class="code" href="classWait__for__flush.html">00543</a> <span class="keyword">class </span><a class="code" href="classWait__for__flush.html">Wait_for_flush</a> : <span class="keyword">public</span> <a class="code" href="classMDL__wait__for__subgraph.html">MDL_wait_for_subgraph</a>
<a name="l00544"></a>00544 {
<a name="l00545"></a>00545   <a class="code" href="classMDL__context.html">MDL_context</a> *m_ctx;
<a name="l00546"></a>00546   <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *m_share;
<a name="l00547"></a>00547   uint m_deadlock_weight;
<a name="l00548"></a>00548 <span class="keyword">public</span>:
<a name="l00549"></a>00549   <a class="code" href="classWait__for__flush.html">Wait_for_flush</a>(<a class="code" href="classMDL__context.html">MDL_context</a> *ctx_arg, <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share_arg,
<a name="l00550"></a>00550                uint deadlock_weight_arg)
<a name="l00551"></a>00551     : m_ctx(ctx_arg), m_share(share_arg),
<a name="l00552"></a>00552       m_deadlock_weight(deadlock_weight_arg)
<a name="l00553"></a>00553   {}
<a name="l00554"></a>00554 
<a name="l00555"></a>00555   <a class="code" href="classMDL__context.html">MDL_context</a> *get_ctx()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_ctx; }
<a name="l00556"></a>00556 
<a name="l00557"></a>00557   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classWait__for__flush.html#a5d355af9c8dd888cf46b6c5c24552900">accept_visitor</a>(<a class="code" href="classMDL__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *dvisitor);
<a name="l00558"></a>00558 
<a name="l00559"></a>00559   <span class="keyword">virtual</span> uint get_deadlock_weight() <span class="keyword">const</span>;
<a name="l00560"></a>00560 
<a name="l00564"></a><a class="code" href="classWait__for__flush.html#a4c6991330bc28f7cdbc2a924dfef3a38">00564</a>   <a class="code" href="classWait__for__flush.html">Wait_for_flush</a> *<a class="code" href="classWait__for__flush.html#a4c6991330bc28f7cdbc2a924dfef3a38">next_in_share</a>;
<a name="l00565"></a>00565   <a class="code" href="classWait__for__flush.html">Wait_for_flush</a> **prev_in_share;
<a name="l00566"></a>00566 };
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 <span class="keyword">typedef</span> <a class="code" href="classI__P__List.html">I_P_List</a> &lt;<a class="code" href="classWait__for__flush.html">Wait_for_flush</a>,
<a name="l00570"></a>00570                   <a class="code" href="structI__P__List__adapter.html">I_P_List_adapter</a>&lt;Wait_for_flush,
<a name="l00571"></a>00571                                    &amp;<a class="code" href="classWait__for__flush.html#a4c6991330bc28f7cdbc2a924dfef3a38">Wait_for_flush::next_in_share</a>,
<a name="l00572"></a>00572                                    &amp;Wait_for_flush::prev_in_share&gt; &gt;
<a name="l00573"></a>00573                  <a class="code" href="classI__P__List.html">Wait_for_flush_list</a>;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 
<a name="l00581"></a><a class="code" href="structTABLE__SHARE.html">00581</a> <span class="keyword">struct </span><a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a>
<a name="l00582"></a>00582 {
<a name="l00583"></a>00583   <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a>() {}                    <span class="comment">/* Remove gcc warning */</span>
<a name="l00584"></a>00584 
<a name="l00586"></a><a class="code" href="structTABLE__SHARE.html#aaf3e5f8c4f8f32d7e7b3451800e03243">00586</a>   TABLE_CATEGORY <a class="code" href="structTABLE__SHARE.html#aaf3e5f8c4f8f32d7e7b3451800e03243">table_category</a>;
<a name="l00587"></a>00587 
<a name="l00588"></a>00588   <span class="comment">/* hash of field names (contains pointers to elements of field array) */</span>
<a name="l00589"></a>00589   HASH  name_hash;                      <span class="comment">/* hash of field names */</span>
<a name="l00590"></a>00590   MEM_ROOT mem_root;
<a name="l00591"></a>00591   TYPELIB keynames;                     <span class="comment">/* Pointers to keynames */</span>
<a name="l00592"></a>00592   TYPELIB fieldnames;                   <span class="comment">/* Pointer to fieldnames */</span>
<a name="l00593"></a>00593   TYPELIB *intervals;                   <span class="comment">/* pointer to interval info */</span>
<a name="l00594"></a>00594   mysql_mutex_t LOCK_ha_data;           <span class="comment">/* To protect access to ha_data */</span>
<a name="l00595"></a>00595   <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *next, **prev;            <span class="comment">/* Link to unused shares */</span>
<a name="l00604"></a><a class="code" href="structTABLE__SHARE.html#a0b2d66b9a33c0007107a15690955b44f">00604</a>   <a class="code" href="classTable__cache__element.html">Table_cache_element</a> **<a class="code" href="structTABLE__SHARE.html#a0b2d66b9a33c0007107a15690955b44f">cache_element</a>;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606   <span class="comment">/* The following is copied to each TABLE on OPEN */</span>
<a name="l00607"></a>00607   <a class="code" href="classField.html">Field</a> **field;
<a name="l00608"></a>00608   <a class="code" href="classField.html">Field</a> **found_next_number_field;
<a name="l00609"></a>00609   <a class="code" href="structst__key.html">KEY</a>  *key_info;                       <span class="comment">/* data of keys defined for the table */</span>
<a name="l00610"></a>00610   uint  *blob_field;                    <span class="comment">/* Index to blobs in Field arrray*/</span>
<a name="l00611"></a>00611 
<a name="l00612"></a>00612   uchar *default_values;                <span class="comment">/* row with default values */</span>
<a name="l00613"></a>00613   LEX_STRING comment;                   <span class="comment">/* Comment about table */</span>
<a name="l00614"></a>00614   <span class="keyword">const</span> CHARSET_INFO *table_charset;    <span class="comment">/* Default charset of string fields */</span>
<a name="l00615"></a>00615 
<a name="l00616"></a>00616   MY_BITMAP all_set;
<a name="l00617"></a>00617   <span class="comment">/*</span>
<a name="l00618"></a>00618 <span class="comment">    Key which is used for looking-up table in table cache and in the list</span>
<a name="l00619"></a>00619 <span class="comment">    of thread&#39;s temporary tables. Has the form of:</span>
<a name="l00620"></a>00620 <span class="comment">      &quot;database_name\0table_name\0&quot; + optional part for temporary tables.</span>
<a name="l00621"></a>00621 <span class="comment"></span>
<a name="l00622"></a>00622 <span class="comment">    Note that all three &#39;table_cache_key&#39;, &#39;db&#39; and &#39;table_name&#39; members</span>
<a name="l00623"></a>00623 <span class="comment">    must be set (and be non-zero) for tables in table cache. They also</span>
<a name="l00624"></a>00624 <span class="comment">    should correspond to each other.</span>
<a name="l00625"></a>00625 <span class="comment">    To ensure this one can use set_table_cache() methods.</span>
<a name="l00626"></a>00626 <span class="comment">  */</span>
<a name="l00627"></a>00627   LEX_STRING table_cache_key;
<a name="l00628"></a>00628   LEX_STRING db;                        <span class="comment">/* Pointer to db */</span>
<a name="l00629"></a>00629   LEX_STRING table_name;                <span class="comment">/* Table name (for open) */</span>
<a name="l00630"></a>00630   LEX_STRING path;                      <span class="comment">/* Path to .frm file (from datadir) */</span>
<a name="l00631"></a>00631   LEX_STRING normalized_path;           <span class="comment">/* unpack_filename(path) */</span>
<a name="l00632"></a>00632   LEX_STRING connect_string;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634   <span class="comment">/* </span>
<a name="l00635"></a>00635 <span class="comment">     Set of keys in use, implemented as a Bitmap.</span>
<a name="l00636"></a>00636 <span class="comment">     Excludes keys disabled by ALTER TABLE ... DISABLE KEYS.</span>
<a name="l00637"></a>00637 <span class="comment">  */</span>
<a name="l00638"></a>00638   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> keys_in_use;
<a name="l00639"></a>00639   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> keys_for_keyread;
<a name="l00640"></a>00640   ha_rows min_rows, max_rows;           <span class="comment">/* create information */</span>
<a name="l00641"></a>00641   ulong   avg_row_length;               <span class="comment">/* create information */</span>
<a name="l00647"></a><a class="code" href="structTABLE__SHARE.html#ae04c033776f1dc39863ebf60b842c505">00647</a>   ulong   <a class="code" href="structTABLE__SHARE.html#ae04c033776f1dc39863ebf60b842c505">version</a>;
<a name="l00648"></a>00648   ulong   mysql_version;                <span class="comment">/* 0 if .frm is created before 5.0 */</span>
<a name="l00649"></a>00649   ulong   reclength;                    <span class="comment">/* Recordlength */</span>
<a name="l00650"></a>00650 
<a name="l00651"></a>00651   <a class="code" href="structst__plugin__int.html">plugin_ref</a> db_plugin;                 <span class="comment">/* storage engine plugin */</span>
<a name="l00652"></a>00652   <span class="keyword">inline</span> <a class="code" href="structhandlerton.html">handlerton</a> *db_type() const    <span class="comment">/* table_type for handler */</span>
<a name="l00653"></a>00653   { 
<a name="l00654"></a>00654     <span class="comment">// DBUG_ASSERT(db_plugin);</span>
<a name="l00655"></a>00655     <span class="keywordflow">return</span> db_plugin ? plugin_data(db_plugin, <a class="code" href="structhandlerton.html">handlerton</a>*) : NULL;
<a name="l00656"></a>00656   }
<a name="l00657"></a>00657   <span class="keyword">enum</span> row_type row_type;               <span class="comment">/* How rows are stored */</span>
<a name="l00658"></a>00658   <span class="keyword">enum</span> tmp_table_type tmp_table;
<a name="l00659"></a>00659 
<a name="l00660"></a>00660   uint ref_count;                       <span class="comment">/* How many TABLE objects uses this */</span>
<a name="l00661"></a>00661   uint key_block_size;                  <span class="comment">/* create key_block_size, if used */</span>
<a name="l00662"></a>00662   uint stats_sample_pages;              <span class="comment">/* number of pages to sample during</span>
<a name="l00663"></a>00663 <span class="comment">                                        stats estimation, if used, otherwise 0. */</span>
<a name="l00664"></a>00664   enum_stats_auto_recalc stats_auto_recalc; <span class="comment">/* Automatic recalc of stats. */</span>
<a name="l00665"></a>00665   uint null_bytes, last_null_bit_pos;
<a name="l00666"></a>00666   uint fields;                          <span class="comment">/* Number of fields */</span>
<a name="l00667"></a>00667   uint rec_buff_length;                 <span class="comment">/* Size of table-&gt;record[] buffer */</span>
<a name="l00668"></a>00668   uint keys;                            <span class="comment">/* Number of keys defined for the table*/</span>
<a name="l00669"></a>00669   uint key_parts;                       <span class="comment">/* Number of key parts of all keys</span>
<a name="l00670"></a>00670 <span class="comment">                                           defined for the table</span>
<a name="l00671"></a>00671 <span class="comment">                                        */</span>
<a name="l00672"></a>00672   uint max_key_length;                  <span class="comment">/* Length of the longest key */</span>
<a name="l00673"></a>00673   uint max_unique_length;               <span class="comment">/* Length of the longest unique key */</span>
<a name="l00674"></a>00674   uint total_key_length;
<a name="l00675"></a>00675   uint uniques;                         <span class="comment">/* Number of UNIQUE index */</span>
<a name="l00676"></a>00676   uint null_fields;                     <span class="comment">/* number of null fields */</span>
<a name="l00677"></a>00677   uint blob_fields;                     <span class="comment">/* number of blob fields */</span>
<a name="l00678"></a>00678   uint varchar_fields;                  <span class="comment">/* number of varchar fields */</span>
<a name="l00679"></a>00679   uint db_create_options;               <span class="comment">/* Create options from database */</span>
<a name="l00680"></a>00680   uint db_options_in_use;               <span class="comment">/* Options in use */</span>
<a name="l00681"></a>00681   uint db_record_offset;                <span class="comment">/* if HA_REC_IN_SEQ */</span>
<a name="l00682"></a>00682   uint rowid_field_offset;              <span class="comment">/* Field_nr +1 to rowid field */</span>
<a name="l00683"></a>00683   <span class="comment">/* Primary key index number, used in TABLE::key_info[] */</span>
<a name="l00684"></a>00684   uint primary_key;                     
<a name="l00685"></a>00685   uint next_number_index;               <span class="comment">/* autoincrement key number */</span>
<a name="l00686"></a>00686   uint next_number_key_offset;          <span class="comment">/* autoinc keypart offset in a key */</span>
<a name="l00687"></a>00687   uint next_number_keypart;             <span class="comment">/* autoinc keypart number in a key */</span>
<a name="l00688"></a>00688   uint error, open_errno, errarg;       <span class="comment">/* error from open_table_def() */</span>
<a name="l00689"></a>00689   uint column_bitmap_size;
<a name="l00690"></a>00690   uchar frm_version;
<a name="l00691"></a>00691   <span class="keywordtype">bool</span> null_field_first;
<a name="l00692"></a>00692   <span class="keywordtype">bool</span> system;                          <span class="comment">/* Set if system table (one record) */</span>
<a name="l00693"></a>00693   <span class="keywordtype">bool</span> crypted;                         <span class="comment">/* If .frm file is crypted */</span>
<a name="l00694"></a>00694   <span class="keywordtype">bool</span> db_low_byte_first;               <span class="comment">/* Portable row format */</span>
<a name="l00695"></a>00695   <span class="keywordtype">bool</span> crashed;
<a name="l00696"></a>00696   <span class="keywordtype">bool</span> is_view;
<a name="l00697"></a>00697   <a class="code" href="classTable__id.html">Table_id</a> table_map_id;                   <span class="comment">/* for row-based replication */</span>
<a name="l00698"></a>00698 
<a name="l00699"></a>00699   <span class="comment">/*</span>
<a name="l00700"></a>00700 <span class="comment">    Cache for row-based replication table share checks that does not</span>
<a name="l00701"></a>00701 <span class="comment">    need to be repeated. Possible values are: -1 when cache value is</span>
<a name="l00702"></a>00702 <span class="comment">    not calculated yet, 0 when table *shall not* be replicated, 1 when</span>
<a name="l00703"></a>00703 <span class="comment">    table *may* be replicated.</span>
<a name="l00704"></a>00704 <span class="comment">  */</span>
<a name="l00705"></a>00705   <span class="keywordtype">int</span> cached_row_logging_check;
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="comment">/*</span>
<a name="l00708"></a>00708 <span class="comment">    Storage media to use for this table (unless another storage</span>
<a name="l00709"></a>00709 <span class="comment">    media has been specified on an individual column - in versions</span>
<a name="l00710"></a>00710 <span class="comment">    where that is supported)</span>
<a name="l00711"></a>00711 <span class="comment">  */</span>
<a name="l00712"></a>00712   <span class="keyword">enum</span> ha_storage_media default_storage_media;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="comment">/* Name of the tablespace used for this table */</span>
<a name="l00715"></a>00715   <span class="keywordtype">char</span> *tablespace;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717 <span class="preprocessor">#ifdef WITH_PARTITION_STORAGE_ENGINE</span>
<a name="l00718"></a>00718 <span class="preprocessor"></span>  <span class="comment">/* filled in when reading from frm */</span>
<a name="l00719"></a>00719   <span class="keywordtype">bool</span> auto_partitioned;
<a name="l00720"></a>00720   <span class="keywordtype">char</span> *partition_info_str;
<a name="l00721"></a>00721   uint  partition_info_str_len;
<a name="l00722"></a>00722   uint  partition_info_buffer_size;
<a name="l00723"></a>00723   <a class="code" href="structhandlerton.html">handlerton</a> *default_part_db_type;
<a name="l00724"></a>00724 <span class="preprocessor">#endif</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span>
<a name="l00736"></a><a class="code" href="structTABLE__SHARE.html#a2eae47fa6d1ab98ea2af1b1073170274">00736</a>   <span class="keyword">const</span> <a class="code" href="structst__table__field__def.html">TABLE_FIELD_DEF</a> *<a class="code" href="structTABLE__SHARE.html#a2eae47fa6d1ab98ea2af1b1073170274">table_field_def_cache</a>;
<a name="l00737"></a>00737 
<a name="l00739"></a><a class="code" href="structTABLE__SHARE.html#a20f65b925c665708bd19df8190115c66">00739</a>   <a class="code" href="classHandler__share.html">Handler_share</a> *<a class="code" href="structTABLE__SHARE.html#a20f65b925c665708bd19df8190115c66">ha_share</a>;
<a name="l00740"></a>00740 
<a name="l00742"></a><a class="code" href="structTABLE__SHARE.html#a40d5321098268634196a67766c666d93">00742</a>   PSI_table_share *<a class="code" href="structTABLE__SHARE.html#a40d5321098268634196a67766c666d93">m_psi</a>;
<a name="l00743"></a>00743 
<a name="l00747"></a><a class="code" href="structTABLE__SHARE.html#aa9f03d5defc37e2c2c919f59d77988a0">00747</a>   Wait_for_flush_list <a class="code" href="structTABLE__SHARE.html#aa9f03d5defc37e2c2c919f59d77988a0">m_flush_tickets</a>;
<a name="l00748"></a>00748 
<a name="l00753"></a><a class="code" href="structTABLE__SHARE.html#a6d49595d1beeea24f9e653efaa0d41a2">00753</a>   <span class="keyword">const</span> <a class="code" href="classFile__parser.html">File_parser</a> *<a class="code" href="structTABLE__SHARE.html#a6d49595d1beeea24f9e653efaa0d41a2">view_def</a>;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 
<a name="l00756"></a>00756   <span class="comment">/*</span>
<a name="l00757"></a>00757 <span class="comment">    Set share&#39;s table cache key and update its db and table name appropriately.</span>
<a name="l00758"></a>00758 <span class="comment"></span>
<a name="l00759"></a>00759 <span class="comment">    SYNOPSIS</span>
<a name="l00760"></a>00760 <span class="comment">      set_table_cache_key()</span>
<a name="l00761"></a>00761 <span class="comment">        key_buff    Buffer with already built table cache key to be</span>
<a name="l00762"></a>00762 <span class="comment">                    referenced from share.</span>
<a name="l00763"></a>00763 <span class="comment">        key_length  Key length.</span>
<a name="l00764"></a>00764 <span class="comment"></span>
<a name="l00765"></a>00765 <span class="comment">    NOTES</span>
<a name="l00766"></a>00766 <span class="comment">      Since &#39;key_buff&#39; buffer will be referenced from share it should has same</span>
<a name="l00767"></a>00767 <span class="comment">      life-time as share itself.</span>
<a name="l00768"></a>00768 <span class="comment">      This method automatically ensures that TABLE_SHARE::table_name/db have</span>
<a name="l00769"></a>00769 <span class="comment">      appropriate values by using table cache key as their source.</span>
<a name="l00770"></a>00770 <span class="comment">  */</span>
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   <span class="keywordtype">void</span> set_table_cache_key(<span class="keywordtype">char</span> *key_buff, uint key_length)
<a name="l00773"></a>00773   {
<a name="l00774"></a>00774     table_cache_key.str= key_buff;
<a name="l00775"></a>00775     table_cache_key.length= key_length;
<a name="l00776"></a>00776     <span class="comment">/*</span>
<a name="l00777"></a>00777 <span class="comment">      Let us use the fact that the key is &quot;db/0/table_name/0&quot; + optional</span>
<a name="l00778"></a>00778 <span class="comment">      part for temporary tables.</span>
<a name="l00779"></a>00779 <span class="comment">    */</span>
<a name="l00780"></a>00780     db.str=            table_cache_key.str;
<a name="l00781"></a>00781     db.length=         strlen(db.str);
<a name="l00782"></a>00782     table_name.str=    db.str + db.length + 1;
<a name="l00783"></a>00783     table_name.length= strlen(table_name.str);
<a name="l00784"></a>00784   }
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   <span class="comment">/*</span>
<a name="l00788"></a>00788 <span class="comment">    Set share&#39;s table cache key and update its db and table name appropriately.</span>
<a name="l00789"></a>00789 <span class="comment"></span>
<a name="l00790"></a>00790 <span class="comment">    SYNOPSIS</span>
<a name="l00791"></a>00791 <span class="comment">      set_table_cache_key()</span>
<a name="l00792"></a>00792 <span class="comment">        key_buff    Buffer to be used as storage for table cache key</span>
<a name="l00793"></a>00793 <span class="comment">                    (should be at least key_length bytes).</span>
<a name="l00794"></a>00794 <span class="comment">        key         Value for table cache key.</span>
<a name="l00795"></a>00795 <span class="comment">        key_length  Key length.</span>
<a name="l00796"></a>00796 <span class="comment"></span>
<a name="l00797"></a>00797 <span class="comment">    NOTE</span>
<a name="l00798"></a>00798 <span class="comment">      Since &#39;key_buff&#39; buffer will be used as storage for table cache key</span>
<a name="l00799"></a>00799 <span class="comment">      it should has same life-time as share itself.</span>
<a name="l00800"></a>00800 <span class="comment">  */</span>
<a name="l00801"></a>00801 
<a name="l00802"></a>00802   <span class="keywordtype">void</span> set_table_cache_key(<span class="keywordtype">char</span> *key_buff, <span class="keyword">const</span> <span class="keywordtype">char</span> *key, uint key_length)
<a name="l00803"></a>00803   {
<a name="l00804"></a>00804     memcpy(key_buff, key, key_length);
<a name="l00805"></a>00805     set_table_cache_key(key_buff, key_length);
<a name="l00806"></a>00806   }
<a name="l00807"></a>00807 
<a name="l00808"></a>00808   <span class="keyword">inline</span> <span class="keywordtype">bool</span> honor_global_locks()
<a name="l00809"></a>00809   {
<a name="l00810"></a>00810     <span class="keywordflow">return</span> ((<a class="code" href="structTABLE__SHARE.html#aaf3e5f8c4f8f32d7e7b3451800e03243">table_category</a> == TABLE_CATEGORY_USER)
<a name="l00811"></a>00811             || (<a class="code" href="structTABLE__SHARE.html#aaf3e5f8c4f8f32d7e7b3451800e03243">table_category</a> == TABLE_CATEGORY_SYSTEM));
<a name="l00812"></a>00812   }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814   <span class="keyword">inline</span> ulonglong get_table_def_version()
<a name="l00815"></a>00815   {
<a name="l00816"></a>00816     <span class="keywordflow">return</span> table_map_id;
<a name="l00817"></a>00817   }
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 
<a name="l00821"></a><a class="code" href="structTABLE__SHARE.html#aa75fa8382c790c005dc52e2d8d4e3a3f">00821</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="structTABLE__SHARE.html#aa75fa8382c790c005dc52e2d8d4e3a3f">has_old_version</a>()<span class="keyword"> const</span>
<a name="l00822"></a>00822 <span class="keyword">  </span>{
<a name="l00823"></a>00823     <span class="keywordflow">return</span> <a class="code" href="structTABLE__SHARE.html#ae04c033776f1dc39863ebf60b842c505">version</a> != refresh_version;
<a name="l00824"></a>00824   }
<a name="l00831"></a><a class="code" href="structTABLE__SHARE.html#ac58358f786a71e0ede5213ee8ea571fd">00831</a>   <span class="keyword">enum</span> enum_table_ref_type <a class="code" href="structTABLE__SHARE.html#ac58358f786a71e0ede5213ee8ea571fd">get_table_ref_type</a>()<span class="keyword"> const</span>
<a name="l00832"></a>00832 <span class="keyword">  </span>{
<a name="l00833"></a>00833     <span class="keywordflow">if</span> (is_view)
<a name="l00834"></a>00834       <span class="keywordflow">return</span> TABLE_REF_VIEW;
<a name="l00835"></a>00835     <span class="keywordflow">switch</span> (tmp_table) {
<a name="l00836"></a>00836     <span class="keywordflow">case</span> NO_TMP_TABLE:
<a name="l00837"></a>00837       <span class="keywordflow">return</span> TABLE_REF_BASE_TABLE;
<a name="l00838"></a>00838     <span class="keywordflow">case</span> SYSTEM_TMP_TABLE:
<a name="l00839"></a>00839       <span class="keywordflow">return</span> TABLE_REF_I_S_TABLE;
<a name="l00840"></a>00840     <span class="keywordflow">default</span>:
<a name="l00841"></a>00841       <span class="keywordflow">return</span> TABLE_REF_TMP_TABLE;
<a name="l00842"></a>00842     }
<a name="l00843"></a>00843   }
<a name="l00899"></a><a class="code" href="structTABLE__SHARE.html#aa4eff60aaa18dab133cd8cf3ca672b25">00899</a>   ulonglong <a class="code" href="structTABLE__SHARE.html#aa4eff60aaa18dab133cd8cf3ca672b25">get_table_ref_version</a>()<span class="keyword"> const</span>
<a name="l00900"></a>00900 <span class="keyword">  </span>{
<a name="l00901"></a>00901     <span class="keywordflow">return</span> (tmp_table == SYSTEM_TMP_TABLE) ? 0 : table_map_id.id();
<a name="l00902"></a>00902   }
<a name="l00903"></a>00903 
<a name="l00904"></a>00904   <span class="keywordtype">bool</span> <a class="code" href="structTABLE__SHARE.html#a084ed977027000a392ff8992d540f257">visit_subgraph</a>(Wait_for_flush *waiting_ticket,
<a name="l00905"></a>00905                       <a class="code" href="classMDL__wait__for__graph__visitor.html">MDL_wait_for_graph_visitor</a> *gvisitor);
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <span class="keywordtype">bool</span> <a class="code" href="structTABLE__SHARE.html#a7570f5c5956dfda8b27bef43e24492d5">wait_for_old_version</a>(THD *thd, <span class="keyword">struct</span> timespec *abstime,
<a name="l00908"></a>00908                             uint deadlock_weight);
<a name="l00910"></a>00910   <span class="keywordtype">void</span> <a class="code" href="structTABLE__SHARE.html#a18fb7405f4f0af28970bdcbf85aed419">destroy</a>();
<a name="l00911"></a>00911 };
<a name="l00912"></a>00912 
<a name="l00913"></a>00913 
<a name="l00920"></a><a class="code" href="classBlob__mem__storage.html">00920</a> <span class="keyword">class </span><a class="code" href="classBlob__mem__storage.html">Blob_mem_storage</a>: <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l00921"></a>00921 {
<a name="l00922"></a>00922 <span class="keyword">private</span>:
<a name="l00923"></a>00923   MEM_ROOT storage;
<a name="l00928"></a>00928   <span class="keywordtype">bool</span> truncated_value;
<a name="l00929"></a>00929 <span class="keyword">public</span>:
<a name="l00930"></a>00930   <a class="code" href="classBlob__mem__storage.html">Blob_mem_storage</a>() :truncated_value(<span class="keyword">false</span>)
<a name="l00931"></a>00931   {
<a name="l00932"></a>00932     init_alloc_root(&amp;storage, MAX_FIELD_VARCHARLENGTH, 0);
<a name="l00933"></a>00933   }
<a name="l00934"></a>00934   ~<a class="code" href="classBlob__mem__storage.html"> Blob_mem_storage</a>()
<a name="l00935"></a>00935   {
<a name="l00936"></a>00936     free_root(&amp;storage, MYF(0));
<a name="l00937"></a>00937   }
<a name="l00938"></a>00938   <span class="keywordtype">void</span> reset()
<a name="l00939"></a>00939   {
<a name="l00940"></a>00940     free_root(&amp;storage, MYF(MY_MARK_BLOCKS_FREE));
<a name="l00941"></a>00941     truncated_value= <span class="keyword">false</span>;
<a name="l00942"></a>00942   }
<a name="l00953"></a><a class="code" href="classBlob__mem__storage.html#a419785795e18ee97d83d7013c3a5ccd5">00953</a>   <span class="keywordtype">char</span> *<a class="code" href="classBlob__mem__storage.html#a419785795e18ee97d83d7013c3a5ccd5">store</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *from, uint length)
<a name="l00954"></a>00954   {
<a name="l00955"></a>00955     <span class="keywordflow">return</span> (<span class="keywordtype">char</span>*) memdup_root(&amp;storage, from, length);
<a name="l00956"></a>00956   }
<a name="l00957"></a>00957   <span class="keywordtype">void</span> set_truncated_value(<span class="keywordtype">bool</span> is_truncated_value)
<a name="l00958"></a>00958   {
<a name="l00959"></a>00959     truncated_value= is_truncated_value;
<a name="l00960"></a>00960   }
<a name="l00961"></a>00961   <span class="keywordtype">bool</span> is_truncated_value() { <span class="keywordflow">return</span> truncated_value; }
<a name="l00962"></a>00962 };
<a name="l00963"></a>00963 
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="comment">/* Information for one open table */</span>
<a name="l00966"></a>00966 <span class="keyword">enum</span> index_hint_type
<a name="l00967"></a>00967 {
<a name="l00968"></a>00968   INDEX_HINT_IGNORE,
<a name="l00969"></a>00969   INDEX_HINT_USE,
<a name="l00970"></a>00970   INDEX_HINT_FORCE
<a name="l00971"></a>00971 };
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 <span class="comment">/* Bitmap of table&#39;s fields */</span>
<a name="l00974"></a>00974 <span class="keyword">typedef</span> <a class="code" href="classBitmap.html">Bitmap&lt;MAX_FIELDS&gt;</a> <a class="code" href="classBitmap.html">Field_map</a>;
<a name="l00975"></a>00975 
<a name="l00976"></a><a class="code" href="structTABLE.html">00976</a> <span class="keyword">struct </span><a class="code" href="structTABLE.html">TABLE</a>
<a name="l00977"></a>00977 {
<a name="l00978"></a>00978   <a class="code" href="structTABLE.html">TABLE</a>() {}                               <span class="comment">/* Remove gcc warning */</span>
<a name="l00979"></a>00979   <span class="comment">/*</span>
<a name="l00980"></a>00980 <span class="comment">    Since TABLE instances are often cleared using memset(), do not</span>
<a name="l00981"></a>00981 <span class="comment">    add virtual members and do not inherit from TABLE.</span>
<a name="l00982"></a>00982 <span class="comment">    Otherwise memset() will start overwriting the vtable pointer.</span>
<a name="l00983"></a>00983 <span class="comment">  */</span>
<a name="l00984"></a>00984 
<a name="l00985"></a>00985   <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a>   *s;
<a name="l00986"></a>00986   <a class="code" href="classhandler.html">handler</a>       *file;
<a name="l00987"></a>00987   <a class="code" href="structTABLE.html">TABLE</a> *next, *prev;
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="keyword">private</span>:
<a name="l00997"></a>00997   <a class="code" href="structTABLE.html">TABLE</a> *cache_next, **cache_prev;
<a name="l00998"></a>00998 
<a name="l00999"></a>00999   <span class="comment">/*</span>
<a name="l01000"></a>01000 <span class="comment">    Give Table_cache_element access to the above two members to allow</span>
<a name="l01001"></a>01001 <span class="comment">    using them for linking TABLE objects in a list.</span>
<a name="l01002"></a>01002 <span class="comment">  */</span>
<a name="l01003"></a>01003   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classTable__cache__element.html">Table_cache_element</a>;
<a name="l01004"></a>01004 
<a name="l01005"></a>01005 <span class="keyword">public</span>:
<a name="l01006"></a>01006 
<a name="l01007"></a>01007   THD   *in_use;                        <span class="comment">/* Which thread uses this */</span>
<a name="l01008"></a>01008   <a class="code" href="classField.html">Field</a> **field;                        <span class="comment">/* Pointer to fields */</span>
<a name="l01009"></a>01009 
<a name="l01010"></a>01010   uchar *record[2];                     <span class="comment">/* Pointer to records */</span>
<a name="l01011"></a>01011   uchar *write_row_record;              <span class="comment">/* Used as optimisation in</span>
<a name="l01012"></a>01012 <span class="comment">                                           THD::write_row */</span>
<a name="l01013"></a>01013   uchar *insert_values;                  <span class="comment">/* used by INSERT ... UPDATE */</span>
<a name="l01014"></a>01014   <span class="comment">/* </span>
<a name="l01015"></a>01015 <span class="comment">    Map of keys that can be used to retrieve all data from this table </span>
<a name="l01016"></a>01016 <span class="comment">    needed by the query without reading the row.</span>
<a name="l01017"></a>01017 <span class="comment">  */</span>
<a name="l01018"></a>01018   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> covering_keys;
<a name="l01019"></a>01019   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> quick_keys, merge_keys;
<a name="l01020"></a>01020   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> used_keys;  <span class="comment">/* Indexes that cover all fields used by the query */</span>
<a name="l01021"></a>01021   
<a name="l01022"></a>01022   <span class="comment">/*</span>
<a name="l01023"></a>01023 <span class="comment">    possible_quick_keys is a superset of quick_keys to use with EXPLAIN of</span>
<a name="l01024"></a>01024 <span class="comment">    JOIN-less commands (single-table UPDATE and DELETE).</span>
<a name="l01025"></a>01025 <span class="comment">    </span>
<a name="l01026"></a>01026 <span class="comment">    When explaining regular JOINs, we use JOIN_TAB::keys to output the </span>
<a name="l01027"></a>01027 <span class="comment">    &quot;possible_keys&quot; column value. However, it is not available for</span>
<a name="l01028"></a>01028 <span class="comment">    single-table UPDATE and DELETE commands, since they don&#39;t use JOIN</span>
<a name="l01029"></a>01029 <span class="comment">    optimizer at the top level. OTOH they directly use the range optimizer,</span>
<a name="l01030"></a>01030 <span class="comment">    that collects all keys usable for range access here.</span>
<a name="l01031"></a>01031 <span class="comment">  */</span>
<a name="l01032"></a>01032   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> possible_quick_keys;
<a name="l01033"></a>01033 
<a name="l01034"></a>01034   <span class="comment">/*</span>
<a name="l01035"></a>01035 <span class="comment">    A set of keys that can be used in the query that references this</span>
<a name="l01036"></a>01036 <span class="comment">    table.</span>
<a name="l01037"></a>01037 <span class="comment"></span>
<a name="l01038"></a>01038 <span class="comment">    All indexes disabled on the table&#39;s TABLE_SHARE (see TABLE::s) will be </span>
<a name="l01039"></a>01039 <span class="comment">    subtracted from this set upon instantiation. Thus for any TABLE t it holds</span>
<a name="l01040"></a>01040 <span class="comment">    that t.keys_in_use_for_query is a subset of t.s.keys_in_use. Generally we </span>
<a name="l01041"></a>01041 <span class="comment">    must not introduce any new keys here (see setup_tables).</span>
<a name="l01042"></a>01042 <span class="comment"></span>
<a name="l01043"></a>01043 <span class="comment">    The set is implemented as a bitmap.</span>
<a name="l01044"></a>01044 <span class="comment">  */</span>
<a name="l01045"></a>01045   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> keys_in_use_for_query;
<a name="l01046"></a>01046   <span class="comment">/* Map of keys that can be used to calculate GROUP BY without sorting */</span>
<a name="l01047"></a>01047   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> keys_in_use_for_group_by;
<a name="l01048"></a>01048   <span class="comment">/* Map of keys that can be used to calculate ORDER BY without sorting */</span>
<a name="l01049"></a>01049   <a class="code" href="classBitmap_3_0164_01_4.html">key_map</a> keys_in_use_for_order_by;
<a name="l01050"></a>01050   <a class="code" href="structst__key.html">KEY</a>  *key_info;                       <span class="comment">/* data of keys defined for the table */</span>
<a name="l01051"></a>01051 
<a name="l01052"></a>01052   <a class="code" href="classField.html">Field</a> *next_number_field;             <span class="comment">/* Set if next_number is activated */</span>
<a name="l01053"></a>01053   <a class="code" href="classField.html">Field</a> *found_next_number_field;       <span class="comment">/* Set on open */</span>
<a name="l01054"></a>01054   <a class="code" href="classField.html">Field</a> *fts_doc_id_field;              <span class="comment">/* Set if FTS_DOC_ID field is present */</span>
<a name="l01055"></a>01055 
<a name="l01056"></a>01056   <span class="comment">/* Table&#39;s triggers, 0 if there are no of them */</span>
<a name="l01057"></a>01057   <a class="code" href="classTable__triggers__list.html">Table_triggers_list</a> *triggers;
<a name="l01058"></a>01058   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *pos_in_table_list;<span class="comment">/* Element referring to this table */</span>
<a name="l01059"></a>01059   <span class="comment">/* Position in thd-&gt;locked_table_list under LOCK TABLES */</span>
<a name="l01060"></a>01060   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *pos_in_locked_tables;
<a name="l01061"></a>01061   <a class="code" href="structst__order.html">ORDER</a>         *group;
<a name="l01062"></a>01062   <span class="keyword">const</span> <span class="keywordtype">char</span>    *alias;                   <span class="comment">/* alias or table name */</span>
<a name="l01063"></a>01063   uchar         *null_flags;
<a name="l01064"></a>01064   my_bitmap_map *bitmap_init_value;
<a name="l01065"></a>01065   MY_BITMAP     def_read_set, def_write_set, tmp_set; <span class="comment">/* containers */</span>
<a name="l01066"></a>01066   MY_BITMAP     *read_set, *write_set;          <span class="comment">/* Active column sets */</span>
<a name="l01067"></a>01067   <span class="comment">/*</span>
<a name="l01068"></a>01068 <span class="comment">   The ID of the query that opened and is using this table. Has different</span>
<a name="l01069"></a>01069 <span class="comment">   meanings depending on the table type.</span>
<a name="l01070"></a>01070 <span class="comment"></span>
<a name="l01071"></a>01071 <span class="comment">   Temporary tables:</span>
<a name="l01072"></a>01072 <span class="comment"></span>
<a name="l01073"></a>01073 <span class="comment">   table-&gt;query_id is set to thd-&gt;query_id for the duration of a statement</span>
<a name="l01074"></a>01074 <span class="comment">   and is reset to 0 once it is closed by the same statement. A non-zero</span>
<a name="l01075"></a>01075 <span class="comment">   table-&gt;query_id means that a statement is using the table even if it&#39;s</span>
<a name="l01076"></a>01076 <span class="comment">   not the current statement (table is in use by some outer statement).</span>
<a name="l01077"></a>01077 <span class="comment"></span>
<a name="l01078"></a>01078 <span class="comment">   Non-temporary tables:</span>
<a name="l01079"></a>01079 <span class="comment"></span>
<a name="l01080"></a>01080 <span class="comment">   Under pre-locked or LOCK TABLES mode: query_id is set to thd-&gt;query_id</span>
<a name="l01081"></a>01081 <span class="comment">   for the duration of a statement and is reset to 0 once it is closed by</span>
<a name="l01082"></a>01082 <span class="comment">   the same statement. A non-zero query_id is used to control which tables</span>
<a name="l01083"></a>01083 <span class="comment">   in the list of pre-opened and locked tables are actually being used.</span>
<a name="l01084"></a>01084 <span class="comment">  */</span>
<a name="l01085"></a>01085   query_id_t    query_id;
<a name="l01086"></a>01086 
<a name="l01087"></a>01087   <span class="comment">/* </span>
<a name="l01088"></a>01088 <span class="comment">    For each key that has quick_keys.is_set(key) == TRUE: estimate of #records</span>
<a name="l01089"></a>01089 <span class="comment">    and max #key parts that range access would use.</span>
<a name="l01090"></a>01090 <span class="comment">  */</span>
<a name="l01091"></a>01091   ha_rows       quick_rows[MAX_KEY];
<a name="l01092"></a>01092 
<a name="l01093"></a>01093   <span class="comment">/* Bitmaps of key parts that =const for the entire join. */</span>
<a name="l01094"></a>01094   key_part_map  const_key_parts[MAX_KEY];
<a name="l01095"></a>01095 
<a name="l01096"></a>01096   uint          quick_key_parts[MAX_KEY];
<a name="l01097"></a>01097   uint          quick_n_ranges[MAX_KEY];
<a name="l01098"></a>01098 
<a name="l01099"></a>01099   <span class="comment">/* </span>
<a name="l01100"></a>01100 <span class="comment">    Estimate of number of records that satisfy SARGable part of the table</span>
<a name="l01101"></a>01101 <span class="comment">    condition, or table-&gt;file-&gt;records if no SARGable condition could be</span>
<a name="l01102"></a>01102 <span class="comment">    constructed.</span>
<a name="l01103"></a>01103 <span class="comment">    This value is used by join optimizer as an estimate of number of records</span>
<a name="l01104"></a>01104 <span class="comment">    that will pass the table condition (condition that depends on fields of </span>
<a name="l01105"></a>01105 <span class="comment">    this table and constants)</span>
<a name="l01106"></a>01106 <span class="comment">  */</span>
<a name="l01107"></a>01107   ha_rows       quick_condition_rows;
<a name="l01108"></a>01108   table_map     map;                    <span class="comment">/* ID bit of table (1,2,4,8,16...) */</span>
<a name="l01109"></a>01109 
<a name="l01110"></a>01110   uint          lock_position;          <span class="comment">/* Position in MYSQL_LOCK.table */</span>
<a name="l01111"></a>01111   uint          lock_data_start;        <span class="comment">/* Start pos. in MYSQL_LOCK.locks */</span>
<a name="l01112"></a>01112   uint          lock_count;             <span class="comment">/* Number of locks */</span>
<a name="l01113"></a>01113   uint          tablenr,used_fields;
<a name="l01114"></a>01114   uint          temp_pool_slot;         <span class="comment">/* Used by intern temp tables */</span>
<a name="l01115"></a>01115   uint          db_stat;                <span class="comment">/* mode of file as in handler.h */</span>
<a name="l01116"></a>01116   <span class="keywordtype">int</span>           current_lock;           <span class="comment">/* Type of lock on table */</span>
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <span class="comment">/*</span>
<a name="l01119"></a>01119 <span class="comment">    0 or JOIN_TYPE_{LEFT|RIGHT}. Currently this is only compared to 0.</span>
<a name="l01120"></a>01120 <span class="comment">    If maybe_null !=0, this table is inner w.r.t. some outer join operation,</span>
<a name="l01121"></a>01121 <span class="comment">    and null_row may be true.</span>
<a name="l01122"></a>01122 <span class="comment">  */</span>
<a name="l01123"></a>01123   uint maybe_null;
<a name="l01124"></a>01124   <span class="comment">/*</span>
<a name="l01125"></a>01125 <span class="comment">    If true, the current table row is considered to have all columns set to </span>
<a name="l01126"></a>01126 <span class="comment">    NULL, including columns declared as &quot;not null&quot; (see maybe_null).</span>
<a name="l01127"></a>01127 <span class="comment">  */</span>
<a name="l01128"></a>01128   my_bool null_row;
<a name="l01129"></a>01129 
<a name="l01130"></a>01130   uint8   status;                       <span class="comment">/* What&#39;s in record[0] */</span>
<a name="l01131"></a>01131   my_bool copy_blobs;                   <span class="comment">/* copy_blobs when storing */</span>
<a name="l01132"></a>01132 
<a name="l01133"></a>01133   <span class="comment">/*</span>
<a name="l01134"></a>01134 <span class="comment">    TODO: Each of the following flags take up 8 bits. They can just as easily</span>
<a name="l01135"></a>01135 <span class="comment">    be put into one single unsigned long and instead of taking up 18</span>
<a name="l01136"></a>01136 <span class="comment">    bytes, it would take up 4.</span>
<a name="l01137"></a>01137 <span class="comment">  */</span>
<a name="l01138"></a>01138   my_bool force_index;
<a name="l01139"></a>01139 
<a name="l01144"></a><a class="code" href="structTABLE.html#a5555a069b95c932eeaa61b78313ddbf7">01144</a>   my_bool <a class="code" href="structTABLE.html#a5555a069b95c932eeaa61b78313ddbf7">force_index_order</a>;
<a name="l01145"></a>01145 
<a name="l01150"></a><a class="code" href="structTABLE.html#aaeda0a79564d3f6d473cd77f155e16cb">01150</a>   my_bool <a class="code" href="structTABLE.html#aaeda0a79564d3f6d473cd77f155e16cb">force_index_group</a>;
<a name="l01151"></a>01151   my_bool distinct,const_table,no_rows;
<a name="l01152"></a>01152 
<a name="l01157"></a><a class="code" href="structTABLE.html#a4580bb49e147af8adb714508a1891acb">01157</a>   my_bool <a class="code" href="structTABLE.html#a4580bb49e147af8adb714508a1891acb">key_read</a>;
<a name="l01158"></a>01158   my_bool no_keyread;
<a name="l01159"></a>01159   my_bool locked_by_logger;
<a name="l01163"></a><a class="code" href="structTABLE.html#a5b99d728b08a795783c2a5b0a1c997f7">01163</a>   my_bool <a class="code" href="structTABLE.html#a5b99d728b08a795783c2a5b0a1c997f7">no_replicate</a>;
<a name="l01164"></a>01164   my_bool locked_by_name;
<a name="l01165"></a>01165   my_bool fulltext_searched;
<a name="l01166"></a>01166   my_bool no_cache;
<a name="l01167"></a>01167   <span class="comment">/* To signal that the table is associated with a HANDLER statement */</span>
<a name="l01168"></a>01168   my_bool open_by_handler;
<a name="l01169"></a>01169   <span class="comment">/*</span>
<a name="l01170"></a>01170 <span class="comment">    To indicate that a non-null value of the auto_increment field</span>
<a name="l01171"></a>01171 <span class="comment">    was provided by the user or retrieved from the current record.</span>
<a name="l01172"></a>01172 <span class="comment">    Used only in the MODE_NO_AUTO_VALUE_ON_ZERO mode.</span>
<a name="l01173"></a>01173 <span class="comment">  */</span>
<a name="l01174"></a>01174   my_bool auto_increment_field_not_null;
<a name="l01175"></a>01175   my_bool insert_or_update;             <span class="comment">/* Can be used by the handler */</span>
<a name="l01176"></a>01176   my_bool alias_name_used;              <span class="comment">/* true if table_name is alias */</span>
<a name="l01177"></a>01177   my_bool get_fields_in_item_tree;      <span class="comment">/* Signal to fix_field */</span>
<a name="l01183"></a><a class="code" href="structTABLE.html#a3cfec9aee859fac059aa0f7cbecfbc92">01183</a>   my_bool <a class="code" href="structTABLE.html#a3cfec9aee859fac059aa0f7cbecfbc92">m_needs_reopen</a>;
<a name="l01184"></a>01184 <span class="keyword">private</span>:
<a name="l01185"></a>01185   <span class="keywordtype">bool</span> created; <span class="comment">/* For tmp tables. TRUE &lt;=&gt; tmp table has been instantiated.*/</span>
<a name="l01186"></a>01186 <span class="keyword">public</span>:
<a name="l01187"></a>01187   uint max_keys; <span class="comment">/* Size of allocated key_info array. */</span>
<a name="l01188"></a>01188 
<a name="l01189"></a>01189   <a class="code" href="structst__reginfo.html">REGINFO</a> reginfo;                      <span class="comment">/* field connections */</span>
<a name="l01195"></a><a class="code" href="structTABLE.html#aa76fd5e13a8b5101a247413701978730">01195</a>   MEM_ROOT <a class="code" href="structTABLE.html#aa76fd5e13a8b5101a247413701978730">mem_root</a>;
<a name="l01201"></a><a class="code" href="structTABLE.html#ae97224c2b47679281629de05a4155a71">01201</a>   <a class="code" href="classBlob__mem__storage.html">Blob_mem_storage</a> *<a class="code" href="structTABLE.html#ae97224c2b47679281629de05a4155a71">blob_storage</a>;
<a name="l01202"></a>01202   <a class="code" href="structst__grant__info.html" title="The current state of the privilege checking process for the current user, SQL statement and SQL objec...">GRANT_INFO</a> grant;
<a name="l01203"></a>01203   <a class="code" href="classFilesort__info.html">Filesort_info</a> sort;
<a name="l01204"></a>01204 <span class="preprocessor">#ifdef WITH_PARTITION_STORAGE_ENGINE</span>
<a name="l01205"></a>01205 <span class="preprocessor"></span>  <a class="code" href="classpartition__info.html">partition_info</a> *part_info;            <span class="comment">/* Partition related information */</span>
<a name="l01206"></a>01206   <span class="comment">/* If true, all partitions have been pruned away */</span>
<a name="l01207"></a>01207   <span class="keywordtype">bool</span> all_partitions_pruned_away;
<a name="l01208"></a>01208 <span class="preprocessor">#endif</span>
<a name="l01209"></a>01209 <span class="preprocessor"></span>  <a class="code" href="classMDL__ticket.html">MDL_ticket</a> *mdl_ticket;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211   <span class="keywordtype">void</span> <a class="code" href="structTABLE.html#a4c6c0d87326e6006abe59c861c947ad3">init</a>(THD *thd, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *tl);
<a name="l01212"></a>01212   <span class="keywordtype">bool</span> fill_item_list(<a class="code" href="classList.html">List&lt;Item&gt;</a> *item_list) <span class="keyword">const</span>;
<a name="l01213"></a>01213   <span class="keywordtype">void</span> reset_item_list(<a class="code" href="classList.html">List&lt;Item&gt;</a> *item_list) <span class="keyword">const</span>;
<a name="l01214"></a>01214   <span class="keywordtype">void</span> clear_column_bitmaps(<span class="keywordtype">void</span>);
<a name="l01215"></a>01215   <span class="keywordtype">void</span> <a class="code" href="structTABLE.html#aeae1505f7281ef739f97287727b4685e">prepare_for_position</a>(<span class="keywordtype">void</span>);
<a name="l01216"></a>01216   <span class="keywordtype">void</span> mark_columns_used_by_index_no_reset(uint index, MY_BITMAP *map);
<a name="l01217"></a>01217   <span class="keywordtype">void</span> mark_columns_used_by_index(uint index);
<a name="l01218"></a>01218   <span class="keywordtype">void</span> mark_auto_increment_column(<span class="keywordtype">void</span>);
<a name="l01219"></a>01219   <span class="keywordtype">void</span> <a class="code" href="structTABLE.html#a89ef061c4f01b901f0f99ccc84b47c34" title="Mark columns needed for doing an update of a row.">mark_columns_needed_for_update</a>(<span class="keywordtype">void</span>);
<a name="l01220"></a>01220   <span class="keywordtype">void</span> mark_columns_needed_for_delete(<span class="keywordtype">void</span>);
<a name="l01221"></a>01221   <span class="keywordtype">void</span> mark_columns_needed_for_insert(<span class="keywordtype">void</span>);
<a name="l01222"></a>01222   <span class="keywordtype">void</span> <a class="code" href="structTABLE.html#a80aa5acb1308e30d425ab0c9b07fa809">mark_columns_per_binlog_row_image</a>(<span class="keywordtype">void</span>);
<a name="l01223"></a>01223   <span class="keyword">inline</span> <span class="keywordtype">void</span> column_bitmaps_set(MY_BITMAP *read_set_arg,
<a name="l01224"></a>01224                                  MY_BITMAP *write_set_arg)
<a name="l01225"></a>01225   {
<a name="l01226"></a>01226     read_set= read_set_arg;
<a name="l01227"></a>01227     write_set= write_set_arg;
<a name="l01228"></a>01228     <span class="keywordflow">if</span> (file &amp;&amp; created)
<a name="l01229"></a>01229       file-&gt;<a class="code" href="classhandler.html#a4de97045e5381007565fd2b0da235c07" title="MySQL signal that it changed the column bitmap.">column_bitmaps_signal</a>();
<a name="l01230"></a>01230   }
<a name="l01231"></a>01231   <span class="keyword">inline</span> <span class="keywordtype">void</span> column_bitmaps_set_no_signal(MY_BITMAP *read_set_arg,
<a name="l01232"></a>01232                                            MY_BITMAP *write_set_arg)
<a name="l01233"></a>01233   {
<a name="l01234"></a>01234     read_set= read_set_arg;
<a name="l01235"></a>01235     write_set= write_set_arg;
<a name="l01236"></a>01236   }
<a name="l01237"></a>01237   <span class="keyword">inline</span> <span class="keywordtype">void</span> use_all_columns()
<a name="l01238"></a>01238   {
<a name="l01239"></a>01239     column_bitmaps_set(&amp;s-&gt;all_set, &amp;s-&gt;all_set);
<a name="l01240"></a>01240   }
<a name="l01241"></a>01241   <span class="keyword">inline</span> <span class="keywordtype">void</span> default_column_bitmaps()
<a name="l01242"></a>01242   {
<a name="l01243"></a>01243     read_set= &amp;def_read_set;
<a name="l01244"></a>01244     write_set= &amp;def_write_set;
<a name="l01245"></a>01245   }
<a name="l01247"></a><a class="code" href="structTABLE.html#a2557166f01a25c157d4c16dd3305bddb">01247</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="structTABLE.html#a2557166f01a25c157d4c16dd3305bddb">needs_reopen</a>()
<a name="l01248"></a>01248   { <span class="keywordflow">return</span> !db_stat || <a class="code" href="structTABLE.html#a3cfec9aee859fac059aa0f7cbecfbc92">m_needs_reopen</a>; }
<a name="l01249"></a>01249   <span class="keywordtype">bool</span> <a class="code" href="structTABLE.html#a6e1532a0f768fbb90b2151a4890b4936" title="Allocate space for keys.">alloc_keys</a>(uint key_count);
<a name="l01250"></a>01250   <span class="keywordtype">bool</span> <a class="code" href="structTABLE.html#ad78429d129e0432b21bfdb41c05f928a" title="Add one key to a temporary table.">add_tmp_key</a>(Field_map *key_parts, <span class="keywordtype">char</span> *key_name);
<a name="l01251"></a>01251   <span class="keywordtype">void</span> use_index(<span class="keywordtype">int</span> key_to_save);
<a name="l01252"></a>01252 
<a name="l01253"></a>01253   <span class="keywordtype">void</span> set_keyread(<span class="keywordtype">bool</span> flag)
<a name="l01254"></a>01254   {
<a name="l01255"></a>01255     DBUG_ASSERT(file);
<a name="l01256"></a>01256     <span class="keywordflow">if</span> (flag &amp;&amp; !<a class="code" href="structTABLE.html#a4580bb49e147af8adb714508a1891acb">key_read</a>)
<a name="l01257"></a>01257     {
<a name="l01258"></a>01258       <a class="code" href="structTABLE.html#a4580bb49e147af8adb714508a1891acb">key_read</a>= 1;
<a name="l01259"></a>01259       <span class="keywordflow">if</span> (<a class="code" href="structTABLE.html#a7927f9ca649ed418e495e17705e63379" title="Return true if table is instantiated, and false otherwise.">is_created</a>())
<a name="l01260"></a>01260         file-&gt;extra(HA_EXTRA_KEYREAD);
<a name="l01261"></a>01261     }
<a name="l01262"></a>01262     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!flag &amp;&amp; <a class="code" href="structTABLE.html#a4580bb49e147af8adb714508a1891acb">key_read</a>)
<a name="l01263"></a>01263     {
<a name="l01264"></a>01264       <a class="code" href="structTABLE.html#a4580bb49e147af8adb714508a1891acb">key_read</a>= 0;
<a name="l01265"></a>01265       <span class="keywordflow">if</span> (<a class="code" href="structTABLE.html#a7927f9ca649ed418e495e17705e63379" title="Return true if table is instantiated, and false otherwise.">is_created</a>())
<a name="l01266"></a>01266         file-&gt;extra(HA_EXTRA_NO_KEYREAD);
<a name="l01267"></a>01267     }
<a name="l01268"></a>01268   }
<a name="l01269"></a>01269 
<a name="l01270"></a>01270   <span class="keywordtype">bool</span> <a class="code" href="structTABLE.html#aded373553a351dbb53ae979e21aacd48">update_const_key_parts</a>(<a class="code" href="classItem.html">Item</a> *conds);
<a name="l01271"></a>01271 
<a name="l01272"></a>01272   <span class="keywordtype">bool</span> <a class="code" href="structTABLE.html#ab03bd2dcb8c01194f4d28d2948aa5ba7">check_read_removal</a>(uint index);
<a name="l01273"></a>01273 
<a name="l01275"></a><a class="code" href="structTABLE.html#a7927f9ca649ed418e495e17705e63379">01275</a>   <span class="keywordtype">bool</span> <a class="code" href="structTABLE.html#a7927f9ca649ed418e495e17705e63379" title="Return true if table is instantiated, and false otherwise.">is_created</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> created; }
<a name="l01276"></a>01276 
<a name="l01281"></a><a class="code" href="structTABLE.html#a2c88ea05c0c70fc854b9c809f797f89b">01281</a>   <span class="keywordtype">void</span> <a class="code" href="structTABLE.html#a2c88ea05c0c70fc854b9c809f797f89b">set_created</a>()
<a name="l01282"></a>01282   {
<a name="l01283"></a>01283     <span class="keywordflow">if</span> (created)
<a name="l01284"></a>01284       <span class="keywordflow">return</span>;
<a name="l01285"></a>01285     <span class="keywordflow">if</span> (<a class="code" href="structTABLE.html#a4580bb49e147af8adb714508a1891acb">key_read</a>)
<a name="l01286"></a>01286       file-&gt;extra(HA_EXTRA_KEYREAD);
<a name="l01287"></a>01287     created= <span class="keyword">true</span>;
<a name="l01288"></a>01288   }
<a name="l01293"></a><a class="code" href="structTABLE.html#a2bac1524ecf90bda2145cfc92b16b040">01293</a>   <span class="keywordtype">void</span> <a class="code" href="structTABLE.html#a2bac1524ecf90bda2145cfc92b16b040">set_deleted</a>()
<a name="l01294"></a>01294   {
<a name="l01295"></a>01295     created= <span class="keyword">false</span>;
<a name="l01296"></a>01296   }
<a name="l01297"></a>01297 };
<a name="l01298"></a>01298 
<a name="l01299"></a>01299 
<a name="l01300"></a>01300 <span class="keyword">enum</span> enum_schema_table_state
<a name="l01301"></a>01301 { 
<a name="l01302"></a>01302   NOT_PROCESSED= 0,
<a name="l01303"></a>01303   PROCESSED_BY_CREATE_SORT_INDEX,
<a name="l01304"></a>01304   PROCESSED_BY_JOIN_EXEC
<a name="l01305"></a>01305 };
<a name="l01306"></a>01306 
<a name="l01307"></a><a class="code" href="structst__foreign__key__info.html">01307</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__foreign__key__info.html">st_foreign_key_info</a>
<a name="l01308"></a>01308 {
<a name="l01309"></a>01309   LEX_STRING *foreign_id;
<a name="l01310"></a>01310   LEX_STRING *foreign_db;
<a name="l01311"></a>01311   LEX_STRING *foreign_table;
<a name="l01312"></a>01312   LEX_STRING *referenced_db;
<a name="l01313"></a>01313   LEX_STRING *referenced_table;
<a name="l01314"></a>01314   LEX_STRING *update_method;
<a name="l01315"></a>01315   LEX_STRING *delete_method;
<a name="l01316"></a>01316   LEX_STRING *referenced_key_name;
<a name="l01317"></a>01317   <a class="code" href="classList.html">List&lt;LEX_STRING&gt;</a> foreign_fields;
<a name="l01318"></a>01318   <a class="code" href="classList.html">List&lt;LEX_STRING&gt;</a> referenced_fields;
<a name="l01319"></a>01319 } <a class="code" href="structst__foreign__key__info.html">FOREIGN_KEY_INFO</a>;
<a name="l01320"></a>01320 
<a name="l01321"></a>01321 <span class="preprocessor">#define MY_I_S_MAYBE_NULL 1</span>
<a name="l01322"></a>01322 <span class="preprocessor"></span><span class="preprocessor">#define MY_I_S_UNSIGNED   2</span>
<a name="l01323"></a>01323 <span class="preprocessor"></span>
<a name="l01324"></a>01324 
<a name="l01325"></a>01325 <span class="preprocessor">#define SKIP_OPEN_TABLE 0                // do not open table</span>
<a name="l01326"></a>01326 <span class="preprocessor"></span><span class="preprocessor">#define OPEN_FRM_ONLY   1                // open FRM file only</span>
<a name="l01327"></a>01327 <span class="preprocessor"></span><span class="preprocessor">#define OPEN_FULL_TABLE 2                // open FRM,MYD, MYI files</span>
<a name="l01328"></a>01328 <span class="preprocessor"></span>
<a name="l01329"></a><a class="code" href="structst__field__info.html">01329</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__field__info.html">st_field_info</a>
<a name="l01330"></a>01330 {
<a name="l01334"></a><a class="code" href="structst__field__info.html#aad2046c4548bf5eafe4bdbeeb7298232">01334</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="structst__field__info.html#aad2046c4548bf5eafe4bdbeeb7298232">field_name</a>;
<a name="l01339"></a><a class="code" href="structst__field__info.html#a82de297dd0e4835ada40570f1a0822f9">01339</a>   uint <a class="code" href="structst__field__info.html#a82de297dd0e4835ada40570f1a0822f9">field_length</a>;
<a name="l01345"></a><a class="code" href="structst__field__info.html#a70226cb26db7fb2d7bbde155db4c6829">01345</a>   <span class="keyword">enum</span> enum_field_types <a class="code" href="structst__field__info.html#a70226cb26db7fb2d7bbde155db4c6829">field_type</a>;
<a name="l01346"></a>01346   <span class="keywordtype">int</span> value;
<a name="l01355"></a><a class="code" href="structst__field__info.html#a5cc25359e4b59962ae5b2fb6ea387fed">01355</a>   uint <a class="code" href="structst__field__info.html#a5cc25359e4b59962ae5b2fb6ea387fed">field_flags</a>;        <span class="comment">// Field atributes(maybe_null, signed, unsigned etc.)</span>
<a name="l01356"></a>01356   <span class="keyword">const</span> <span class="keywordtype">char</span>* old_name;
<a name="l01361"></a><a class="code" href="structst__field__info.html#a7e8e6e6d5634ec75f81a0540dc3ed7dd">01361</a>   uint <a class="code" href="structst__field__info.html#a7e8e6e6d5634ec75f81a0540dc3ed7dd">open_method</a>;
<a name="l01362"></a>01362 } <a class="code" href="structst__field__info.html">ST_FIELD_INFO</a>;
<a name="l01363"></a>01363 
<a name="l01364"></a>01364 
<a name="l01365"></a>01365 <span class="keyword">struct </span><a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>;
<a name="l01366"></a>01366 
<a name="l01367"></a><a class="code" href="structst__schema__table.html">01367</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__schema__table.html">st_schema_table</a>
<a name="l01368"></a>01368 {
<a name="l01369"></a>01369   <span class="keyword">const</span> <span class="keywordtype">char</span>* table_name;
<a name="l01370"></a>01370   <a class="code" href="structst__field__info.html">ST_FIELD_INFO</a> *fields_info;
<a name="l01371"></a>01371   <span class="comment">/* Create information_schema table */</span>
<a name="l01372"></a>01372   <a class="code" href="structTABLE.html">TABLE</a> *(*create_table)  (THD *thd, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list);
<a name="l01373"></a>01373   <span class="comment">/* Fill table with data */</span>
<a name="l01374"></a>01374   int (*fill_table) (THD *thd, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="code" href="classItem.html">Item</a> *cond);
<a name="l01375"></a>01375   <span class="comment">/* Handle fileds for old SHOW */</span>
<a name="l01376"></a>01376   int (*old_format) (THD *thd, <span class="keyword">struct </span><a class="code" href="structst__schema__table.html">st_schema_table</a> *schema_table);
<a name="l01377"></a>01377   int (*process_table) (THD *thd, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *tables, <a class="code" href="structTABLE.html">TABLE</a> *table,
<a name="l01378"></a>01378                         <span class="keywordtype">bool</span> res, LEX_STRING *db_name, LEX_STRING *table_name);
<a name="l01379"></a>01379   <span class="keywordtype">int</span> idx_field1, idx_field2; 
<a name="l01380"></a>01380   <span class="keywordtype">bool</span> hidden;
<a name="l01381"></a>01381   uint i_s_requested_object;  <span class="comment">/* the object we need to open(TABLE | VIEW) */</span>
<a name="l01382"></a>01382 } <a class="code" href="structst__schema__table.html">ST_SCHEMA_TABLE</a>;
<a name="l01383"></a>01383 
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 <span class="preprocessor">#define JOIN_TYPE_LEFT  1</span>
<a name="l01386"></a>01386 <span class="preprocessor"></span><span class="preprocessor">#define JOIN_TYPE_RIGHT 2</span>
<a name="l01387"></a>01387 <span class="preprocessor"></span>
<a name="l01388"></a>01388 <span class="keyword">enum</span> enum_derived_type {
<a name="l01389"></a>01389   VIEW_ALGORITHM_UNDEFINED = 0,
<a name="l01390"></a>01390   VIEW_ALGORITHM_TMPTABLE,
<a name="l01391"></a>01391   VIEW_ALGORITHM_MERGE,
<a name="l01392"></a>01392   DERIVED_ALGORITHM_TMPTABLE
<a name="l01393"></a>01393 };
<a name="l01394"></a>01394 
<a name="l01395"></a>01395 <span class="preprocessor">#define VIEW_SUID_INVOKER               0</span>
<a name="l01396"></a>01396 <span class="preprocessor"></span><span class="preprocessor">#define VIEW_SUID_DEFINER               1</span>
<a name="l01397"></a>01397 <span class="preprocessor"></span><span class="preprocessor">#define VIEW_SUID_DEFAULT               2</span>
<a name="l01398"></a>01398 <span class="preprocessor"></span>
<a name="l01399"></a>01399 <span class="comment">/* view WITH CHECK OPTION parameter options */</span>
<a name="l01400"></a>01400 <span class="preprocessor">#define VIEW_CHECK_NONE       0</span>
<a name="l01401"></a>01401 <span class="preprocessor"></span><span class="preprocessor">#define VIEW_CHECK_LOCAL      1</span>
<a name="l01402"></a>01402 <span class="preprocessor"></span><span class="preprocessor">#define VIEW_CHECK_CASCADED   2</span>
<a name="l01403"></a>01403 <span class="preprocessor"></span>
<a name="l01404"></a>01404 <span class="comment">/* result of view WITH CHECK OPTION parameter check */</span>
<a name="l01405"></a>01405 <span class="preprocessor">#define VIEW_CHECK_OK         0</span>
<a name="l01406"></a>01406 <span class="preprocessor"></span><span class="preprocessor">#define VIEW_CHECK_ERROR      1</span>
<a name="l01407"></a>01407 <span class="preprocessor"></span><span class="preprocessor">#define VIEW_CHECK_SKIP       2</span>
<a name="l01408"></a>01408 <span class="preprocessor"></span>
<a name="l01410"></a>01410 <span class="preprocessor">#define MAX_TDC_BLOB_SIZE 65536</span>
<a name="l01411"></a>01411 <span class="preprocessor"></span>
<a name="l01412"></a>01412 <span class="keyword">class </span>select_union;
<a name="l01413"></a>01413 <span class="keyword">class </span>TMP_TABLE_PARAM;
<a name="l01414"></a>01414 
<a name="l01415"></a><a class="code" href="structField__translator.html">01415</a> <span class="keyword">struct </span><a class="code" href="structField__translator.html">Field_translator</a>
<a name="l01416"></a>01416 {
<a name="l01417"></a>01417   <a class="code" href="classItem.html">Item</a> *item;
<a name="l01418"></a>01418   <span class="keyword">const</span> <span class="keywordtype">char</span> *name;
<a name="l01419"></a>01419 };
<a name="l01420"></a>01420 
<a name="l01421"></a>01421 
<a name="l01422"></a>01422 <span class="comment">/*</span>
<a name="l01423"></a>01423 <span class="comment">  Column reference of a NATURAL/USING join. Since column references in</span>
<a name="l01424"></a>01424 <span class="comment">  joins can be both from views and stored tables, may point to either a</span>
<a name="l01425"></a>01425 <span class="comment">  Field (for tables), or a Field_translator (for views).</span>
<a name="l01426"></a>01426 <span class="comment">*/</span>
<a name="l01427"></a>01427 
<a name="l01428"></a><a class="code" href="classNatural__join__column.html">01428</a> <span class="keyword">class </span><a class="code" href="classNatural__join__column.html">Natural_join_column</a>: <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l01429"></a>01429 {
<a name="l01430"></a>01430 <span class="keyword">public</span>:
<a name="l01431"></a>01431   <a class="code" href="structField__translator.html">Field_translator</a> *view_field;  <span class="comment">/* Column reference of merge view. */</span>
<a name="l01432"></a>01432   <a class="code" href="classItem__field.html">Item_field</a>       *table_field; <span class="comment">/* Column reference of table or temp view. */</span>
<a name="l01433"></a>01433   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref; <span class="comment">/* Original base table/view reference. */</span>
<a name="l01434"></a>01434   <span class="comment">/*</span>
<a name="l01435"></a>01435 <span class="comment">    True if a common join column of two NATURAL/USING join operands. Notice</span>
<a name="l01436"></a>01436 <span class="comment">    that when we have a hierarchy of nested NATURAL/USING joins, a column can</span>
<a name="l01437"></a>01437 <span class="comment">    be common at some level of nesting but it may not be common at higher</span>
<a name="l01438"></a>01438 <span class="comment">    levels of nesting. Thus this flag may change depending on at which level</span>
<a name="l01439"></a>01439 <span class="comment">    we are looking at some column.</span>
<a name="l01440"></a>01440 <span class="comment">  */</span>
<a name="l01441"></a>01441   <span class="keywordtype">bool</span> is_common;
<a name="l01442"></a>01442 <span class="keyword">public</span>:
<a name="l01443"></a>01443   <a class="code" href="classNatural__join__column.html">Natural_join_column</a>(<a class="code" href="structField__translator.html">Field_translator</a> *field_param, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *tab);
<a name="l01444"></a>01444   <a class="code" href="classNatural__join__column.html">Natural_join_column</a>(<a class="code" href="classItem__field.html">Item_field</a> *field_param, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *tab);
<a name="l01445"></a>01445   <span class="keyword">const</span> <span class="keywordtype">char</span> *name();
<a name="l01446"></a>01446   <a class="code" href="classItem.html">Item</a> *create_item(THD *thd);
<a name="l01447"></a>01447   <a class="code" href="classField.html">Field</a> *field();
<a name="l01448"></a>01448   <span class="keyword">const</span> <span class="keywordtype">char</span> *table_name();
<a name="l01449"></a>01449   <span class="keyword">const</span> <span class="keywordtype">char</span> *db_name();
<a name="l01450"></a>01450   <a class="code" href="structst__grant__info.html" title="The current state of the privilege checking process for the current user, SQL statement and SQL objec...">GRANT_INFO</a> *grant();
<a name="l01451"></a>01451 };
<a name="l01452"></a>01452 
<a name="l01453"></a>01453 
<a name="l01458"></a>01458 <span class="keyword">enum</span> enum_open_type
<a name="l01459"></a>01459 {
<a name="l01460"></a>01460   OT_TEMPORARY_OR_BASE= 0, OT_TEMPORARY_ONLY, OT_BASE_ONLY
<a name="l01461"></a>01461 };
<a name="l01462"></a>01462 
<a name="l01472"></a><a class="code" href="classDerived__key.html">01472</a> <span class="keyword">class </span><a class="code" href="classDerived__key.html">Derived_key</a>: <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a> {
<a name="l01473"></a>01473 <span class="keyword">public</span>:
<a name="l01474"></a>01474   table_map referenced_by;
<a name="l01475"></a>01475   Field_map used_fields;
<a name="l01476"></a>01476 };
<a name="l01477"></a>01477 
<a name="l01478"></a>01478 <span class="keyword">class </span>Index_hint;
<a name="l01479"></a>01479 <span class="keyword">class </span><a class="code" href="classItem__exists__subselect.html">Item_exists_subselect</a>;
<a name="l01480"></a>01480 
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 <span class="comment">/*</span>
<a name="l01483"></a>01483 <span class="comment">  Table reference in the FROM clause.</span>
<a name="l01484"></a>01484 <span class="comment"></span>
<a name="l01485"></a>01485 <span class="comment">  These table references can be of several types that correspond to</span>
<a name="l01486"></a>01486 <span class="comment">  different SQL elements. Below we list all types of TABLE_LISTs with</span>
<a name="l01487"></a>01487 <span class="comment">  the necessary conditions to determine when a TABLE_LIST instance</span>
<a name="l01488"></a>01488 <span class="comment">  belongs to a certain type.</span>
<a name="l01489"></a>01489 <span class="comment"></span>
<a name="l01490"></a>01490 <span class="comment">  1) table (TABLE_LIST::view == NULL)</span>
<a name="l01491"></a>01491 <span class="comment">     - base table</span>
<a name="l01492"></a>01492 <span class="comment">       (TABLE_LIST::derived == NULL)</span>
<a name="l01493"></a>01493 <span class="comment">     - subquery - TABLE_LIST::table is a temp table</span>
<a name="l01494"></a>01494 <span class="comment">       (TABLE_LIST::derived != NULL)</span>
<a name="l01495"></a>01495 <span class="comment">     - information schema table</span>
<a name="l01496"></a>01496 <span class="comment">       (TABLE_LIST::schema_table != NULL)</span>
<a name="l01497"></a>01497 <span class="comment">       NOTICE: for schema tables TABLE_LIST::field_translation may be != NULL</span>
<a name="l01498"></a>01498 <span class="comment">  2) view (TABLE_LIST::view != NULL)</span>
<a name="l01499"></a>01499 <span class="comment">     - merge    (TABLE_LIST::effective_algorithm == VIEW_ALGORITHM_MERGE)</span>
<a name="l01500"></a>01500 <span class="comment">           also (TABLE_LIST::field_translation != NULL)</span>
<a name="l01501"></a>01501 <span class="comment">     - tmptable (TABLE_LIST::effective_algorithm == VIEW_ALGORITHM_TMPTABLE)</span>
<a name="l01502"></a>01502 <span class="comment">           also (TABLE_LIST::field_translation == NULL)</span>
<a name="l01503"></a>01503 <span class="comment">  3) nested table reference (TABLE_LIST::nested_join != NULL)</span>
<a name="l01504"></a>01504 <span class="comment">     - table sequence - e.g. (t1, t2, t3)</span>
<a name="l01505"></a>01505 <span class="comment">       TODO: how to distinguish from a JOIN?</span>
<a name="l01506"></a>01506 <span class="comment">     - general JOIN</span>
<a name="l01507"></a>01507 <span class="comment">       TODO: how to distinguish from a table sequence?</span>
<a name="l01508"></a>01508 <span class="comment">     - NATURAL JOIN</span>
<a name="l01509"></a>01509 <span class="comment">       (TABLE_LIST::natural_join != NULL)</span>
<a name="l01510"></a>01510 <span class="comment">       - JOIN ... USING</span>
<a name="l01511"></a>01511 <span class="comment">         (TABLE_LIST::join_using_fields != NULL)</span>
<a name="l01512"></a>01512 <span class="comment">     - semi-join</span>
<a name="l01513"></a>01513 <span class="comment">       ;</span>
<a name="l01514"></a>01514 <span class="comment">*/</span>
<a name="l01515"></a>01515 
<a name="l01516"></a>01516 <span class="keyword">struct </span><a class="code" href="structName__resolution__context.html">Name_resolution_context</a>;
<a name="l01517"></a>01517 <span class="keyword">struct </span>LEX;
<a name="l01518"></a><a class="code" href="structTABLE__LIST.html">01518</a> <span class="keyword">struct </span><a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>
<a name="l01519"></a>01519 {
<a name="l01520"></a>01520   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>() {}                          <span class="comment">/* Remove gcc warning */</span>
<a name="l01521"></a>01521 
<a name="l01526"></a><a class="code" href="structTABLE__LIST.html#a240fcf827fe504bebbbb4caa0f76b6ab">01526</a>   <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="structTABLE__LIST.html#a240fcf827fe504bebbbb4caa0f76b6ab">init_one_table</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *db_name_arg,
<a name="l01527"></a>01527                              <span class="keywordtype">size_t</span> db_length_arg,
<a name="l01528"></a>01528                              <span class="keyword">const</span> <span class="keywordtype">char</span> *table_name_arg,
<a name="l01529"></a>01529                              <span class="keywordtype">size_t</span> table_name_length_arg,
<a name="l01530"></a>01530                              <span class="keyword">const</span> <span class="keywordtype">char</span> *alias_arg,
<a name="l01531"></a>01531                              <span class="keyword">enum</span> thr_lock_type lock_type_arg)
<a name="l01532"></a>01532   {
<a name="l01533"></a>01533     memset(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(*<span class="keyword">this</span>));
<a name="l01534"></a>01534     db= (<span class="keywordtype">char</span>*) db_name_arg;
<a name="l01535"></a>01535     db_length= db_length_arg;
<a name="l01536"></a>01536     table_name= (<span class="keywordtype">char</span>*) table_name_arg;
<a name="l01537"></a>01537     table_name_length= table_name_length_arg;
<a name="l01538"></a>01538     alias= (<span class="keywordtype">char</span>*) alias_arg;
<a name="l01539"></a>01539     lock_type= lock_type_arg;
<a name="l01540"></a>01540     mdl_request.<a class="code" href="classMDL__request.html#a3702105c9fd923310169a8dbf4941588">init</a>(MDL_key::TABLE, db, table_name,
<a name="l01541"></a>01541                      (lock_type &gt;= TL_WRITE_ALLOW_WRITE) ?
<a name="l01542"></a>01542                      MDL_SHARED_WRITE : MDL_SHARED_READ,
<a name="l01543"></a>01543                      MDL_TRANSACTION);
<a name="l01544"></a>01544     callback_func= 0;
<a name="l01545"></a>01545   }
<a name="l01546"></a>01546 
<a name="l01548"></a>01548   <span class="keyword">static</span> <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *<a class="code" href="structTABLE__LIST.html#a0410916850db388be734dad75e4dcb8a" title="Create a TABLE_LIST object representing a nested join.">new_nested_join</a>(MEM_ROOT *allocator,
<a name="l01549"></a>01549                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *alias,
<a name="l01550"></a>01550                                      <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *embedding,
<a name="l01551"></a>01551                                      <a class="code" href="classList.html">List&lt;TABLE_LIST&gt;</a> *belongs_to,
<a name="l01552"></a>01552                                      <span class="keyword">class</span> st_select_lex *select);
<a name="l01553"></a>01553 
<a name="l01554"></a>01554   <span class="comment">/*</span>
<a name="l01555"></a>01555 <span class="comment">    List of tables local to a subquery or the top-level SELECT (used by</span>
<a name="l01556"></a>01556 <span class="comment">    SQL_I_List). Considers views as leaves (unlike &#39;next_leaf&#39; below).</span>
<a name="l01557"></a>01557 <span class="comment">    Created at parse time in st_select_lex::add_table_to_list() -&gt;</span>
<a name="l01558"></a>01558 <span class="comment">    table_list.link_in_list().</span>
<a name="l01559"></a>01559 <span class="comment">  */</span>
<a name="l01560"></a>01560   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *next_local;
<a name="l01561"></a>01561   <span class="comment">/* link in a global list of all queries tables */</span>
<a name="l01562"></a>01562   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *next_global, **prev_global;
<a name="l01563"></a>01563   <span class="keywordtype">char</span>          *db, *alias, *table_name, *schema_table_name;
<a name="l01564"></a>01564   <span class="keywordtype">char</span>          *option;                <span class="comment">/* Used by cache index  */</span>
<a name="l01571"></a><a class="code" href="structTABLE__LIST.html#ad2814dff1dc9df41c607fdb66e2abbc1">01571</a>   <a class="code" href="structName__resolution__context.html">Name_resolution_context</a> *<a class="code" href="structTABLE__LIST.html#ad2814dff1dc9df41c607fdb66e2abbc1">context_of_embedding</a>;
<a name="l01572"></a>01572 
<a name="l01573"></a>01573 <span class="keyword">private</span>:
<a name="l01574"></a>01574   <a class="code" href="classItem.html">Item</a>          *m_join_cond;           <span class="comment">/* Used with outer join */</span>
<a name="l01575"></a>01575 <span class="keyword">public</span>:
<a name="l01576"></a>01576   <a class="code" href="classItem.html">Item</a>         **join_cond_ref() { <span class="keywordflow">return</span> &amp;m_join_cond; }
<a name="l01577"></a>01577   <a class="code" href="classItem.html">Item</a>          *join_cond()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_join_cond; }
<a name="l01578"></a>01578   <a class="code" href="classItem.html">Item</a>          *set_join_cond(<a class="code" href="classItem.html">Item</a> *val)
<a name="l01579"></a>01579                  { <span class="keywordflow">return</span> m_join_cond= val; }
<a name="l01580"></a>01580   <span class="comment">/*</span>
<a name="l01581"></a>01581 <span class="comment">    The structure of the join condition presented in the member above</span>
<a name="l01582"></a>01582 <span class="comment">    can be changed during certain optimizations. This member</span>
<a name="l01583"></a>01583 <span class="comment">    contains a snapshot of AND-OR structure of the join condition</span>
<a name="l01584"></a>01584 <span class="comment">    made after permanent transformations of the parse tree, and is</span>
<a name="l01585"></a>01585 <span class="comment">    used to restore the join condition before every reexecution of a prepared</span>
<a name="l01586"></a>01586 <span class="comment">    statement or stored procedure.</span>
<a name="l01587"></a>01587 <span class="comment">  */</span>
<a name="l01588"></a>01588   <a class="code" href="classItem.html">Item</a>          *prep_join_cond;
<a name="l01589"></a>01589 
<a name="l01590"></a>01590   <a class="code" href="classItem.html">Item</a>          *sj_on_expr;            <span class="comment">/* Synthesized semijoin condition */</span>
<a name="l01591"></a>01591   <span class="comment">/*</span>
<a name="l01592"></a>01592 <span class="comment">    (Valid only for semi-join nests) Bitmap of tables that are within the</span>
<a name="l01593"></a>01593 <span class="comment">    semi-join (this is different from bitmap of all nest&#39;s children because</span>
<a name="l01594"></a>01594 <span class="comment">    tables that were pulled out of the semi-join nest remain listed as</span>
<a name="l01595"></a>01595 <span class="comment">    nest&#39;s children).</span>
<a name="l01596"></a>01596 <span class="comment">  */</span>
<a name="l01597"></a>01597   table_map     sj_inner_tables;
<a name="l01598"></a>01598 
<a name="l01599"></a>01599   <a class="code" href="classCOND__EQUAL.html">COND_EQUAL</a>    *cond_equal;            <span class="comment">/* Used with outer join */</span>
<a name="l01600"></a>01600   <span class="comment">/*</span>
<a name="l01601"></a>01601 <span class="comment">    During parsing - left operand of NATURAL/USING join where &#39;this&#39; is</span>
<a name="l01602"></a>01602 <span class="comment">    the right operand. After parsing (this-&gt;natural_join == this) iff</span>
<a name="l01603"></a>01603 <span class="comment">    &#39;this&#39; represents a NATURAL or USING join operation. Thus after</span>
<a name="l01604"></a>01604 <span class="comment">    parsing &#39;this&#39; is a NATURAL/USING join iff (natural_join != NULL).</span>
<a name="l01605"></a>01605 <span class="comment">  */</span>
<a name="l01606"></a>01606   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *natural_join;
<a name="l01607"></a>01607   <span class="comment">/*</span>
<a name="l01608"></a>01608 <span class="comment">    True if &#39;this&#39; represents a nested join that is a NATURAL JOIN.</span>
<a name="l01609"></a>01609 <span class="comment">    For one of the operands of &#39;this&#39;, the member &#39;natural_join&#39; points</span>
<a name="l01610"></a>01610 <span class="comment">    to the other operand of &#39;this&#39;.</span>
<a name="l01611"></a>01611 <span class="comment">  */</span>
<a name="l01612"></a>01612   <span class="keywordtype">bool</span> is_natural_join;
<a name="l01613"></a>01613   <span class="comment">/* Field names in a USING clause for JOIN ... USING. */</span>
<a name="l01614"></a>01614   <a class="code" href="classList.html">List&lt;String&gt;</a> *join_using_fields;
<a name="l01615"></a>01615   <span class="comment">/*</span>
<a name="l01616"></a>01616 <span class="comment">    Explicitly store the result columns of either a NATURAL/USING join or</span>
<a name="l01617"></a>01617 <span class="comment">    an operand of such a join.</span>
<a name="l01618"></a>01618 <span class="comment">  */</span>
<a name="l01619"></a>01619   <a class="code" href="classList.html">List&lt;Natural_join_column&gt;</a> *join_columns;
<a name="l01620"></a>01620   <span class="comment">/* TRUE if join_columns contains all columns of this table reference. */</span>
<a name="l01621"></a>01621   <span class="keywordtype">bool</span> is_join_columns_complete;
<a name="l01622"></a>01622 
<a name="l01623"></a>01623   <span class="comment">/*</span>
<a name="l01624"></a>01624 <span class="comment">    List of nodes in a nested join tree, that should be considered as</span>
<a name="l01625"></a>01625 <span class="comment">    leaves with respect to name resolution. The leaves are: views,</span>
<a name="l01626"></a>01626 <span class="comment">    top-most nodes representing NATURAL/USING joins, subqueries, and</span>
<a name="l01627"></a>01627 <span class="comment">    base tables. All of these TABLE_LIST instances contain a</span>
<a name="l01628"></a>01628 <span class="comment">    materialized list of columns. The list is local to a subquery.</span>
<a name="l01629"></a>01629 <span class="comment">  */</span>
<a name="l01630"></a>01630   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *next_name_resolution_table;
<a name="l01631"></a>01631   <span class="comment">/* Index names in a &quot;... JOIN ... USE/IGNORE INDEX ...&quot; clause. */</span>
<a name="l01632"></a>01632   <a class="code" href="classList.html">List&lt;Index_hint&gt;</a> *index_hints;
<a name="l01633"></a>01633   <a class="code" href="structTABLE.html">TABLE</a>        *table;                          <span class="comment">/* opened table */</span>
<a name="l01634"></a>01634   <a class="code" href="classTable__id.html">Table_id</a> table_id; <span class="comment">/* table id (from binlog) for opened table */</span>
<a name="l01635"></a>01635   <span class="comment">/*</span>
<a name="l01636"></a>01636 <span class="comment">    select_result for derived table to pass it from table creation to table</span>
<a name="l01637"></a>01637 <span class="comment">    filling procedure</span>
<a name="l01638"></a>01638 <span class="comment">  */</span>
<a name="l01639"></a>01639   select_union  *derived_result;
<a name="l01640"></a>01640   <span class="comment">/*</span>
<a name="l01641"></a>01641 <span class="comment">    Reference from aux_tables to local list entry of main select of</span>
<a name="l01642"></a>01642 <span class="comment">    multi-delete statement:</span>
<a name="l01643"></a>01643 <span class="comment">    delete t1 from t2,t1 where t1.a&lt;&#39;B&#39; and t2.b=t1.b;</span>
<a name="l01644"></a>01644 <span class="comment">    here it will be reference of first occurrence of t1 to second (as you</span>
<a name="l01645"></a>01645 <span class="comment">    can see this lists can&#39;t be merged)</span>
<a name="l01646"></a>01646 <span class="comment">  */</span>
<a name="l01647"></a>01647   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>    *correspondent_table;
<a name="l01669"></a><a class="code" href="structTABLE__LIST.html#ab1ea5a263b55f0aaa954a6ab78ed62b0">01669</a>   st_select_lex_unit *<a class="code" href="structTABLE__LIST.html#ab1ea5a263b55f0aaa954a6ab78ed62b0" title="Normally, this field is non-null for anonymous derived tables only.">derived</a>;          <span class="comment">/* SELECT_LEX_UNIT of derived table */</span>
<a name="l01670"></a>01670   <span class="comment">/*</span>
<a name="l01671"></a>01671 <span class="comment">    TRUE &lt;=&gt; all possible keys for a derived table were collected and</span>
<a name="l01672"></a>01672 <span class="comment">    could be re-used while statement re-execution.</span>
<a name="l01673"></a>01673 <span class="comment">  */</span>
<a name="l01674"></a>01674   <span class="keywordtype">bool</span> derived_keys_ready;
<a name="l01675"></a>01675   <a class="code" href="structst__schema__table.html">ST_SCHEMA_TABLE</a> *schema_table;        <span class="comment">/* Information_schema table */</span>
<a name="l01676"></a>01676   st_select_lex *schema_select_lex;
<a name="l01677"></a>01677   <span class="comment">/*</span>
<a name="l01678"></a>01678 <span class="comment">    True when the view field translation table is used to convert</span>
<a name="l01679"></a>01679 <span class="comment">    schema table fields for backwards compatibility with SHOW command.</span>
<a name="l01680"></a>01680 <span class="comment">  */</span>
<a name="l01681"></a>01681   <span class="keywordtype">bool</span> schema_table_reformed;
<a name="l01682"></a>01682   TMP_TABLE_PARAM *schema_table_param;
<a name="l01683"></a>01683   <span class="comment">/* link to select_lex where this table was used */</span>
<a name="l01684"></a>01684   st_select_lex *select_lex;
<a name="l01685"></a>01685   LEX *view;                    <span class="comment">/* link on VIEW lex for merging */</span>
<a name="l01686"></a>01686   <a class="code" href="structField__translator.html">Field_translator</a> *field_translation;  <span class="comment">/* array of VIEW fields */</span>
<a name="l01687"></a>01687   <span class="comment">/* pointer to element after last one in translation table above */</span>
<a name="l01688"></a>01688   <a class="code" href="structField__translator.html">Field_translator</a> *field_translation_end;
<a name="l01689"></a>01689   <span class="comment">/*</span>
<a name="l01690"></a>01690 <span class="comment">    List (based on next_local) of underlying tables of this view. I.e. it</span>
<a name="l01691"></a>01691 <span class="comment">    does not include the tables of subqueries used in the view. Is set only</span>
<a name="l01692"></a>01692 <span class="comment">    for merged views.</span>
<a name="l01693"></a>01693 <span class="comment">  */</span>
<a name="l01694"></a>01694   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>    *merge_underlying_list;
<a name="l01695"></a>01695   <span class="comment">/*</span>
<a name="l01696"></a>01696 <span class="comment">    - 0 for base tables</span>
<a name="l01697"></a>01697 <span class="comment">    - in case of the view it is the list of all (not only underlying</span>
<a name="l01698"></a>01698 <span class="comment">    tables but also used in subquery ones) tables of the view.</span>
<a name="l01699"></a>01699 <span class="comment">  */</span>
<a name="l01700"></a>01700   <a class="code" href="classList.html">List&lt;TABLE_LIST&gt;</a> *view_tables;
<a name="l01701"></a>01701   <span class="comment">/* most upper view this table belongs to */</span>
<a name="l01702"></a>01702   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>    *belong_to_view;
<a name="l01703"></a>01703   <span class="comment">/*</span>
<a name="l01704"></a>01704 <span class="comment">    The view directly referencing this table</span>
<a name="l01705"></a>01705 <span class="comment">    (non-zero only for merged underlying tables of a view).</span>
<a name="l01706"></a>01706 <span class="comment">  */</span>
<a name="l01707"></a>01707   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>    *referencing_view;
<a name="l01708"></a>01708   <span class="comment">/* Ptr to parent MERGE table list item. See top comment in ha_myisammrg.cc */</span>
<a name="l01709"></a>01709   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>    *parent_l;
<a name="l01710"></a>01710   <span class="comment">/*</span>
<a name="l01711"></a>01711 <span class="comment">    Security  context (non-zero only for tables which belong</span>
<a name="l01712"></a>01712 <span class="comment">    to view with SQL SECURITY DEFINER)</span>
<a name="l01713"></a>01713 <span class="comment">  */</span>
<a name="l01714"></a>01714   Security_context *security_ctx;
<a name="l01715"></a>01715   <span class="comment">/*</span>
<a name="l01716"></a>01716 <span class="comment">    This view security context (non-zero only for views with</span>
<a name="l01717"></a>01717 <span class="comment">    SQL SECURITY DEFINER)</span>
<a name="l01718"></a>01718 <span class="comment">  */</span>
<a name="l01719"></a>01719   Security_context *view_sctx;
<a name="l01720"></a>01720   <span class="comment">/*</span>
<a name="l01721"></a>01721 <span class="comment">    List of all base tables local to a subquery including all view</span>
<a name="l01722"></a>01722 <span class="comment">    tables. Unlike &#39;next_local&#39;, this in this list views are *not*</span>
<a name="l01723"></a>01723 <span class="comment">    leaves. Created in setup_tables() -&gt; make_leaves_list().</span>
<a name="l01724"></a>01724 <span class="comment">  */</span>
<a name="l01725"></a>01725   <span class="keywordtype">bool</span> allowed_show;
<a name="l01726"></a>01726   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>    *next_leaf;
<a name="l01727"></a>01727   <a class="code" href="classItem.html">Item</a>          *where;                 <span class="comment">/* VIEW WHERE clause condition */</span>
<a name="l01728"></a>01728   <a class="code" href="classItem.html">Item</a>          *check_option;          <span class="comment">/* WITH CHECK OPTION condition */</span>
<a name="l01729"></a>01729   LEX_STRING    select_stmt;            <span class="comment">/* text of (CREATE/SELECT) statement */</span>
<a name="l01730"></a>01730   LEX_STRING    md5;                    <span class="comment">/* md5 of query text */</span>
<a name="l01731"></a>01731   LEX_STRING    source;                 <span class="comment">/* source of CREATE VIEW */</span>
<a name="l01732"></a>01732   LEX_STRING    view_db;                <span class="comment">/* saved view database */</span>
<a name="l01733"></a>01733   LEX_STRING    view_name;              <span class="comment">/* saved view name */</span>
<a name="l01734"></a>01734   LEX_STRING    timestamp;              <span class="comment">/* GMT time stamp of last operation */</span>
<a name="l01735"></a>01735   <a class="code" href="structst__lex__user.html">st_lex_user</a>   definer;                <span class="comment">/* definer of view */</span>
<a name="l01736"></a>01736   ulonglong     file_version;           <span class="comment">/* version of file&#39;s field set */</span>
<a name="l01737"></a>01737   ulonglong     updatable_view;         <span class="comment">/* VIEW can be updated */</span>
<a name="l01746"></a><a class="code" href="structTABLE__LIST.html#a633281c70738815a782e14dad746f98d">01746</a>   ulonglong     <a class="code" href="structTABLE__LIST.html#a633281c70738815a782e14dad746f98d" title="The declared algorithm, if this is a view.">algorithm</a>;
<a name="l01747"></a>01747   ulonglong     view_suid;              <span class="comment">/* view is suid (TRUE dy default) */</span>
<a name="l01748"></a>01748   ulonglong     with_check;             <span class="comment">/* WITH CHECK OPTION */</span>
<a name="l01749"></a>01749   <span class="comment">/*</span>
<a name="l01750"></a>01750 <span class="comment">    effective value of WITH CHECK OPTION (differ for temporary table</span>
<a name="l01751"></a>01751 <span class="comment">    algorithm)</span>
<a name="l01752"></a>01752 <span class="comment">  */</span>
<a name="l01753"></a>01753   uint8         effective_with_check;
<a name="l01762"></a><a class="code" href="structTABLE__LIST.html#a7b7d076ac6306ba70e1344c12c16f8b3">01762</a>   enum_derived_type <a class="code" href="structTABLE__LIST.html#a7b7d076ac6306ba70e1344c12c16f8b3" title="The view algorithm that is actually used, if this is a view.">effective_algorithm</a>;
<a name="l01763"></a>01763   <a class="code" href="structst__grant__info.html" title="The current state of the privilege checking process for the current user, SQL statement and SQL objec...">GRANT_INFO</a>    grant;
<a name="l01764"></a>01764   <span class="comment">/* data need by some engines in query cache*/</span>
<a name="l01765"></a>01765   ulonglong     engine_data;
<a name="l01766"></a>01766   <span class="comment">/* call back function for asking handler about caching in query cache */</span>
<a name="l01767"></a>01767   qc_engine_callback callback_func;
<a name="l01768"></a>01768   thr_lock_type lock_type;
<a name="l01769"></a>01769   uint          outer_join;             <span class="comment">/* Which join type */</span>
<a name="l01770"></a>01770   uint          shared;                 <span class="comment">/* Used in multi-upd */</span>
<a name="l01771"></a>01771   <span class="keywordtype">size_t</span>        db_length;
<a name="l01772"></a>01772   <span class="keywordtype">size_t</span>        table_name_length;
<a name="l01773"></a>01773   <span class="keywordtype">bool</span>          updatable;              <span class="comment">/* VIEW/TABLE can be updated now */</span>
<a name="l01774"></a>01774   <span class="keywordtype">bool</span>          straight;               <span class="comment">/* optimize with prev table */</span>
<a name="l01775"></a>01775   <span class="keywordtype">bool</span>          updating;               <span class="comment">/* for replicate-do/ignore table */</span>
<a name="l01776"></a>01776   <span class="keywordtype">bool</span>          force_index;            <span class="comment">/* prefer index over table scan */</span>
<a name="l01777"></a>01777   <span class="keywordtype">bool</span>          ignore_leaves;          <span class="comment">/* preload only non-leaf nodes */</span>
<a name="l01778"></a>01778   table_map     dep_tables;             <span class="comment">/* tables the table depends on      */</span>
<a name="l01779"></a>01779   table_map     on_expr_dep_tables;     <span class="comment">/* tables on expression depends on  */</span>
<a name="l01780"></a>01780   <span class="keyword">struct </span><a class="code" href="structst__nested__join.html">st_nested_join</a> *nested_join;   <span class="comment">/* if the element is a nested join  */</span>
<a name="l01781"></a>01781   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *embedding;             <span class="comment">/* nested join containing the table */</span>
<a name="l01782"></a>01782   <a class="code" href="classList.html">List&lt;TABLE_LIST&gt;</a> *join_list;<span class="comment">/* join list the table belongs to   */</span>
<a name="l01783"></a>01783   <span class="keywordtype">bool</span>          cacheable_table;        <span class="comment">/* stop PS caching */</span>
<a name="l01784"></a>01784   <span class="comment">/* used in multi-upd/views privilege check */</span>
<a name="l01785"></a>01785   <span class="keywordtype">bool</span>          table_in_first_from_clause;
<a name="l01790"></a><a class="code" href="structTABLE__LIST.html#a258a1d3e3c052cd563fb5690b70e86e8">01790</a>   <span class="keyword">enum</span> enum_open_type <a class="code" href="structTABLE__LIST.html#a258a1d3e3c052cd563fb5690b70e86e8">open_type</a>;
<a name="l01791"></a>01791   <span class="comment">/* TRUE if this merged view contain auto_increment field */</span>
<a name="l01792"></a>01792   <span class="keywordtype">bool</span>          contain_auto_increment;
<a name="l01793"></a>01793   <span class="keywordtype">bool</span>          multitable_view;        <span class="comment">/* TRUE iff this is multitable view */</span>
<a name="l01794"></a>01794   <span class="keywordtype">bool</span>          compact_view_format;    <span class="comment">/* Use compact format for SHOW CREATE VIEW */</span>
<a name="l01795"></a>01795   <span class="comment">/* view where processed */</span>
<a name="l01796"></a>01796   <span class="keywordtype">bool</span>          where_processed;
<a name="l01797"></a>01797   <span class="comment">/* TRUE &lt;=&gt; VIEW CHECK OPTION expression has been processed */</span>
<a name="l01798"></a>01798   <span class="keywordtype">bool</span>          check_option_processed;
<a name="l01799"></a>01799   <span class="comment">/* FRMTYPE_ERROR if any type is acceptable */</span>
<a name="l01800"></a>01800   <span class="keyword">enum</span> frm_type_enum required_type;
<a name="l01801"></a>01801   <span class="keywordtype">char</span>          timestamp_buffer[20];   <span class="comment">/* buffer for timestamp (19+1) */</span>
<a name="l01802"></a>01802   <span class="comment">/*</span>
<a name="l01803"></a>01803 <span class="comment">    This TABLE_LIST object is just placeholder for prelocking, it will be</span>
<a name="l01804"></a>01804 <span class="comment">    used for implicit LOCK TABLES only and won&#39;t be used in real statement.</span>
<a name="l01805"></a>01805 <span class="comment">  */</span>
<a name="l01806"></a>01806   <span class="keywordtype">bool</span>          prelocking_placeholder;
<a name="l01811"></a>01811   <span class="keyword">enum</span>
<a name="l01812"></a>01812   {
<a name="l01813"></a>01813     <span class="comment">/* Normal open. */</span>
<a name="l01814"></a>01814     OPEN_NORMAL= 0,
<a name="l01815"></a>01815     <span class="comment">/* Associate a table share only if the the table exists. */</span>
<a name="l01816"></a>01816     OPEN_IF_EXISTS,
<a name="l01817"></a>01817     <span class="comment">/*</span>
<a name="l01818"></a>01818 <span class="comment">      Associate a table share only if the the table exists.</span>
<a name="l01819"></a>01819 <span class="comment">      Also upgrade metadata lock to exclusive if table doesn&#39;t exist.</span>
<a name="l01820"></a>01820 <span class="comment">    */</span>
<a name="l01821"></a>01821     OPEN_FOR_CREATE,
<a name="l01822"></a>01822     <span class="comment">/* Don&#39;t associate a table share. */</span>
<a name="l01823"></a>01823     OPEN_STUB
<a name="l01824"></a>01824   } <a class="code" href="structTABLE__LIST.html#a2f91ffa46082ff0e3bf0800de997117a">open_strategy</a>;
<a name="l01825"></a>01825   <span class="keywordtype">bool</span>          internal_tmp_table;
<a name="l01827"></a><a class="code" href="structTABLE__LIST.html#a43e85dbcb5379f852cf9ec23c069aa7a">01827</a>   <span class="keywordtype">bool</span>          <a class="code" href="structTABLE__LIST.html#a43e85dbcb5379f852cf9ec23c069aa7a">is_alias</a>;
<a name="l01831"></a><a class="code" href="structTABLE__LIST.html#a497fa25f3f142c883057ad2f37eae87c">01831</a>   <span class="keywordtype">bool</span>          <a class="code" href="structTABLE__LIST.html#a497fa25f3f142c883057ad2f37eae87c">is_fqtn</a>;
<a name="l01832"></a>01832 
<a name="l01833"></a>01833 
<a name="l01834"></a>01834   <span class="comment">/* View creation context. */</span>
<a name="l01835"></a>01835 
<a name="l01836"></a>01836   <a class="code" href="classView__creation__ctx.html">View_creation_ctx</a> *view_creation_ctx;
<a name="l01837"></a>01837 
<a name="l01838"></a>01838   <span class="comment">/*</span>
<a name="l01839"></a>01839 <span class="comment">    Attributes to save/load view creation context in/from frm-file.</span>
<a name="l01840"></a>01840 <span class="comment"></span>
<a name="l01841"></a>01841 <span class="comment">    Ther are required only to be able to use existing parser to load</span>
<a name="l01842"></a>01842 <span class="comment">    view-definition file. As soon as the parser parsed the file, view</span>
<a name="l01843"></a>01843 <span class="comment">    creation context is initialized and the attributes become redundant.</span>
<a name="l01844"></a>01844 <span class="comment"></span>
<a name="l01845"></a>01845 <span class="comment">    These attributes MUST NOT be used for any purposes but the parsing.</span>
<a name="l01846"></a>01846 <span class="comment">  */</span>
<a name="l01847"></a>01847 
<a name="l01848"></a>01848   LEX_STRING view_client_cs_name;
<a name="l01849"></a>01849   LEX_STRING view_connection_cl_name;
<a name="l01850"></a>01850 
<a name="l01851"></a>01851   <span class="comment">/*</span>
<a name="l01852"></a>01852 <span class="comment">    View definition (SELECT-statement) in the UTF-form.</span>
<a name="l01853"></a>01853 <span class="comment">  */</span>
<a name="l01854"></a>01854 
<a name="l01855"></a>01855   LEX_STRING view_body_utf8;
<a name="l01856"></a>01856 
<a name="l01857"></a>01857    <span class="comment">/* End of view definition context. */</span>
<a name="l01858"></a>01858   <span class="comment">/* List of possible keys. Valid only for materialized derived tables/views. */</span>
<a name="l01859"></a>01859   <a class="code" href="classList.html">List&lt;Derived_key&gt;</a> derived_key_list;
<a name="l01860"></a>01860 
<a name="l01866"></a><a class="code" href="structTABLE__LIST.html#afe86284f138571126421c238a7abb863">01866</a>   uint8 <a class="code" href="structTABLE__LIST.html#afe86284f138571126421c238a7abb863">trg_event_map</a>;
<a name="l01867"></a>01867   <span class="comment">/* TRUE &lt;=&gt; this table is a const one and was optimized away. */</span>
<a name="l01868"></a>01868   <span class="keywordtype">bool</span> optimized_away;
<a name="l01869"></a>01869   uint i_s_requested_object;
<a name="l01870"></a>01870   <span class="keywordtype">bool</span> has_db_lookup_value;
<a name="l01871"></a>01871   <span class="keywordtype">bool</span> has_table_lookup_value;
<a name="l01872"></a>01872   uint table_open_method;
<a name="l01873"></a>01873   <span class="keyword">enum</span> enum_schema_table_state schema_table_state;
<a name="l01874"></a>01874 
<a name="l01875"></a>01875   <a class="code" href="classMDL__request.html">MDL_request</a> mdl_request;
<a name="l01876"></a>01876 
<a name="l01877"></a>01877 <span class="preprocessor">#ifdef WITH_PARTITION_STORAGE_ENGINE</span>
<a name="l01878"></a>01878 <span class="preprocessor"></span>  <span class="comment">/* List to carry partition names from PARTITION (...) clause in statement */</span>
<a name="l01879"></a>01879   <a class="code" href="classList.html">List&lt;String&gt;</a> *partition_names;
<a name="l01880"></a>01880 <span class="preprocessor">#endif </span><span class="comment">/* WITH_PARTITION_STORAGE_ENGINE */</span>
<a name="l01881"></a>01881 
<a name="l01882"></a>01882   <span class="keywordtype">void</span> calc_md5(<span class="keywordtype">char</span> *buffer);
<a name="l01883"></a>01883   <span class="keywordtype">void</span> <a class="code" href="structTABLE__LIST.html#a3442b86fb09fd919be5e0ae14cf0795a" title="Set underlying table for table place holder of view.">set_underlying_merge</a>();
<a name="l01884"></a>01884   <span class="keywordtype">int</span> view_check_option(THD *thd, <span class="keywordtype">bool</span> ignore_failure) <span class="keyword">const</span>;
<a name="l01885"></a>01885   <span class="keywordtype">bool</span> setup_underlying(THD *thd);
<a name="l01886"></a>01886   <span class="keywordtype">void</span> <a class="code" href="group__Runtime__Environment.html#gaf7bccb54271a0546d92f2bc732abf3d1">cleanup_items</a>();
<a name="l01887"></a>01887   <span class="keywordtype">bool</span> placeholder()
<a name="l01888"></a>01888   {
<a name="l01889"></a>01889     <span class="keywordflow">return</span> <a class="code" href="structTABLE__LIST.html#ab1ea5a263b55f0aaa954a6ab78ed62b0" title="Normally, this field is non-null for anonymous derived tables only.">derived</a> || view || schema_table || !table;
<a name="l01890"></a>01890   }
<a name="l01891"></a>01891   <span class="keywordtype">void</span> <a class="code" href="structTABLE__LIST.html#a6bf6eacc31dbbbb0d00b89ed7b857a98">print</a>(THD *thd, <a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01892"></a>01892   <span class="keywordtype">bool</span> check_single_table(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> **table, table_map map,
<a name="l01893"></a>01893                           <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *view);
<a name="l01894"></a>01894   <span class="keywordtype">bool</span> set_insert_values(MEM_ROOT *mem_root);
<a name="l01895"></a>01895   <span class="keywordtype">void</span> <a class="code" href="structTABLE__LIST.html#a7299fd2a9872f80a303b84b7508d2a0e">hide_view_error</a>(THD *thd);
<a name="l01896"></a>01896   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *find_underlying_table(<a class="code" href="structTABLE.html">TABLE</a> *table);
<a name="l01897"></a>01897   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *first_leaf_for_name_resolution();
<a name="l01898"></a>01898   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *last_leaf_for_name_resolution();
<a name="l01899"></a>01899   <span class="keywordtype">bool</span> is_leaf_for_name_resolution();
<a name="l01900"></a>01900   <span class="keyword">inline</span> <span class="keyword">const</span> <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *top_table()<span class="keyword"> const</span>
<a name="l01901"></a>01901 <span class="keyword">    </span>{ <span class="keywordflow">return</span> belong_to_view ? belong_to_view : <span class="keyword">this</span>; }
<a name="l01902"></a>01902 
<a name="l01903"></a>01903   <span class="keyword">inline</span> <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *top_table()
<a name="l01904"></a>01904   {
<a name="l01905"></a>01905     <span class="keywordflow">return</span>
<a name="l01906"></a>01906       <span class="keyword">const_cast&lt;</span><a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>*<span class="keyword">&gt;</span>(<span class="keyword">const_cast&lt;</span><span class="keyword">const </span><a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>*<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;top_table());
<a name="l01907"></a>01907   }
<a name="l01908"></a>01908 
<a name="l01909"></a>01909   <span class="keyword">inline</span> <span class="keywordtype">bool</span> prepare_check_option(THD *thd)
<a name="l01910"></a>01910   {
<a name="l01911"></a>01911     <span class="keywordtype">bool</span> res= FALSE;
<a name="l01912"></a>01912     <span class="keywordflow">if</span> (effective_with_check)
<a name="l01913"></a>01913       res= prep_check_option(thd, effective_with_check);
<a name="l01914"></a>01914     <span class="keywordflow">return</span> res;
<a name="l01915"></a>01915   }
<a name="l01916"></a>01916   <span class="keyword">inline</span> <span class="keywordtype">bool</span> prepare_where(THD *thd, <a class="code" href="classItem.html">Item</a> **conds,
<a name="l01917"></a>01917                             <span class="keywordtype">bool</span> no_where_clause)
<a name="l01918"></a>01918   {
<a name="l01919"></a>01919     <span class="keywordflow">if</span> (<a class="code" href="structTABLE__LIST.html#a7b7d076ac6306ba70e1344c12c16f8b3" title="The view algorithm that is actually used, if this is a view.">effective_algorithm</a> == VIEW_ALGORITHM_MERGE)
<a name="l01920"></a>01920       <span class="keywordflow">return</span> prep_where(thd, conds, no_where_clause);
<a name="l01921"></a>01921     <span class="keywordflow">return</span> FALSE;
<a name="l01922"></a>01922   }
<a name="l01928"></a><a class="code" href="structTABLE__LIST.html#abb3af76875012772437ad9ffda36234f">01928</a>   <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="structTABLE__LIST.html#abb3af76875012772437ad9ffda36234f">uses_materialization</a>()<span class="keyword"> const</span>
<a name="l01929"></a>01929 <span class="keyword">  </span>{
<a name="l01930"></a>01930     <span class="keywordflow">return</span> (<a class="code" href="structTABLE__LIST.html#a7b7d076ac6306ba70e1344c12c16f8b3" title="The view algorithm that is actually used, if this is a view.">effective_algorithm</a> == VIEW_ALGORITHM_TMPTABLE ||
<a name="l01931"></a>01931             <a class="code" href="structTABLE__LIST.html#a7b7d076ac6306ba70e1344c12c16f8b3" title="The view algorithm that is actually used, if this is a view.">effective_algorithm</a> == DERIVED_ALGORITHM_TMPTABLE);
<a name="l01932"></a>01932   }
<a name="l01933"></a>01933   <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_view_or_derived()<span class="keyword"> const</span>
<a name="l01934"></a>01934 <span class="keyword">  </span>{
<a name="l01935"></a>01935     <span class="keywordflow">return</span> (<a class="code" href="structTABLE__LIST.html#a7b7d076ac6306ba70e1344c12c16f8b3" title="The view algorithm that is actually used, if this is a view.">effective_algorithm</a> != VIEW_ALGORITHM_UNDEFINED);
<a name="l01936"></a>01936   }
<a name="l01943"></a>01943   <span class="keywordtype">bool</span> <a class="code" href="structTABLE__LIST.html#a95e418c15a81f39daf64c8e9bfab1a9a">materializable_is_const</a>() <span class="keyword">const</span>;
<a name="l01944"></a>01944 
<a name="l01945"></a>01945   <span class="keywordtype">void</span> register_want_access(ulong want_access);
<a name="l01946"></a>01946   <span class="keywordtype">bool</span> prepare_security(THD *thd);
<a name="l01947"></a>01947 <span class="preprocessor">#ifndef NO_EMBEDDED_ACCESS_CHECKS</span>
<a name="l01948"></a>01948 <span class="preprocessor"></span>  Security_context *find_view_security_context(THD *thd);
<a name="l01949"></a>01949   <span class="keywordtype">bool</span> prepare_view_securety_context(THD *thd);
<a name="l01950"></a>01950 <span class="preprocessor">#endif</span>
<a name="l01951"></a>01951 <span class="preprocessor"></span>  <span class="comment">/*</span>
<a name="l01952"></a>01952 <span class="comment">    Cleanup for re-execution in a prepared statement or a stored</span>
<a name="l01953"></a>01953 <span class="comment">    procedure.</span>
<a name="l01954"></a>01954 <span class="comment">  */</span>
<a name="l01955"></a>01955   <span class="keywordtype">void</span> reinit_before_use(THD *thd);
<a name="l01956"></a>01956   <a class="code" href="classItem__subselect.html">Item_subselect</a> *containing_subselect();
<a name="l01957"></a>01957 
<a name="l01958"></a>01958   <span class="comment">/* </span>
<a name="l01959"></a>01959 <span class="comment">    Compiles the tagged hints list and fills up TABLE::keys_in_use_for_query,</span>
<a name="l01960"></a>01960 <span class="comment">    TABLE::keys_in_use_for_group_by, TABLE::keys_in_use_for_order_by,</span>
<a name="l01961"></a>01961 <span class="comment">    TABLE::force_index and TABLE::covering_keys.</span>
<a name="l01962"></a>01962 <span class="comment">  */</span>
<a name="l01963"></a>01963   <span class="keywordtype">bool</span> process_index_hints(<a class="code" href="structTABLE.html">TABLE</a> *table);
<a name="l01964"></a>01964 
<a name="l01972"></a>01972   <span class="keyword">inline</span>
<a name="l01973"></a><a class="code" href="structTABLE__LIST.html#adaa74dc24ec24b5f9123c840d10de011">01973</a>   <span class="keywordtype">bool</span> <a class="code" href="structTABLE__LIST.html#adaa74dc24ec24b5f9123c840d10de011">is_table_ref_id_equal</a>(<a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *s)<span class="keyword"> const</span>
<a name="l01974"></a>01974 <span class="keyword">  </span>{
<a name="l01975"></a>01975     <span class="keywordflow">return</span> (m_table_ref_type == s-&gt;<a class="code" href="structTABLE__SHARE.html#ac58358f786a71e0ede5213ee8ea571fd">get_table_ref_type</a>() &amp;&amp;
<a name="l01976"></a>01976             m_table_ref_version == s-&gt;<a class="code" href="structTABLE__SHARE.html#aa4eff60aaa18dab133cd8cf3ca672b25">get_table_ref_version</a>());
<a name="l01977"></a>01977   }
<a name="l01978"></a>01978 
<a name="l01985"></a>01985   <span class="keyword">inline</span>
<a name="l01986"></a><a class="code" href="structTABLE__LIST.html#a2bd270d99bc469b6fc0315f7fac39e04">01986</a>   <span class="keywordtype">void</span> <a class="code" href="structTABLE__LIST.html#a2bd270d99bc469b6fc0315f7fac39e04">set_table_ref_id</a>(<a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *s)
<a name="l01987"></a>01987   { <a class="code" href="structTABLE__LIST.html#a2bd270d99bc469b6fc0315f7fac39e04">set_table_ref_id</a>(s-&gt;<a class="code" href="structTABLE__SHARE.html#ac58358f786a71e0ede5213ee8ea571fd">get_table_ref_type</a>(), s-&gt;<a class="code" href="structTABLE__SHARE.html#aa4eff60aaa18dab133cd8cf3ca672b25">get_table_ref_version</a>()); }
<a name="l01988"></a>01988 
<a name="l01989"></a>01989   <span class="keyword">inline</span>
<a name="l01990"></a>01990   <span class="keywordtype">void</span> <a class="code" href="structTABLE__LIST.html#a2bd270d99bc469b6fc0315f7fac39e04">set_table_ref_id</a>(enum_table_ref_type table_ref_type_arg,
<a name="l01991"></a>01991                         ulonglong table_ref_version_arg)
<a name="l01992"></a>01992   {
<a name="l01993"></a>01993     m_table_ref_type= table_ref_type_arg;
<a name="l01994"></a>01994     m_table_ref_version= table_ref_version_arg;
<a name="l01995"></a>01995   }
<a name="l01996"></a>01996 
<a name="l02001"></a><a class="code" href="structTABLE__LIST.html#a87bee8dfc47025d90077327538b2d471">02001</a>   <span class="keywordtype">bool</span> <a class="code" href="structTABLE__LIST.html#a87bee8dfc47025d90077327538b2d471" title="True if this TABLE_LIST represents an anonymous derived table, i.e. the result of a subquery...">is_anonymous_derived_table</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="structTABLE__LIST.html#ab1ea5a263b55f0aaa954a6ab78ed62b0" title="Normally, this field is non-null for anonymous derived tables only.">derived</a> &amp;&amp; !view; }
<a name="l02002"></a>02002 
<a name="l02004"></a>02004   uint <a class="code" href="structTABLE__LIST.html#a281d4d67e8b13a145391e94d4fffb2d8" title="returns query block id for derived table, and zero if not derived.">query_block_id</a>() <span class="keyword">const</span>;
<a name="l02005"></a>02005 
<a name="l02010"></a><a class="code" href="structTABLE__LIST.html#ab894fbb60a2b9dafac83728e4fdde9cf">02010</a>   <span class="keywordtype">char</span> *<a class="code" href="structTABLE__LIST.html#ab894fbb60a2b9dafac83728e4fdde9cf" title="Returns the name of the database that the referenced table belongs to.">get_db_name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> view != NULL ? view_db.str : db; }
<a name="l02011"></a>02011 
<a name="l02018"></a><a class="code" href="structTABLE__LIST.html#a481c56715a09aeaeb839cf2919cd7d8d">02018</a>   <span class="keywordtype">char</span> *<a class="code" href="structTABLE__LIST.html#a481c56715a09aeaeb839cf2919cd7d8d" title="Returns the name of the table that this TABLE_LIST represents.">get_table_name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> view != NULL ? view_name.str : table_name; }
<a name="l02019"></a>02019   <span class="keywordtype">int</span> <a class="code" href="structTABLE__LIST.html#a8ff5480f49562c213faf73c3a7f0dc15" title="Retrieve number of rows in the table.">fetch_number_of_rows</a>();
<a name="l02020"></a>02020   <span class="keywordtype">bool</span> update_derived_keys(<a class="code" href="classField.html">Field</a>*, <a class="code" href="classItem.html">Item</a>**, uint);
<a name="l02021"></a>02021   <span class="keywordtype">bool</span> <a class="code" href="structTABLE__LIST.html#a6997748d74d5802c625d2db9f423ba58" title="Generate keys for a materialized derived table/view.">generate_keys</a>();
<a name="l02022"></a>02022   <span class="keywordtype">bool</span> handle_derived(LEX *lex, <span class="keywordtype">bool</span> (*processor)(THD*, LEX*, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a>*));
<a name="l02023"></a>02023   st_select_lex_unit *<a class="code" href="structTABLE__LIST.html#ad973edb44112b65e6d902316d7cd77f6" title="Return unit of this derived table/view.">get_unit</a>() <span class="keyword">const</span>;
<a name="l02024"></a>02024 
<a name="l02042"></a><a class="code" href="structTABLE__LIST.html#a6b0159220d6bc7b5043a0b562633b02e">02042</a>   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *<a class="code" href="structTABLE__LIST.html#a6b0159220d6bc7b5043a0b562633b02e" title="Returns the outer join nest that this TABLE_LIST belongs to, if any.">outer_join_nest</a>()<span class="keyword"> const</span>
<a name="l02043"></a>02043 <span class="keyword">  </span>{
<a name="l02044"></a>02044     <span class="keywordflow">if</span> (!embedding)
<a name="l02045"></a>02045       <span class="keywordflow">return</span> NULL;
<a name="l02046"></a>02046     <span class="keywordflow">if</span> (embedding-&gt;sj_on_expr)
<a name="l02047"></a>02047       <span class="keywordflow">return</span> embedding-&gt;embedding;
<a name="l02048"></a>02048     <span class="keywordflow">return</span> embedding;
<a name="l02049"></a>02049   }
<a name="l02050"></a>02050 
<a name="l02051"></a>02051 <span class="keyword">private</span>:
<a name="l02052"></a>02052   <span class="keywordtype">bool</span> prep_check_option(THD *thd, uint8 check_opt_type);
<a name="l02053"></a>02053   <span class="keywordtype">bool</span> prep_where(THD *thd, <a class="code" href="classItem.html">Item</a> **conds, <span class="keywordtype">bool</span> no_where_clause);
<a name="l02055"></a>02055   <span class="keyword">enum</span> enum_table_ref_type m_table_ref_type;
<a name="l02057"></a>02057   ulonglong m_table_ref_version;
<a name="l02058"></a>02058 };
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 
<a name="l02061"></a>02061 <span class="keyword">struct </span><a class="code" href="structst__position.html">st_position</a>;
<a name="l02062"></a>02062   
<a name="l02063"></a>02063 <span class="keyword">class </span><a class="code" href="classItem.html">Item</a>;
<a name="l02064"></a>02064 
<a name="l02065"></a>02065 <span class="comment">/*</span>
<a name="l02066"></a>02066 <span class="comment">  Iterator over the fields of a generic table reference.</span>
<a name="l02067"></a>02067 <span class="comment">*/</span>
<a name="l02068"></a>02068 
<a name="l02069"></a><a class="code" href="classField__iterator.html">02069</a> <span class="keyword">class </span><a class="code" href="classField__iterator.html">Field_iterator</a>: <span class="keyword">public</span> <a class="code" href="classSql__alloc.html">Sql_alloc</a>
<a name="l02070"></a>02070 {
<a name="l02071"></a>02071 <span class="keyword">public</span>:
<a name="l02072"></a>02072   <a class="code" href="classField__iterator.html">Field_iterator</a>() {}                         <span class="comment">/* Remove gcc warning */</span>
<a name="l02073"></a>02073   <span class="keyword">virtual</span> ~<a class="code" href="classField__iterator.html">Field_iterator</a>() {}
<a name="l02074"></a>02074   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *)= 0;
<a name="l02075"></a>02075   <span class="keyword">virtual</span> <span class="keywordtype">void</span> next()= 0;
<a name="l02076"></a>02076   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> end_of_fields()= 0;              <span class="comment">/* Return 1 at end of list */</span>
<a name="l02077"></a>02077   <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *name()= 0;
<a name="l02078"></a>02078   <span class="keyword">virtual</span> <a class="code" href="classItem.html">Item</a> *create_item(THD *)= 0;
<a name="l02079"></a>02079   <span class="keyword">virtual</span> <a class="code" href="classField.html">Field</a> *field()= 0;
<a name="l02080"></a>02080 };
<a name="l02081"></a>02081 
<a name="l02082"></a>02082 
<a name="l02083"></a>02083 <span class="comment">/* </span>
<a name="l02084"></a>02084 <span class="comment">  Iterator over the fields of a base table, view with temporary</span>
<a name="l02085"></a>02085 <span class="comment">  table, or subquery.</span>
<a name="l02086"></a>02086 <span class="comment">*/</span>
<a name="l02087"></a>02087 
<a name="l02088"></a><a class="code" href="classField__iterator__table.html">02088</a> <span class="keyword">class </span><a class="code" href="classField__iterator__table.html">Field_iterator_table</a>: <span class="keyword">public</span> <a class="code" href="classField__iterator.html">Field_iterator</a>
<a name="l02089"></a>02089 {
<a name="l02090"></a>02090   <a class="code" href="classField.html">Field</a> **ptr;
<a name="l02091"></a>02091 <span class="keyword">public</span>:
<a name="l02092"></a>02092   <a class="code" href="classField__iterator__table.html">Field_iterator_table</a>() :ptr(0) {}
<a name="l02093"></a>02093   <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table) { ptr= table-&gt;table-&gt;field; }
<a name="l02094"></a>02094   <span class="keywordtype">void</span> set_table(<a class="code" href="structTABLE.html">TABLE</a> *table) { ptr= table-&gt;field; }
<a name="l02095"></a>02095   <span class="keywordtype">void</span> next() { ptr++; }
<a name="l02096"></a>02096   <span class="keywordtype">bool</span> end_of_fields() { <span class="keywordflow">return</span> *ptr == 0; }
<a name="l02097"></a>02097   <span class="keyword">const</span> <span class="keywordtype">char</span> *name();
<a name="l02098"></a>02098   <a class="code" href="classItem.html">Item</a> *create_item(THD *thd);
<a name="l02099"></a>02099   <a class="code" href="classField.html">Field</a> *field() { <span class="keywordflow">return</span> *ptr; }
<a name="l02100"></a>02100 };
<a name="l02101"></a>02101 
<a name="l02102"></a>02102 
<a name="l02103"></a>02103 <span class="comment">/* Iterator over the fields of a merge view. */</span>
<a name="l02104"></a>02104 
<a name="l02105"></a><a class="code" href="classField__iterator__view.html">02105</a> <span class="keyword">class </span><a class="code" href="classField__iterator__view.html">Field_iterator_view</a>: <span class="keyword">public</span> <a class="code" href="classField__iterator.html">Field_iterator</a>
<a name="l02106"></a>02106 {
<a name="l02107"></a>02107   <a class="code" href="structField__translator.html">Field_translator</a> *ptr, *array_end;
<a name="l02108"></a>02108   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *view;
<a name="l02109"></a>02109 <span class="keyword">public</span>:
<a name="l02110"></a>02110   <a class="code" href="classField__iterator__view.html">Field_iterator_view</a>() :ptr(0), array_end(0) {}
<a name="l02111"></a>02111   <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table);
<a name="l02112"></a>02112   <span class="keywordtype">void</span> next() { ptr++; }
<a name="l02113"></a>02113   <span class="keywordtype">bool</span> end_of_fields() { <span class="keywordflow">return</span> ptr == array_end; }
<a name="l02114"></a>02114   <span class="keyword">const</span> <span class="keywordtype">char</span> *name();
<a name="l02115"></a>02115   <a class="code" href="classItem.html">Item</a> *create_item(THD *thd);
<a name="l02116"></a>02116   <a class="code" href="classItem.html">Item</a> **item_ptr() {<span class="keywordflow">return</span> &amp;ptr-&gt;item; }
<a name="l02117"></a>02117   <a class="code" href="classField.html">Field</a> *field() { <span class="keywordflow">return</span> 0; }
<a name="l02118"></a>02118   <span class="keyword">inline</span> <a class="code" href="classItem.html">Item</a> *item() { <span class="keywordflow">return</span> ptr-&gt;item; }
<a name="l02119"></a>02119   <a class="code" href="structField__translator.html">Field_translator</a> *field_translator() { <span class="keywordflow">return</span> ptr; }
<a name="l02120"></a>02120 };
<a name="l02121"></a>02121 
<a name="l02122"></a>02122 
<a name="l02123"></a>02123 <span class="comment">/*</span>
<a name="l02124"></a>02124 <span class="comment">  Field_iterator interface to the list of materialized fields of a</span>
<a name="l02125"></a>02125 <span class="comment">  NATURAL/USING join.</span>
<a name="l02126"></a>02126 <span class="comment">*/</span>
<a name="l02127"></a>02127 
<a name="l02128"></a><a class="code" href="classField__iterator__natural__join.html">02128</a> <span class="keyword">class </span><a class="code" href="classField__iterator__natural__join.html">Field_iterator_natural_join</a>: <span class="keyword">public</span> <a class="code" href="classField__iterator.html">Field_iterator</a>
<a name="l02129"></a>02129 {
<a name="l02130"></a>02130   <a class="code" href="classList__iterator__fast.html">List_iterator_fast&lt;Natural_join_column&gt;</a> column_ref_it;
<a name="l02131"></a>02131   <a class="code" href="classNatural__join__column.html">Natural_join_column</a> *cur_column_ref;
<a name="l02132"></a>02132 <span class="keyword">public</span>:
<a name="l02133"></a>02133   <a class="code" href="classField__iterator__natural__join.html">Field_iterator_natural_join</a>() :cur_column_ref(NULL) {}
<a name="l02134"></a>02134   ~<a class="code" href="classField__iterator__natural__join.html">Field_iterator_natural_join</a>() {}
<a name="l02135"></a>02135   <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table);
<a name="l02136"></a>02136   <span class="keywordtype">void</span> next();
<a name="l02137"></a>02137   <span class="keywordtype">bool</span> end_of_fields() { <span class="keywordflow">return</span> !cur_column_ref; }
<a name="l02138"></a>02138   <span class="keyword">const</span> <span class="keywordtype">char</span> *name() { <span class="keywordflow">return</span> cur_column_ref-&gt;name(); }
<a name="l02139"></a>02139   <a class="code" href="classItem.html">Item</a> *create_item(THD *thd) { <span class="keywordflow">return</span> cur_column_ref-&gt;create_item(thd); }
<a name="l02140"></a>02140   <a class="code" href="classField.html">Field</a> *field() { <span class="keywordflow">return</span> cur_column_ref-&gt;field(); }
<a name="l02141"></a>02141   <a class="code" href="classNatural__join__column.html">Natural_join_column</a> *column_ref() { <span class="keywordflow">return</span> cur_column_ref; }
<a name="l02142"></a>02142 };
<a name="l02143"></a>02143 
<a name="l02144"></a>02144 
<a name="l02145"></a>02145 <span class="comment">/*</span>
<a name="l02146"></a>02146 <span class="comment">  Generic iterator over the fields of an arbitrary table reference.</span>
<a name="l02147"></a>02147 <span class="comment"></span>
<a name="l02148"></a>02148 <span class="comment">  DESCRIPTION</span>
<a name="l02149"></a>02149 <span class="comment">    This class unifies the various ways of iterating over the columns</span>
<a name="l02150"></a>02150 <span class="comment">    of a table reference depending on the type of SQL entity it</span>
<a name="l02151"></a>02151 <span class="comment">    represents. If such an entity represents a nested table reference,</span>
<a name="l02152"></a>02152 <span class="comment">    this iterator encapsulates the iteration over the columns of the</span>
<a name="l02153"></a>02153 <span class="comment">    members of the table reference.</span>
<a name="l02154"></a>02154 <span class="comment"></span>
<a name="l02155"></a>02155 <span class="comment">  IMPLEMENTATION</span>
<a name="l02156"></a>02156 <span class="comment">    The implementation assumes that all underlying NATURAL/USING table</span>
<a name="l02157"></a>02157 <span class="comment">    references already contain their result columns and are linked into</span>
<a name="l02158"></a>02158 <span class="comment">    the list TABLE_LIST::next_name_resolution_table.</span>
<a name="l02159"></a>02159 <span class="comment">*/</span>
<a name="l02160"></a>02160 
<a name="l02161"></a><a class="code" href="classField__iterator__table__ref.html">02161</a> <span class="keyword">class </span><a class="code" href="classField__iterator__table__ref.html">Field_iterator_table_ref</a>: <span class="keyword">public</span> <a class="code" href="classField__iterator.html">Field_iterator</a>
<a name="l02162"></a>02162 {
<a name="l02163"></a>02163   <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_ref, *first_leaf, *last_leaf;
<a name="l02164"></a>02164   <a class="code" href="classField__iterator__table.html">Field_iterator_table</a>        table_field_it;
<a name="l02165"></a>02165   <a class="code" href="classField__iterator__view.html">Field_iterator_view</a>         view_field_it;
<a name="l02166"></a>02166   <a class="code" href="classField__iterator__natural__join.html">Field_iterator_natural_join</a> natural_join_it;
<a name="l02167"></a>02167   <a class="code" href="classField__iterator.html">Field_iterator</a> *field_it;
<a name="l02168"></a>02168   <span class="keywordtype">void</span> set_field_iterator();
<a name="l02169"></a>02169 <span class="keyword">public</span>:
<a name="l02170"></a>02170   <a class="code" href="classField__iterator__table__ref.html">Field_iterator_table_ref</a>() :field_it(NULL) {}
<a name="l02171"></a>02171   <span class="keywordtype">void</span> <span class="keyword">set</span>(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table);
<a name="l02172"></a>02172   <span class="keywordtype">void</span> next();
<a name="l02173"></a>02173   <span class="keywordtype">bool</span> end_of_fields()
<a name="l02174"></a>02174   { <span class="keywordflow">return</span> (table_ref == last_leaf &amp;&amp; field_it-&gt;end_of_fields()); }
<a name="l02175"></a>02175   <span class="keyword">const</span> <span class="keywordtype">char</span> *name() { <span class="keywordflow">return</span> field_it-&gt;name(); }
<a name="l02176"></a>02176   <span class="keyword">const</span> <span class="keywordtype">char</span> *get_table_name();
<a name="l02177"></a>02177   <span class="keyword">const</span> <span class="keywordtype">char</span> *get_db_name();
<a name="l02178"></a>02178   <a class="code" href="structst__grant__info.html" title="The current state of the privilege checking process for the current user, SQL statement and SQL objec...">GRANT_INFO</a> *grant();
<a name="l02179"></a>02179   <a class="code" href="classItem.html">Item</a> *create_item(THD *thd) { <span class="keywordflow">return</span> field_it-&gt;create_item(thd); }
<a name="l02180"></a>02180   <a class="code" href="classField.html">Field</a> *field() { <span class="keywordflow">return</span> field_it-&gt;field(); }
<a name="l02181"></a>02181   <a class="code" href="classNatural__join__column.html">Natural_join_column</a> *get_or_create_column_ref(THD *thd, <a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *parent_table_ref);
<a name="l02182"></a>02182   <a class="code" href="classNatural__join__column.html">Natural_join_column</a> *get_natural_column_ref();
<a name="l02183"></a>02183 };
<a name="l02184"></a>02184 
<a name="l02191"></a><a class="code" href="structSemijoin__mat__optimize.html">02191</a> <span class="keyword">struct </span><a class="code" href="structSemijoin__mat__optimize.html">Semijoin_mat_optimize</a>
<a name="l02192"></a>02192 {
<a name="l02194"></a><a class="code" href="structSemijoin__mat__optimize.html#a64190010b2d734e906ad6c3cb63d3832">02194</a>   <span class="keyword">struct </span><a class="code" href="structst__position.html">st_position</a> *<a class="code" href="structSemijoin__mat__optimize.html#a64190010b2d734e906ad6c3cb63d3832" title="Optimal join order calculated for inner tables of this semijoin op.">positions</a>;
<a name="l02196"></a><a class="code" href="structSemijoin__mat__optimize.html#a5a5be2d028c3bc10f2053b5d64fdc037">02196</a>   <span class="keywordtype">bool</span> <a class="code" href="structSemijoin__mat__optimize.html#a5a5be2d028c3bc10f2053b5d64fdc037" title="True if data types allow the MaterializeLookup semijoin strategy.">lookup_allowed</a>;
<a name="l02198"></a><a class="code" href="structSemijoin__mat__optimize.html#a00ed7608a42f44e46c66118a9a325699">02198</a>   <span class="keywordtype">bool</span> <a class="code" href="structSemijoin__mat__optimize.html#a00ed7608a42f44e46c66118a9a325699" title="True if data types allow the MaterializeScan semijoin strategy.">scan_allowed</a>;
<a name="l02200"></a><a class="code" href="structSemijoin__mat__optimize.html#a933e3977fcf5bf765573cff3740743c8">02200</a>   <span class="keywordtype">double</span> <a class="code" href="structSemijoin__mat__optimize.html#a933e3977fcf5bf765573cff3740743c8" title="Expected #rows in the materialized table.">expected_rowcount</a>;
<a name="l02202"></a><a class="code" href="structSemijoin__mat__optimize.html#aa9c3f89722ff096a12dd4e203e514c78">02202</a>   <a class="code" href="classCost__estimate.html">Cost_estimate</a> <a class="code" href="structSemijoin__mat__optimize.html#aa9c3f89722ff096a12dd4e203e514c78" title="Materialization cost - execute sub-join and write rows to temp.table.">materialization_cost</a>;
<a name="l02204"></a><a class="code" href="structSemijoin__mat__optimize.html#ab0884cb4a9503fadf397370b031c21b2">02204</a>   <a class="code" href="classCost__estimate.html">Cost_estimate</a> <a class="code" href="structSemijoin__mat__optimize.html#ab0884cb4a9503fadf397370b031c21b2" title="Cost to make one lookup in the temptable.">lookup_cost</a>;
<a name="l02206"></a><a class="code" href="structSemijoin__mat__optimize.html#ac12a0028b62abbb8fb77371a5a8d9cf7">02206</a>   <a class="code" href="classCost__estimate.html">Cost_estimate</a> <a class="code" href="structSemijoin__mat__optimize.html#ac12a0028b62abbb8fb77371a5a8d9cf7" title="Cost of scanning the materialized table.">scan_cost</a>;
<a name="l02208"></a><a class="code" href="structSemijoin__mat__optimize.html#af0527a7114db374cb66b121b081e3df3">02208</a>   <a class="code" href="classItem__field.html">Item_field</a> **<a class="code" href="structSemijoin__mat__optimize.html#af0527a7114db374cb66b121b081e3df3" title="Array of pointers to fields in the materialized table.">mat_fields</a>;
<a name="l02209"></a>02209 };
<a name="l02210"></a>02210 
<a name="l02219"></a><a class="code" href="structst__nested__join.html">02219</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__nested__join.html">st_nested_join</a>
<a name="l02220"></a>02220 {
<a name="l02221"></a>02221   <a class="code" href="classList.html">List&lt;TABLE_LIST&gt;</a>  join_list;       <span class="comment">/* list of elements in the nested join */</span>
<a name="l02222"></a>02222   table_map         used_tables;     <span class="comment">/* bitmap of tables in the nested join */</span>
<a name="l02223"></a>02223   table_map         not_null_tables; <span class="comment">/* tables that rejects nulls           */</span>
<a name="l02228"></a><a class="code" href="structst__nested__join.html#a5bffb6d66c0390e8fa0cf06b84fc7fcb">02228</a>   <span class="keyword">struct </span><a class="code" href="structst__join__table.html">st_join_table</a> *<a class="code" href="structst__nested__join.html#a5bffb6d66c0390e8fa0cf06b84fc7fcb">first_nested</a>;
<a name="l02235"></a><a class="code" href="structst__nested__join.html#a9c35fa9ceadc335b3a9c06e498d4f8e5">02235</a>   uint              <a class="code" href="structst__nested__join.html#a9c35fa9ceadc335b3a9c06e498d4f8e5">nj_total</a>;
<a name="l02243"></a><a class="code" href="structst__nested__join.html#a361b5386d86e7de51ef7241de0de3fd3">02243</a>   uint              <a class="code" href="structst__nested__join.html#a361b5386d86e7de51ef7241de0de3fd3">nj_counter</a>;
<a name="l02248"></a><a class="code" href="structst__nested__join.html#a46f1da529bd60920ec39ab4082cade2e">02248</a>   nested_join_map   <a class="code" href="structst__nested__join.html#a46f1da529bd60920ec39ab4082cade2e">nj_map</a>;
<a name="l02253"></a><a class="code" href="structst__nested__join.html#a9076f50ec461d7ff2340d77f89fac1e9">02253</a>   table_map         <a class="code" href="structst__nested__join.html#a9076f50ec461d7ff2340d77f89fac1e9">sj_depends_on</a>;
<a name="l02257"></a><a class="code" href="structst__nested__join.html#ab4542c325c02396712de1f629fd621a9">02257</a>   table_map         <a class="code" href="structst__nested__join.html#ab4542c325c02396712de1f629fd621a9">sj_corr_tables</a>;
<a name="l02261"></a><a class="code" href="structst__nested__join.html#ae77e1736a81f0c6de9df6d9953106f12">02261</a>   uint <a class="code" href="structst__nested__join.html#ae77e1736a81f0c6de9df6d9953106f12">query_block_id</a>;
<a name="l02262"></a>02262   <span class="comment">/*</span>
<a name="l02263"></a>02263 <span class="comment">    Lists of trivially-correlated expressions from the outer and inner tables</span>
<a name="l02264"></a>02264 <span class="comment">    of the semi-join, respectively.</span>
<a name="l02265"></a>02265 <span class="comment">  */</span>
<a name="l02266"></a>02266   <a class="code" href="classList.html">List&lt;Item&gt;</a>        sj_outer_exprs, sj_inner_exprs;
<a name="l02267"></a>02267   <a class="code" href="structSemijoin__mat__optimize.html">Semijoin_mat_optimize</a> sjm;
<a name="l02268"></a>02268 } <a class="code" href="structst__nested__join.html">NESTED_JOIN</a>;
<a name="l02269"></a>02269 
<a name="l02270"></a>02270 
<a name="l02271"></a><a class="code" href="structst__changed__table__list.html">02271</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__changed__table__list.html">st_changed_table_list</a>
<a name="l02272"></a>02272 {
<a name="l02273"></a>02273   <span class="keyword">struct        </span><a class="code" href="structst__changed__table__list.html">st_changed_table_list</a> *next;
<a name="l02274"></a>02274   <span class="keywordtype">char</span>          *key;
<a name="l02275"></a>02275   uint32        key_length;
<a name="l02276"></a>02276 } <a class="code" href="structst__changed__table__list.html">CHANGED_TABLE_LIST</a>;
<a name="l02277"></a>02277 
<a name="l02278"></a>02278 
<a name="l02279"></a><a class="code" href="structst__open__table__list.html">02279</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structst__open__table__list.html">st_open_table_list</a>{
<a name="l02280"></a>02280   <span class="keyword">struct </span><a class="code" href="structst__open__table__list.html">st_open_table_list</a> *next;
<a name="l02281"></a>02281   <span class="keywordtype">char</span>  *db,*table;
<a name="l02282"></a>02282   uint32 in_use,locked;
<a name="l02283"></a>02283 } <a class="code" href="structst__open__table__list.html">OPEN_TABLE_LIST</a>;
<a name="l02284"></a>02284 
<a name="l02285"></a>02285 
<a name="l02286"></a>02286 <span class="keyword">static</span> <span class="keyword">inline</span> my_bitmap_map *tmp_use_all_columns(<a class="code" href="structTABLE.html">TABLE</a> *table,
<a name="l02287"></a>02287                                                  MY_BITMAP *bitmap)
<a name="l02288"></a>02288 {
<a name="l02289"></a>02289   my_bitmap_map *old= bitmap-&gt;bitmap;
<a name="l02290"></a>02290   bitmap-&gt;bitmap= table-&gt;s-&gt;all_set.bitmap;<span class="comment">// does not repoint last_word_ptr</span>
<a name="l02291"></a>02291   <span class="keywordflow">return</span> old;
<a name="l02292"></a>02292 }
<a name="l02293"></a>02293 
<a name="l02294"></a>02294 
<a name="l02295"></a>02295 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> tmp_restore_column_map(MY_BITMAP *bitmap,
<a name="l02296"></a>02296                                           my_bitmap_map *old)
<a name="l02297"></a>02297 {
<a name="l02298"></a>02298   bitmap-&gt;bitmap= old;
<a name="l02299"></a>02299 }
<a name="l02300"></a>02300 
<a name="l02301"></a>02301 <span class="comment">/* The following is only needed for debugging */</span>
<a name="l02302"></a>02302 
<a name="l02303"></a>02303 <span class="keyword">static</span> <span class="keyword">inline</span> my_bitmap_map *dbug_tmp_use_all_columns(<a class="code" href="structTABLE.html">TABLE</a> *table,
<a name="l02304"></a>02304                                                       MY_BITMAP *bitmap)
<a name="l02305"></a>02305 {
<a name="l02306"></a>02306 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02307"></a>02307 <span class="preprocessor"></span>  <span class="keywordflow">return</span> tmp_use_all_columns(table, bitmap);
<a name="l02308"></a>02308 <span class="preprocessor">#else</span>
<a name="l02309"></a>02309 <span class="preprocessor"></span>  <span class="keywordflow">return</span> 0;
<a name="l02310"></a>02310 <span class="preprocessor">#endif</span>
<a name="l02311"></a>02311 <span class="preprocessor"></span>}
<a name="l02312"></a>02312 
<a name="l02313"></a>02313 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> dbug_tmp_restore_column_map(MY_BITMAP *bitmap,
<a name="l02314"></a>02314                                                my_bitmap_map *old)
<a name="l02315"></a>02315 {
<a name="l02316"></a>02316 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02317"></a>02317 <span class="preprocessor"></span>  tmp_restore_column_map(bitmap, old);
<a name="l02318"></a>02318 <span class="preprocessor">#endif</span>
<a name="l02319"></a>02319 <span class="preprocessor"></span>}
<a name="l02320"></a>02320 
<a name="l02321"></a>02321 
<a name="l02322"></a>02322 <span class="comment">/* </span>
<a name="l02323"></a>02323 <span class="comment">  Variant of the above : handle both read and write sets.</span>
<a name="l02324"></a>02324 <span class="comment">  Provide for the possiblity of the read set being the same as the write set</span>
<a name="l02325"></a>02325 <span class="comment">*/</span>
<a name="l02326"></a>02326 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> dbug_tmp_use_all_columns(<a class="code" href="structTABLE.html">TABLE</a> *table,
<a name="l02327"></a>02327                                             my_bitmap_map **save,
<a name="l02328"></a>02328                                             MY_BITMAP *read_set,
<a name="l02329"></a>02329                                             MY_BITMAP *write_set)
<a name="l02330"></a>02330 {
<a name="l02331"></a>02331 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02332"></a>02332 <span class="preprocessor"></span>  save[0]= read_set-&gt;bitmap;
<a name="l02333"></a>02333   save[1]= write_set-&gt;bitmap;
<a name="l02334"></a>02334   (void) tmp_use_all_columns(table, read_set);
<a name="l02335"></a>02335   (void) tmp_use_all_columns(table, write_set);
<a name="l02336"></a>02336 <span class="preprocessor">#endif</span>
<a name="l02337"></a>02337 <span class="preprocessor"></span>}
<a name="l02338"></a>02338 
<a name="l02339"></a>02339 
<a name="l02340"></a>02340 <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> dbug_tmp_restore_column_maps(MY_BITMAP *read_set,
<a name="l02341"></a>02341                                                 MY_BITMAP *write_set,
<a name="l02342"></a>02342                                                 my_bitmap_map **old)
<a name="l02343"></a>02343 {
<a name="l02344"></a>02344 <span class="preprocessor">#ifndef DBUG_OFF</span>
<a name="l02345"></a>02345 <span class="preprocessor"></span>  tmp_restore_column_map(read_set, old[0]);
<a name="l02346"></a>02346   tmp_restore_column_map(write_set, old[1]);
<a name="l02347"></a>02347 <span class="preprocessor">#endif</span>
<a name="l02348"></a>02348 <span class="preprocessor"></span>}
<a name="l02349"></a>02349 
<a name="l02350"></a>02350 
<a name="l02351"></a>02351 <span class="keywordtype">size_t</span> max_row_length(<a class="code" href="structTABLE.html">TABLE</a> *table, <span class="keyword">const</span> uchar *data);
<a name="l02352"></a>02352 
<a name="l02353"></a>02353 
<a name="l02354"></a>02354 <span class="keywordtype">void</span> init_mdl_requests(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list);
<a name="l02355"></a>02355 
<a name="l02356"></a>02356 <span class="keywordtype">int</span> open_table_from_share(THD *thd, <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <span class="keyword">const</span> <span class="keywordtype">char</span> *alias,
<a name="l02357"></a>02357                           uint db_stat, uint prgflag, uint ha_open_flags,
<a name="l02358"></a>02358                           <a class="code" href="structTABLE.html">TABLE</a> *outparam, <span class="keywordtype">bool</span> is_create_table);
<a name="l02359"></a>02359 <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *alloc_table_share(<a class="code" href="structTABLE__LIST.html">TABLE_LIST</a> *table_list, <span class="keyword">const</span> <span class="keywordtype">char</span> *key,
<a name="l02360"></a>02360                                uint key_length);
<a name="l02361"></a>02361 <span class="keywordtype">void</span> init_tmp_table_share(THD *thd, <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <span class="keyword">const</span> <span class="keywordtype">char</span> *key,
<a name="l02362"></a>02362                           uint key_length,
<a name="l02363"></a>02363                           <span class="keyword">const</span> <span class="keywordtype">char</span> *table_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *path);
<a name="l02364"></a>02364 <span class="keywordtype">void</span> free_table_share(<a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share);
<a name="l02365"></a>02365 <span class="keywordtype">int</span> open_table_def(THD *thd, <a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, uint db_flags);
<a name="l02366"></a>02366 <span class="keywordtype">void</span> open_table_error(<a class="code" href="structTABLE__SHARE.html">TABLE_SHARE</a> *share, <span class="keywordtype">int</span> error, <span class="keywordtype">int</span> db_errno, <span class="keywordtype">int</span> errarg);
<a name="l02367"></a>02367 <span class="keywordtype">void</span> update_create_info_from_table(<a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *info, <a class="code" href="structTABLE.html">TABLE</a> *form);
<a name="l02368"></a>02368 enum_ident_name_check check_and_convert_db_name(LEX_STRING *db,
<a name="l02369"></a>02369                                                 <span class="keywordtype">bool</span> preserve_lettercase);
<a name="l02370"></a>02370 <span class="keywordtype">bool</span> check_column_name(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);
<a name="l02371"></a>02371 enum_ident_name_check check_table_name(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">size_t</span> length,
<a name="l02372"></a>02372                                        <span class="keywordtype">bool</span> check_for_path_chars);
<a name="l02373"></a>02373 <span class="keywordtype">int</span> rename_file_ext(<span class="keyword">const</span> <span class="keywordtype">char</span> * from,<span class="keyword">const</span> <span class="keywordtype">char</span> * to,<span class="keyword">const</span> <span class="keywordtype">char</span> * ext);
<a name="l02374"></a>02374 <span class="keywordtype">char</span> *get_field(MEM_ROOT *mem, <a class="code" href="classField.html">Field</a> *field);
<a name="l02375"></a>02375 <span class="keywordtype">bool</span> get_field(MEM_ROOT *mem, <a class="code" href="classField.html">Field</a> *field, <span class="keyword">class</span> <a class="code" href="classString.html">String</a> *res);
<a name="l02376"></a>02376 
<a name="l02377"></a>02377 <span class="keywordtype">int</span> closefrm(<a class="code" href="structTABLE.html">TABLE</a> *table, <span class="keywordtype">bool</span> free_share);
<a name="l02378"></a>02378 <span class="keywordtype">int</span> read_string(File file, uchar* *to, <span class="keywordtype">size_t</span> length);
<a name="l02379"></a>02379 <span class="keywordtype">void</span> free_blobs(<a class="code" href="structTABLE.html">TABLE</a> *table);
<a name="l02380"></a>02380 <span class="keywordtype">void</span> free_field_buffers_larger_than(<a class="code" href="structTABLE.html">TABLE</a> *table, uint32 size);
<a name="l02381"></a>02381 <span class="keywordtype">int</span> set_zone(<span class="keywordtype">int</span> nr,<span class="keywordtype">int</span> min_zone,<span class="keywordtype">int</span> max_zone);
<a name="l02382"></a>02382 ulong get_form_pos(File file, uchar *head, TYPELIB *save_names);
<a name="l02383"></a>02383 ulong make_new_entry(File file,uchar *fileinfo,TYPELIB *formnames,
<a name="l02384"></a>02384                      <span class="keyword">const</span> <span class="keywordtype">char</span> *newname);
<a name="l02385"></a>02385 ulong next_io_size(ulong pos);
<a name="l02386"></a>02386 <span class="keywordtype">void</span> append_unescaped(<a class="code" href="classString.html">String</a> *res, <span class="keyword">const</span> <span class="keywordtype">char</span> *pos, uint length);
<a name="l02387"></a>02387 File create_frm(THD *thd, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> *db,
<a name="l02388"></a>02388                 <span class="keyword">const</span> <span class="keywordtype">char</span> *table, uint reclength, uchar *fileinfo,
<a name="l02389"></a>02389                 <a class="code" href="structst__ha__create__information.html">HA_CREATE_INFO</a> *create_info, uint keys, <a class="code" href="structst__key.html">KEY</a> *key_info);
<a name="l02390"></a>02390 <span class="keywordtype">char</span> *fn_rext(<span class="keywordtype">char</span> *name);
<a name="l02391"></a>02391 
<a name="l02392"></a>02392 <span class="comment">/* performance schema */</span>
<a name="l02393"></a>02393 <span class="keyword">extern</span> LEX_STRING PERFORMANCE_SCHEMA_DB_NAME;
<a name="l02394"></a>02394 
<a name="l02395"></a>02395 <span class="keyword">extern</span> LEX_STRING GENERAL_LOG_NAME;
<a name="l02396"></a>02396 <span class="keyword">extern</span> LEX_STRING SLOW_LOG_NAME;
<a name="l02397"></a>02397 
<a name="l02398"></a>02398 <span class="comment">/* information schema */</span>
<a name="l02399"></a>02399 <span class="keyword">extern</span> LEX_STRING INFORMATION_SCHEMA_NAME;
<a name="l02400"></a>02400 <span class="keyword">extern</span> LEX_STRING MYSQL_SCHEMA_NAME;
<a name="l02401"></a>02401 
<a name="l02402"></a>02402 <span class="comment">/* replication&#39;s tables */</span>
<a name="l02403"></a>02403 <span class="keyword">extern</span> LEX_STRING RLI_INFO_NAME;
<a name="l02404"></a>02404 <span class="keyword">extern</span> LEX_STRING MI_INFO_NAME;
<a name="l02405"></a>02405 <span class="keyword">extern</span> LEX_STRING WORKER_INFO_NAME;
<a name="l02406"></a>02406 
<a name="l02407"></a>02407 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_infoschema_db(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">size_t</span> len)
<a name="l02408"></a>02408 {
<a name="l02409"></a>02409   <span class="keywordflow">return</span> (INFORMATION_SCHEMA_NAME.length == len &amp;&amp;
<a name="l02410"></a>02410           !my_strcasecmp(system_charset_info,
<a name="l02411"></a>02411                          INFORMATION_SCHEMA_NAME.str, name));
<a name="l02412"></a>02412 }
<a name="l02413"></a>02413 
<a name="l02414"></a>02414 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_infoschema_db(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)
<a name="l02415"></a>02415 {
<a name="l02416"></a>02416   <span class="keywordflow">return</span> !my_strcasecmp(system_charset_info,
<a name="l02417"></a>02417                         INFORMATION_SCHEMA_NAME.str, name);
<a name="l02418"></a>02418 }
<a name="l02419"></a>02419 
<a name="l02420"></a>02420 TYPELIB *typelib(MEM_ROOT *mem_root, <a class="code" href="classList.html">List&lt;String&gt;</a> &amp;strings);
<a name="l02421"></a>02421 
<a name="l02425"></a>02425 <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_user_table(<a class="code" href="structTABLE.html">TABLE</a> * table)
<a name="l02426"></a>02426 {
<a name="l02427"></a>02427   <span class="keyword">const</span> <span class="keywordtype">char</span> *name= table-&gt;s-&gt;table_name.str;
<a name="l02428"></a>02428   <span class="keywordflow">return</span> strncmp(name, tmp_file_prefix, tmp_file_prefix_length);
<a name="l02429"></a>02429 }
<a name="l02430"></a>02430 
<a name="l02431"></a>02431 <span class="keyword">inline</span> <span class="keywordtype">void</span> mark_as_null_row(<a class="code" href="structTABLE.html">TABLE</a> *table)
<a name="l02432"></a>02432 {
<a name="l02433"></a>02433   table-&gt;null_row=1;
<a name="l02434"></a>02434   table-&gt;status|=STATUS_NULL_ROW;
<a name="l02435"></a>02435   memset(table-&gt;null_flags, 255, table-&gt;s-&gt;null_bytes);
<a name="l02436"></a>02436 }
<a name="l02437"></a>02437 
<a name="l02438"></a>02438 <span class="keywordtype">bool</span> is_simple_order(<a class="code" href="structst__order.html">ORDER</a> *order);
<a name="l02439"></a>02439 
<a name="l02440"></a>02440 <span class="preprocessor">#endif </span><span class="comment">/* MYSQL_CLIENT */</span>
<a name="l02441"></a>02441 
<a name="l02442"></a>02442 <span class="preprocessor">#endif </span><span class="comment">/* TABLE_INCLUDED */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:46 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
