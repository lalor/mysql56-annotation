<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: item_func.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">item_func.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef ITEM_FUNC_INCLUDED</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define ITEM_FUNC_INCLUDED</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a>00004 <span class="comment">/* Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.</span>
<a name="l00005"></a>00005 <span class="comment"></span>
<a name="l00006"></a>00006 <span class="comment">   This program is free software; you can redistribute it and/or modify</span>
<a name="l00007"></a>00007 <span class="comment">   it under the terms of the GNU General Public License as published by</span>
<a name="l00008"></a>00008 <span class="comment">   the Free Software Foundation; version 2 of the License.</span>
<a name="l00009"></a>00009 <span class="comment"></span>
<a name="l00010"></a>00010 <span class="comment">   This program is distributed in the hope that it will be useful,</span>
<a name="l00011"></a>00011 <span class="comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00012"></a>00012 <span class="comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00013"></a>00013 <span class="comment">   GNU General Public License for more details.</span>
<a name="l00014"></a>00014 <span class="comment"></span>
<a name="l00015"></a>00015 <span class="comment">   You should have received a copy of the GNU General Public License</span>
<a name="l00016"></a>00016 <span class="comment">   along with this program; if not, write to the Free Software</span>
<a name="l00017"></a>00017 <span class="comment">   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">/* Function items used by mysql */</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#ifdef HAVE_IEEEFP_H</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>                              <span class="comment">/* Bug in BSDI include file */</span>
<a name="l00024"></a>00024 {
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;ieeefp.h&gt;</span>
<a name="l00026"></a>00026 }
<a name="l00027"></a>00027 <span class="preprocessor">#endif</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a><a class="code" href="classItem__func.html">00029</a> <span class="keyword">class </span><a class="code" href="classItem__func.html">Item_func</a> :<span class="keyword">public</span> <a class="code" href="classItem__result__field.html">Item_result_field</a>
<a name="l00030"></a>00030 {
<a name="l00031"></a>00031 <span class="keyword">protected</span>:
<a name="l00032"></a>00032   <a class="code" href="classItem.html">Item</a> **args, *tmp_arg[2];
<a name="l00034"></a><a class="code" href="classItem__func.html#a5c3ce683f091c957f4d164fe4d6403f8">00034</a>   <span class="keywordtype">bool</span> <a class="code" href="classItem__func.html#a5c3ce683f091c957f4d164fe4d6403f8" title="Value used in calculation of result of const_item()">const_item_cache</a>;
<a name="l00035"></a>00035   <span class="comment">/*</span>
<a name="l00036"></a>00036 <span class="comment">    Allowed numbers of columns in result (usually 1, which means scalar value)</span>
<a name="l00037"></a>00037 <span class="comment">    0 means get this number from first argument</span>
<a name="l00038"></a>00038 <span class="comment">  */</span>
<a name="l00039"></a>00039   uint allowed_arg_cols;
<a name="l00041"></a><a class="code" href="classItem__func.html#a663d83299b42a9afbc090dc9286d2603">00041</a>   table_map <a class="code" href="classItem__func.html#a663d83299b42a9afbc090dc9286d2603" title="Value used in calculation of result of used_tables()">used_tables_cache</a>;
<a name="l00043"></a><a class="code" href="classItem__func.html#ae62695d67fc6167d3b142bc5b1065d87">00043</a>   table_map <a class="code" href="classItem__func.html#ae62695d67fc6167d3b142bc5b1065d87" title="Value used in calculation of result of not_null_tables()">not_null_tables_cache</a>;
<a name="l00044"></a>00044 <span class="keyword">public</span>:
<a name="l00045"></a>00045   uint arg_count;
<a name="l00046"></a>00046   <span class="comment">//bool const_item_cache;</span>
<a name="l00047"></a>00047   <span class="keyword">enum</span> Functype { UNKNOWN_FUNC,EQ_FUNC,EQUAL_FUNC,NE_FUNC,LT_FUNC,LE_FUNC,
<a name="l00048"></a>00048                   GE_FUNC,GT_FUNC,FT_FUNC,
<a name="l00049"></a>00049                   LIKE_FUNC,ISNULL_FUNC,ISNOTNULL_FUNC,
<a name="l00050"></a>00050                   COND_AND_FUNC, COND_OR_FUNC, XOR_FUNC,
<a name="l00051"></a>00051                   BETWEEN, IN_FUNC, MULT_EQUAL_FUNC,
<a name="l00052"></a>00052                   INTERVAL_FUNC, ISNOTNULLTEST_FUNC,
<a name="l00053"></a>00053                   SP_EQUALS_FUNC, SP_DISJOINT_FUNC,SP_INTERSECTS_FUNC,
<a name="l00054"></a>00054                   SP_TOUCHES_FUNC,SP_CROSSES_FUNC,SP_WITHIN_FUNC,
<a name="l00055"></a>00055                   SP_CONTAINS_FUNC,SP_OVERLAPS_FUNC,
<a name="l00056"></a>00056                   SP_STARTPOINT,SP_ENDPOINT,SP_EXTERIORRING,
<a name="l00057"></a>00057                   SP_POINTN,SP_GEOMETRYN,SP_INTERIORRINGN,
<a name="l00058"></a>00058                   NOT_FUNC, NOT_ALL_FUNC,
<a name="l00059"></a>00059                   NOW_FUNC, TRIG_COND_FUNC,
<a name="l00060"></a>00060                   SUSERVAR_FUNC, GUSERVAR_FUNC, COLLATE_FUNC,
<a name="l00061"></a>00061                   EXTRACT_FUNC, CHAR_TYPECAST_FUNC, FUNC_SP, UDF_FUNC,
<a name="l00062"></a>00062                   NEG_FUNC, GSYSVAR_FUNC };
<a name="l00063"></a>00063   <span class="keyword">enum</span> optimize_type { OPTIMIZE_NONE,OPTIMIZE_KEY,OPTIMIZE_OP, OPTIMIZE_NULL,
<a name="l00064"></a>00064                        OPTIMIZE_EQUAL };
<a name="l00065"></a>00065   <span class="keyword">enum</span> Type type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> FUNC_ITEM; }
<a name="l00066"></a>00066   <span class="keyword">virtual</span> <span class="keyword">enum</span> Functype functype()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> UNKNOWN_FUNC; }
<a name="l00067"></a>00067   <a class="code" href="classItem__func.html">Item_func</a>(<span class="keywordtype">void</span>):
<a name="l00068"></a>00068     allowed_arg_cols(1), arg_count(0)
<a name="l00069"></a>00069   {
<a name="l00070"></a>00070     with_sum_func= 0;
<a name="l00071"></a>00071   }
<a name="l00072"></a>00072   <a class="code" href="classItem__func.html">Item_func</a>(<a class="code" href="classItem.html">Item</a> *a):
<a name="l00073"></a>00073     allowed_arg_cols(1), arg_count(1)
<a name="l00074"></a>00074   {
<a name="l00075"></a>00075     args= tmp_arg;
<a name="l00076"></a>00076     args[0]= a;
<a name="l00077"></a>00077     with_sum_func= a-&gt;with_sum_func;
<a name="l00078"></a>00078   }
<a name="l00079"></a>00079   <a class="code" href="classItem__func.html">Item_func</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b):
<a name="l00080"></a>00080     allowed_arg_cols(1), arg_count(2)
<a name="l00081"></a>00081   {
<a name="l00082"></a>00082     args= tmp_arg;
<a name="l00083"></a>00083     args[0]= a; args[1]= b;
<a name="l00084"></a>00084     with_sum_func= a-&gt;with_sum_func || b-&gt;with_sum_func;
<a name="l00085"></a>00085   }
<a name="l00086"></a>00086   <a class="code" href="classItem__func.html">Item_func</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b,<a class="code" href="classItem.html">Item</a> *c):
<a name="l00087"></a>00087     allowed_arg_cols(1)
<a name="l00088"></a>00088   {
<a name="l00089"></a>00089     arg_count= 0;
<a name="l00090"></a>00090     <span class="keywordflow">if</span> ((args= (<a class="code" href="classItem.html">Item</a>**) sql_alloc(<span class="keyword">sizeof</span>(<a class="code" href="classItem.html">Item</a>*)*3)))
<a name="l00091"></a>00091     {
<a name="l00092"></a>00092       arg_count= 3;
<a name="l00093"></a>00093       args[0]= a; args[1]= b; args[2]= c;
<a name="l00094"></a>00094       with_sum_func= a-&gt;with_sum_func || b-&gt;with_sum_func || c-&gt;with_sum_func;
<a name="l00095"></a>00095     }
<a name="l00096"></a>00096   }
<a name="l00097"></a>00097   <a class="code" href="classItem__func.html">Item_func</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b,<a class="code" href="classItem.html">Item</a> *c,<a class="code" href="classItem.html">Item</a> *d):
<a name="l00098"></a>00098     allowed_arg_cols(1)
<a name="l00099"></a>00099   {
<a name="l00100"></a>00100     arg_count= 0;
<a name="l00101"></a>00101     <span class="keywordflow">if</span> ((args= (<a class="code" href="classItem.html">Item</a>**) sql_alloc(<span class="keyword">sizeof</span>(<a class="code" href="classItem.html">Item</a>*)*4)))
<a name="l00102"></a>00102     {
<a name="l00103"></a>00103       arg_count= 4;
<a name="l00104"></a>00104       args[0]= a; args[1]= b; args[2]= c; args[3]= d;
<a name="l00105"></a>00105       with_sum_func= a-&gt;with_sum_func || b-&gt;with_sum_func ||
<a name="l00106"></a>00106         c-&gt;with_sum_func || d-&gt;with_sum_func;
<a name="l00107"></a>00107     }
<a name="l00108"></a>00108   }
<a name="l00109"></a>00109   <a class="code" href="classItem__func.html">Item_func</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b,<a class="code" href="classItem.html">Item</a> *c,<a class="code" href="classItem.html">Item</a> *d,<a class="code" href="classItem.html">Item</a>* e):
<a name="l00110"></a>00110     allowed_arg_cols(1)
<a name="l00111"></a>00111   {
<a name="l00112"></a>00112     arg_count= 5;
<a name="l00113"></a>00113     <span class="keywordflow">if</span> ((args= (<a class="code" href="classItem.html">Item</a>**) sql_alloc(<span class="keyword">sizeof</span>(<a class="code" href="classItem.html">Item</a>*)*5)))
<a name="l00114"></a>00114     {
<a name="l00115"></a>00115       args[0]= a; args[1]= b; args[2]= c; args[3]= d; args[4]= e;
<a name="l00116"></a>00116       with_sum_func= a-&gt;with_sum_func || b-&gt;with_sum_func ||
<a name="l00117"></a>00117         c-&gt;with_sum_func || d-&gt;with_sum_func || e-&gt;with_sum_func ;
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119   }
<a name="l00120"></a>00120   <a class="code" href="classItem__func.html">Item_func</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list);
<a name="l00121"></a>00121   <span class="comment">// Constructor used for Item_cond_and/or (see Item comment)</span>
<a name="l00122"></a>00122   <a class="code" href="classItem__func.html">Item_func</a>(THD *thd, <a class="code" href="classItem__func.html">Item_func</a> *item);
<a name="l00123"></a>00123   <span class="keywordtype">bool</span> fix_fields(THD *, <a class="code" href="classItem.html">Item</a> **ref);
<a name="l00124"></a>00124   <span class="keywordtype">void</span> <a class="code" href="classItem__func.html#ab2b8cc7a3bf580679718da7e99e3e8d9">fix_after_pullout</a>(st_select_lex *parent_select,
<a name="l00125"></a>00125                          st_select_lex *removed_select);
<a name="l00126"></a>00126   table_map used_tables() <span class="keyword">const</span>;
<a name="l00132"></a><a class="code" href="classItem__func.html#ab072eb0cabeb11346493b2831fdf4546">00132</a>   <span class="keyword">virtual</span> table_map <a class="code" href="classItem__func.html#ab072eb0cabeb11346493b2831fdf4546">get_initial_pseudo_tables</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00133"></a>00133   table_map not_null_tables() <span class="keyword">const</span>;
<a name="l00134"></a>00134   <span class="keywordtype">void</span> update_used_tables();
<a name="l00135"></a>00135   <span class="keywordtype">void</span> set_used_tables(table_map map) { <a class="code" href="classItem__func.html#a663d83299b42a9afbc090dc9286d2603" title="Value used in calculation of result of used_tables()">used_tables_cache</a>= map; }
<a name="l00136"></a>00136   <span class="keywordtype">void</span> set_not_null_tables(table_map map) { <a class="code" href="classItem__func.html#ae62695d67fc6167d3b142bc5b1065d87" title="Value used in calculation of result of not_null_tables()">not_null_tables_cache</a>= map; }
<a name="l00137"></a>00137   <span class="keywordtype">bool</span> <a class="code" href="classItem__func.html#a8bbf67b5fcc5ef2b718d3ef46b7db48a">eq</a>(<span class="keyword">const</span> <a class="code" href="classItem.html">Item</a> *item, <span class="keywordtype">bool</span> binary_cmp) <span class="keyword">const</span>;
<a name="l00138"></a>00138   <span class="keyword">virtual</span> optimize_type select_optimize()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> OPTIMIZE_NONE; }
<a name="l00139"></a>00139   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> have_rev_func()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00140"></a>00140   <span class="keyword">virtual</span> <a class="code" href="classItem.html">Item</a> *key_item()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> args[0]; }
<a name="l00141"></a>00141   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> const_item()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classItem__func.html#a5c3ce683f091c957f4d164fe4d6403f8" title="Value used in calculation of result of const_item()">const_item_cache</a>; }
<a name="l00142"></a>00142   <span class="keyword">inline</span> <a class="code" href="classItem.html">Item</a> **arguments()<span class="keyword"> const</span>
<a name="l00143"></a>00143 <span class="keyword">  </span>{ DBUG_ASSERT(argument_count() &gt; 0); <span class="keywordflow">return</span> args; }
<a name="l00144"></a>00144   <span class="keywordtype">void</span> set_arguments(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list);
<a name="l00145"></a>00145   <span class="keyword">inline</span> uint argument_count()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> arg_count; }
<a name="l00146"></a>00146   <span class="keyword">inline</span> <span class="keywordtype">void</span> remove_arguments() { arg_count=0; }
<a name="l00147"></a>00147   <span class="keywordtype">void</span> <a class="code" href="classItem__func.html#a893eba2921ac100faa99edd67879561b">split_sum_func</a>(THD *thd, <a class="code" href="classBounds__checked__array.html">Ref_ptr_array</a> ref_pointer_array,
<a name="l00148"></a>00148                       <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;fields);
<a name="l00149"></a>00149   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func.html#afb302ee25d4721ace27d3f5053d4ee41">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l00150"></a>00150   <span class="keywordtype">void</span> print_op(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l00151"></a>00151   <span class="keywordtype">void</span> print_args(<a class="code" href="classString.html">String</a> *str, uint from, enum_query_type query_type);
<a name="l00152"></a>00152   <span class="keyword">virtual</span> <span class="keywordtype">void</span> fix_num_length_and_dec();
<a name="l00153"></a>00153   <span class="keywordtype">void</span> <a class="code" href="classItem__func.html#a8d850c74056662d3bb11bbb43dcacab0">count_only_length</a>(<a class="code" href="classItem.html">Item</a> **item, uint nitems);
<a name="l00154"></a>00154   <span class="keywordtype">void</span> <a class="code" href="classItem__func.html#a3645951d107a6fcae8efc49927c0a48b">count_real_length</a>();
<a name="l00155"></a>00155   <span class="keywordtype">void</span> <a class="code" href="classItem__func.html#affadf53baddfd8f0eb56e6ab580d62a4">count_decimal_length</a>();
<a name="l00156"></a>00156   <span class="keywordtype">void</span> <a class="code" href="classItem__func.html#a3380dac8e8c760d72db5efeaa1c59d58">count_datetime_length</a>(<a class="code" href="classItem.html">Item</a> **item, uint nitems);
<a name="l00157"></a>00157   <span class="keywordtype">bool</span> <a class="code" href="classItem__func.html#a1ae5c3d14e9920407d536a8ce660b7fb">count_string_result_length</a>(enum_field_types field_type,
<a name="l00158"></a>00158                                   <a class="code" href="classItem.html">Item</a> **item, uint nitems);
<a name="l00159"></a>00159   <span class="keyword">inline</span> <span class="keywordtype">bool</span> get_arg0_date(MYSQL_TIME *ltime, uint fuzzy_date)
<a name="l00160"></a>00160   {
<a name="l00161"></a>00161     <span class="keywordflow">return</span> (null_value=args[0]-&gt;get_date(ltime, fuzzy_date));
<a name="l00162"></a>00162   }
<a name="l00163"></a>00163   <span class="keyword">inline</span> <span class="keywordtype">bool</span> get_arg0_time(MYSQL_TIME *ltime)
<a name="l00164"></a>00164   {
<a name="l00165"></a>00165     <span class="keywordflow">return</span> (null_value= args[0]-&gt;get_time(ltime));
<a name="l00166"></a>00166   }
<a name="l00167"></a>00167   <span class="keywordtype">bool</span> is_null() { 
<a name="l00168"></a>00168     update_null_value();
<a name="l00169"></a>00169     <span class="keywordflow">return</span> null_value; 
<a name="l00170"></a>00170   }
<a name="l00171"></a>00171   <span class="keywordtype">void</span> signal_divide_by_null();
<a name="l00172"></a>00172   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classudf__handler.html">udf_handler</a>;
<a name="l00173"></a>00173   <a class="code" href="classField.html">Field</a> *tmp_table_field() { <span class="keywordflow">return</span> result_field; }
<a name="l00174"></a>00174   <a class="code" href="classField.html">Field</a> *tmp_table_field(<a class="code" href="structTABLE.html">TABLE</a> *t_arg);
<a name="l00175"></a>00175   <a class="code" href="classItem.html">Item</a> *get_tmp_table_item(THD *thd);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00178"></a>00178 
<a name="l00179"></a>00179   <span class="keywordtype">bool</span> agg_arg_charsets(<a class="code" href="classDTCollation.html">DTCollation</a> &amp;c, <a class="code" href="classItem.html">Item</a> **items, uint nitems,
<a name="l00180"></a>00180                         uint flags, <span class="keywordtype">int</span> item_sep)
<a name="l00181"></a>00181   {
<a name="l00182"></a>00182     <span class="keywordflow">return</span> agg_item_charsets(c, func_name(), items, nitems, flags, item_sep);
<a name="l00183"></a>00183   }
<a name="l00184"></a>00184   <span class="comment">/*</span>
<a name="l00185"></a>00185 <span class="comment">    Aggregate arguments for string result, e.g: CONCAT(a,b)</span>
<a name="l00186"></a>00186 <span class="comment">    - convert to @@character_set_connection if all arguments are numbers</span>
<a name="l00187"></a>00187 <span class="comment">    - allow DERIVATION_NONE</span>
<a name="l00188"></a>00188 <span class="comment">  */</span>
<a name="l00189"></a>00189   <span class="keywordtype">bool</span> agg_arg_charsets_for_string_result(<a class="code" href="classDTCollation.html">DTCollation</a> &amp;c,
<a name="l00190"></a>00190                                           <a class="code" href="classItem.html">Item</a> **items, uint nitems,
<a name="l00191"></a>00191                                           <span class="keywordtype">int</span> item_sep= 1)
<a name="l00192"></a>00192   {
<a name="l00193"></a>00193     <span class="keywordflow">return</span> agg_item_charsets_for_string_result(c, func_name(),
<a name="l00194"></a>00194                                                items, nitems, item_sep);
<a name="l00195"></a>00195   }
<a name="l00196"></a>00196   <span class="comment">/*</span>
<a name="l00197"></a>00197 <span class="comment">    Aggregate arguments for comparison, e.g: a=b, a LIKE b, a RLIKE b</span>
<a name="l00198"></a>00198 <span class="comment">    - don&#39;t convert to @@character_set_connection if all arguments are numbers</span>
<a name="l00199"></a>00199 <span class="comment">    - don&#39;t allow DERIVATION_NONE</span>
<a name="l00200"></a>00200 <span class="comment">  */</span>
<a name="l00201"></a>00201   <span class="keywordtype">bool</span> agg_arg_charsets_for_comparison(<a class="code" href="classDTCollation.html">DTCollation</a> &amp;c,
<a name="l00202"></a>00202                                        <a class="code" href="classItem.html">Item</a> **items, uint nitems,
<a name="l00203"></a>00203                                        <span class="keywordtype">int</span> item_sep= 1)
<a name="l00204"></a>00204   {
<a name="l00205"></a>00205     <span class="keywordflow">return</span> agg_item_charsets_for_comparison(c, func_name(),
<a name="l00206"></a>00206                                             items, nitems, item_sep);
<a name="l00207"></a>00207   }
<a name="l00208"></a>00208   <span class="comment">/*</span>
<a name="l00209"></a>00209 <span class="comment">    Aggregate arguments for string result, when some comparison</span>
<a name="l00210"></a>00210 <span class="comment">    is involved internally, e.g: REPLACE(a,b,c)</span>
<a name="l00211"></a>00211 <span class="comment">    - convert to @@character_set_connection if all arguments are numbers</span>
<a name="l00212"></a>00212 <span class="comment">    - disallow DERIVATION_NONE</span>
<a name="l00213"></a>00213 <span class="comment">  */</span>
<a name="l00214"></a>00214   <span class="keywordtype">bool</span> agg_arg_charsets_for_string_result_with_comparison(<a class="code" href="classDTCollation.html">DTCollation</a> &amp;c,
<a name="l00215"></a>00215                                                           <a class="code" href="classItem.html">Item</a> **items,
<a name="l00216"></a>00216                                                           uint nitems,
<a name="l00217"></a>00217                                                           <span class="keywordtype">int</span> item_sep= 1)
<a name="l00218"></a>00218   {
<a name="l00219"></a>00219     <span class="keywordflow">return</span> agg_item_charsets_for_string_result_with_comparison(c, func_name(),
<a name="l00220"></a>00220                                                                items, nitems,
<a name="l00221"></a>00221                                                                item_sep);
<a name="l00222"></a>00222   }
<a name="l00223"></a>00223   <span class="keywordtype">bool</span> walk(Item_processor processor, <span class="keywordtype">bool</span> walk_subquery, uchar *arg);
<a name="l00224"></a>00224   <a class="code" href="classItem.html">Item</a> *<a class="code" href="classItem__func.html#a808d0fe427eec3c050ee5214594b8908">transform</a>(Item_transformer transformer, uchar *arg);
<a name="l00225"></a>00225   <a class="code" href="classItem.html">Item</a>* <a class="code" href="classItem__func.html#a11d488fd62efb4c1ad9f85009057cd1c">compile</a>(Item_analyzer analyzer, uchar **arg_p,
<a name="l00226"></a>00226                 Item_transformer transformer, uchar *arg_t);
<a name="l00227"></a>00227   <span class="keywordtype">void</span> traverse_cond(Cond_traverser traverser,
<a name="l00228"></a>00228                      <span class="keywordtype">void</span> * arg, traverse_order order);
<a name="l00229"></a>00229   <span class="keyword">inline</span> <span class="keywordtype">double</span> fix_result(<span class="keywordtype">double</span> value)
<a name="l00230"></a>00230   {
<a name="l00231"></a>00231     <span class="keywordflow">if</span> (my_isfinite(value))
<a name="l00232"></a>00232       <span class="keywordflow">return</span> value;
<a name="l00233"></a>00233     null_value=1;
<a name="l00234"></a>00234     <span class="keywordflow">return</span> 0.0;
<a name="l00235"></a>00235   }
<a name="l00236"></a>00236   <span class="keyword">inline</span> <span class="keywordtype">void</span> raise_numeric_overflow(<span class="keyword">const</span> <span class="keywordtype">char</span> *type_name)
<a name="l00237"></a>00237   {
<a name="l00238"></a>00238     <span class="keywordtype">char</span> buf[256];
<a name="l00239"></a>00239     <a class="code" href="classString.html">String</a> str(buf, <span class="keyword">sizeof</span>(buf), system_charset_info);
<a name="l00240"></a>00240     str.length(0);
<a name="l00241"></a>00241     <a class="code" href="classItem__func.html#afb302ee25d4721ace27d3f5053d4ee41">print</a>(&amp;str, QT_ORDINARY);
<a name="l00242"></a>00242     my_error(ER_DATA_OUT_OF_RANGE, MYF(0), type_name, str.c_ptr_safe());
<a name="l00243"></a>00243   }
<a name="l00244"></a>00244   <span class="keyword">inline</span> <span class="keywordtype">double</span> raise_float_overflow()
<a name="l00245"></a>00245   {
<a name="l00246"></a>00246     raise_numeric_overflow(<span class="stringliteral">&quot;DOUBLE&quot;</span>);
<a name="l00247"></a>00247     <span class="keywordflow">return</span> 0.0;
<a name="l00248"></a>00248   }
<a name="l00249"></a>00249   <span class="keyword">inline</span> longlong raise_integer_overflow()
<a name="l00250"></a>00250   {
<a name="l00251"></a>00251     raise_numeric_overflow(unsigned_flag ? <span class="stringliteral">&quot;BIGINT UNSIGNED&quot;</span>: <span class="stringliteral">&quot;BIGINT&quot;</span>);
<a name="l00252"></a>00252     <span class="keywordflow">return</span> 0;
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254   <span class="keyword">inline</span> <span class="keywordtype">int</span> raise_decimal_overflow()
<a name="l00255"></a>00255   {
<a name="l00256"></a>00256     raise_numeric_overflow(<span class="stringliteral">&quot;DECIMAL&quot;</span>);
<a name="l00257"></a>00257     <span class="keywordflow">return</span> E_DEC_OVERFLOW;
<a name="l00258"></a>00258   }
<a name="l00263"></a><a class="code" href="classItem__func.html#ad5e212313e17d9373e339d59e903f05d">00263</a>   <span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="classItem__func.html#ad5e212313e17d9373e339d59e903f05d">check_float_overflow</a>(<span class="keywordtype">double</span> value)
<a name="l00264"></a>00264   {
<a name="l00265"></a>00265     <span class="keywordflow">return</span> my_isfinite(value) ? value : raise_float_overflow();
<a name="l00266"></a>00266   }
<a name="l00272"></a><a class="code" href="classItem__func.html#a47683db1fe024c786d27ca475c916c00">00272</a>   <span class="keyword">inline</span> longlong <a class="code" href="classItem__func.html#a47683db1fe024c786d27ca475c916c00">check_integer_overflow</a>(longlong value, <span class="keywordtype">bool</span> val_unsigned)
<a name="l00273"></a>00273   {
<a name="l00274"></a>00274     <span class="keywordflow">if</span> ((unsigned_flag &amp;&amp; !val_unsigned &amp;&amp; value &lt; 0) ||
<a name="l00275"></a>00275         (!unsigned_flag &amp;&amp; val_unsigned &amp;&amp;
<a name="l00276"></a>00276          (ulonglong) value &gt; (ulonglong) LONGLONG_MAX))
<a name="l00277"></a>00277       <span class="keywordflow">return</span> raise_integer_overflow();
<a name="l00278"></a>00278     <span class="keywordflow">return</span> value;
<a name="l00279"></a>00279   }
<a name="l00283"></a><a class="code" href="classItem__func.html#a09947594d7f70394fad68d8d1341c0d0">00283</a>   <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="classItem__func.html#a09947594d7f70394fad68d8d1341c0d0">check_decimal_overflow</a>(<span class="keywordtype">int</span> error)
<a name="l00284"></a>00284   {
<a name="l00285"></a>00285     <span class="keywordflow">return</span> (error == E_DEC_OVERFLOW) ? raise_decimal_overflow() : error;
<a name="l00286"></a>00286   }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="keywordtype">bool</span> has_timestamp_args()
<a name="l00289"></a>00289   {
<a name="l00290"></a>00290     DBUG_ASSERT(fixed == TRUE);
<a name="l00291"></a>00291     <span class="keywordflow">for</span> (uint i= 0; i &lt; arg_count; i++)
<a name="l00292"></a>00292     {
<a name="l00293"></a>00293       <span class="keywordflow">if</span> (args[i]-&gt;type() == Item::FIELD_ITEM &amp;&amp;
<a name="l00294"></a>00294           args[i]-&gt;field_type() == MYSQL_TYPE_TIMESTAMP)
<a name="l00295"></a>00295         <span class="keywordflow">return</span> TRUE;
<a name="l00296"></a>00296     }
<a name="l00297"></a>00297     <span class="keywordflow">return</span> FALSE;
<a name="l00298"></a>00298   }
<a name="l00299"></a>00299 
<a name="l00300"></a>00300   <span class="keywordtype">bool</span> has_date_args()
<a name="l00301"></a>00301   {
<a name="l00302"></a>00302     DBUG_ASSERT(fixed == TRUE);
<a name="l00303"></a>00303     <span class="keywordflow">for</span> (uint i= 0; i &lt; arg_count; i++)
<a name="l00304"></a>00304     {
<a name="l00305"></a>00305       <span class="keywordflow">if</span> (args[i]-&gt;type() == Item::FIELD_ITEM &amp;&amp;
<a name="l00306"></a>00306           (args[i]-&gt;field_type() == MYSQL_TYPE_DATE ||
<a name="l00307"></a>00307            args[i]-&gt;field_type() == MYSQL_TYPE_DATETIME))
<a name="l00308"></a>00308         <span class="keywordflow">return</span> TRUE;
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310     <span class="keywordflow">return</span> FALSE;
<a name="l00311"></a>00311   }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313   <span class="keywordtype">bool</span> has_time_args()
<a name="l00314"></a>00314   {
<a name="l00315"></a>00315     DBUG_ASSERT(fixed == TRUE);
<a name="l00316"></a>00316     <span class="keywordflow">for</span> (uint i= 0; i &lt; arg_count; i++)
<a name="l00317"></a>00317     {
<a name="l00318"></a>00318       <span class="keywordflow">if</span> (args[i]-&gt;type() == Item::FIELD_ITEM &amp;&amp;
<a name="l00319"></a>00319           (args[i]-&gt;field_type() == MYSQL_TYPE_TIME ||
<a name="l00320"></a>00320            args[i]-&gt;field_type() == MYSQL_TYPE_DATETIME))
<a name="l00321"></a>00321         <span class="keywordflow">return</span> TRUE;
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323     <span class="keywordflow">return</span> FALSE;
<a name="l00324"></a>00324   }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="keywordtype">bool</span> has_datetime_args()
<a name="l00327"></a>00327   {
<a name="l00328"></a>00328     DBUG_ASSERT(fixed == TRUE);
<a name="l00329"></a>00329     <span class="keywordflow">for</span> (uint i= 0; i &lt; arg_count; i++)
<a name="l00330"></a>00330     {
<a name="l00331"></a>00331       <span class="keywordflow">if</span> (args[i]-&gt;type() == Item::FIELD_ITEM &amp;&amp;
<a name="l00332"></a>00332           args[i]-&gt;field_type() == MYSQL_TYPE_DATETIME)
<a name="l00333"></a>00333         <span class="keywordflow">return</span> TRUE;
<a name="l00334"></a>00334     }
<a name="l00335"></a>00335     <span class="keywordflow">return</span> FALSE;
<a name="l00336"></a>00336   }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338   <span class="comment">/*</span>
<a name="l00339"></a>00339 <span class="comment">    We assume the result of any function that has a TIMESTAMP argument to be</span>
<a name="l00340"></a>00340 <span class="comment">    timezone-dependent, since a TIMESTAMP value in both numeric and string</span>
<a name="l00341"></a>00341 <span class="comment">    contexts is interpreted according to the current timezone.</span>
<a name="l00342"></a>00342 <span class="comment">    The only exception is UNIX_TIMESTAMP() which returns the internal</span>
<a name="l00343"></a>00343 <span class="comment">    representation of a TIMESTAMP argument verbatim, and thus does not depend on</span>
<a name="l00344"></a>00344 <span class="comment">    the timezone.</span>
<a name="l00345"></a>00345 <span class="comment">   */</span>
<a name="l00346"></a>00346   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> check_valid_arguments_processor(uchar *bool_arg)
<a name="l00347"></a>00347   {
<a name="l00348"></a>00348     <span class="keywordflow">return</span> has_timestamp_args();
<a name="l00349"></a>00349   }
<a name="l00350"></a>00350 
<a name="l00351"></a><a class="code" href="classItem__func.html#a0aeb033ca165677743782518419b71ac">00351</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classItem__func.html#a0aeb033ca165677743782518419b71ac">find_function_processor</a> (uchar *arg)
<a name="l00352"></a>00352   {
<a name="l00353"></a>00353     <span class="keywordflow">return</span> functype() == *(Functype *) arg;
<a name="l00354"></a>00354   }
<a name="l00355"></a>00355 };
<a name="l00356"></a>00356 
<a name="l00357"></a>00357 
<a name="l00358"></a><a class="code" href="classItem__real__func.html">00358</a> <span class="keyword">class </span><a class="code" href="classItem__real__func.html">Item_real_func</a> :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l00359"></a>00359 {
<a name="l00360"></a>00360 <span class="keyword">public</span>:
<a name="l00361"></a>00361   <a class="code" href="classItem__real__func.html">Item_real_func</a>() :<a class="code" href="classItem__func.html">Item_func</a>() { collation.set_numeric(); }
<a name="l00362"></a>00362   <a class="code" href="classItem__real__func.html">Item_real_func</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func.html">Item_func</a>(a) { collation.set_numeric(); }
<a name="l00363"></a>00363   <a class="code" href="classItem__real__func.html">Item_real_func</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func.html">Item_func</a>(a,b) { collation.set_numeric(); }
<a name="l00364"></a>00364   <a class="code" href="classItem__real__func.html">Item_real_func</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list) :<a class="code" href="classItem__func.html">Item_func</a>(list) { collation.set_numeric(); }
<a name="l00365"></a>00365   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*str);
<a name="l00366"></a>00366   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *decimal_value);
<a name="l00367"></a>00367   longlong val_int()
<a name="l00368"></a>00368     { DBUG_ASSERT(fixed == 1); <span class="keywordflow">return</span> (longlong) rint(val_real()); }
<a name="l00369"></a>00369   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l00370"></a>00370   {
<a name="l00371"></a>00371     <span class="keywordflow">return</span> <a class="code" href="classItem.html#ae3a6ba6818f83f4c727a27c71bd59f59">get_date_from_real</a>(ltime, fuzzydate);
<a name="l00372"></a>00372   }
<a name="l00373"></a>00373   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l00374"></a>00374   {
<a name="l00375"></a>00375     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a309d78890d1ca16e7555d3030614a9fa">get_time_from_real</a>(ltime);
<a name="l00376"></a>00376   }
<a name="l00377"></a>00377   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> REAL_RESULT; }
<a name="l00378"></a>00378   <span class="keywordtype">void</span> fix_length_and_dec()
<a name="l00379"></a>00379   { decimals= NOT_FIXED_DEC; max_length= float_length(decimals); }
<a name="l00380"></a>00380 };
<a name="l00381"></a>00381 
<a name="l00382"></a>00382 
<a name="l00383"></a><a class="code" href="classItem__func__numhybrid.html">00383</a> <span class="keyword">class </span><a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>: <span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l00384"></a>00384 {
<a name="l00385"></a>00385 <span class="keyword">protected</span>:
<a name="l00386"></a>00386   Item_result hybrid_type;
<a name="l00387"></a>00387 <span class="keyword">public</span>:
<a name="l00388"></a>00388   <a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func.html">Item_func</a>(a), hybrid_type(REAL_RESULT)
<a name="l00389"></a>00389   { collation.set_numeric(); }
<a name="l00390"></a>00390   <a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b)
<a name="l00391"></a>00391     :<a class="code" href="classItem__func.html">Item_func</a>(a,b), hybrid_type(REAL_RESULT)
<a name="l00392"></a>00392   { collation.set_numeric(); }
<a name="l00393"></a>00393   <a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l00394"></a>00394     :<a class="code" href="classItem__func.html">Item_func</a>(list), hybrid_type(REAL_RESULT)
<a name="l00395"></a>00395   { collation.set_numeric(); }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> hybrid_type; }
<a name="l00398"></a>00398   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00399"></a>00399   <span class="keywordtype">void</span> fix_num_length_and_dec();
<a name="l00400"></a>00400   <span class="keyword">virtual</span> <span class="keywordtype">void</span> find_num_type()= 0; <span class="comment">/* To be called from fix_length_and_dec */</span>
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="keywordtype">double</span> val_real();
<a name="l00403"></a>00403   longlong val_int();
<a name="l00404"></a>00404   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00405"></a>00405   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*str);
<a name="l00406"></a>00406   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l00407"></a>00407   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime);
<a name="l00414"></a>00414   <span class="keyword">virtual</span> longlong <a class="code" href="classItem__func__numhybrid.html#a19bd0af87e6aa9a85db125c5f520f210" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>()= 0;
<a name="l00415"></a>00415 
<a name="l00422"></a>00422   <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classItem__func__numhybrid.html#adaa2624fc55ab41a16e893b00a525f58" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>()= 0;
<a name="l00423"></a>00423 
<a name="l00434"></a>00434   <span class="keyword">virtual</span> <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__numhybrid.html#a8bb7bf951d9b0b910d4d96a566007ddf" title="Performs the operation that this functions implements when the result type is DECIMAL.">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *)= 0;
<a name="l00435"></a>00435 
<a name="l00442"></a>00442   <span class="keyword">virtual</span> <a class="code" href="classString.html">String</a> *<a class="code" href="classItem__func__numhybrid.html#a1ac0884749e6f6990ba5480ffe654a68" title="Performs the operation that this functions implements when the result type is a string type...">str_op</a>(<a class="code" href="classString.html">String</a> *)= 0;
<a name="l00449"></a>00449   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classItem__func__numhybrid.html#ad09122f3d70c1248b3fea4bad8cfc44e" title="Performs the operation that this functions implements when the result type is MYSQL_TYPE_DATE or MYSQ...">date_op</a>(MYSQL_TIME *ltime, uint fuzzydate)= 0;
<a name="l00450"></a>00450   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> time_op(MYSQL_TIME *ltime)= 0;
<a name="l00451"></a>00451   <span class="keywordtype">bool</span> is_null() { update_null_value(); <span class="keywordflow">return</span> null_value; }
<a name="l00452"></a>00452 };
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="comment">/* function where type of result detected by first argument */</span>
<a name="l00455"></a><a class="code" href="classItem__func__num1.html">00455</a> <span class="keyword">class </span><a class="code" href="classItem__func__num1.html">Item_func_num1</a>: <span class="keyword">public</span> <a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>
<a name="l00456"></a>00456 {
<a name="l00457"></a>00457 <span class="keyword">public</span>:
<a name="l00458"></a>00458   <a class="code" href="classItem__func__num1.html">Item_func_num1</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>(a) {}
<a name="l00459"></a>00459   <a class="code" href="classItem__func__num1.html">Item_func_num1</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>(a, b) {}
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="keywordtype">void</span> fix_num_length_and_dec();
<a name="l00462"></a>00462   <span class="keywordtype">void</span> <a class="code" href="classItem__func__num1.html#a58b6da0335658959a94f94883002c18a">find_num_type</a>();
<a name="l00463"></a><a class="code" href="classItem__func__num1.html#a9889e8f20355ac44d14efd421a9a9a1d">00463</a>   <a class="code" href="classString.html">String</a> *<a class="code" href="classItem__func__num1.html#a9889e8f20355ac44d14efd421a9a9a1d" title="Performs the operation that this functions implements when the result type is a string type...">str_op</a>(<a class="code" href="classString.html">String</a> *str) { DBUG_ASSERT(0); <span class="keywordflow">return</span> 0; }
<a name="l00464"></a><a class="code" href="classItem__func__num1.html#a98acb42d83cb7e157429902202303698">00464</a>   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__num1.html#a98acb42d83cb7e157429902202303698" title="Performs the operation that this functions implements when the result type is MYSQL_TYPE_DATE or MYSQ...">date_op</a>(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l00465"></a>00465   { DBUG_ASSERT(0); <span class="keywordflow">return</span> 0; }
<a name="l00466"></a>00466   <span class="keywordtype">bool</span> time_op(MYSQL_TIME *ltime)
<a name="l00467"></a>00467   { DBUG_ASSERT(0); <span class="keywordflow">return</span> 0; }
<a name="l00468"></a>00468 };
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 
<a name="l00471"></a>00471 <span class="comment">/* Base class for operations like &#39;+&#39;, &#39;-&#39;, &#39;*&#39; */</span>
<a name="l00472"></a><a class="code" href="classItem__num__op.html">00472</a> <span class="keyword">class </span><a class="code" href="classItem__num__op.html">Item_num_op</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>
<a name="l00473"></a>00473 {
<a name="l00474"></a>00474  <span class="keyword">public</span>:
<a name="l00475"></a>00475   <a class="code" href="classItem__num__op.html">Item_num_op</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__numhybrid.html">Item_func_numhybrid</a>(a, b) {}
<a name="l00476"></a>00476   <span class="keyword">virtual</span> <span class="keywordtype">void</span> result_precision()= 0;
<a name="l00477"></a>00477 
<a name="l00478"></a><a class="code" href="classItem__num__op.html#ae2da408dbfe7289fbfcaf7052f667dc9">00478</a>   <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classItem__num__op.html#ae2da408dbfe7289fbfcaf7052f667dc9">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type)
<a name="l00479"></a>00479   {
<a name="l00480"></a>00480     print_op(str, query_type);
<a name="l00481"></a>00481   }
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   <span class="keywordtype">void</span> <a class="code" href="classItem__num__op.html#af77cd02c491e972d41657d7fc93943ef">find_num_type</a>();
<a name="l00484"></a><a class="code" href="classItem__num__op.html#a80b7d47ad0cdbe854844a29be7f64628">00484</a>   <a class="code" href="classString.html">String</a> *<a class="code" href="classItem__num__op.html#a80b7d47ad0cdbe854844a29be7f64628" title="Performs the operation that this functions implements when the result type is a string type...">str_op</a>(<a class="code" href="classString.html">String</a> *str) { DBUG_ASSERT(0); <span class="keywordflow">return</span> 0; }
<a name="l00485"></a><a class="code" href="classItem__num__op.html#a95ac84723ab16d077d0bb3ef61e5aea9">00485</a>   <span class="keywordtype">bool</span> <a class="code" href="classItem__num__op.html#a95ac84723ab16d077d0bb3ef61e5aea9" title="Performs the operation that this functions implements when the result type is MYSQL_TYPE_DATE or MYSQ...">date_op</a>(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l00486"></a>00486   { DBUG_ASSERT(0); <span class="keywordflow">return</span> 0; }
<a name="l00487"></a>00487   <span class="keywordtype">bool</span> time_op(MYSQL_TIME *ltime)
<a name="l00488"></a>00488   { DBUG_ASSERT(0); <span class="keywordflow">return</span> 0; }
<a name="l00489"></a>00489 };
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 
<a name="l00492"></a><a class="code" href="classItem__int__func.html">00492</a> <span class="keyword">class </span><a class="code" href="classItem__int__func.html">Item_int_func</a> :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l00493"></a>00493 {
<a name="l00494"></a>00494 <span class="keyword">public</span>:
<a name="l00495"></a>00495   <a class="code" href="classItem__int__func.html">Item_int_func</a>() :<a class="code" href="classItem__func.html">Item_func</a>()
<a name="l00496"></a>00496   { collation.set_numeric(); fix_char_length(21); }
<a name="l00497"></a>00497   <a class="code" href="classItem__int__func.html">Item_int_func</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func.html">Item_func</a>(a)
<a name="l00498"></a>00498   { collation.set_numeric(); fix_char_length(21); }
<a name="l00499"></a>00499   <a class="code" href="classItem__int__func.html">Item_int_func</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func.html">Item_func</a>(a,b)
<a name="l00500"></a>00500   { collation.set_numeric(); fix_char_length(21); }
<a name="l00501"></a>00501   <a class="code" href="classItem__int__func.html">Item_int_func</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b,<a class="code" href="classItem.html">Item</a> *c) :<a class="code" href="classItem__func.html">Item_func</a>(a,b,c)
<a name="l00502"></a>00502   { collation.set_numeric(); fix_char_length(21); }
<a name="l00503"></a>00503   <a class="code" href="classItem__int__func.html">Item_int_func</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list) :<a class="code" href="classItem__func.html">Item_func</a>(list)
<a name="l00504"></a>00504   { collation.set_numeric(); fix_char_length(21); }
<a name="l00505"></a>00505   <a class="code" href="classItem__int__func.html">Item_int_func</a>(THD *thd, <a class="code" href="classItem__int__func.html">Item_int_func</a> *item) :<a class="code" href="classItem__func.html">Item_func</a>(thd, item)
<a name="l00506"></a>00506   { collation.set_numeric(); }
<a name="l00507"></a>00507   <span class="keywordtype">double</span> val_real();
<a name="l00508"></a>00508   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>*str);
<a name="l00509"></a>00509   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l00510"></a>00510   {
<a name="l00511"></a>00511     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a79cce40c2785a2126cd3b8277a165a61">get_date_from_int</a>(ltime, fuzzydate);
<a name="l00512"></a>00512   }
<a name="l00513"></a>00513   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l00514"></a>00514   {
<a name="l00515"></a>00515     <span class="keywordflow">return</span> <a class="code" href="classItem.html#afc9b0e1c1a122f5394f6ab80135cfd24">get_time_from_int</a>(ltime);
<a name="l00516"></a>00516   }
<a name="l00517"></a>00517   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l00518"></a>00518   <span class="keywordtype">void</span> fix_length_and_dec() {}
<a name="l00519"></a>00519 };
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 
<a name="l00522"></a><a class="code" href="classItem__func__connection__id.html">00522</a> <span class="keyword">class </span><a class="code" href="classItem__func__connection__id.html">Item_func_connection_id</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l00523"></a>00523 {
<a name="l00524"></a>00524   longlong value;
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 <span class="keyword">public</span>:
<a name="l00527"></a>00527   <a class="code" href="classItem__func__connection__id.html">Item_func_connection_id</a>() {}
<a name="l00528"></a>00528   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;connection_id&quot;</span>; }
<a name="l00529"></a>00529   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00530"></a>00530   <span class="keywordtype">bool</span> fix_fields(THD *thd, <a class="code" href="classItem.html">Item</a> **ref);
<a name="l00531"></a>00531   longlong val_int() { DBUG_ASSERT(fixed == 1); <span class="keywordflow">return</span> value; }
<a name="l00532"></a>00532 };
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 
<a name="l00535"></a><a class="code" href="classItem__func__signed.html">00535</a> <span class="keyword">class </span><a class="code" href="classItem__func__signed.html">Item_func_signed</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l00536"></a>00536 {
<a name="l00537"></a>00537 <span class="keyword">public</span>:
<a name="l00538"></a>00538   <a class="code" href="classItem__func__signed.html">Item_func_signed</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) 
<a name="l00539"></a>00539   {
<a name="l00540"></a>00540     unsigned_flag= 0;
<a name="l00541"></a>00541   }
<a name="l00542"></a>00542   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;cast_as_signed&quot;</span>; }
<a name="l00543"></a>00543   longlong val_int();
<a name="l00544"></a>00544   longlong val_int_from_str(<span class="keywordtype">int</span> *error);
<a name="l00545"></a>00545   <span class="keywordtype">void</span> fix_length_and_dec()
<a name="l00546"></a>00546   {
<a name="l00547"></a>00547     fix_char_length(std::min&lt;uint32&gt;(args[0]-&gt;max_char_length(),
<a name="l00548"></a>00548                                      MY_INT64_NUM_DECIMAL_DIGITS));
<a name="l00549"></a>00549   }
<a name="l00550"></a>00550   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__signed.html#a963a78ea77d22ca1d3e56e96d4fc7e1a">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l00551"></a>00551   uint decimal_precision()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> args[0]-&gt;decimal_precision(); }
<a name="l00552"></a>00552 };
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 
<a name="l00555"></a><a class="code" href="classItem__func__unsigned.html">00555</a> <span class="keyword">class </span><a class="code" href="classItem__func__unsigned.html">Item_func_unsigned</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__signed.html">Item_func_signed</a>
<a name="l00556"></a>00556 {
<a name="l00557"></a>00557 <span class="keyword">public</span>:
<a name="l00558"></a>00558   <a class="code" href="classItem__func__unsigned.html">Item_func_unsigned</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__signed.html">Item_func_signed</a>(a)
<a name="l00559"></a>00559   {
<a name="l00560"></a>00560     unsigned_flag= 1;
<a name="l00561"></a>00561   }
<a name="l00562"></a>00562   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;cast_as_unsigned&quot;</span>; }
<a name="l00563"></a>00563   longlong val_int();
<a name="l00564"></a>00564   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__unsigned.html#a9bed5b4e07ff33e7d780dd7a25c7558f">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l00565"></a>00565 };
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 
<a name="l00568"></a><a class="code" href="classItem__decimal__typecast.html">00568</a> <span class="keyword">class </span><a class="code" href="classItem__decimal__typecast.html">Item_decimal_typecast</a> :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l00569"></a>00569 {
<a name="l00570"></a>00570   <a class="code" href="classmy__decimal.html">my_decimal</a> decimal_value;
<a name="l00571"></a>00571 <span class="keyword">public</span>:
<a name="l00572"></a>00572   <a class="code" href="classItem__decimal__typecast.html">Item_decimal_typecast</a>(<a class="code" href="classItem.html">Item</a> *a, <span class="keywordtype">int</span> len, <span class="keywordtype">int</span> dec) :<a class="code" href="classItem__func.html">Item_func</a>(a)
<a name="l00573"></a>00573   {
<a name="l00574"></a>00574     decimals= dec;
<a name="l00575"></a>00575     collation.set_numeric();
<a name="l00576"></a>00576     fix_char_length(my_decimal_precision_to_length_no_truncation(len, dec,
<a name="l00577"></a>00577                                                                  unsigned_flag));
<a name="l00578"></a>00578   }
<a name="l00579"></a>00579   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str);
<a name="l00580"></a>00580   <span class="keywordtype">double</span> val_real();
<a name="l00581"></a>00581   longlong val_int();
<a name="l00582"></a>00582   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l00583"></a>00583   {
<a name="l00584"></a>00584     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a4bc61001a2485f584b526ca9da05f3e0">get_date_from_decimal</a>(ltime, fuzzydate);
<a name="l00585"></a>00585   }
<a name="l00586"></a>00586   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l00587"></a>00587   {
<a name="l00588"></a>00588     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a099dd8c794d94ac482747e34e4f7a6b3">get_time_from_decimal</a>(ltime);
<a name="l00589"></a>00589   }
<a name="l00590"></a>00590   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a>*);
<a name="l00591"></a>00591   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DECIMAL_RESULT; }
<a name="l00592"></a>00592   enum_field_types field_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> MYSQL_TYPE_NEWDECIMAL; }
<a name="l00593"></a>00593   <span class="keywordtype">void</span> fix_length_and_dec() {};
<a name="l00594"></a>00594   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;decimal_typecast&quot;</span>; }
<a name="l00595"></a>00595   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__decimal__typecast.html#a717d1f01e379eee9f3c4e3c45acb5bec">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l00596"></a>00596 };
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 
<a name="l00599"></a><a class="code" href="classItem__func__additive__op.html">00599</a> <span class="keyword">class </span><a class="code" href="classItem__func__additive__op.html">Item_func_additive_op</a> :<span class="keyword">public</span> <a class="code" href="classItem__num__op.html">Item_num_op</a>
<a name="l00600"></a>00600 {
<a name="l00601"></a>00601 <span class="keyword">public</span>:
<a name="l00602"></a>00602   <a class="code" href="classItem__func__additive__op.html">Item_func_additive_op</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__num__op.html">Item_num_op</a>(a,b) {}
<a name="l00603"></a>00603   <span class="keywordtype">void</span> <a class="code" href="classItem__func__additive__op.html#a2cf82a11e82aff94459d341bbadc95c6">result_precision</a>();
<a name="l00604"></a>00604   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l00605"></a>00605 };
<a name="l00606"></a>00606 
<a name="l00607"></a>00607 
<a name="l00608"></a><a class="code" href="classItem__func__plus.html">00608</a> <span class="keyword">class </span><a class="code" href="classItem__func__plus.html">Item_func_plus</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__additive__op.html">Item_func_additive_op</a>
<a name="l00609"></a>00609 {
<a name="l00610"></a>00610 <span class="keyword">public</span>:
<a name="l00611"></a>00611   <a class="code" href="classItem__func__plus.html">Item_func_plus</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__additive__op.html">Item_func_additive_op</a>(a,b) {}
<a name="l00612"></a>00612   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;+&quot;</span>; }
<a name="l00613"></a>00613   longlong <a class="code" href="classItem__func__plus.html#ae67ea09ed334bd4ccc4bfa8e0a7d41d3" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00614"></a>00614   <span class="keywordtype">double</span> <a class="code" href="classItem__func__plus.html#adcf48f4645aa1bd8363749fa45d41d3c" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00615"></a>00615   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__plus.html#a9e50ac55c5f05e8bcd9794a67cbc36ba">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00616"></a>00616 };
<a name="l00617"></a>00617 
<a name="l00618"></a><a class="code" href="classItem__func__minus.html">00618</a> <span class="keyword">class </span><a class="code" href="classItem__func__minus.html">Item_func_minus</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__additive__op.html">Item_func_additive_op</a>
<a name="l00619"></a>00619 {
<a name="l00620"></a>00620 <span class="keyword">public</span>:
<a name="l00621"></a>00621   <a class="code" href="classItem__func__minus.html">Item_func_minus</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__additive__op.html">Item_func_additive_op</a>(a,b) {}
<a name="l00622"></a>00622   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>; }
<a name="l00623"></a>00623   longlong <a class="code" href="classItem__func__minus.html#a111d606af6777010ebcf7a6ab982ee6b" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00624"></a>00624   <span class="keywordtype">double</span> <a class="code" href="classItem__func__minus.html#a706bf514ecfaa3519db592ff23d29a3f" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00625"></a>00625   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__minus.html#af8a2b13a0441e03a3b29095737f8b636">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00626"></a>00626   <span class="keywordtype">void</span> <a class="code" href="classItem__func__minus.html#aa25af12ce7307ab2b78310441568e9bc">fix_length_and_dec</a>();
<a name="l00627"></a>00627 };
<a name="l00628"></a>00628 
<a name="l00629"></a>00629 
<a name="l00630"></a><a class="code" href="classItem__func__mul.html">00630</a> <span class="keyword">class </span><a class="code" href="classItem__func__mul.html">Item_func_mul</a> :<span class="keyword">public</span> <a class="code" href="classItem__num__op.html">Item_num_op</a>
<a name="l00631"></a>00631 {
<a name="l00632"></a>00632 <span class="keyword">public</span>:
<a name="l00633"></a>00633   <a class="code" href="classItem__func__mul.html">Item_func_mul</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__num__op.html">Item_num_op</a>(a,b) {}
<a name="l00634"></a>00634   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;*&quot;</span>; }
<a name="l00635"></a>00635   longlong <a class="code" href="classItem__func__mul.html#a4b340f446e85209cbb1cd9d6a6f44f89" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00636"></a>00636   <span class="keywordtype">double</span> <a class="code" href="classItem__func__mul.html#afa67c26d7e33ed69e046afc916e5e289" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00637"></a>00637   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__mul.html#adab208576e5f6cef40540234c208dc8b">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00638"></a>00638   <span class="keywordtype">void</span> result_precision();
<a name="l00639"></a>00639   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l00640"></a>00640 };
<a name="l00641"></a>00641 
<a name="l00642"></a>00642 
<a name="l00643"></a><a class="code" href="classItem__func__div.html">00643</a> <span class="keyword">class </span><a class="code" href="classItem__func__div.html">Item_func_div</a> :<span class="keyword">public</span> <a class="code" href="classItem__num__op.html">Item_num_op</a>
<a name="l00644"></a>00644 {
<a name="l00645"></a>00645 <span class="keyword">public</span>:
<a name="l00646"></a>00646   uint prec_increment;
<a name="l00647"></a>00647   <a class="code" href="classItem__func__div.html">Item_func_div</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__num__op.html">Item_num_op</a>(a,b) {}
<a name="l00648"></a><a class="code" href="classItem__func__div.html#a80b4eb1b4b16d48c9fc38d85c278c076">00648</a>   longlong <a class="code" href="classItem__func__div.html#a80b4eb1b4b16d48c9fc38d85c278c076" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>() { DBUG_ASSERT(0); <span class="keywordflow">return</span> 0; }
<a name="l00649"></a>00649   <span class="keywordtype">double</span> <a class="code" href="classItem__func__div.html#ae064ddd0c9d71e9297b35c4bb21b2412" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00650"></a>00650   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__div.html#aa86c3a3e12ec597b4e6e9ce9b9776407" title="Performs the operation that this functions implements when the result type is DECIMAL.">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00651"></a>00651   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;/&quot;</span>; }
<a name="l00652"></a>00652   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00653"></a>00653   <span class="keywordtype">void</span> result_precision();
<a name="l00654"></a>00654 };
<a name="l00655"></a>00655 
<a name="l00656"></a>00656 
<a name="l00657"></a><a class="code" href="classItem__func__int__div.html">00657</a> <span class="keyword">class </span><a class="code" href="classItem__func__int__div.html">Item_func_int_div</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l00658"></a>00658 {
<a name="l00659"></a>00659 <span class="keyword">public</span>:
<a name="l00660"></a>00660   <a class="code" href="classItem__func__int__div.html">Item_func_int_div</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a,b)
<a name="l00661"></a>00661   {}
<a name="l00662"></a>00662   longlong val_int();
<a name="l00663"></a>00663   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;DIV&quot;</span>; }
<a name="l00664"></a>00664   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00665"></a>00665 
<a name="l00666"></a><a class="code" href="classItem__func__int__div.html#a5ba36d4e0677cd7c634808019bb8c5ac">00666</a>   <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__int__div.html#a5ba36d4e0677cd7c634808019bb8c5ac">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type)
<a name="l00667"></a>00667   {
<a name="l00668"></a>00668     print_op(str, query_type);
<a name="l00669"></a>00669   }
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l00672"></a>00672 };
<a name="l00673"></a>00673 
<a name="l00674"></a>00674 
<a name="l00675"></a><a class="code" href="classItem__func__mod.html">00675</a> <span class="keyword">class </span><a class="code" href="classItem__func__mod.html">Item_func_mod</a> :<span class="keyword">public</span> <a class="code" href="classItem__num__op.html">Item_num_op</a>
<a name="l00676"></a>00676 {
<a name="l00677"></a>00677 <span class="keyword">public</span>:
<a name="l00678"></a>00678   <a class="code" href="classItem__func__mod.html">Item_func_mod</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__num__op.html">Item_num_op</a>(a,b) {}
<a name="l00679"></a>00679   longlong <a class="code" href="classItem__func__mod.html#a0bfc2912fb1344633c43d2325e3e50c4" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00680"></a>00680   <span class="keywordtype">double</span> <a class="code" href="classItem__func__mod.html#acbd8a5502dbcf444704731e4bfe85bc6" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00681"></a>00681   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__mod.html#a8a540b53340322819a5b7fb06572307b" title="Performs the operation that this functions implements when the result type is DECIMAL.">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00682"></a>00682   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;%&quot;</span>; }
<a name="l00683"></a>00683   <span class="keywordtype">void</span> result_precision();
<a name="l00684"></a>00684   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00685"></a>00685   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l00686"></a>00686 };
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 
<a name="l00689"></a><a class="code" href="classItem__func__neg.html">00689</a> <span class="keyword">class </span><a class="code" href="classItem__func__neg.html">Item_func_neg</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__num1.html">Item_func_num1</a>
<a name="l00690"></a>00690 {
<a name="l00691"></a>00691 <span class="keyword">public</span>:
<a name="l00692"></a>00692   <a class="code" href="classItem__func__neg.html">Item_func_neg</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__num1.html">Item_func_num1</a>(a) {}
<a name="l00693"></a>00693   <span class="keywordtype">double</span> <a class="code" href="classItem__func__neg.html#a4b1e351fe9f02e84fe4294cdf9c99e71" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00694"></a>00694   longlong <a class="code" href="classItem__func__neg.html#a2b212eb09382fbd657f039035203de15" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00695"></a>00695   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__neg.html#ad44b73d598ec7a7e588b3ec40ddb95dc" title="Performs the operation that this functions implements when the result type is DECIMAL.">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00696"></a>00696   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;-&quot;</span>; }
<a name="l00697"></a>00697   <span class="keyword">enum</span> Functype functype()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> NEG_FUNC; }
<a name="l00698"></a>00698   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00699"></a>00699   <span class="keywordtype">void</span> fix_num_length_and_dec();
<a name="l00700"></a>00700   uint decimal_precision()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> args[0]-&gt;decimal_precision(); }
<a name="l00701"></a>00701   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l00702"></a>00702 };
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 
<a name="l00705"></a><a class="code" href="classItem__func__abs.html">00705</a> <span class="keyword">class </span><a class="code" href="classItem__func__abs.html">Item_func_abs</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__num1.html">Item_func_num1</a>
<a name="l00706"></a>00706 {
<a name="l00707"></a>00707 <span class="keyword">public</span>:
<a name="l00708"></a>00708   <a class="code" href="classItem__func__abs.html">Item_func_abs</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__num1.html">Item_func_num1</a>(a) {}
<a name="l00709"></a>00709   <span class="keywordtype">double</span> <a class="code" href="classItem__func__abs.html#a19810e6ff9ca5c533ea9779ae402f162" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00710"></a>00710   longlong <a class="code" href="classItem__func__abs.html#ae7eff52fe390d10cbd2a99b1a97c1542" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00711"></a>00711   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__abs.html#aae949c8f3cbb41efecd8cf7e4bea9086" title="Performs the operation that this functions implements when the result type is DECIMAL.">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00712"></a>00712   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;abs&quot;</span>; }
<a name="l00713"></a>00713   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00714"></a>00714   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l00715"></a>00715 };
<a name="l00716"></a>00716 
<a name="l00717"></a>00717 <span class="comment">// A class to handle logarithmic and trigonometric functions</span>
<a name="l00718"></a>00718 
<a name="l00719"></a><a class="code" href="classItem__dec__func.html">00719</a> <span class="keyword">class </span><a class="code" href="classItem__dec__func.html">Item_dec_func</a> :<span class="keyword">public</span> <a class="code" href="classItem__real__func.html">Item_real_func</a>
<a name="l00720"></a>00720 {
<a name="l00721"></a>00721  <span class="keyword">public</span>:
<a name="l00722"></a>00722   <a class="code" href="classItem__dec__func.html">Item_dec_func</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__real__func.html">Item_real_func</a>(a) {}
<a name="l00723"></a>00723   <a class="code" href="classItem__dec__func.html">Item_dec_func</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__real__func.html">Item_real_func</a>(a,b) {}
<a name="l00724"></a>00724   <span class="keywordtype">void</span> fix_length_and_dec()
<a name="l00725"></a>00725   {
<a name="l00726"></a>00726     decimals=NOT_FIXED_DEC; max_length=float_length(decimals);
<a name="l00727"></a>00727     maybe_null=1;
<a name="l00728"></a>00728   }
<a name="l00729"></a>00729 };
<a name="l00730"></a>00730 
<a name="l00731"></a><a class="code" href="classItem__func__exp.html">00731</a> <span class="keyword">class </span><a class="code" href="classItem__func__exp.html">Item_func_exp</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00732"></a>00732 {
<a name="l00733"></a>00733 <span class="keyword">public</span>:
<a name="l00734"></a>00734   <a class="code" href="classItem__func__exp.html">Item_func_exp</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00735"></a>00735   <span class="keywordtype">double</span> val_real();
<a name="l00736"></a>00736   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;exp&quot;</span>; }
<a name="l00737"></a>00737 };
<a name="l00738"></a>00738 
<a name="l00739"></a>00739 
<a name="l00740"></a><a class="code" href="classItem__func__ln.html">00740</a> <span class="keyword">class </span><a class="code" href="classItem__func__ln.html">Item_func_ln</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00741"></a>00741 {
<a name="l00742"></a>00742 <span class="keyword">public</span>:
<a name="l00743"></a>00743   <a class="code" href="classItem__func__ln.html">Item_func_ln</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00744"></a>00744   <span class="keywordtype">double</span> <a class="code" href="classItem__func__ln.html#af5f769d3c87642ff6e7a1bf4c48aaa92">val_real</a>();
<a name="l00745"></a>00745   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;ln&quot;</span>; }
<a name="l00746"></a>00746 };
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 
<a name="l00749"></a><a class="code" href="classItem__func__log.html">00749</a> <span class="keyword">class </span><a class="code" href="classItem__func__log.html">Item_func_log</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00750"></a>00750 {
<a name="l00751"></a>00751 <span class="keyword">public</span>:
<a name="l00752"></a>00752   <a class="code" href="classItem__func__log.html">Item_func_log</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00753"></a>00753   <a class="code" href="classItem__func__log.html">Item_func_log</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a,b) {}
<a name="l00754"></a>00754   <span class="keywordtype">double</span> <a class="code" href="classItem__func__log.html#a1efb717fce06d554db39a18047c50c9f">val_real</a>();
<a name="l00755"></a>00755   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;log&quot;</span>; }
<a name="l00756"></a>00756 };
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 
<a name="l00759"></a><a class="code" href="classItem__func__log2.html">00759</a> <span class="keyword">class </span><a class="code" href="classItem__func__log2.html">Item_func_log2</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00760"></a>00760 {
<a name="l00761"></a>00761 <span class="keyword">public</span>:
<a name="l00762"></a>00762   <a class="code" href="classItem__func__log2.html">Item_func_log2</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00763"></a>00763   <span class="keywordtype">double</span> val_real();
<a name="l00764"></a>00764   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;log2&quot;</span>; }
<a name="l00765"></a>00765 };
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 
<a name="l00768"></a><a class="code" href="classItem__func__log10.html">00768</a> <span class="keyword">class </span><a class="code" href="classItem__func__log10.html">Item_func_log10</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00769"></a>00769 {
<a name="l00770"></a>00770 <span class="keyword">public</span>:
<a name="l00771"></a>00771   <a class="code" href="classItem__func__log10.html">Item_func_log10</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00772"></a>00772   <span class="keywordtype">double</span> val_real();
<a name="l00773"></a>00773   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;log10&quot;</span>; }
<a name="l00774"></a>00774 };
<a name="l00775"></a>00775 
<a name="l00776"></a>00776 
<a name="l00777"></a><a class="code" href="classItem__func__sqrt.html">00777</a> <span class="keyword">class </span><a class="code" href="classItem__func__sqrt.html">Item_func_sqrt</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00778"></a>00778 {
<a name="l00779"></a>00779 <span class="keyword">public</span>:
<a name="l00780"></a>00780   <a class="code" href="classItem__func__sqrt.html">Item_func_sqrt</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00781"></a>00781   <span class="keywordtype">double</span> val_real();
<a name="l00782"></a>00782   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;sqrt&quot;</span>; }
<a name="l00783"></a>00783 };
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 
<a name="l00786"></a><a class="code" href="classItem__func__pow.html">00786</a> <span class="keyword">class </span><a class="code" href="classItem__func__pow.html">Item_func_pow</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00787"></a>00787 {
<a name="l00788"></a>00788 <span class="keyword">public</span>:
<a name="l00789"></a>00789   <a class="code" href="classItem__func__pow.html">Item_func_pow</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a,b) {}
<a name="l00790"></a>00790   <span class="keywordtype">double</span> val_real();
<a name="l00791"></a>00791   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;pow&quot;</span>; }
<a name="l00792"></a>00792 };
<a name="l00793"></a>00793 
<a name="l00794"></a>00794 
<a name="l00795"></a><a class="code" href="classItem__func__acos.html">00795</a> <span class="keyword">class </span><a class="code" href="classItem__func__acos.html">Item_func_acos</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00796"></a>00796 {
<a name="l00797"></a>00797 <span class="keyword">public</span>:
<a name="l00798"></a>00798   <a class="code" href="classItem__func__acos.html">Item_func_acos</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00799"></a>00799   <span class="keywordtype">double</span> val_real();
<a name="l00800"></a>00800   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;acos&quot;</span>; }
<a name="l00801"></a>00801 };
<a name="l00802"></a>00802 
<a name="l00803"></a><a class="code" href="classItem__func__asin.html">00803</a> <span class="keyword">class </span><a class="code" href="classItem__func__asin.html">Item_func_asin</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00804"></a>00804 {
<a name="l00805"></a>00805 <span class="keyword">public</span>:
<a name="l00806"></a>00806   <a class="code" href="classItem__func__asin.html">Item_func_asin</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00807"></a>00807   <span class="keywordtype">double</span> val_real();
<a name="l00808"></a>00808   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;asin&quot;</span>; }
<a name="l00809"></a>00809 };
<a name="l00810"></a>00810 
<a name="l00811"></a><a class="code" href="classItem__func__atan.html">00811</a> <span class="keyword">class </span><a class="code" href="classItem__func__atan.html">Item_func_atan</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00812"></a>00812 {
<a name="l00813"></a>00813 <span class="keyword">public</span>:
<a name="l00814"></a>00814   <a class="code" href="classItem__func__atan.html">Item_func_atan</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00815"></a>00815   <a class="code" href="classItem__func__atan.html">Item_func_atan</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a,b) {}
<a name="l00816"></a>00816   <span class="keywordtype">double</span> val_real();
<a name="l00817"></a>00817   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;atan&quot;</span>; }
<a name="l00818"></a>00818 };
<a name="l00819"></a>00819 
<a name="l00820"></a><a class="code" href="classItem__func__cos.html">00820</a> <span class="keyword">class </span><a class="code" href="classItem__func__cos.html">Item_func_cos</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00821"></a>00821 {
<a name="l00822"></a>00822 <span class="keyword">public</span>:
<a name="l00823"></a>00823   <a class="code" href="classItem__func__cos.html">Item_func_cos</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00824"></a>00824   <span class="keywordtype">double</span> val_real();
<a name="l00825"></a>00825   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;cos&quot;</span>; }
<a name="l00826"></a>00826 };
<a name="l00827"></a>00827 
<a name="l00828"></a><a class="code" href="classItem__func__sin.html">00828</a> <span class="keyword">class </span><a class="code" href="classItem__func__sin.html">Item_func_sin</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00829"></a>00829 {
<a name="l00830"></a>00830 <span class="keyword">public</span>:
<a name="l00831"></a>00831   <a class="code" href="classItem__func__sin.html">Item_func_sin</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00832"></a>00832   <span class="keywordtype">double</span> val_real();
<a name="l00833"></a>00833   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;sin&quot;</span>; }
<a name="l00834"></a>00834 };
<a name="l00835"></a>00835 
<a name="l00836"></a><a class="code" href="classItem__func__tan.html">00836</a> <span class="keyword">class </span><a class="code" href="classItem__func__tan.html">Item_func_tan</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00837"></a>00837 {
<a name="l00838"></a>00838 <span class="keyword">public</span>:
<a name="l00839"></a>00839   <a class="code" href="classItem__func__tan.html">Item_func_tan</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00840"></a>00840   <span class="keywordtype">double</span> val_real();
<a name="l00841"></a>00841   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;tan&quot;</span>; }
<a name="l00842"></a>00842 };
<a name="l00843"></a>00843 
<a name="l00844"></a><a class="code" href="classItem__func__cot.html">00844</a> <span class="keyword">class </span><a class="code" href="classItem__func__cot.html">Item_func_cot</a> :<span class="keyword">public</span> <a class="code" href="classItem__dec__func.html">Item_dec_func</a>
<a name="l00845"></a>00845 {
<a name="l00846"></a>00846 <span class="keyword">public</span>:
<a name="l00847"></a>00847   <a class="code" href="classItem__func__cot.html">Item_func_cot</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__dec__func.html">Item_dec_func</a>(a) {}
<a name="l00848"></a>00848   <span class="keywordtype">double</span> val_real();
<a name="l00849"></a>00849   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;cot&quot;</span>; }
<a name="l00850"></a>00850 };
<a name="l00851"></a>00851 
<a name="l00852"></a><a class="code" href="classItem__func__integer.html">00852</a> <span class="keyword">class </span><a class="code" href="classItem__func__integer.html">Item_func_integer</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l00853"></a>00853 {
<a name="l00854"></a>00854 <span class="keyword">public</span>:
<a name="l00855"></a>00855   <span class="keyword">inline</span> <a class="code" href="classItem__func__integer.html">Item_func_integer</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l00856"></a>00856   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00857"></a>00857 };
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 
<a name="l00860"></a><a class="code" href="classItem__func__int__val.html">00860</a> <span class="keyword">class </span><a class="code" href="classItem__func__int__val.html">Item_func_int_val</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__num1.html">Item_func_num1</a>
<a name="l00861"></a>00861 {
<a name="l00862"></a>00862 <span class="keyword">public</span>:
<a name="l00863"></a>00863   <a class="code" href="classItem__func__int__val.html">Item_func_int_val</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__num1.html">Item_func_num1</a>(a) {}
<a name="l00864"></a>00864   <span class="keywordtype">void</span> fix_num_length_and_dec();
<a name="l00865"></a>00865   <span class="keywordtype">void</span> <a class="code" href="classItem__func__int__val.html#a538c1839a29090025a241c3017151e24">find_num_type</a>();
<a name="l00866"></a>00866 };
<a name="l00867"></a>00867 
<a name="l00868"></a>00868 
<a name="l00869"></a><a class="code" href="classItem__func__ceiling.html">00869</a> <span class="keyword">class </span><a class="code" href="classItem__func__ceiling.html">Item_func_ceiling</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__int__val.html">Item_func_int_val</a>
<a name="l00870"></a>00870 {
<a name="l00871"></a>00871 <span class="keyword">public</span>:
<a name="l00872"></a>00872   <a class="code" href="classItem__func__ceiling.html">Item_func_ceiling</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__int__val.html">Item_func_int_val</a>(a) {}
<a name="l00873"></a>00873   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;ceiling&quot;</span>; }
<a name="l00874"></a>00874   longlong <a class="code" href="classItem__func__ceiling.html#ac49c24eb67b0450e546045a4e09e9643" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00875"></a>00875   <span class="keywordtype">double</span> <a class="code" href="classItem__func__ceiling.html#aac75c27aec8c2e59489bcbd9342831ad" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00876"></a>00876   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__ceiling.html#a7a64d20711d7d8f9bbe7af54e8b83414" title="Performs the operation that this functions implements when the result type is DECIMAL.">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00877"></a>00877   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l00878"></a>00878 };
<a name="l00879"></a>00879 
<a name="l00880"></a>00880 
<a name="l00881"></a><a class="code" href="classItem__func__floor.html">00881</a> <span class="keyword">class </span><a class="code" href="classItem__func__floor.html">Item_func_floor</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__int__val.html">Item_func_int_val</a>
<a name="l00882"></a>00882 {
<a name="l00883"></a>00883 <span class="keyword">public</span>:
<a name="l00884"></a>00884   <a class="code" href="classItem__func__floor.html">Item_func_floor</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__int__val.html">Item_func_int_val</a>(a) {}
<a name="l00885"></a>00885   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;floor&quot;</span>; }
<a name="l00886"></a>00886   longlong <a class="code" href="classItem__func__floor.html#a4422771a486e1489c82cd237ac92df02" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00887"></a>00887   <span class="keywordtype">double</span> <a class="code" href="classItem__func__floor.html#adfa9c00d201a65853c9a5a5091e60323" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00888"></a>00888   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__floor.html#a193a178a3d72da596ea0b4f61cbe2e4b" title="Performs the operation that this functions implements when the result type is DECIMAL.">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00889"></a>00889   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l00890"></a>00890 };
<a name="l00891"></a>00891 
<a name="l00892"></a>00892 <span class="comment">/* This handles round and truncate */</span>
<a name="l00893"></a>00893 
<a name="l00894"></a><a class="code" href="classItem__func__round.html">00894</a> <span class="keyword">class </span><a class="code" href="classItem__func__round.html">Item_func_round</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__num1.html">Item_func_num1</a>
<a name="l00895"></a>00895 {
<a name="l00896"></a>00896   <span class="keywordtype">bool</span> truncate;
<a name="l00897"></a>00897 <span class="keyword">public</span>:
<a name="l00898"></a>00898   <a class="code" href="classItem__func__round.html">Item_func_round</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b, <span class="keywordtype">bool</span> trunc_arg)
<a name="l00899"></a>00899     :<a class="code" href="classItem__func__num1.html">Item_func_num1</a>(a,b), truncate(trunc_arg) {}
<a name="l00900"></a>00900   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> truncate ? <span class="stringliteral">&quot;truncate&quot;</span> : <span class="stringliteral">&quot;round&quot;</span>; }
<a name="l00901"></a>00901   <span class="keywordtype">double</span> <a class="code" href="classItem__func__round.html#ada29f71a79a9a6861c66f63a416d844d" title="Performs the operation that this functions implements when the result type is REAL.">real_op</a>();
<a name="l00902"></a>00902   longlong <a class="code" href="classItem__func__round.html#a85e6a144c355f53db72e50cf6f679cd2" title="Performs the operation that this functions implements when the result type is INT.">int_op</a>();
<a name="l00903"></a>00903   <a class="code" href="classmy__decimal.html">my_decimal</a> *<a class="code" href="classItem__func__round.html#a640c351797b9ccbaa7d05928f09f12ba" title="Performs the operation that this functions implements when the result type is DECIMAL.">decimal_op</a>(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00904"></a>00904   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00905"></a>00905 };
<a name="l00906"></a>00906 
<a name="l00907"></a>00907 
<a name="l00908"></a><a class="code" href="classItem__func__rand.html">00908</a> <span class="keyword">class </span><a class="code" href="classItem__func__rand.html">Item_func_rand</a> :<span class="keyword">public</span> <a class="code" href="classItem__real__func.html">Item_real_func</a>
<a name="l00909"></a>00909 {
<a name="l00910"></a>00910   <span class="keyword">struct </span>rand_struct *rand;
<a name="l00911"></a>00911   <span class="keywordtype">bool</span> first_eval; <span class="comment">// TRUE if val_real() is called 1st time</span>
<a name="l00912"></a>00912 <span class="keyword">public</span>:
<a name="l00913"></a>00913   <a class="code" href="classItem__func__rand.html">Item_func_rand</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__real__func.html">Item_real_func</a>(a), rand(0), first_eval(TRUE) {}
<a name="l00914"></a>00914   <a class="code" href="classItem__func__rand.html">Item_func_rand</a>()        :<a class="code" href="classItem__real__func.html">Item_real_func</a>() {}
<a name="l00915"></a>00915   <span class="keywordtype">double</span> val_real();
<a name="l00916"></a>00916   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;rand&quot;</span>; }
<a name="l00917"></a>00917   <span class="keywordtype">bool</span> const_item()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l00924"></a><a class="code" href="classItem__func__rand.html#a51491f1e55f12487fe645b6288add018">00924</a>   table_map <a class="code" href="classItem__func__rand.html#a51491f1e55f12487fe645b6288add018">get_initial_pseudo_tables</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> RAND_TABLE_BIT; }
<a name="l00925"></a>00925   <span class="keywordtype">bool</span> fix_fields(THD *thd, <a class="code" href="classItem.html">Item</a> **ref);
<a name="l00926"></a>00926   <span class="keywordtype">void</span> cleanup() { first_eval= TRUE; Item_real_func::cleanup(); }
<a name="l00927"></a>00927 <span class="keyword">private</span>:
<a name="l00928"></a>00928   <span class="keywordtype">void</span> seed_random (<a class="code" href="classItem.html">Item</a> * val);  
<a name="l00929"></a>00929 };
<a name="l00930"></a>00930 
<a name="l00931"></a>00931 
<a name="l00932"></a><a class="code" href="classItem__func__sign.html">00932</a> <span class="keyword">class </span><a class="code" href="classItem__func__sign.html">Item_func_sign</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l00933"></a>00933 {
<a name="l00934"></a>00934 <span class="keyword">public</span>:
<a name="l00935"></a>00935   <a class="code" href="classItem__func__sign.html">Item_func_sign</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l00936"></a>00936   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;sign&quot;</span>; }
<a name="l00937"></a>00937   longlong val_int();
<a name="l00938"></a>00938 };
<a name="l00939"></a>00939 
<a name="l00940"></a>00940 
<a name="l00941"></a><a class="code" href="classItem__func__units.html">00941</a> <span class="keyword">class </span><a class="code" href="classItem__func__units.html">Item_func_units</a> :<span class="keyword">public</span> <a class="code" href="classItem__real__func.html">Item_real_func</a>
<a name="l00942"></a>00942 {
<a name="l00943"></a>00943   <span class="keywordtype">char</span> *name;
<a name="l00944"></a>00944   <span class="keywordtype">double</span> mul,add;
<a name="l00945"></a>00945 <span class="keyword">public</span>:
<a name="l00946"></a>00946   <a class="code" href="classItem__func__units.html">Item_func_units</a>(<span class="keywordtype">char</span> *name_arg,<a class="code" href="classItem.html">Item</a> *a,<span class="keywordtype">double</span> mul_arg,<span class="keywordtype">double</span> add_arg)
<a name="l00947"></a>00947     :<a class="code" href="classItem__real__func.html">Item_real_func</a>(a),name(name_arg),mul(mul_arg),add(add_arg) {}
<a name="l00948"></a>00948   <span class="keywordtype">double</span> val_real();
<a name="l00949"></a>00949   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> name; }
<a name="l00950"></a>00950   <span class="keywordtype">void</span> fix_length_and_dec()
<a name="l00951"></a>00951   { decimals= NOT_FIXED_DEC; max_length= float_length(decimals); }
<a name="l00952"></a>00952 };
<a name="l00953"></a>00953 
<a name="l00954"></a>00954 
<a name="l00955"></a><a class="code" href="classItem__func__min__max.html">00955</a> <span class="keyword">class </span><a class="code" href="classItem__func__min__max.html">Item_func_min_max</a> :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l00956"></a>00956 {
<a name="l00957"></a>00957   Item_result cmp_type;
<a name="l00958"></a>00958   <a class="code" href="classString.html">String</a> tmp_value;
<a name="l00959"></a>00959   <span class="keywordtype">int</span> cmp_sign;
<a name="l00960"></a>00960   <span class="comment">/* TRUE &lt;=&gt; arguments should be compared in the DATETIME context. */</span>
<a name="l00961"></a>00961   <span class="keywordtype">bool</span> compare_as_dates;
<a name="l00962"></a>00962   <span class="comment">/* An item used for issuing warnings while string to DATETIME conversion. */</span>
<a name="l00963"></a>00963   <a class="code" href="classItem.html">Item</a> *datetime_item;
<a name="l00964"></a>00964   THD *thd;
<a name="l00965"></a>00965 <span class="keyword">protected</span>:
<a name="l00966"></a>00966   enum_field_types cached_field_type;
<a name="l00967"></a>00967   uint cmp_datetimes(longlong *value);
<a name="l00968"></a>00968   uint cmp_times(longlong *value);
<a name="l00969"></a>00969 <span class="keyword">public</span>:
<a name="l00970"></a>00970   <a class="code" href="classItem__func__min__max.html">Item_func_min_max</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list,<span class="keywordtype">int</span> cmp_sign_arg) :<a class="code" href="classItem__func.html">Item_func</a>(list),
<a name="l00971"></a>00971     cmp_type(INT_RESULT), cmp_sign(cmp_sign_arg), compare_as_dates(FALSE),
<a name="l00972"></a>00972     datetime_item(0) {}
<a name="l00973"></a>00973   <span class="keywordtype">double</span> val_real();
<a name="l00974"></a>00974   longlong val_int();
<a name="l00975"></a>00975   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *);
<a name="l00976"></a>00976   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l00977"></a>00977   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate);
<a name="l00978"></a>00978   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime);  
<a name="l00979"></a>00979   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l00980"></a>00980   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const</span>
<a name="l00981"></a>00981 <span class="keyword">  </span>{
<a name="l00982"></a>00982     <span class="comment">/*</span>
<a name="l00983"></a>00983 <span class="comment">      If we compare as dates, then:</span>
<a name="l00984"></a>00984 <span class="comment">      - field_type is MYSQL_TYPE_VARSTRING, MYSQL_TYPE_DATETIME</span>
<a name="l00985"></a>00985 <span class="comment">        or MYSQL_TYPE_DATE.</span>
<a name="l00986"></a>00986 <span class="comment">      - cmp_type is INT_RESULT or DECIMAL_RESULT,</span>
<a name="l00987"></a>00987 <span class="comment">        depending on the amount of fractional digits.</span>
<a name="l00988"></a>00988 <span class="comment">      We need to return STRING_RESULT in this case instead of cmp_type.</span>
<a name="l00989"></a>00989 <span class="comment">    */</span>
<a name="l00990"></a>00990     <span class="keywordflow">return</span> compare_as_dates ? STRING_RESULT : cmp_type;
<a name="l00991"></a>00991   }
<a name="l00992"></a>00992   <span class="keyword">enum</span> Item_result cast_to_int_type ()<span class="keyword"> const</span>
<a name="l00993"></a>00993 <span class="keyword">  </span>{
<a name="l00994"></a>00994     <span class="comment">/*</span>
<a name="l00995"></a>00995 <span class="comment">      make CAST(LEAST_OR_GREATEST(datetime_expr, varchar_expr))</span>
<a name="l00996"></a>00996 <span class="comment">      return a number in format &quot;YYYMMDDhhmmss&quot;.</span>
<a name="l00997"></a>00997 <span class="comment">    */</span>
<a name="l00998"></a>00998     <span class="keywordflow">return</span> compare_as_dates ? INT_RESULT : result_type();
<a name="l00999"></a>00999   }
<a name="l01000"></a>01000   enum_field_types field_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cached_field_type; }
<a name="l01001"></a>01001 };
<a name="l01002"></a>01002 
<a name="l01003"></a><a class="code" href="classItem__func__min.html">01003</a> <span class="keyword">class </span><a class="code" href="classItem__func__min.html">Item_func_min</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__min__max.html">Item_func_min_max</a>
<a name="l01004"></a>01004 {
<a name="l01005"></a>01005 <span class="keyword">public</span>:
<a name="l01006"></a>01006   <a class="code" href="classItem__func__min.html">Item_func_min</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list) :<a class="code" href="classItem__func__min__max.html">Item_func_min_max</a>(list,1) {}
<a name="l01007"></a>01007   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;least&quot;</span>; }
<a name="l01008"></a>01008 };
<a name="l01009"></a>01009 
<a name="l01010"></a><a class="code" href="classItem__func__max.html">01010</a> <span class="keyword">class </span><a class="code" href="classItem__func__max.html">Item_func_max</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__min__max.html">Item_func_min_max</a>
<a name="l01011"></a>01011 {
<a name="l01012"></a>01012 <span class="keyword">public</span>:
<a name="l01013"></a>01013   <a class="code" href="classItem__func__max.html">Item_func_max</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list) :<a class="code" href="classItem__func__min__max.html">Item_func_min_max</a>(list,-1) {}
<a name="l01014"></a>01014   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;greatest&quot;</span>; }
<a name="l01015"></a>01015 };
<a name="l01016"></a>01016 
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="comment">/* </span>
<a name="l01019"></a>01019 <span class="comment">  Objects of this class are used for ROLLUP queries to wrap up </span>
<a name="l01020"></a>01020 <span class="comment">  each constant item referred to in GROUP BY list. </span>
<a name="l01021"></a>01021 <span class="comment">*/</span>
<a name="l01022"></a>01022 
<a name="l01023"></a><a class="code" href="classItem__func__rollup__const.html">01023</a> <span class="keyword">class </span><a class="code" href="classItem__func__rollup__const.html">Item_func_rollup_const</a> :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l01024"></a>01024 {
<a name="l01025"></a>01025 <span class="keyword">public</span>:
<a name="l01026"></a>01026   <a class="code" href="classItem__func__rollup__const.html">Item_func_rollup_const</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func.html">Item_func</a>(a)
<a name="l01027"></a>01027   {
<a name="l01028"></a>01028     item_name= a-&gt;item_name;
<a name="l01029"></a>01029   }
<a name="l01030"></a>01030   <span class="keywordtype">double</span> val_real() { <span class="keywordflow">return</span> args[0]-&gt;val_real(); }
<a name="l01031"></a>01031   longlong val_int() { <span class="keywordflow">return</span> args[0]-&gt;val_int(); }
<a name="l01032"></a>01032   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str) { <span class="keywordflow">return</span> args[0]-&gt;val_str(str); }
<a name="l01033"></a>01033   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *dec) { <span class="keywordflow">return</span> args[0]-&gt;val_decimal(dec); }
<a name="l01034"></a>01034   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l01035"></a>01035   {
<a name="l01036"></a>01036     <span class="keywordflow">return</span> args[0]-&gt;get_date(ltime, fuzzydate);
<a name="l01037"></a>01037   }
<a name="l01038"></a>01038   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l01039"></a>01039   {
<a name="l01040"></a>01040     <span class="keywordflow">return</span> args[0]-&gt;get_time(ltime);
<a name="l01041"></a>01041   }
<a name="l01042"></a>01042   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;rollup_const&quot;</span>; }
<a name="l01043"></a>01043   <span class="keywordtype">bool</span> const_item()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l01044"></a>01044   Item_result result_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> args[0]-&gt;result_type(); }
<a name="l01045"></a>01045   <span class="keywordtype">void</span> fix_length_and_dec()
<a name="l01046"></a>01046   {
<a name="l01047"></a>01047     collation= args[0]-&gt;collation;
<a name="l01048"></a>01048     max_length= args[0]-&gt;max_length;
<a name="l01049"></a>01049     decimals=args[0]-&gt;decimals; 
<a name="l01050"></a>01050     <span class="comment">/* The item could be a NULL constant. */</span>
<a name="l01051"></a>01051     null_value= args[0]-&gt;is_null();
<a name="l01052"></a>01052   }
<a name="l01053"></a>01053   enum_field_types field_type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> args[0]-&gt;field_type(); }
<a name="l01054"></a>01054 };
<a name="l01055"></a>01055 
<a name="l01056"></a>01056 
<a name="l01057"></a><a class="code" href="classItem__func__length.html">01057</a> <span class="keyword">class </span><a class="code" href="classItem__func__length.html">Item_func_length</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01058"></a>01058 {
<a name="l01059"></a>01059   <a class="code" href="classString.html">String</a> value;
<a name="l01060"></a>01060 <span class="keyword">public</span>:
<a name="l01061"></a>01061   <a class="code" href="classItem__func__length.html">Item_func_length</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01062"></a>01062   longlong val_int();
<a name="l01063"></a>01063   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;length&quot;</span>; }
<a name="l01064"></a>01064   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=10; }
<a name="l01065"></a>01065 };
<a name="l01066"></a>01066 
<a name="l01067"></a><a class="code" href="classItem__func__bit__length.html">01067</a> <span class="keyword">class </span><a class="code" href="classItem__func__bit__length.html">Item_func_bit_length</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__length.html">Item_func_length</a>
<a name="l01068"></a>01068 {
<a name="l01069"></a>01069 <span class="keyword">public</span>:
<a name="l01070"></a>01070   <a class="code" href="classItem__func__bit__length.html">Item_func_bit_length</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__length.html">Item_func_length</a>(a) {}
<a name="l01071"></a>01071   longlong val_int()
<a name="l01072"></a>01072     { DBUG_ASSERT(fixed == 1); <span class="keywordflow">return</span> Item_func_length::val_int()*8; }
<a name="l01073"></a>01073   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;bit_length&quot;</span>; }
<a name="l01074"></a>01074 };
<a name="l01075"></a>01075 
<a name="l01076"></a><a class="code" href="classItem__func__char__length.html">01076</a> <span class="keyword">class </span><a class="code" href="classItem__func__char__length.html">Item_func_char_length</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01077"></a>01077 {
<a name="l01078"></a>01078   <a class="code" href="classString.html">String</a> value;
<a name="l01079"></a>01079 <span class="keyword">public</span>:
<a name="l01080"></a>01080   <a class="code" href="classItem__func__char__length.html">Item_func_char_length</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01081"></a>01081   longlong val_int();
<a name="l01082"></a>01082   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;char_length&quot;</span>; }
<a name="l01083"></a>01083   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=10; }
<a name="l01084"></a>01084 };
<a name="l01085"></a>01085 
<a name="l01086"></a><a class="code" href="classItem__func__coercibility.html">01086</a> <span class="keyword">class </span><a class="code" href="classItem__func__coercibility.html">Item_func_coercibility</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01087"></a>01087 {
<a name="l01088"></a>01088 <span class="keyword">public</span>:
<a name="l01089"></a>01089   <a class="code" href="classItem__func__coercibility.html">Item_func_coercibility</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01090"></a>01090   longlong val_int();
<a name="l01091"></a>01091   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;coercibility&quot;</span>; }
<a name="l01092"></a>01092   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=10; maybe_null= 0; }
<a name="l01093"></a>01093   table_map not_null_tables()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l01094"></a>01094 };
<a name="l01095"></a>01095 
<a name="l01096"></a><a class="code" href="classItem__func__locate.html">01096</a> <span class="keyword">class </span><a class="code" href="classItem__func__locate.html">Item_func_locate</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01097"></a>01097 {
<a name="l01098"></a>01098   <a class="code" href="classString.html">String</a> value1,value2;
<a name="l01099"></a>01099   <a class="code" href="classDTCollation.html">DTCollation</a> cmp_collation;
<a name="l01100"></a>01100 <span class="keyword">public</span>:
<a name="l01101"></a>01101   <a class="code" href="classItem__func__locate.html">Item_func_locate</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a,b) {}
<a name="l01102"></a>01102   <a class="code" href="classItem__func__locate.html">Item_func_locate</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b,<a class="code" href="classItem.html">Item</a> *c) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a,b,c) {}
<a name="l01103"></a>01103   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;locate&quot;</span>; }
<a name="l01104"></a>01104   longlong val_int();
<a name="l01105"></a>01105   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l01106"></a>01106   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__locate.html#a66c584b36c479cedcf3d7e2434fbf2d9">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01107"></a>01107 };
<a name="l01108"></a>01108 
<a name="l01109"></a>01109 
<a name="l01110"></a><a class="code" href="classItem__func__validate__password__strength.html">01110</a> <span class="keyword">class </span><a class="code" href="classItem__func__validate__password__strength.html">Item_func_validate_password_strength</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01111"></a>01111 {
<a name="l01112"></a>01112   <a class="code" href="classString.html">String</a> value;
<a name="l01113"></a>01113 <span class="keyword">public</span>:
<a name="l01114"></a>01114   <a class="code" href="classItem__func__validate__password__strength.html">Item_func_validate_password_strength</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01115"></a>01115   longlong val_int();
<a name="l01116"></a>01116   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;validate_password_strength&quot;</span>; }
<a name="l01117"></a>01117   <span class="keywordtype">void</span> fix_length_and_dec() { max_length= 10; maybe_null= 1; }
<a name="l01118"></a>01118 };
<a name="l01119"></a>01119 
<a name="l01120"></a>01120 
<a name="l01121"></a><a class="code" href="classItem__func__field.html">01121</a> <span class="keyword">class </span><a class="code" href="classItem__func__field.html">Item_func_field</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01122"></a>01122 {
<a name="l01123"></a>01123   <a class="code" href="classString.html">String</a> value,tmp;
<a name="l01124"></a>01124   Item_result cmp_type;
<a name="l01125"></a>01125   <a class="code" href="classDTCollation.html">DTCollation</a> cmp_collation;
<a name="l01126"></a>01126 <span class="keyword">public</span>:
<a name="l01127"></a>01127   <a class="code" href="classItem__func__field.html">Item_func_field</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(list) {}
<a name="l01128"></a>01128   longlong val_int();
<a name="l01129"></a>01129   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;field&quot;</span>; }
<a name="l01130"></a>01130   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l01131"></a>01131 };
<a name="l01132"></a>01132 
<a name="l01133"></a>01133 
<a name="l01134"></a><a class="code" href="classItem__func__ascii.html">01134</a> <span class="keyword">class </span><a class="code" href="classItem__func__ascii.html">Item_func_ascii</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01135"></a>01135 {
<a name="l01136"></a>01136   <a class="code" href="classString.html">String</a> value;
<a name="l01137"></a>01137 <span class="keyword">public</span>:
<a name="l01138"></a>01138   <a class="code" href="classItem__func__ascii.html">Item_func_ascii</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01139"></a>01139   longlong val_int();
<a name="l01140"></a>01140   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;ascii&quot;</span>; }
<a name="l01141"></a>01141   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=3; }
<a name="l01142"></a>01142 };
<a name="l01143"></a>01143 
<a name="l01144"></a><a class="code" href="classItem__func__ord.html">01144</a> <span class="keyword">class </span><a class="code" href="classItem__func__ord.html">Item_func_ord</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01145"></a>01145 {
<a name="l01146"></a>01146   <a class="code" href="classString.html">String</a> value;
<a name="l01147"></a>01147 <span class="keyword">public</span>:
<a name="l01148"></a>01148   <a class="code" href="classItem__func__ord.html">Item_func_ord</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01149"></a>01149   longlong val_int();
<a name="l01150"></a>01150   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;ord&quot;</span>; }
<a name="l01151"></a>01151 };
<a name="l01152"></a>01152 
<a name="l01153"></a><a class="code" href="classItem__func__find__in__set.html">01153</a> <span class="keyword">class </span><a class="code" href="classItem__func__find__in__set.html">Item_func_find_in_set</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01154"></a>01154 {
<a name="l01155"></a>01155   <a class="code" href="classString.html">String</a> value,value2;
<a name="l01156"></a>01156   uint enum_value;
<a name="l01157"></a>01157   ulonglong enum_bit;
<a name="l01158"></a>01158   <a class="code" href="classDTCollation.html">DTCollation</a> cmp_collation;
<a name="l01159"></a>01159 <span class="keyword">public</span>:
<a name="l01160"></a>01160   <a class="code" href="classItem__func__find__in__set.html">Item_func_find_in_set</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a,b),enum_value(0) {}
<a name="l01161"></a>01161   longlong val_int();
<a name="l01162"></a>01162   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;find_in_set&quot;</span>; }
<a name="l01163"></a>01163   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l01164"></a>01164 };
<a name="l01165"></a>01165 
<a name="l01166"></a>01166 <span class="comment">/* Base class for all bit functions: &#39;~&#39;, &#39;|&#39;, &#39;^&#39;, &#39;&amp;&#39;, &#39;&gt;&gt;&#39;, &#39;&lt;&lt;&#39; */</span>
<a name="l01167"></a>01167 
<a name="l01168"></a><a class="code" href="classItem__func__bit.html">01168</a> <span class="keyword">class </span><a class="code" href="classItem__func__bit.html">Item_func_bit</a>: <span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01169"></a>01169 {
<a name="l01170"></a>01170 <span class="keyword">public</span>:
<a name="l01171"></a>01171   <a class="code" href="classItem__func__bit.html">Item_func_bit</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a, b) {}
<a name="l01172"></a>01172   <a class="code" href="classItem__func__bit.html">Item_func_bit</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01173"></a>01173   <span class="keywordtype">void</span> fix_length_and_dec() { unsigned_flag= 1; }
<a name="l01174"></a>01174 
<a name="l01175"></a><a class="code" href="classItem__func__bit.html#ae3e963b6144fa092e3b8a5d44c42a76e">01175</a>   <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__bit.html#ae3e963b6144fa092e3b8a5d44c42a76e">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type)
<a name="l01176"></a>01176   {
<a name="l01177"></a>01177     print_op(str, query_type);
<a name="l01178"></a>01178   }
<a name="l01179"></a>01179 };
<a name="l01180"></a>01180 
<a name="l01181"></a><a class="code" href="classItem__func__bit__or.html">01181</a> <span class="keyword">class </span><a class="code" href="classItem__func__bit__or.html">Item_func_bit_or</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__bit.html">Item_func_bit</a>
<a name="l01182"></a>01182 {
<a name="l01183"></a>01183 <span class="keyword">public</span>:
<a name="l01184"></a>01184   <a class="code" href="classItem__func__bit__or.html">Item_func_bit_or</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__bit.html">Item_func_bit</a>(a, b) {}
<a name="l01185"></a>01185   longlong val_int();
<a name="l01186"></a>01186   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;|&quot;</span>; }
<a name="l01187"></a>01187 };
<a name="l01188"></a>01188 
<a name="l01189"></a><a class="code" href="classItem__func__bit__and.html">01189</a> <span class="keyword">class </span><a class="code" href="classItem__func__bit__and.html">Item_func_bit_and</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__bit.html">Item_func_bit</a>
<a name="l01190"></a>01190 {
<a name="l01191"></a>01191 <span class="keyword">public</span>:
<a name="l01192"></a>01192   <a class="code" href="classItem__func__bit__and.html">Item_func_bit_and</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__bit.html">Item_func_bit</a>(a, b) {}
<a name="l01193"></a>01193   longlong val_int();
<a name="l01194"></a>01194   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;&amp;&quot;</span>; }
<a name="l01195"></a>01195 };
<a name="l01196"></a>01196 
<a name="l01197"></a><a class="code" href="classItem__func__bit__count.html">01197</a> <span class="keyword">class </span><a class="code" href="classItem__func__bit__count.html">Item_func_bit_count</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01198"></a>01198 {
<a name="l01199"></a>01199 <span class="keyword">public</span>:
<a name="l01200"></a>01200   <a class="code" href="classItem__func__bit__count.html">Item_func_bit_count</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01201"></a>01201   longlong val_int();
<a name="l01202"></a>01202   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;bit_count&quot;</span>; }
<a name="l01203"></a>01203   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=2; }
<a name="l01204"></a>01204 };
<a name="l01205"></a>01205 
<a name="l01206"></a><a class="code" href="classItem__func__shift__left.html">01206</a> <span class="keyword">class </span><a class="code" href="classItem__func__shift__left.html">Item_func_shift_left</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__bit.html">Item_func_bit</a>
<a name="l01207"></a>01207 {
<a name="l01208"></a>01208 <span class="keyword">public</span>:
<a name="l01209"></a>01209   <a class="code" href="classItem__func__shift__left.html">Item_func_shift_left</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__bit.html">Item_func_bit</a>(a, b) {}
<a name="l01210"></a>01210   longlong val_int();
<a name="l01211"></a>01211   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;&lt;&quot;</span>; }
<a name="l01212"></a>01212 };
<a name="l01213"></a>01213 
<a name="l01214"></a><a class="code" href="classItem__func__shift__right.html">01214</a> <span class="keyword">class </span><a class="code" href="classItem__func__shift__right.html">Item_func_shift_right</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__bit.html">Item_func_bit</a>
<a name="l01215"></a>01215 {
<a name="l01216"></a>01216 <span class="keyword">public</span>:
<a name="l01217"></a>01217   <a class="code" href="classItem__func__shift__right.html">Item_func_shift_right</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__bit.html">Item_func_bit</a>(a, b) {}
<a name="l01218"></a>01218   longlong val_int();
<a name="l01219"></a>01219   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;&gt;&gt;&quot;</span>; }
<a name="l01220"></a>01220 };
<a name="l01221"></a>01221 
<a name="l01222"></a><a class="code" href="classItem__func__bit__neg.html">01222</a> <span class="keyword">class </span><a class="code" href="classItem__func__bit__neg.html">Item_func_bit_neg</a> :<span class="keyword">public</span> <a class="code" href="classItem__func__bit.html">Item_func_bit</a>
<a name="l01223"></a>01223 {
<a name="l01224"></a>01224 <span class="keyword">public</span>:
<a name="l01225"></a>01225   <a class="code" href="classItem__func__bit__neg.html">Item_func_bit_neg</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func__bit.html">Item_func_bit</a>(a) {}
<a name="l01226"></a>01226   longlong val_int();
<a name="l01227"></a>01227   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;~&quot;</span>; }
<a name="l01228"></a>01228 
<a name="l01229"></a><a class="code" href="classItem__func__bit__neg.html#a7bdcce3973449979418cdcbc6a2ec3df">01229</a>   <span class="keyword">virtual</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__bit__neg.html#a7bdcce3973449979418cdcbc6a2ec3df">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type)
<a name="l01230"></a>01230   {
<a name="l01231"></a>01231     <a class="code" href="classItem__func__bit__neg.html#a7bdcce3973449979418cdcbc6a2ec3df">Item_func::print</a>(str, query_type);
<a name="l01232"></a>01232   }
<a name="l01233"></a>01233 };
<a name="l01234"></a>01234 
<a name="l01235"></a>01235 
<a name="l01236"></a><a class="code" href="classItem__func__last__insert__id.html">01236</a> <span class="keyword">class </span><a class="code" href="classItem__func__last__insert__id.html">Item_func_last_insert_id</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01237"></a>01237 {
<a name="l01238"></a>01238 <span class="keyword">public</span>:
<a name="l01239"></a>01239   <a class="code" href="classItem__func__last__insert__id.html">Item_func_last_insert_id</a>() :<a class="code" href="classItem__int__func.html">Item_int_func</a>() {}
<a name="l01240"></a>01240   <a class="code" href="classItem__func__last__insert__id.html">Item_func_last_insert_id</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01241"></a>01241   longlong val_int();
<a name="l01242"></a>01242   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;last_insert_id&quot;</span>; }
<a name="l01243"></a>01243   <span class="keywordtype">void</span> fix_length_and_dec()
<a name="l01244"></a>01244   {
<a name="l01245"></a>01245     unsigned_flag= TRUE;
<a name="l01246"></a>01246     <span class="keywordflow">if</span> (arg_count)
<a name="l01247"></a>01247       max_length= args[0]-&gt;max_length;
<a name="l01248"></a>01248   }
<a name="l01249"></a>01249   <span class="keywordtype">bool</span> fix_fields(THD *thd, <a class="code" href="classItem.html">Item</a> **ref);
<a name="l01250"></a>01250 };
<a name="l01251"></a>01251 
<a name="l01252"></a>01252 
<a name="l01253"></a><a class="code" href="classItem__func__benchmark.html">01253</a> <span class="keyword">class </span><a class="code" href="classItem__func__benchmark.html">Item_func_benchmark</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01254"></a>01254 {
<a name="l01255"></a>01255 <span class="keyword">public</span>:
<a name="l01256"></a>01256   <a class="code" href="classItem__func__benchmark.html">Item_func_benchmark</a>(<a class="code" href="classItem.html">Item</a> *count_expr, <a class="code" href="classItem.html">Item</a> *expr)
<a name="l01257"></a>01257     :<a class="code" href="classItem__int__func.html">Item_int_func</a>(count_expr, expr)
<a name="l01258"></a>01258   {}
<a name="l01259"></a>01259   longlong val_int();
<a name="l01260"></a>01260   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;benchmark&quot;</span>; }
<a name="l01261"></a>01261   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=1; maybe_null=0; }
<a name="l01262"></a>01262   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__benchmark.html#a715af910383ced4843ec9cf3fb41ce75">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01263"></a>01263 };
<a name="l01264"></a>01264 
<a name="l01265"></a>01265 
<a name="l01266"></a><a class="code" href="classItem__func__sleep.html">01266</a> <span class="keyword">class </span><a class="code" href="classItem__func__sleep.html">Item_func_sleep</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01267"></a>01267 {
<a name="l01268"></a>01268 <span class="keyword">public</span>:
<a name="l01269"></a>01269   <a class="code" href="classItem__func__sleep.html">Item_func_sleep</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01270"></a>01270   <span class="keywordtype">bool</span> const_item()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l01271"></a>01271   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;sleep&quot;</span>; }
<a name="l01278"></a><a class="code" href="classItem__func__sleep.html#a68a55cd80d7bd76487d2cf7887b620ea">01278</a>   table_map <a class="code" href="classItem__func__sleep.html#a68a55cd80d7bd76487d2cf7887b620ea">get_initial_pseudo_tables</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> RAND_TABLE_BIT; }
<a name="l01279"></a>01279   longlong <a class="code" href="classItem__func__sleep.html#a999707d353b1b7c9142b97521b196b3a">val_int</a>();
<a name="l01280"></a>01280 };
<a name="l01281"></a>01281 
<a name="l01282"></a>01282 
<a name="l01283"></a>01283 
<a name="l01284"></a>01284 <span class="preprocessor">#ifdef HAVE_DLOPEN</span>
<a name="l01285"></a>01285 <span class="preprocessor"></span>
<a name="l01286"></a>01286 <span class="keyword">class </span>Item_udf_func :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l01287"></a>01287 {
<a name="l01288"></a>01288 <span class="keyword">protected</span>:
<a name="l01289"></a>01289   <a class="code" href="classudf__handler.html">udf_handler</a> udf;
<a name="l01290"></a>01290   <span class="keywordtype">bool</span> is_expensive_processor(uchar *arg) { <span class="keywordflow">return</span> TRUE; }
<a name="l01291"></a>01291 
<a name="l01292"></a>01292 <span class="keyword">public</span>:
<a name="l01293"></a>01293   Item_udf_func(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01294"></a>01294     :<a class="code" href="classItem__func.html">Item_func</a>(), udf(udf_arg) {}
<a name="l01295"></a>01295   Item_udf_func(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg, <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01296"></a>01296     :<a class="code" href="classItem__func.html">Item_func</a>(list), udf(udf_arg) {}
<a name="l01297"></a>01297   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> udf.name(); }
<a name="l01298"></a>01298   <span class="keyword">enum</span> Functype functype()<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> UDF_FUNC; }
<a name="l01299"></a>01299   <span class="keywordtype">bool</span> fix_fields(THD *thd, <a class="code" href="classItem.html">Item</a> **ref)
<a name="l01300"></a>01300   {
<a name="l01301"></a>01301     DBUG_ASSERT(fixed == 0);
<a name="l01302"></a>01302     <span class="keywordtype">bool</span> res= udf.fix_fields(thd, <span class="keyword">this</span>, arg_count, args);
<a name="l01303"></a>01303     used_tables_cache= udf.used_tables_cache;
<a name="l01304"></a>01304     const_item_cache= udf.const_item_cache;
<a name="l01305"></a>01305     fixed= 1;
<a name="l01306"></a>01306     <span class="keywordflow">return</span> res;
<a name="l01307"></a>01307   }
<a name="l01308"></a>01308   <span class="keywordtype">void</span> update_used_tables() 
<a name="l01309"></a>01309   {
<a name="l01310"></a>01310     <span class="comment">/*</span>
<a name="l01311"></a>01311 <span class="comment">      TODO: Make a member in UDF_INIT and return if a UDF is deterministic or</span>
<a name="l01312"></a>01312 <span class="comment">      not.</span>
<a name="l01313"></a>01313 <span class="comment">      Currently UDF_INIT has a member (const_item) that is an in/out </span>
<a name="l01314"></a>01314 <span class="comment">      parameter to the init() call.</span>
<a name="l01315"></a>01315 <span class="comment">      The code in udf_handler::fix_fields also duplicates the arguments </span>
<a name="l01316"></a>01316 <span class="comment">      handling code in Item_func::fix_fields().</span>
<a name="l01317"></a>01317 <span class="comment">      </span>
<a name="l01318"></a>01318 <span class="comment">      The lack of information if a UDF is deterministic makes writing</span>
<a name="l01319"></a>01319 <span class="comment">      a correct update_used_tables() for UDFs impossible.</span>
<a name="l01320"></a>01320 <span class="comment">      One solution to this would be :</span>
<a name="l01321"></a>01321 <span class="comment">       - Add a is_deterministic member of UDF_INIT</span>
<a name="l01322"></a>01322 <span class="comment">       - (optionally) deprecate the const_item member of UDF_INIT</span>
<a name="l01323"></a>01323 <span class="comment">       - Take away the duplicate code from udf_handler::fix_fields() and</span>
<a name="l01324"></a>01324 <span class="comment">         make Item_udf_func call Item_func::fix_fields() to process its </span>
<a name="l01325"></a>01325 <span class="comment">         arguments as for any other function.</span>
<a name="l01326"></a>01326 <span class="comment">       - Store the deterministic flag returned by &lt;udf&gt;_init into the </span>
<a name="l01327"></a>01327 <span class="comment">       udf_handler. </span>
<a name="l01328"></a>01328 <span class="comment">       - Don&#39;t implement Item_udf_func::fix_fields, implement</span>
<a name="l01329"></a>01329 <span class="comment">       Item_udf_func::fix_length_and_dec() instead (similar to non-UDF</span>
<a name="l01330"></a>01330 <span class="comment">       functions).</span>
<a name="l01331"></a>01331 <span class="comment">       - Override Item_func::update_used_tables to call </span>
<a name="l01332"></a>01332 <span class="comment">       Item_func::update_used_tables() and add a RAND_TABLE_BIT to the </span>
<a name="l01333"></a>01333 <span class="comment">       result of Item_func::update_used_tables() if the UDF is </span>
<a name="l01334"></a>01334 <span class="comment">       non-deterministic.</span>
<a name="l01335"></a>01335 <span class="comment">       - (optionally) rename RAND_TABLE_BIT to NONDETERMINISTIC_BIT to</span>
<a name="l01336"></a>01336 <span class="comment">       better describe its usage.</span>
<a name="l01337"></a>01337 <span class="comment">       </span>
<a name="l01338"></a>01338 <span class="comment">      The above would require a change of the UDF API.</span>
<a name="l01339"></a>01339 <span class="comment">      Until that change is done here&#39;s how the current code works:</span>
<a name="l01340"></a>01340 <span class="comment">      We call Item_func::update_used_tables() only when we know that</span>
<a name="l01341"></a>01341 <span class="comment">      the function depends on real non-const tables and is deterministic.</span>
<a name="l01342"></a>01342 <span class="comment">      This can be done only because we know that the optimizer will</span>
<a name="l01343"></a>01343 <span class="comment">      call update_used_tables() only when there&#39;s possibly a new const</span>
<a name="l01344"></a>01344 <span class="comment">      table. So update_used_tables() can only make a Item_func more</span>
<a name="l01345"></a>01345 <span class="comment">      constant than it is currently.</span>
<a name="l01346"></a>01346 <span class="comment">      That&#39;s why we don&#39;t need to do anything if a function is guaranteed</span>
<a name="l01347"></a>01347 <span class="comment">      to return non-constant (it&#39;s non-deterministic) or is already a</span>
<a name="l01348"></a>01348 <span class="comment">      const.</span>
<a name="l01349"></a>01349 <span class="comment">    */</span>  
<a name="l01350"></a>01350     <span class="keywordflow">if</span> ((used_tables_cache &amp; ~PSEUDO_TABLE_BITS) &amp;&amp; 
<a name="l01351"></a>01351         !(used_tables_cache &amp; RAND_TABLE_BIT))
<a name="l01352"></a>01352     {
<a name="l01353"></a>01353       Item_func::update_used_tables();
<a name="l01354"></a>01354       <span class="keywordflow">if</span> (!const_item_cache &amp;&amp; !used_tables_cache)
<a name="l01355"></a>01355         used_tables_cache= RAND_TABLE_BIT;
<a name="l01356"></a>01356     }
<a name="l01357"></a>01357   }
<a name="l01358"></a>01358   <span class="keywordtype">void</span> cleanup();
<a name="l01359"></a>01359   Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> udf.result_type(); }
<a name="l01360"></a>01360   table_map not_null_tables()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l01361"></a>01361   <span class="keywordtype">bool</span> is_expensive() { <span class="keywordflow">return</span> 1; }
<a name="l01362"></a>01362   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func.html#afb302ee25d4721ace27d3f5053d4ee41">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01363"></a>01363 };
<a name="l01364"></a>01364 
<a name="l01365"></a>01365 
<a name="l01366"></a>01366 <span class="keyword">class </span><a class="code" href="classItem__func__udf__float.html">Item_func_udf_float</a> :<span class="keyword">public</span> Item_udf_func
<a name="l01367"></a>01367 {
<a name="l01368"></a>01368  <span class="keyword">public</span>:
<a name="l01369"></a>01369   <a class="code" href="classItem__func__udf__float.html">Item_func_udf_float</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01370"></a>01370     :Item_udf_func(udf_arg) {}
<a name="l01371"></a>01371   <a class="code" href="classItem__func__udf__float.html">Item_func_udf_float</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg,
<a name="l01372"></a>01372                       <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01373"></a>01373     :Item_udf_func(udf_arg, list) {}
<a name="l01374"></a>01374   longlong val_int()
<a name="l01375"></a>01375   {
<a name="l01376"></a>01376     DBUG_ASSERT(fixed == 1);
<a name="l01377"></a>01377     <span class="keywordflow">return</span> (longlong) rint(Item_func_udf_float::val_real());
<a name="l01378"></a>01378   }
<a name="l01379"></a>01379   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *dec_buf)
<a name="l01380"></a>01380   {
<a name="l01381"></a>01381     <span class="keywordtype">double</span> res=val_real();
<a name="l01382"></a>01382     <span class="keywordflow">if</span> (null_value)
<a name="l01383"></a>01383       <span class="keywordflow">return</span> NULL;
<a name="l01384"></a>01384     double2my_decimal(E_DEC_FATAL_ERROR, res, dec_buf);
<a name="l01385"></a>01385     <span class="keywordflow">return</span> dec_buf;
<a name="l01386"></a>01386   }
<a name="l01387"></a>01387   <span class="keywordtype">double</span> val_real();
<a name="l01388"></a>01388   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str);
<a name="l01389"></a>01389   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l01390"></a>01390   {
<a name="l01391"></a>01391     <span class="keywordflow">return</span> <a class="code" href="classItem.html#ae3a6ba6818f83f4c727a27c71bd59f59">get_date_from_real</a>(ltime, fuzzydate);
<a name="l01392"></a>01392   }
<a name="l01393"></a>01393   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l01394"></a>01394   {
<a name="l01395"></a>01395     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a309d78890d1ca16e7555d3030614a9fa">get_time_from_real</a>(ltime);
<a name="l01396"></a>01396   }
<a name="l01397"></a>01397   <span class="keywordtype">void</span> fix_length_and_dec() { fix_num_length_and_dec(); }
<a name="l01398"></a>01398 };
<a name="l01399"></a>01399 
<a name="l01400"></a>01400 
<a name="l01401"></a>01401 <span class="keyword">class </span><a class="code" href="classItem__func__udf__int.html">Item_func_udf_int</a> :<span class="keyword">public</span> Item_udf_func
<a name="l01402"></a>01402 {
<a name="l01403"></a>01403 <span class="keyword">public</span>:
<a name="l01404"></a>01404   <a class="code" href="classItem__func__udf__int.html">Item_func_udf_int</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01405"></a>01405     :Item_udf_func(udf_arg) {}
<a name="l01406"></a>01406   <a class="code" href="classItem__func__udf__int.html">Item_func_udf_int</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg,
<a name="l01407"></a>01407                     <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01408"></a>01408     :Item_udf_func(udf_arg, list) {}
<a name="l01409"></a>01409   longlong val_int();
<a name="l01410"></a>01410   <span class="keywordtype">double</span> val_real() { <span class="keywordflow">return</span> (<span class="keywordtype">double</span>) Item_func_udf_int::val_int(); }
<a name="l01411"></a>01411   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str);
<a name="l01412"></a>01412   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l01413"></a>01413   {
<a name="l01414"></a>01414     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a79cce40c2785a2126cd3b8277a165a61">get_date_from_int</a>(ltime, fuzzydate);
<a name="l01415"></a>01415   }
<a name="l01416"></a>01416   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l01417"></a>01417   {
<a name="l01418"></a>01418     <span class="keywordflow">return</span> <a class="code" href="classItem.html#afc9b0e1c1a122f5394f6ab80135cfd24">get_time_from_int</a>(ltime);
<a name="l01419"></a>01419   }
<a name="l01420"></a>01420   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> INT_RESULT; }
<a name="l01421"></a>01421   <span class="keywordtype">void</span> fix_length_and_dec() { decimals= 0; max_length= 21; }
<a name="l01422"></a>01422 };
<a name="l01423"></a>01423 
<a name="l01424"></a>01424 
<a name="l01425"></a>01425 <span class="keyword">class </span><a class="code" href="classItem__func__udf__decimal.html">Item_func_udf_decimal</a> :<span class="keyword">public</span> Item_udf_func
<a name="l01426"></a>01426 {
<a name="l01427"></a>01427 <span class="keyword">public</span>:
<a name="l01428"></a>01428   <a class="code" href="classItem__func__udf__decimal.html">Item_func_udf_decimal</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01429"></a>01429     :Item_udf_func(udf_arg) {}
<a name="l01430"></a>01430   <a class="code" href="classItem__func__udf__decimal.html">Item_func_udf_decimal</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg, <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01431"></a>01431     :Item_udf_func(udf_arg, list) {}
<a name="l01432"></a>01432   longlong val_int();
<a name="l01433"></a>01433   <span class="keywordtype">double</span> val_real();
<a name="l01434"></a>01434   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01435"></a>01435   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str);
<a name="l01436"></a>01436   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l01437"></a>01437   {
<a name="l01438"></a>01438     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a4bc61001a2485f584b526ca9da05f3e0">get_date_from_decimal</a>(ltime, fuzzydate);
<a name="l01439"></a>01439   }
<a name="l01440"></a>01440   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l01441"></a>01441   {
<a name="l01442"></a>01442     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a099dd8c794d94ac482747e34e4f7a6b3">get_time_from_decimal</a>(ltime);
<a name="l01443"></a>01443   }
<a name="l01444"></a>01444   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> DECIMAL_RESULT; }
<a name="l01445"></a>01445   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l01446"></a>01446 };
<a name="l01447"></a>01447 
<a name="l01448"></a>01448 
<a name="l01449"></a>01449 <span class="keyword">class </span><a class="code" href="classItem__func__udf__str.html">Item_func_udf_str</a> :<span class="keyword">public</span> Item_udf_func
<a name="l01450"></a>01450 {
<a name="l01451"></a>01451 <span class="keyword">public</span>:
<a name="l01452"></a>01452   <a class="code" href="classItem__func__udf__str.html">Item_func_udf_str</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01453"></a>01453     :Item_udf_func(udf_arg) {}
<a name="l01454"></a>01454   <a class="code" href="classItem__func__udf__str.html">Item_func_udf_str</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg, <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01455"></a>01455     :Item_udf_func(udf_arg, list) {}
<a name="l01456"></a>01456   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *);
<a name="l01457"></a>01457   <span class="keywordtype">double</span> val_real()
<a name="l01458"></a>01458   {
<a name="l01459"></a>01459     <span class="keywordtype">int</span> err_not_used;
<a name="l01460"></a>01460     <span class="keywordtype">char</span> *end_not_used;
<a name="l01461"></a>01461     <a class="code" href="classString.html">String</a> *res;
<a name="l01462"></a>01462     res= val_str(&amp;str_value);
<a name="l01463"></a>01463     <span class="keywordflow">return</span> res ? my_strntod(res-&gt;charset(),(<span class="keywordtype">char</span>*) res-&gt;ptr(), 
<a name="l01464"></a>01464                             res-&gt;length(), &amp;end_not_used, &amp;err_not_used) : 0.0;
<a name="l01465"></a>01465   }
<a name="l01466"></a>01466   longlong val_int()
<a name="l01467"></a>01467   {
<a name="l01468"></a>01468     <span class="keywordtype">int</span> err_not_used;
<a name="l01469"></a>01469     <a class="code" href="classString.html">String</a> *res;  res=val_str(&amp;str_value);
<a name="l01470"></a>01470     <span class="keywordflow">return</span> res ? my_strntoll(res-&gt;charset(),res-&gt;ptr(),res-&gt;length(),10,
<a name="l01471"></a>01471                              (<span class="keywordtype">char</span>**) 0, &amp;err_not_used) : (longlong) 0;
<a name="l01472"></a>01472   }
<a name="l01473"></a>01473   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *dec_buf)
<a name="l01474"></a>01474   {
<a name="l01475"></a>01475     <a class="code" href="classString.html">String</a> *res=val_str(&amp;str_value);
<a name="l01476"></a>01476     <span class="keywordflow">if</span> (!res)
<a name="l01477"></a>01477       <span class="keywordflow">return</span> NULL;
<a name="l01478"></a>01478     string2my_decimal(E_DEC_FATAL_ERROR, res, dec_buf);
<a name="l01479"></a>01479     <span class="keywordflow">return</span> dec_buf;
<a name="l01480"></a>01480   }
<a name="l01481"></a>01481   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l01482"></a>01482   {
<a name="l01483"></a>01483     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a801d5f0976207aa8a4fad3aa824664d2">get_date_from_string</a>(ltime, fuzzydate);
<a name="l01484"></a>01484   }
<a name="l01485"></a>01485   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l01486"></a>01486   {
<a name="l01487"></a>01487     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a1f6773c162fa458b6ef2087b427244b7">get_time_from_string</a>(ltime);
<a name="l01488"></a>01488   }
<a name="l01489"></a>01489   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> STRING_RESULT; }
<a name="l01490"></a>01490   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l01491"></a>01491 };
<a name="l01492"></a>01492 
<a name="l01493"></a>01493 <span class="preprocessor">#else </span><span class="comment">/* Dummy functions to get sql_yacc.cc compiled */</span>
<a name="l01494"></a>01494 
<a name="l01495"></a>01495 
<a name="l01496"></a><a class="code" href="classItem__func__udf__float.html">01496</a> <span class="keyword">class </span><a class="code" href="classItem__func__udf__float.html">Item_func_udf_float</a> :<span class="keyword">public</span> <a class="code" href="classItem__real__func.html">Item_real_func</a>
<a name="l01497"></a>01497 {
<a name="l01498"></a>01498  <span class="keyword">public</span>:
<a name="l01499"></a>01499   <a class="code" href="classItem__func__udf__float.html">Item_func_udf_float</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01500"></a>01500     :<a class="code" href="classItem__real__func.html">Item_real_func</a>() {}
<a name="l01501"></a>01501   <a class="code" href="classItem__func__udf__float.html">Item_func_udf_float</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg, <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01502"></a>01502     :<a class="code" href="classItem__real__func.html">Item_real_func</a>(list) {}
<a name="l01503"></a>01503   <span class="keywordtype">double</span> val_real() { DBUG_ASSERT(fixed == 1); <span class="keywordflow">return</span> 0.0; }
<a name="l01504"></a>01504 };
<a name="l01505"></a>01505 
<a name="l01506"></a>01506 
<a name="l01507"></a><a class="code" href="classItem__func__udf__int.html">01507</a> <span class="keyword">class </span><a class="code" href="classItem__func__udf__int.html">Item_func_udf_int</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01508"></a>01508 {
<a name="l01509"></a>01509 <span class="keyword">public</span>:
<a name="l01510"></a>01510   <a class="code" href="classItem__func__udf__int.html">Item_func_udf_int</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01511"></a>01511     :<a class="code" href="classItem__int__func.html">Item_int_func</a>() {}
<a name="l01512"></a>01512   <a class="code" href="classItem__func__udf__int.html">Item_func_udf_int</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg, <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01513"></a>01513     :<a class="code" href="classItem__int__func.html">Item_int_func</a>(list) {}
<a name="l01514"></a>01514   longlong val_int() { DBUG_ASSERT(fixed == 1); <span class="keywordflow">return</span> 0; }
<a name="l01515"></a>01515 };
<a name="l01516"></a>01516 
<a name="l01517"></a>01517 
<a name="l01518"></a><a class="code" href="classItem__func__udf__decimal.html">01518</a> <span class="keyword">class </span><a class="code" href="classItem__func__udf__decimal.html">Item_func_udf_decimal</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01519"></a>01519 {
<a name="l01520"></a>01520 <span class="keyword">public</span>:
<a name="l01521"></a>01521   <a class="code" href="classItem__func__udf__decimal.html">Item_func_udf_decimal</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01522"></a>01522     :<a class="code" href="classItem__int__func.html">Item_int_func</a>() {}
<a name="l01523"></a>01523   <a class="code" href="classItem__func__udf__decimal.html">Item_func_udf_decimal</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg, <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01524"></a>01524     :<a class="code" href="classItem__int__func.html">Item_int_func</a>(list) {}
<a name="l01525"></a>01525   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *) { DBUG_ASSERT(fixed == 1); <span class="keywordflow">return</span> 0; }
<a name="l01526"></a>01526 };
<a name="l01527"></a>01527 
<a name="l01528"></a>01528 
<a name="l01529"></a><a class="code" href="classItem__func__udf__str.html">01529</a> <span class="keyword">class </span><a class="code" href="classItem__func__udf__str.html">Item_func_udf_str</a> :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l01530"></a>01530 {
<a name="l01531"></a>01531 <span class="keyword">public</span>:
<a name="l01532"></a>01532   <a class="code" href="classItem__func__udf__str.html">Item_func_udf_str</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg)
<a name="l01533"></a>01533     :<a class="code" href="classItem__func.html">Item_func</a>() {}
<a name="l01534"></a>01534   <a class="code" href="classItem__func__udf__str.html">Item_func_udf_str</a>(<a class="code" href="structst__udf__func.html">udf_func</a> *udf_arg, <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list)
<a name="l01535"></a>01535     :<a class="code" href="classItem__func.html">Item_func</a>(list) {}
<a name="l01536"></a>01536   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *)
<a name="l01537"></a>01537     { DBUG_ASSERT(fixed == 1); null_value=1; <span class="keywordflow">return</span> 0; }
<a name="l01538"></a>01538   <span class="keywordtype">double</span> val_real() { DBUG_ASSERT(fixed == 1); null_value= 1; <span class="keywordflow">return</span> 0.0; }
<a name="l01539"></a>01539   longlong val_int() { DBUG_ASSERT(fixed == 1); null_value=1; <span class="keywordflow">return</span> 0; }
<a name="l01540"></a>01540   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> STRING_RESULT; }
<a name="l01541"></a>01541   <span class="keywordtype">void</span> fix_length_and_dec() { maybe_null=1; max_length=0; }
<a name="l01542"></a>01542 };
<a name="l01543"></a>01543 
<a name="l01544"></a>01544 <span class="preprocessor">#endif </span><span class="comment">/* HAVE_DLOPEN */</span>
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 <span class="comment">/*</span>
<a name="l01547"></a>01547 <span class="comment">** User level locks</span>
<a name="l01548"></a>01548 <span class="comment">*/</span>
<a name="l01549"></a>01549 
<a name="l01550"></a>01550 <span class="keyword">class </span><a class="code" href="classUser__level__lock.html">User_level_lock</a>;
<a name="l01551"></a>01551 <span class="keywordtype">void</span> item_user_lock_init(<span class="keywordtype">void</span>);
<a name="l01552"></a>01552 <span class="keywordtype">void</span> item_user_lock_release(<a class="code" href="classUser__level__lock.html">User_level_lock</a> *ull);
<a name="l01553"></a>01553 <span class="keywordtype">void</span> item_user_lock_free(<span class="keywordtype">void</span>);
<a name="l01554"></a>01554 
<a name="l01555"></a><a class="code" href="classItem__func__get__lock.html">01555</a> <span class="keyword">class </span><a class="code" href="classItem__func__get__lock.html">Item_func_get_lock</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01556"></a>01556 {
<a name="l01557"></a>01557   <a class="code" href="classString.html">String</a> value;
<a name="l01558"></a>01558  <span class="keyword">public</span>:
<a name="l01559"></a>01559   <a class="code" href="classItem__func__get__lock.html">Item_func_get_lock</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a,b) {}
<a name="l01560"></a>01560   longlong <a class="code" href="classItem__func__get__lock.html#a807bbfa3db1e5b9d07313ab2c62f48dc">val_int</a>();
<a name="l01561"></a>01561   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;get_lock&quot;</span>; }
<a name="l01562"></a>01562   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=1; maybe_null=1;}
<a name="l01563"></a>01563 };
<a name="l01564"></a>01564 
<a name="l01565"></a><a class="code" href="classItem__func__release__lock.html">01565</a> <span class="keyword">class </span><a class="code" href="classItem__func__release__lock.html">Item_func_release_lock</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01566"></a>01566 {
<a name="l01567"></a>01567   <a class="code" href="classString.html">String</a> value;
<a name="l01568"></a>01568 <span class="keyword">public</span>:
<a name="l01569"></a>01569   <a class="code" href="classItem__func__release__lock.html">Item_func_release_lock</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01570"></a>01570   longlong <a class="code" href="classItem__func__release__lock.html#ad391ab0ac6f516b9a676055451c37fa4">val_int</a>();
<a name="l01571"></a>01571   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;release_lock&quot;</span>; }
<a name="l01572"></a>01572   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=1; maybe_null=1;}
<a name="l01573"></a>01573 };
<a name="l01574"></a>01574 
<a name="l01575"></a>01575 <span class="comment">/* replication functions */</span>
<a name="l01576"></a>01576 
<a name="l01577"></a><a class="code" href="classItem__master__pos__wait.html">01577</a> <span class="keyword">class </span><a class="code" href="classItem__master__pos__wait.html">Item_master_pos_wait</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01578"></a>01578 {
<a name="l01579"></a>01579   <a class="code" href="classString.html">String</a> value;
<a name="l01580"></a>01580 <span class="keyword">public</span>:
<a name="l01581"></a>01581   <a class="code" href="classItem__master__pos__wait.html">Item_master_pos_wait</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a,b) {}
<a name="l01582"></a>01582   <a class="code" href="classItem__master__pos__wait.html">Item_master_pos_wait</a>(<a class="code" href="classItem.html">Item</a> *a,<a class="code" href="classItem.html">Item</a> *b,<a class="code" href="classItem.html">Item</a> *c) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a,b,c) {}
<a name="l01583"></a>01583   longlong <a class="code" href="classItem__master__pos__wait.html#a87939178b261b77eb5856d60f5577ac6">val_int</a>();
<a name="l01584"></a>01584   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;master_pos_wait&quot;</span>; }
<a name="l01585"></a>01585   <span class="keywordtype">void</span> fix_length_and_dec() { max_length=21; maybe_null=1;}
<a name="l01586"></a>01586 };
<a name="l01587"></a>01587 
<a name="l01588"></a><a class="code" href="classItem__master__gtid__set__wait.html">01588</a> <span class="keyword">class </span><a class="code" href="classItem__master__gtid__set__wait.html">Item_master_gtid_set_wait</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01589"></a>01589 {
<a name="l01590"></a>01590   <a class="code" href="classString.html">String</a> value;
<a name="l01591"></a>01591 <span class="keyword">public</span>:
<a name="l01592"></a>01592   <a class="code" href="classItem__master__gtid__set__wait.html">Item_master_gtid_set_wait</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l01593"></a>01593   <a class="code" href="classItem__master__gtid__set__wait.html">Item_master_gtid_set_wait</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a,b) {}
<a name="l01594"></a>01594   longlong val_int();
<a name="l01595"></a>01595   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;wait_until_sql_thread_after_gtids&quot;</span>; }
<a name="l01596"></a>01596   <span class="keywordtype">void</span> fix_length_and_dec() { max_length= 21; maybe_null= 1; }
<a name="l01597"></a>01597 };
<a name="l01598"></a>01598 
<a name="l01599"></a><a class="code" href="classItem__func__gtid__subset.html">01599</a> <span class="keyword">class </span><a class="code" href="classItem__func__gtid__subset.html">Item_func_gtid_subset</a> : <span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01600"></a>01600 {
<a name="l01601"></a>01601   <a class="code" href="classString.html">String</a> buf1;
<a name="l01602"></a>01602   <a class="code" href="classString.html">String</a> buf2;
<a name="l01603"></a>01603 <span class="keyword">public</span>:
<a name="l01604"></a>01604   <a class="code" href="classItem__func__gtid__subset.html">Item_func_gtid_subset</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) : <a class="code" href="classItem__int__func.html">Item_int_func</a>(a, b) {}
<a name="l01605"></a>01605   longlong <a class="code" href="classItem__func__gtid__subset.html#ad78025cb0be8b291d7a4c647202debaf">val_int</a>();
<a name="l01606"></a>01606   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;gtid_subset&quot;</span>; }
<a name="l01607"></a>01607   <span class="keywordtype">void</span> fix_length_and_dec() { max_length= 21; maybe_null= 0; }
<a name="l01608"></a>01608 };
<a name="l01609"></a>01609 
<a name="l01610"></a>01610 
<a name="l01617"></a><a class="code" href="classItem__var__func.html">01617</a> <span class="keyword">class </span><a class="code" href="classItem__var__func.html">Item_var_func</a> :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l01618"></a>01618 {
<a name="l01619"></a>01619 <span class="keyword">public</span>:
<a name="l01620"></a>01620   <a class="code" href="classItem__var__func.html">Item_var_func</a>() :<a class="code" href="classItem__func.html">Item_func</a>() { }
<a name="l01621"></a>01621   <a class="code" href="classItem__var__func.html">Item_var_func</a>(THD *thd, <a class="code" href="classItem__var__func.html">Item_var_func</a> *item) :<a class="code" href="classItem__func.html">Item_func</a>(thd, item) { }
<a name="l01622"></a>01622   <a class="code" href="classItem__var__func.html">Item_var_func</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__func.html">Item_func</a>(a) { }
<a name="l01623"></a>01623   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l01624"></a>01624   {
<a name="l01625"></a>01625     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a27dbeb53435ed82027e36a6c9a7f1989">get_date_from_non_temporal</a>(ltime, fuzzydate);
<a name="l01626"></a>01626   }
<a name="l01627"></a>01627   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l01628"></a>01628   {
<a name="l01629"></a>01629     <span class="keywordflow">return</span> <a class="code" href="classItem.html#a7af21871229b24c64767bb189a8fa42f">get_time_from_non_temporal</a>(ltime);
<a name="l01630"></a>01630   }
<a name="l01631"></a>01631 };
<a name="l01632"></a>01632 
<a name="l01633"></a>01633 
<a name="l01634"></a>01634 <span class="comment">/* Handling of user definable variables */</span>
<a name="l01635"></a>01635 
<a name="l01636"></a>01636 <span class="keyword">class </span>user_var_entry;
<a name="l01637"></a>01637 
<a name="l01638"></a><a class="code" href="classItem__func__set__user__var.html">01638</a> <span class="keyword">class </span><a class="code" href="classItem__func__set__user__var.html">Item_func_set_user_var</a> :<span class="keyword">public</span> <a class="code" href="classItem__var__func.html">Item_var_func</a>
<a name="l01639"></a>01639 {
<a name="l01640"></a>01640   <span class="keyword">enum</span> Item_result cached_result_type;
<a name="l01641"></a>01641   user_var_entry *entry;
<a name="l01642"></a>01642   <span class="comment">/*</span>
<a name="l01643"></a>01643 <span class="comment">    The entry_thread_id variable is used:</span>
<a name="l01644"></a>01644 <span class="comment">    1) to skip unnecessary updates of the entry field (see above);</span>
<a name="l01645"></a>01645 <span class="comment">    2) to reset the entry field that was initialized in the other thread</span>
<a name="l01646"></a>01646 <span class="comment">       (for example, an item tree of a trigger that updates user variables</span>
<a name="l01647"></a>01647 <span class="comment">       may be shared between several connections, and the entry_thread_id field</span>
<a name="l01648"></a>01648 <span class="comment">       prevents updates of one connection user variables from a concurrent</span>
<a name="l01649"></a>01649 <span class="comment">       connection calling the same trigger that initially updated some</span>
<a name="l01650"></a>01650 <span class="comment">       user variable it the first connection context).</span>
<a name="l01651"></a>01651 <span class="comment">  */</span>
<a name="l01652"></a>01652   my_thread_id entry_thread_id;
<a name="l01666"></a>01666   <span class="keywordtype">bool</span> delayed_non_constness;
<a name="l01667"></a>01667   <span class="keywordtype">char</span> buffer[MAX_FIELD_WIDTH];
<a name="l01668"></a>01668   <a class="code" href="classString.html">String</a> value;
<a name="l01669"></a>01669   <a class="code" href="classmy__decimal.html">my_decimal</a> decimal_buff;
<a name="l01670"></a>01670   <span class="keywordtype">bool</span> null_item;
<a name="l01671"></a>01671   <span class="keyword">union</span>
<a name="l01672"></a>01672   {
<a name="l01673"></a>01673     longlong vint;
<a name="l01674"></a>01674     <span class="keywordtype">double</span> vreal;
<a name="l01675"></a>01675     <a class="code" href="classString.html">String</a> *vstr;
<a name="l01676"></a>01676     <a class="code" href="classmy__decimal.html">my_decimal</a> *vdec;
<a name="l01677"></a>01677   } save_result;
<a name="l01678"></a>01678 
<a name="l01679"></a>01679 <span class="keyword">public</span>:
<a name="l01680"></a>01680   <a class="code" href="className__string.html">Name_string</a> name; <span class="comment">// keep it public</span>
<a name="l01681"></a>01681   <a class="code" href="classItem__func__set__user__var.html">Item_func_set_user_var</a>(<a class="code" href="className__string.html">Name_string</a> a, <a class="code" href="classItem.html">Item</a> *b, <span class="keywordtype">bool</span> delayed)
<a name="l01682"></a>01682     :<a class="code" href="classItem__var__func.html">Item_var_func</a>(b), cached_result_type(INT_RESULT),
<a name="l01683"></a>01683      entry(NULL), entry_thread_id(0), delayed_non_constness(delayed), name(a)
<a name="l01684"></a>01684   {}
<a name="l01685"></a>01685   <a class="code" href="classItem__func__set__user__var.html">Item_func_set_user_var</a>(THD *thd, <a class="code" href="classItem__func__set__user__var.html">Item_func_set_user_var</a> *item)
<a name="l01686"></a>01686     :<a class="code" href="classItem__var__func.html">Item_var_func</a>(thd, item), cached_result_type(item-&gt;cached_result_type),
<a name="l01687"></a>01687      entry(item-&gt;entry), entry_thread_id(item-&gt;entry_thread_id),
<a name="l01688"></a>01688      delayed_non_constness(item-&gt;delayed_non_constness), value(item-&gt;value),
<a name="l01689"></a>01689      decimal_buff(item-&gt;decimal_buff), null_item(item-&gt;null_item),
<a name="l01690"></a>01690      save_result(item-&gt;save_result), name(item-&gt;name)
<a name="l01691"></a>01691   {}
<a name="l01692"></a>01692   <span class="keyword">enum</span> Functype functype()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> SUSERVAR_FUNC; }
<a name="l01693"></a>01693   <span class="keywordtype">double</span> val_real();
<a name="l01694"></a>01694   longlong val_int();
<a name="l01695"></a>01695   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str);
<a name="l01696"></a>01696   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01697"></a>01697   <span class="keywordtype">double</span> val_result();
<a name="l01698"></a>01698   longlong val_int_result();
<a name="l01699"></a>01699   <span class="keywordtype">bool</span> val_bool_result();
<a name="l01700"></a>01700   <a class="code" href="classString.html">String</a> *str_result(<a class="code" href="classString.html">String</a> *str);
<a name="l01701"></a>01701   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal_result(<a class="code" href="classmy__decimal.html">my_decimal</a> *);
<a name="l01702"></a>01702   <span class="keywordtype">bool</span> is_null_result();
<a name="l01703"></a>01703   <span class="keywordtype">bool</span> update_hash(<span class="keywordtype">void</span> *ptr, uint length, <span class="keyword">enum</span> Item_result type,
<a name="l01704"></a>01704                    <span class="keyword">const</span> CHARSET_INFO *cs, Derivation dv, <span class="keywordtype">bool</span> unsigned_arg);
<a name="l01705"></a>01705   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__set__user__var.html#a83c13bd67721992c323337bcc2b2c2b9">send</a>(<a class="code" href="classProtocol.html">Protocol</a> *protocol, <a class="code" href="classString.html">String</a> *str_arg);
<a name="l01706"></a>01706   <span class="keywordtype">void</span> make_field(<a class="code" href="classSend__field.html">Send_field</a> *tmp_field);
<a name="l01707"></a>01707   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__set__user__var.html#ad817884ca175c401c2517a700998f336">check</a>(<span class="keywordtype">bool</span> use_result_field);
<a name="l01708"></a>01708   <span class="keywordtype">void</span> <a class="code" href="classItem__func__set__user__var.html#a6ed37d99a71794e777a6732cc9683f7c" title="Evaluate and store item&#39;s result. This function is invoked on &quot;SELECT ... INTO @var ...">save_item_result</a>(<a class="code" href="classItem.html">Item</a> *item);
<a name="l01709"></a>01709   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__set__user__var.html#a6b79dc130ebd781507b01eadf4e1edad">update</a>();
<a name="l01710"></a>01710   <span class="keyword">enum</span> Item_result result_type ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cached_result_type; }
<a name="l01711"></a>01711   <span class="keywordtype">bool</span> fix_fields(THD *thd, <a class="code" href="classItem.html">Item</a> **ref);
<a name="l01712"></a>01712   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l01713"></a>01713   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__set__user__var.html#aed9d1165e42cd0a238673d70d8029ca4">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01714"></a>01714   <span class="keywordtype">void</span> print_assignment(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01715"></a>01715   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;set_user_var&quot;</span>; }
<a name="l01716"></a>01716   type_conversion_status save_in_field(<a class="code" href="classField.html">Field</a> *field, <span class="keywordtype">bool</span> no_conversions,
<a name="l01717"></a>01717                                        <span class="keywordtype">bool</span> can_use_result_field);
<a name="l01718"></a><a class="code" href="classItem__func__set__user__var.html#a58f1e03003553c9b3a28486946e63999">01718</a>   type_conversion_status save_in_field(<a class="code" href="classField.html">Field</a> *field, <span class="keywordtype">bool</span> no_conversions)
<a name="l01719"></a>01719   {
<a name="l01720"></a>01720     <span class="keywordflow">return</span> save_in_field(field, no_conversions, 1);
<a name="l01721"></a>01721   }
<a name="l01722"></a>01722   <span class="keywordtype">void</span> save_org_in_field(<a class="code" href="classField.html">Field</a> *field) { (void)save_in_field(field, 1, 0); }
<a name="l01723"></a>01723   <span class="keywordtype">bool</span> register_field_in_read_map(uchar *arg);
<a name="l01724"></a>01724   <span class="keywordtype">bool</span> set_entry(THD *thd, <span class="keywordtype">bool</span> create_if_not_exists);
<a name="l01725"></a>01725   <span class="keywordtype">void</span> cleanup();
<a name="l01726"></a>01726 };
<a name="l01727"></a>01727 
<a name="l01728"></a>01728 
<a name="l01729"></a><a class="code" href="classItem__func__get__user__var.html">01729</a> <span class="keyword">class </span><a class="code" href="classItem__func__get__user__var.html">Item_func_get_user_var</a> :<span class="keyword">public</span> <a class="code" href="classItem__var__func.html">Item_var_func</a>,
<a name="l01730"></a>01730                               <span class="keyword">private</span> <a class="code" href="classSettable__routine__parameter.html">Settable_routine_parameter</a>
<a name="l01731"></a>01731 {
<a name="l01732"></a>01732   user_var_entry *var_entry;
<a name="l01733"></a>01733   Item_result m_cached_result_type;
<a name="l01734"></a>01734 
<a name="l01735"></a>01735 <span class="keyword">public</span>:
<a name="l01736"></a>01736   <a class="code" href="className__string.html">Name_string</a> name; <span class="comment">// keep it public</span>
<a name="l01737"></a>01737   <a class="code" href="classItem__func__get__user__var.html">Item_func_get_user_var</a>(<a class="code" href="className__string.html">Name_string</a> a):
<a name="l01738"></a>01738     <a class="code" href="classItem__var__func.html">Item_var_func</a>(), m_cached_result_type(STRING_RESULT), name(a) {}
<a name="l01739"></a>01739   <span class="keyword">enum</span> Functype functype()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> GUSERVAR_FUNC; }
<a name="l01740"></a>01740   <span class="keywordtype">double</span> val_real();
<a name="l01741"></a>01741   longlong val_int();
<a name="l01742"></a>01742   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a>*);
<a name="l01743"></a>01743   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a>* str);
<a name="l01744"></a>01744   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l01745"></a>01745   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__get__user__var.html#ab8a660cae17e531875ca5f102fa46e8d">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01746"></a>01746   <span class="keyword">enum</span> Item_result result_type() <span class="keyword">const</span>;
<a name="l01747"></a>01747   <span class="comment">/*</span>
<a name="l01748"></a>01748 <span class="comment">    We must always return variables as strings to guard against selects of type</span>
<a name="l01749"></a>01749 <span class="comment">    select @t1:=1,@t1,@t:=&quot;hello&quot;,@t from foo where (@t1:= t2.b)</span>
<a name="l01750"></a>01750 <span class="comment">  */</span>
<a name="l01751"></a>01751   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;get_user_var&quot;</span>; }
<a name="l01752"></a>01752   <span class="keywordtype">bool</span> const_item() <span class="keyword">const</span>;
<a name="l01753"></a>01753   table_map used_tables()<span class="keyword"> const</span>
<a name="l01754"></a>01754 <span class="keyword">  </span>{ <span class="keywordflow">return</span> const_item() ? 0 : RAND_TABLE_BIT; }
<a name="l01755"></a>01755   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__get__user__var.html#a7cac9ceba145214b96d39d3e0b11e38d">eq</a>(<span class="keyword">const</span> <a class="code" href="classItem.html">Item</a> *item, <span class="keywordtype">bool</span> binary_cmp) <span class="keyword">const</span>;
<a name="l01756"></a>01756 <span class="keyword">private</span>:
<a name="l01757"></a>01757   <span class="keywordtype">bool</span> set_value(THD *thd, <a class="code" href="classsp__rcontext.html">sp_rcontext</a> *ctx, <a class="code" href="classItem.html">Item</a> **it);
<a name="l01758"></a>01758 
<a name="l01759"></a>01759 <span class="keyword">public</span>:
<a name="l01760"></a>01760   <a class="code" href="classSettable__routine__parameter.html">Settable_routine_parameter</a> *get_settable_routine_parameter()
<a name="l01761"></a>01761   {
<a name="l01762"></a>01762     <span class="keywordflow">return</span> <span class="keyword">this</span>;
<a name="l01763"></a>01763   }
<a name="l01764"></a>01764 };
<a name="l01765"></a>01765 
<a name="l01766"></a>01766 
<a name="l01767"></a>01767 <span class="comment">/*</span>
<a name="l01768"></a>01768 <span class="comment">  This item represents user variable used as out parameter (e.g in LOAD DATA),</span>
<a name="l01769"></a>01769 <span class="comment">  and it is supposed to be used only for this purprose. So it is simplified</span>
<a name="l01770"></a>01770 <span class="comment">  a lot. Actually you should never obtain its value.</span>
<a name="l01771"></a>01771 <span class="comment"></span>
<a name="l01772"></a>01772 <span class="comment">  The only two reasons for this thing being an Item is possibility to store it</span>
<a name="l01773"></a>01773 <span class="comment">  in List&lt;Item&gt; and desire to place this code somewhere near other functions</span>
<a name="l01774"></a>01774 <span class="comment">  working with user variables.</span>
<a name="l01775"></a>01775 <span class="comment">*/</span>
<a name="l01776"></a><a class="code" href="classItem__user__var__as__out__param.html">01776</a> <span class="keyword">class </span><a class="code" href="classItem__user__var__as__out__param.html">Item_user_var_as_out_param</a> :<span class="keyword">public</span> <a class="code" href="classItem.html">Item</a>
<a name="l01777"></a>01777 {
<a name="l01778"></a>01778   <a class="code" href="className__string.html">Name_string</a> name;
<a name="l01779"></a>01779   user_var_entry *entry;
<a name="l01780"></a>01780 <span class="keyword">public</span>:
<a name="l01781"></a>01781   <a class="code" href="classItem__user__var__as__out__param.html">Item_user_var_as_out_param</a>(<a class="code" href="className__string.html">Name_string</a> a) :name(a)
<a name="l01782"></a>01782   { item_name.<a class="code" href="classItem__name__string.html#a41f16804fbc5f43c4aa334fe422bdd94">copy</a>(a); }
<a name="l01783"></a>01783   <span class="comment">/* We should return something different from FIELD_ITEM here */</span>
<a name="l01784"></a>01784   <span class="keyword">enum</span> Type type()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> STRING_ITEM;}
<a name="l01785"></a>01785   <span class="keywordtype">double</span> val_real();
<a name="l01786"></a>01786   longlong val_int();
<a name="l01787"></a>01787   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str);
<a name="l01788"></a>01788   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *decimal_buffer);
<a name="l01789"></a>01789   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l01790"></a>01790   {
<a name="l01791"></a>01791     DBUG_ASSERT(0);
<a name="l01792"></a>01792     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01793"></a>01793   }
<a name="l01794"></a>01794   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l01795"></a>01795   {
<a name="l01796"></a>01796     DBUG_ASSERT(0);
<a name="l01797"></a>01797     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01798"></a>01798   }
<a name="l01799"></a>01799 
<a name="l01800"></a>01800   <span class="comment">/* fix_fields() binds variable name with its entry structure */</span>
<a name="l01801"></a>01801   <span class="keywordtype">bool</span> fix_fields(THD *thd, <a class="code" href="classItem.html">Item</a> **ref);
<a name="l01802"></a>01802   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__user__var__as__out__param.html#aeea0fb9e70e98696bc3414edee3d7073">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01803"></a>01803   <span class="keywordtype">void</span> set_null_value(<span class="keyword">const</span> CHARSET_INFO* cs);
<a name="l01804"></a>01804   <span class="keywordtype">void</span> set_value(<span class="keyword">const</span> <span class="keywordtype">char</span> *str, uint length, <span class="keyword">const</span> CHARSET_INFO* cs);
<a name="l01805"></a>01805 };
<a name="l01806"></a>01806 
<a name="l01807"></a>01807 
<a name="l01808"></a>01808 <span class="comment">/* A system variable */</span>
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 <span class="preprocessor">#define GET_SYS_VAR_CACHE_LONG     1</span>
<a name="l01811"></a>01811 <span class="preprocessor"></span><span class="preprocessor">#define GET_SYS_VAR_CACHE_DOUBLE   2</span>
<a name="l01812"></a>01812 <span class="preprocessor"></span><span class="preprocessor">#define GET_SYS_VAR_CACHE_STRING   4</span>
<a name="l01813"></a>01813 <span class="preprocessor"></span>
<a name="l01814"></a><a class="code" href="classItem__func__get__system__var.html">01814</a> <span class="keyword">class </span><a class="code" href="classItem__func__get__system__var.html">Item_func_get_system_var</a> :<span class="keyword">public</span> <a class="code" href="classItem__var__func.html">Item_var_func</a>
<a name="l01815"></a>01815 {
<a name="l01816"></a>01816   <a class="code" href="classsys__var.html">sys_var</a> *var;
<a name="l01817"></a>01817   enum_var_type var_type, orig_var_type;
<a name="l01818"></a>01818   LEX_STRING component;
<a name="l01819"></a>01819   longlong cached_llval;
<a name="l01820"></a>01820   <span class="keywordtype">double</span> cached_dval;
<a name="l01821"></a>01821   <a class="code" href="classString.html">String</a> cached_strval;
<a name="l01822"></a>01822   my_bool cached_null_value;
<a name="l01823"></a>01823   query_id_t used_query_id;
<a name="l01824"></a>01824   uchar cache_present;
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 <span class="keyword">public</span>:
<a name="l01827"></a>01827   <a class="code" href="classItem__func__get__system__var.html">Item_func_get_system_var</a>(<a class="code" href="classsys__var.html">sys_var</a> *var_arg, enum_var_type var_type_arg,
<a name="l01828"></a>01828                            LEX_STRING *component_arg, <span class="keyword">const</span> <span class="keywordtype">char</span> *name_arg,
<a name="l01829"></a>01829                            <span class="keywordtype">size_t</span> name_len_arg);
<a name="l01830"></a>01830   <span class="keyword">enum</span> Functype functype()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> GSYSVAR_FUNC; }
<a name="l01831"></a>01831   <span class="keywordtype">void</span> update_null_value();
<a name="l01832"></a>01832   <span class="keywordtype">void</span> fix_length_and_dec();
<a name="l01833"></a>01833   <span class="keywordtype">void</span> <a class="code" href="classItem__func__get__system__var.html#a262f30ae86908b2bb4563a9e3136cad3">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01834"></a>01834   <span class="keywordtype">bool</span> const_item()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l01835"></a>01835   table_map used_tables()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l01836"></a>01836   <span class="keyword">enum</span> Item_result result_type() <span class="keyword">const</span>;
<a name="l01837"></a>01837   enum_field_types field_type() <span class="keyword">const</span>;
<a name="l01838"></a>01838   <span class="keywordtype">double</span> val_real();
<a name="l01839"></a>01839   longlong val_int();
<a name="l01840"></a>01840   <a class="code" href="classString.html">String</a>* val_str(<a class="code" href="classString.html">String</a>*);
<a name="l01841"></a>01841   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *dec_buf)
<a name="l01842"></a>01842   { <span class="keywordflow">return</span> val_decimal_from_real(dec_buf); }
<a name="l01843"></a>01843   <span class="comment">/* TODO: fix to support views */</span>
<a name="l01844"></a>01844   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;get_system_var&quot;</span>; }
<a name="l01853"></a>01853   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__get__system__var.html#a2a18a5a0e78b9e92811e0041dcbb3293">is_written_to_binlog</a>();
<a name="l01854"></a>01854   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__get__system__var.html#a4600b10d900213d5c09b0088bc60f831">eq</a>(<span class="keyword">const</span> <a class="code" href="classItem.html">Item</a> *item, <span class="keywordtype">bool</span> binary_cmp) <span class="keyword">const</span>;
<a name="l01855"></a>01855 
<a name="l01856"></a>01856   <span class="keywordtype">void</span> cleanup();
<a name="l01857"></a>01857 };
<a name="l01858"></a>01858 
<a name="l01859"></a>01859 
<a name="l01860"></a>01860 <span class="comment">/* for fulltext search */</span>
<a name="l01861"></a>01861 <span class="preprocessor">#include &lt;ft_global.h&gt;</span>
<a name="l01862"></a>01862 
<a name="l01863"></a><a class="code" href="classItem__func__match.html">01863</a> <span class="keyword">class </span><a class="code" href="classItem__func__match.html">Item_func_match</a> :<span class="keyword">public</span> <a class="code" href="classItem__real__func.html">Item_real_func</a>
<a name="l01864"></a>01864 {
<a name="l01865"></a>01865 <span class="keyword">public</span>:
<a name="l01866"></a>01866   uint key, flags;
<a name="l01867"></a>01867   <span class="keywordtype">bool</span> join_key;
<a name="l01868"></a>01868   <a class="code" href="classDTCollation.html">DTCollation</a> cmp_collation;
<a name="l01869"></a>01869   FT_INFO *ft_handler;
<a name="l01870"></a>01870   <a class="code" href="structTABLE.html">TABLE</a> *table;
<a name="l01871"></a>01871   <a class="code" href="classItem__func__match.html">Item_func_match</a> *master;   <span class="comment">// for master-slave optimization</span>
<a name="l01872"></a>01872   <a class="code" href="classItem.html">Item</a> *concat_ws;           <span class="comment">// Item_func_concat_ws</span>
<a name="l01873"></a>01873   <a class="code" href="classString.html">String</a> value;              <span class="comment">// value of concat_ws</span>
<a name="l01874"></a>01874   <a class="code" href="classString.html">String</a> search_value;       <span class="comment">// key_item()&#39;s value converted to cmp_collation</span>
<a name="l01875"></a>01875 
<a name="l01876"></a>01876   <a class="code" href="classItem__func__match.html">Item_func_match</a>(<a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;a, uint b): <a class="code" href="classItem__real__func.html">Item_real_func</a>(a), key(0), flags(b),
<a name="l01877"></a>01877        join_key(0), ft_handler(0), table(0), master(0), concat_ws(0) { }
<a name="l01878"></a>01878   <span class="keywordtype">void</span> cleanup()
<a name="l01879"></a>01879   {
<a name="l01880"></a>01880     DBUG_ENTER(<span class="stringliteral">&quot;Item_func_match::cleanup&quot;</span>);
<a name="l01881"></a>01881     Item_real_func::cleanup();
<a name="l01882"></a>01882     <span class="keywordflow">if</span> (!master &amp;&amp; ft_handler)
<a name="l01883"></a>01883       ft_handler-&gt;please-&gt;close_search(ft_handler);
<a name="l01884"></a>01884     ft_handler= 0;
<a name="l01885"></a>01885     concat_ws= 0;
<a name="l01886"></a>01886     table= 0;           <span class="comment">// required by Item_func_match::eq()</span>
<a name="l01887"></a>01887     DBUG_VOID_RETURN;
<a name="l01888"></a>01888   }
<a name="l01889"></a>01889   <span class="keyword">enum</span> Functype functype()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> FT_FUNC; }
<a name="l01890"></a>01890   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;match&quot;</span>; }
<a name="l01891"></a>01891   <span class="keywordtype">void</span> update_used_tables() {}
<a name="l01892"></a>01892   table_map not_null_tables()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }
<a name="l01893"></a>01893   <span class="keywordtype">bool</span> fix_fields(THD *thd, <a class="code" href="classItem.html">Item</a> **ref);
<a name="l01894"></a>01894   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__match.html#af5377743ba28aefe44f9976de1ce3ee7">eq</a>(<span class="keyword">const</span> <a class="code" href="classItem.html">Item</a> *, <span class="keywordtype">bool</span> binary_cmp) <span class="keyword">const</span>;
<a name="l01895"></a>01895   <span class="comment">/* The following should be safe, even if we compare doubles */</span>
<a name="l01896"></a>01896   longlong val_int() { DBUG_ASSERT(fixed == 1); <span class="keywordflow">return</span> val_real() != 0.0; }
<a name="l01897"></a>01897   <span class="keywordtype">double</span> val_real();
<a name="l01898"></a>01898   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classItem__func__match.html#a8a8635c83b31cd7abcf556c144c3f006">print</a>(<a class="code" href="classString.html">String</a> *str, enum_query_type query_type);
<a name="l01899"></a>01899 
<a name="l01900"></a>01900   <span class="keywordtype">bool</span> fix_index();
<a name="l01901"></a>01901   <span class="keywordtype">void</span> init_search(<span class="keywordtype">bool</span> no_order);
<a name="l01902"></a>01902 
<a name="l01910"></a><a class="code" href="classItem__func__match.html#afd6bf12cba3643eb3ef03cd6a0913928">01910</a>   ulonglong <a class="code" href="classItem__func__match.html#afd6bf12cba3643eb3ef03cd6a0913928">get_count</a>()
<a name="l01911"></a>01911   {
<a name="l01912"></a>01912     DBUG_ASSERT(ft_handler);
<a name="l01913"></a>01913     DBUG_ASSERT(table-&gt;file-&gt;<a class="code" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">ha_table_flags</a>() &amp; HA_CAN_FULLTEXT_EXT);
<a name="l01914"></a>01914 
<a name="l01915"></a>01915     <span class="keywordflow">return</span> ((FT_INFO_EXT *)ft_handler)-&gt;could_you-&gt;
<a name="l01916"></a>01916       count_matches((FT_INFO_EXT *)ft_handler);
<a name="l01917"></a>01917   }
<a name="l01918"></a>01918 
<a name="l01925"></a><a class="code" href="classItem__func__match.html#a7712a20ea71093dd0e99fd7f10db71a2">01925</a>   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__match.html#a7712a20ea71093dd0e99fd7f10db71a2">ordered_result</a>()
<a name="l01926"></a>01926   {
<a name="l01927"></a>01927     <span class="keywordflow">if</span> (flags &amp; FT_SORTED)
<a name="l01928"></a>01928       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01929"></a>01929 
<a name="l01930"></a>01930     <span class="keywordflow">if</span> ((table-&gt;file-&gt;<a class="code" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">ha_table_flags</a>() &amp; HA_CAN_FULLTEXT_EXT) == 0)
<a name="l01931"></a>01931       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01932"></a>01932 
<a name="l01933"></a>01933     DBUG_ASSERT(ft_handler);
<a name="l01934"></a>01934     <span class="keywordflow">return</span> ((FT_INFO_EXT *)ft_handler)-&gt;could_you-&gt;get_flags() &amp; 
<a name="l01935"></a>01935       FTS_ORDERED_RESULT;
<a name="l01936"></a>01936   }
<a name="l01937"></a>01937 
<a name="l01944"></a><a class="code" href="classItem__func__match.html#a4caab6b0fbc955cc3ab7ede56b1e1966">01944</a>   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__match.html#a4caab6b0fbc955cc3ab7ede56b1e1966">docid_in_result</a>()
<a name="l01945"></a>01945   {
<a name="l01946"></a>01946     DBUG_ASSERT(ft_handler);
<a name="l01947"></a>01947 
<a name="l01948"></a>01948     <span class="keywordflow">if</span> ((table-&gt;file-&gt;<a class="code" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">ha_table_flags</a>() &amp; HA_CAN_FULLTEXT_EXT) == 0)
<a name="l01949"></a>01949       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01950"></a>01950 
<a name="l01951"></a>01951     <span class="keywordflow">return</span> ((FT_INFO_EXT *)ft_handler)-&gt;could_you-&gt;get_flags() &amp; 
<a name="l01952"></a>01952       FTS_DOCID_IN_RESULT;
<a name="l01953"></a>01953   }
<a name="l01954"></a>01954 
<a name="l01955"></a>01955 <span class="keyword">private</span>:
<a name="l01974"></a>01974   <span class="keywordtype">bool</span> allows_search_on_non_indexed_columns(<a class="code" href="structTABLE.html">TABLE</a>* table_arg)
<a name="l01975"></a>01975   {
<a name="l01976"></a>01976     <span class="comment">// Only Boolean search may support non_indexed columns</span>
<a name="l01977"></a>01977     <span class="keywordflow">if</span> (!(flags &amp; FT_BOOL))
<a name="l01978"></a>01978       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01979"></a>01979 
<a name="l01980"></a>01980     DBUG_ASSERT(table_arg &amp;&amp; table_arg-&gt;file);
<a name="l01981"></a>01981 
<a name="l01982"></a>01982     <span class="comment">// Assume that if extended fulltext API is not supported,</span>
<a name="l01983"></a>01983     <span class="comment">// non-indexed columns are allowed.  This will be true for MyISAM.</span>
<a name="l01984"></a>01984     <span class="keywordflow">if</span> ((table_arg-&gt;file-&gt;<a class="code" href="classhandler.html#aaaba28e58d3a9fab58402bda6f2be6fe">ha_table_flags</a>() &amp; HA_CAN_FULLTEXT_EXT) == 0)
<a name="l01985"></a>01985       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01986"></a>01986 
<a name="l01987"></a>01987     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01988"></a>01988   }
<a name="l01989"></a>01989 
<a name="l01990"></a>01990 };
<a name="l01991"></a>01991 
<a name="l01997"></a><a class="code" href="classItem__func__docid.html">01997</a> <span class="keyword">class </span><a class="code" href="classItem__func__docid.html">Item_func_docid</a> : <span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l01998"></a>01998 {
<a name="l01999"></a>01999   FT_INFO_EXT *ft_handler;
<a name="l02000"></a>02000 <span class="keyword">public</span>:
<a name="l02001"></a>02001   <a class="code" href="classItem__func__docid.html">Item_func_docid</a>(FT_INFO_EXT *<a class="code" href="classhandler.html">handler</a>) : ft_handler(handler) 
<a name="l02002"></a>02002   { 
<a name="l02003"></a>02003     max_length= 21;
<a name="l02004"></a>02004     maybe_null= <span class="keyword">false</span>; 
<a name="l02005"></a>02005     unsigned_flag= <span class="keyword">true</span>;
<a name="l02006"></a>02006   } 
<a name="l02007"></a>02007 
<a name="l02008"></a>02008   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;docid&quot;</span>; }
<a name="l02009"></a>02009 
<a name="l02010"></a>02010   <span class="keywordtype">void</span> update_used_tables()
<a name="l02011"></a>02011   {
<a name="l02012"></a>02012     Item_int_func::update_used_tables();
<a name="l02013"></a>02013     <a class="code" href="classItem__func.html#a663d83299b42a9afbc090dc9286d2603" title="Value used in calculation of result of used_tables()">used_tables_cache</a>|= RAND_TABLE_BIT;
<a name="l02014"></a>02014     <a class="code" href="classItem__func.html#a5c3ce683f091c957f4d164fe4d6403f8" title="Value used in calculation of result of const_item()">const_item_cache</a>= <span class="keyword">false</span>;
<a name="l02015"></a>02015   }
<a name="l02016"></a>02016 
<a name="l02017"></a>02017   longlong val_int() 
<a name="l02018"></a>02018   { 
<a name="l02019"></a>02019     DBUG_ASSERT(ft_handler);
<a name="l02020"></a>02020     <span class="keywordflow">return</span> ft_handler-&gt;could_you-&gt;get_docid(ft_handler);
<a name="l02021"></a>02021   }
<a name="l02022"></a>02022 };
<a name="l02023"></a>02023 
<a name="l02024"></a><a class="code" href="classItem__func__bit__xor.html">02024</a> <span class="keyword">class </span><a class="code" href="classItem__func__bit__xor.html">Item_func_bit_xor</a> : <span class="keyword">public</span> <a class="code" href="classItem__func__bit.html">Item_func_bit</a>
<a name="l02025"></a>02025 {
<a name="l02026"></a>02026 <span class="keyword">public</span>:
<a name="l02027"></a>02027   <a class="code" href="classItem__func__bit__xor.html">Item_func_bit_xor</a>(<a class="code" href="classItem.html">Item</a> *a, <a class="code" href="classItem.html">Item</a> *b) :<a class="code" href="classItem__func__bit.html">Item_func_bit</a>(a, b) {}
<a name="l02028"></a>02028   longlong val_int();
<a name="l02029"></a>02029   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;^&quot;</span>; }
<a name="l02030"></a>02030 };
<a name="l02031"></a>02031 
<a name="l02032"></a><a class="code" href="classItem__func__is__free__lock.html">02032</a> <span class="keyword">class </span><a class="code" href="classItem__func__is__free__lock.html">Item_func_is_free_lock</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l02033"></a>02033 {
<a name="l02034"></a>02034   <a class="code" href="classString.html">String</a> value;
<a name="l02035"></a>02035 <span class="keyword">public</span>:
<a name="l02036"></a>02036   <a class="code" href="classItem__func__is__free__lock.html">Item_func_is_free_lock</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l02037"></a>02037   longlong <a class="code" href="classItem__func__is__free__lock.html#a74a0a86732233f80c36ae843f90bd0b3">val_int</a>();
<a name="l02038"></a>02038   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;is_free_lock&quot;</span>; }
<a name="l02039"></a>02039   <span class="keywordtype">void</span> fix_length_and_dec() { decimals=0; max_length=1; maybe_null=1;}
<a name="l02040"></a>02040 };
<a name="l02041"></a>02041 
<a name="l02042"></a><a class="code" href="classItem__func__is__used__lock.html">02042</a> <span class="keyword">class </span><a class="code" href="classItem__func__is__used__lock.html">Item_func_is_used_lock</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l02043"></a>02043 {
<a name="l02044"></a>02044   <a class="code" href="classString.html">String</a> value;
<a name="l02045"></a>02045 <span class="keyword">public</span>:
<a name="l02046"></a>02046   <a class="code" href="classItem__func__is__used__lock.html">Item_func_is_used_lock</a>(<a class="code" href="classItem.html">Item</a> *a) :<a class="code" href="classItem__int__func.html">Item_int_func</a>(a) {}
<a name="l02047"></a>02047   longlong val_int();
<a name="l02048"></a>02048   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;is_used_lock&quot;</span>; }
<a name="l02049"></a>02049   <span class="keywordtype">void</span> fix_length_and_dec() { decimals=0; max_length=10; maybe_null=1;}
<a name="l02050"></a>02050 };
<a name="l02051"></a>02051 
<a name="l02052"></a>02052 <span class="comment">/* For type casts */</span>
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 <span class="keyword">enum</span> Cast_target
<a name="l02055"></a>02055 {
<a name="l02056"></a>02056   ITEM_CAST_BINARY, ITEM_CAST_SIGNED_INT, ITEM_CAST_UNSIGNED_INT,
<a name="l02057"></a>02057   ITEM_CAST_DATE, ITEM_CAST_TIME, ITEM_CAST_DATETIME, ITEM_CAST_CHAR,
<a name="l02058"></a>02058   ITEM_CAST_DECIMAL
<a name="l02059"></a>02059 };
<a name="l02060"></a>02060 
<a name="l02061"></a>02061 
<a name="l02062"></a><a class="code" href="classItem__func__row__count.html">02062</a> <span class="keyword">class </span><a class="code" href="classItem__func__row__count.html">Item_func_row_count</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l02063"></a>02063 {
<a name="l02064"></a>02064 <span class="keyword">public</span>:
<a name="l02065"></a>02065   <a class="code" href="classItem__func__row__count.html">Item_func_row_count</a>() :<a class="code" href="classItem__int__func.html">Item_int_func</a>() {}
<a name="l02066"></a>02066   longlong val_int();
<a name="l02067"></a>02067   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;row_count&quot;</span>; }
<a name="l02068"></a>02068   <span class="keywordtype">void</span> fix_length_and_dec() { decimals= 0; maybe_null=0; }
<a name="l02069"></a>02069 };
<a name="l02070"></a>02070 
<a name="l02071"></a>02071 
<a name="l02072"></a>02072 <span class="comment">/*</span>
<a name="l02073"></a>02073 <span class="comment"> *</span>
<a name="l02074"></a>02074 <span class="comment"> * Stored FUNCTIONs</span>
<a name="l02075"></a>02075 <span class="comment"> *</span>
<a name="l02076"></a>02076 <span class="comment"> */</span>
<a name="l02077"></a>02077 
<a name="l02078"></a>02078 <span class="keyword">class </span><a class="code" href="classsp__head.html">sp_head</a>;
<a name="l02079"></a>02079 <span class="keyword">class </span><a class="code" href="classsp__name.html">sp_name</a>;
<a name="l02080"></a>02080 <span class="keyword">struct </span>st_sp_security_context;
<a name="l02081"></a>02081 
<a name="l02082"></a><a class="code" href="classItem__func__sp.html">02082</a> <span class="keyword">class </span><a class="code" href="classItem__func__sp.html">Item_func_sp</a> :<span class="keyword">public</span> <a class="code" href="classItem__func.html">Item_func</a>
<a name="l02083"></a>02083 {
<a name="l02084"></a>02084 <span class="keyword">private</span>:
<a name="l02085"></a>02085   <a class="code" href="structName__resolution__context.html">Name_resolution_context</a> *context;
<a name="l02086"></a>02086   <a class="code" href="classsp__name.html">sp_name</a> *m_name;
<a name="l02087"></a>02087   <span class="keyword">mutable</span> <a class="code" href="classsp__head.html">sp_head</a> *m_sp;
<a name="l02088"></a>02088   <a class="code" href="structTABLE.html">TABLE</a> *dummy_table;
<a name="l02089"></a>02089   uchar result_buf[64];
<a name="l02090"></a>02090   <span class="comment">/*</span>
<a name="l02091"></a>02091 <span class="comment">     The result field of the concrete stored function.</span>
<a name="l02092"></a>02092 <span class="comment">  */</span>
<a name="l02093"></a>02093   <a class="code" href="classField.html">Field</a> *sp_result_field;
<a name="l02094"></a>02094 
<a name="l02095"></a>02095   <span class="keywordtype">bool</span> execute();
<a name="l02096"></a>02096   <span class="keywordtype">bool</span> execute_impl(THD *thd);
<a name="l02097"></a>02097   <span class="keywordtype">bool</span> init_result_field(THD *thd);
<a name="l02098"></a>02098   
<a name="l02099"></a>02099 <span class="keyword">protected</span>:
<a name="l02100"></a>02100   <span class="keywordtype">bool</span> is_expensive_processor(uchar *arg) { <span class="keywordflow">return</span> TRUE; }
<a name="l02101"></a>02101 
<a name="l02102"></a>02102 <span class="keyword">public</span>:
<a name="l02103"></a>02103 
<a name="l02104"></a>02104   <a class="code" href="classItem__func__sp.html">Item_func_sp</a>(<a class="code" href="structName__resolution__context.html">Name_resolution_context</a> *context_arg, <a class="code" href="classsp__name.html">sp_name</a> *name);
<a name="l02105"></a>02105 
<a name="l02106"></a>02106   <a class="code" href="classItem__func__sp.html">Item_func_sp</a>(<a class="code" href="structName__resolution__context.html">Name_resolution_context</a> *context_arg,
<a name="l02107"></a>02107                <a class="code" href="classsp__name.html">sp_name</a> *name, <a class="code" href="classList.html">List&lt;Item&gt;</a> &amp;list);
<a name="l02108"></a>02108 
<a name="l02109"></a>02109   <span class="keyword">virtual</span> ~<a class="code" href="classItem__func__sp.html">Item_func_sp</a>()
<a name="l02110"></a>02110   {}
<a name="l02111"></a>02111 
<a name="l02116"></a>02116   table_map <a class="code" href="classItem__func__sp.html#ac9620c8b0ae1f67a13065080f170180d">get_initial_pseudo_tables</a>() <span class="keyword">const</span>;
<a name="l02117"></a>02117   <span class="keywordtype">void</span> update_used_tables();
<a name="l02118"></a>02118 
<a name="l02119"></a>02119   <span class="keywordtype">void</span> cleanup();
<a name="l02120"></a>02120 
<a name="l02121"></a>02121   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name() <span class="keyword">const</span>;
<a name="l02122"></a>02122 
<a name="l02123"></a>02123   <span class="keyword">enum</span> enum_field_types field_type() <span class="keyword">const</span>;
<a name="l02124"></a>02124 
<a name="l02125"></a>02125   <a class="code" href="classField.html">Field</a> *tmp_table_field(<a class="code" href="structTABLE.html">TABLE</a> *t_arg);
<a name="l02126"></a>02126 
<a name="l02127"></a>02127   <span class="keywordtype">void</span> make_field(<a class="code" href="classSend__field.html">Send_field</a> *tmp_field);
<a name="l02128"></a>02128 
<a name="l02129"></a>02129   Item_result result_type() <span class="keyword">const</span>;
<a name="l02130"></a>02130 
<a name="l02131"></a>02131   longlong val_int()
<a name="l02132"></a>02132   {
<a name="l02133"></a>02133     <span class="keywordflow">if</span> (execute())
<a name="l02134"></a>02134       <span class="keywordflow">return</span> (longlong) 0;
<a name="l02135"></a>02135     <span class="keywordflow">return</span> sp_result_field-&gt;val_int();
<a name="l02136"></a>02136   }
<a name="l02137"></a>02137 
<a name="l02138"></a>02138   <span class="keywordtype">double</span> val_real()
<a name="l02139"></a>02139   {
<a name="l02140"></a>02140     <span class="keywordflow">if</span> (execute())
<a name="l02141"></a>02141       <span class="keywordflow">return</span> 0.0;
<a name="l02142"></a>02142     <span class="keywordflow">return</span> sp_result_field-&gt;val_real();
<a name="l02143"></a>02143   }
<a name="l02144"></a>02144 
<a name="l02145"></a>02145   <span class="keywordtype">bool</span> get_date(MYSQL_TIME *ltime, uint fuzzydate)
<a name="l02146"></a>02146   {
<a name="l02147"></a>02147     <span class="keywordflow">if</span> (execute())
<a name="l02148"></a>02148       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02149"></a>02149     <span class="keywordflow">return</span> sp_result_field-&gt;get_date(ltime, fuzzydate);
<a name="l02150"></a>02150   }
<a name="l02151"></a>02151 
<a name="l02152"></a>02152   <span class="keywordtype">bool</span> get_time(MYSQL_TIME *ltime)
<a name="l02153"></a>02153   {
<a name="l02154"></a>02154     <span class="keywordflow">if</span> (execute())
<a name="l02155"></a>02155       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02156"></a>02156     <span class="keywordflow">return</span> sp_result_field-&gt;get_time(ltime);
<a name="l02157"></a>02157   }
<a name="l02158"></a>02158 
<a name="l02159"></a>02159   <a class="code" href="classmy__decimal.html">my_decimal</a> *val_decimal(<a class="code" href="classmy__decimal.html">my_decimal</a> *dec_buf)
<a name="l02160"></a>02160   {
<a name="l02161"></a>02161     <span class="keywordflow">if</span> (execute())
<a name="l02162"></a>02162       <span class="keywordflow">return</span> NULL;
<a name="l02163"></a>02163     <span class="keywordflow">return</span> sp_result_field-&gt;val_decimal(dec_buf);
<a name="l02164"></a>02164   }
<a name="l02165"></a>02165 
<a name="l02166"></a>02166   <a class="code" href="classString.html">String</a> *val_str(<a class="code" href="classString.html">String</a> *str)
<a name="l02167"></a>02167   {
<a name="l02168"></a>02168     <a class="code" href="classString.html">String</a> buf;
<a name="l02169"></a>02169     <span class="keywordtype">char</span> buff[20];
<a name="l02170"></a>02170     buf.set(buff, 20, str-&gt;charset());
<a name="l02171"></a>02171     buf.length(0);
<a name="l02172"></a>02172     <span class="keywordflow">if</span> (execute())
<a name="l02173"></a>02173       <span class="keywordflow">return</span> NULL;
<a name="l02174"></a>02174     <span class="comment">/*</span>
<a name="l02175"></a>02175 <span class="comment">      result_field will set buf pointing to internal buffer</span>
<a name="l02176"></a>02176 <span class="comment">      of the resul_field. Due to this it will change any time</span>
<a name="l02177"></a>02177 <span class="comment">      when SP is executed. In order to prevent occasional</span>
<a name="l02178"></a>02178 <span class="comment">      corruption of returned value, we make here a copy.</span>
<a name="l02179"></a>02179 <span class="comment">    */</span>
<a name="l02180"></a>02180     sp_result_field-&gt;val_str(&amp;buf);
<a name="l02181"></a>02181     str-&gt;copy(buf);
<a name="l02182"></a>02182     <span class="keywordflow">return</span> str;
<a name="l02183"></a>02183   }
<a name="l02184"></a>02184 
<a name="l02185"></a>02185   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> change_context_processor(uchar *cntx)
<a name="l02186"></a>02186     { context= (<a class="code" href="structName__resolution__context.html">Name_resolution_context</a> *)cntx; <span class="keywordflow">return</span> FALSE; }
<a name="l02187"></a>02187 
<a name="l02188"></a>02188   <span class="keywordtype">bool</span> <a class="code" href="classItem__func__sp.html#ae5c266dd8ff60049bfbd471bd5dbd5ea" title="Checks if requested access to function can be granted to user. If function isn&#39;t found yet...">sp_check_access</a>(THD * thd);
<a name="l02189"></a>02189   <span class="keyword">virtual</span> <span class="keyword">enum</span> Functype functype()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> FUNC_SP; }
<a name="l02190"></a>02190 
<a name="l02191"></a>02191   <span class="keywordtype">bool</span> fix_fields(THD *thd, <a class="code" href="classItem.html">Item</a> **ref);
<a name="l02192"></a>02192   <span class="keywordtype">void</span> <a class="code" href="classItem__func__sp.html#a85286968fef83a0b535e8dcc6f2df26e" title="Initialize local members with values from the Field interface.">fix_length_and_dec</a>(<span class="keywordtype">void</span>);
<a name="l02193"></a>02193   <span class="keywordtype">bool</span> is_expensive() { <span class="keywordflow">return</span> 1; }
<a name="l02194"></a>02194 
<a name="l02195"></a>02195   <span class="keyword">inline</span> <a class="code" href="classField.html">Field</a> *get_sp_result_field()
<a name="l02196"></a>02196   {
<a name="l02197"></a>02197     <span class="keywordflow">return</span> sp_result_field;
<a name="l02198"></a>02198   }
<a name="l02199"></a>02199 
<a name="l02200"></a>02200   <span class="keyword">virtual</span> <span class="keywordtype">void</span> update_null_value();
<a name="l02201"></a>02201 };
<a name="l02202"></a>02202 
<a name="l02203"></a>02203 
<a name="l02204"></a><a class="code" href="classItem__func__found__rows.html">02204</a> <span class="keyword">class </span><a class="code" href="classItem__func__found__rows.html">Item_func_found_rows</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l02205"></a>02205 {
<a name="l02206"></a>02206 <span class="keyword">public</span>:
<a name="l02207"></a>02207   <a class="code" href="classItem__func__found__rows.html">Item_func_found_rows</a>() :<a class="code" href="classItem__int__func.html">Item_int_func</a>() {}
<a name="l02208"></a>02208   longlong val_int();
<a name="l02209"></a>02209   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;found_rows&quot;</span>; }
<a name="l02210"></a>02210   <span class="keywordtype">void</span> fix_length_and_dec() { decimals= 0; maybe_null=0; }
<a name="l02211"></a>02211 };
<a name="l02212"></a>02212 
<a name="l02213"></a>02213 
<a name="l02214"></a>02214 <span class="keywordtype">void</span> uuid_short_init();
<a name="l02215"></a>02215 
<a name="l02216"></a><a class="code" href="classItem__func__uuid__short.html">02216</a> <span class="keyword">class </span><a class="code" href="classItem__func__uuid__short.html">Item_func_uuid_short</a> :<span class="keyword">public</span> <a class="code" href="classItem__int__func.html">Item_int_func</a>
<a name="l02217"></a>02217 {
<a name="l02218"></a>02218 <span class="keyword">public</span>:
<a name="l02219"></a>02219   <a class="code" href="classItem__func__uuid__short.html">Item_func_uuid_short</a>() :<a class="code" href="classItem__int__func.html">Item_int_func</a>() {}
<a name="l02220"></a>02220   <span class="keyword">const</span> <span class="keywordtype">char</span> *func_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="stringliteral">&quot;uuid_short&quot;</span>; }
<a name="l02221"></a>02221   longlong val_int();
<a name="l02222"></a>02222   <span class="keywordtype">void</span> fix_length_and_dec()
<a name="l02223"></a>02223   { max_length= 21; unsigned_flag=1; }
<a name="l02224"></a>02224   <span class="keywordtype">bool</span> check_partition_func_processor(uchar *int_arg) {<span class="keywordflow">return</span> FALSE;}
<a name="l02225"></a>02225 };
<a name="l02226"></a>02226 
<a name="l02227"></a>02227 <a class="code" href="classItem.html">Item</a> *<a class="code" href="item__func_8cc.html#ab4164b08f86f4715eccf0c3c4a35998d">get_system_var</a>(THD *thd, enum_var_type var_type, LEX_STRING name,
<a name="l02228"></a>02228                      LEX_STRING component);
<a name="l02229"></a>02229 <span class="keyword">extern</span> <span class="keywordtype">bool</span> check_reserved_words(LEX_STRING *name);
<a name="l02230"></a>02230 <span class="keyword">extern</span> enum_field_types <a class="code" href="item__cmpfunc_8cc.html#a62111cd977853a7f76e52aff59436e29" title="Aggregates field types from the array of items.">agg_field_type</a>(<a class="code" href="classItem.html">Item</a> **items, uint nitems);
<a name="l02231"></a>02231 <span class="keywordtype">double</span> my_double_round(<span class="keywordtype">double</span> value, longlong dec, <span class="keywordtype">bool</span> dec_unsigned,
<a name="l02232"></a>02232                        <span class="keywordtype">bool</span> truncate);
<a name="l02233"></a>02233 <span class="keywordtype">bool</span> <a class="code" href="item__func_8cc.html#a19ff4bb59a8ce82f56d7262f33f90319">eval_const_cond</a>(<a class="code" href="classItem.html">Item</a> *cond);
<a name="l02234"></a>02234 
<a name="l02235"></a>02235 <span class="keyword">extern</span> <span class="keywordtype">bool</span> <span class="keyword">volatile</span>  mqh_used;
<a name="l02236"></a>02236 
<a name="l02237"></a>02237 <span class="preprocessor">#endif </span><span class="comment">/* ITEM_FUNC_INCLUDED */</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 16 2015 12:34:45 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
